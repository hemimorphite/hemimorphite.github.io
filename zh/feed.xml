<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hemimorphite.github.io/zh/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hemimorphite.github.io/zh/" rel="alternate" type="text/html" /><updated>2024-07-23T18:25:26+00:00</updated><id>https://hemimorphite.github.io/feed.xml</id><title type="html">Hemimorphite</title><subtitle>Gain a better understanding of mathematics, chemistry, physics, and computer science. Our tutorials provide clear explanations and practical examples to help you learn and master these subjects. Helping learners of all levels to grasp fundamental concepts and hone their skills.</subtitle><entry xml:lang="en"><title type="html">Download ISO images of Debian CD/DVD with Jigdo on Ubuntu 22.04 and Debian 12</title><link href="https://hemimorphite.github.io/zh/2024/07/23/download-iso-images-of-debian-cd-dvd-with-jigdo-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="Download ISO images of Debian CD/DVD with Jigdo on Ubuntu 22.04 and Debian 12" /><published>2024-07-23T16:23:00+00:00</published><updated>2024-07-23T16:23:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/23/download-iso-images-of-debian-cd-dvd-with-jigdo-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/23/download-iso-images-of-debian-cd-dvd-with-jigdo-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Download ISO images of Debian CD/DVD with Jigdo on Ubuntu 22.04 and Debian 12</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 23, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/downloadjigdo.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Jigsaw Download, or short jigdo, is a scheme developed primarily to make it easy to distribute huge filesystem images (e.g. CD (ISO9660) or DVD (UDF) images) over the internet, but it could also be used for other data which is awkward to handle due to its size, like audio/video files or large software packages.</p>

        <p>jigdo tries to ensure that the large file (always called image) is downloaded in small parts which can be stored on different servers.</p>

        <p>For each ISO image you want to download, you'll need both the <code>.jigdo</code> and <code>.template</code> file for that image. Both files follow the same naming convention:</p>

        <pre><code class="language-bash hljs">distro-arch-n.jigdo
distro-arch-n.template</code></pre>
        
        <p>where distro is the name of the distro (like "debian"), arch is the architecture (like "i386") and n is the disk number (like "1").</p>

        <p>To download Debian ISO images using Jigdo, follow these steps:</p>

        <ol>
            <li>Install Jigdo by running:<br>
                <pre><code class="language-bash hljs">sudo apt-get install jigdo-file</code></pre>
            </li>
            <li>Open your web browser and navigate to the Debian CD/DVD images page at: <a href="https://www.debian.org/CD/jigdo-cd/">Debian CD/DVD images</a>.</li>
            <li>Choose the release (such as amd64, arm64, armel, armhf, i386, mips64el, mipsel, ppc64el, s390x) you're interested in.</li>
            <li>Download the .jigdo file and its associated .template file to a directory on your system.<br>
                <pre><code class="language-bash hljs">wget https://cdimage.debian.org/debian-cd/current/amd64/jigdo-dvd/debian-12.6.0-amd64-DVD-{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21}.jigdo
wget https://cdimage.debian.org/debian-cd/current/amd64/jigdo-dvd/debian-12.6.0-amd64-DVD-{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21}.template</code></pre></li>
            <li>Run the following command with the name of your Jigdo file:<br>
                <pre><code class="language-bash hljs">jigdo-lite debian-12.6.0-amd64-DVD-{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21}.jigdo</code></pre></li>
            <li>Next, Jigdo will ask you for the URL of a Debian mirror:<br>
                <pre><code class="language-bash hljs">Jigsaw Download "lite"
Copyright (C) 2001-2009  |  jigdo@
Richard Atterer          |  atterer.org
Copyright (C) 2016-2021
Steve McIntyre &lt;93sam@debian.org&gt;
Loading settings from `/home/ubuntu/.jigdo-lite'

-----------------------------------------------------------------
You have asked me to process several files/URLs:
    debian-12.6.0-amd64-DVD-1.jigdo
    debian-12.6.0-amd64-DVD-2.jigdo
    debian-12.6.0-amd64-DVD-3.jigdo
    debian-12.6.0-amd64-DVD-4.jigdo
    debian-12.6.0-amd64-DVD-5.jigdo
    debian-12.6.0-amd64-DVD-6.jigdo
    debian-12.6.0-amd64-DVD-7.jigdo
    debian-12.6.0-amd64-DVD-8.jigdo
    debian-12.6.0-amd64-DVD-9.jigdo
    debian-12.6.0-amd64-DVD-10.jigdo
    debian-12.6.0-amd64-DVD-11.jigdo
    debian-12.6.0-amd64-DVD-12.jigdo
    debian-12.6.0-amd64-DVD-13.jigdo
    debian-12.6.0-amd64-DVD-14.jigdo
    debian-12.6.0-amd64-DVD-15.jigdo
    debian-12.6.0-amd64-DVD-16.jigdo
    debian-12.6.0-amd64-DVD-17.jigdo
    debian-12.6.0-amd64-DVD-18.jigdo
    debian-12.6.0-amd64-DVD-19.jigdo
    debian-12.6.0-amd64-DVD-20.jigdo
    debian-12.6.0-amd64-DVD-21.jigdo

Entering batch mode

-----------------------------------------------------------------
Images offered by `debian-12.6.0-amd64-DVD-1.jigdo':
    1: 'Debian GNU/Linux 12.6.0 "Bookworm" - Official amd64 DVD Binary-1 with firmware 20240629-10:19 (20240629)' (debian-12.6.0-amd64-DVD-1.iso)

-----------------------------------------------------------------
Batch mode: Will download `debian-12.6.0-amd64-DVD-1.iso'

Further information about `debian-12.6.0-amd64-DVD-1.iso':
Generated on Sat, 29 Jun 2024 11:48:13 +0000

-----------------------------------------------------------------
If you already have a previous version of the CD you are
downloading, jigdo can re-use files on the old CD that are also
present in the new image, and you do not need to download them
again. Mount the old CD ROM and enter the path it is mounted under
(e.g. `/mnt/cdrom').
Alternatively, just press enter if you want to start downloading
the remaining files.
Files to scan:</code></pre></li>
            <li>Jigdo will ask you for the URL of a Debian mirror. You can find the list of <a href="https://www.debian.org/mirror/list">Debian mirrors here</a>.<br>
                <pre><code class="language-bash hljs">-----------------------------------------------------------------
The jigdo file refers to files stored on Debian mirrors. Please
choose a Debian mirror as follows: Either enter a complete URL
pointing to a mirror (in the form
`ftp://ftp.debian.org/debian/'), or enter any regular expression
for searching through the list of mirrors: Try a two-letter
country code such as `de', or a country name like `United
States', or a server name like `sunsite'.
Debian mirror [http://ftp.debian.org/debian/]: http://ftp.debian.org/debian/</code></pre></li>
            <li>Next, Jigdo will again ask you for the URL of a non-US mirror. You can find the list of <a href="https://www.debian.org/mirror/list">non-US mirrors here</a>.<br>
    <pre><code class="language-bash hljs">-----------------------------------------------------------------
The jigdo file also refers to the Non-US section of the Debian
archive. Please repeat the mirror selection for Non-US. Do not
simply copy the URL you entered above; this does not work because
the path on the servers differs!
Debian non-US mirror [http://ftp.debian.org/debian/]: http://ftp.au.debian.org/debian/</code></pre></li>
        </ol>

        <p>Jigdo will start to download all packages from the mirrors that you mentioned above. It may take several hours or even days depending upon your Internet speed.</p>

    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/ubuntu-22-04" class="tag">ubuntu 22.04</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/debian-12" class="tag">debian 12</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/jigdo" class="tag">jigdo</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-23" /><category term="ubuntu 22.04" /><category term="debian 12" /><category term="jigdo" /><summary type="html"><![CDATA[Learn how to efficiently download ISO images of Debian CD/DVD using Jigdo on Ubuntu 22.04 and Debian 12. This guide covers the installation of Jigdo, downloading necessary .jigdo and .template files, and using Jigdo to assemble the ISO images, ensuring you have the latest version of Debian with minimal downloads. Follow our step-by-step instructions to keep your Debian installations up-to-date effortlessly.]]></summary></entry><entry xml:lang="en"><title type="html">Install deb file with all dependencies on Ubuntu 22.04 and Debian 12</title><link href="https://hemimorphite.github.io/zh/2024/07/23/install-deb-file-with-all-dependencies-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="Install deb file with all dependencies on Ubuntu 22.04 and Debian 12" /><published>2024-07-23T13:40:00+00:00</published><updated>2024-07-23T13:40:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/23/install-deb-file-with-all-dependencies-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/23/install-deb-file-with-all-dependencies-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Install deb file with all dependencies on Ubuntu 22.04 and Debian 12</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 23, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/debfile.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Installing a .deb package with all dependencies on Ubuntu or Debian can be done easily using the terminal.</p>

        <h5>Method 1: Using <code>apt</code> Command</h5>

        <ol>
            <li>Download the .deb file from a trusted source.</li>
            <li>Open the terminal and navigate to the directory where the .deb file is located.</li>
            <li>Use the dpkg command to install the package:<br>
                <pre><code class="language-bash hljs">sudo dpkg -i package-name.deb</code></pre>
            </li>
        </ol>

        <h5>Method 2: Using <code>dpkg</code> and <code>apt-get</code></h5>

        <ol>
            <li>Download the .deb file from a trusted source.</li>
            <li>Open the terminal and navigate to the directory where the .deb file is located.</li>
            <li>Use the <code>apt</code> command to install the package and resolve dependencies:<br>
                <pre><code class="language-bash hljs">sudo apt install ./package-name.deb</code></pre>
            </li>
            <li>After running <code>dpkg</code>, you might have missing dependencies. Fix them using <code>apt-get</code>:<br>
                <pre><code class="language-bash hljs">sudo apt-get install -f</code></pre></li>
        </ol>

        <h5>Method 3: Using <code>gdebi</code></h5>

        <ol>
            <li>First, install <code>gdebi</code> if it's not already installed:<br>
                <pre><code class="language-bash hljs">sudo apt-get install gdebi</code></pre></li>
            <li>Use <code>gdebi</code> to install the package and automatically resolve dependencies:<br>
                <pre><code class="language-bash hljs">sudo gdebi package-name.deb</code></pre></li>
        </ol>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/ubuntu-22-04" class="tag">ubuntu 22.04</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/debian-12" class="tag">debian 12</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/apt" class="tag">apt</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/dpkg" class="tag">dpkg</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/apt-get" class="tag">apt-get</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/gdebi" class="tag">gdebi</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-23" /><category term="ubuntu 22.04" /><category term="debian 12" /><category term="apt" /><category term="dpkg" /><category term="apt-get" /><category term="gdebi" /><summary type="html"><![CDATA[Learn how to efficiently install .deb files with all dependencies on Ubuntu 22.04 and Debian 12 using various methods. This comprehensive guide covers the use of apt, dpkg, apt-get, and gdebi to ensure smooth and hassle-free installation. Whether you're a beginner or an experienced user, our step-by-step instructions will help you navigate the process effortlessly, ensuring that all necessary dependencies are resolved and installed correctly. Perfect for users looking to manage their software installations on Ubuntu 22.04 and Debian 12.]]></summary></entry><entry xml:lang="en"><title type="html">Windows Can’t Stop Your Generic Volume Device</title><link href="https://hemimorphite.github.io/zh/2024/07/23/windows-cant-stop-your-generic-volume-device/" rel="alternate" type="text/html" title="Windows Can’t Stop Your Generic Volume Device" /><published>2024-07-23T11:34:00+00:00</published><updated>2024-07-23T11:34:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/23/windows-cant-stop-your-generic-volume-device</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/23/windows-cant-stop-your-generic-volume-device/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Windows Can't Stop Your Generic Volume Device</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 23, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/safelyremove.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error message "Windows Can't Stop Your Generic Volume Device" typically occurs when you try to safely eject an external storage device (like a USB flash drive or an external hard drive) and Windows determines that the device is still in use. This can happen for a variety of reasons, such as open files or programs accessing the device, background processes, or even antivirus software performing scans.</p>

        <p>"USB Safely Remove" is a third-party tool designed to help safely remove USB devices on Windows, avoiding common errors such as "Windows Can't Stop Your Generic Volume Device." Follow these steps to install the software:</p>

        <ol>
            <li>Open your web browser and navigate to the official "USB Safely Remove" website: <a href="https://safelyremove.com/index.htm">https://safelyremove.com/index.htm</a>.</li>
            <li>Click on the "Download" button to download the installer.</li>
            <li>Once the download is complete, locate the downloaded file (usually in your "Downloads" folder) and double-click on it to run the installer.</li>
            <li>Follow the on-screen instructions to install the program. Typically, this involves clicking "Next" through several screens, agreeing to the license agreement, and choosing the installation location.</li>
            <li>After installation, you can launch USB Safely Remove either by clicking "Finish" in the installer with the option to run the program checked or by finding the program in your Start menu or desktop shortcuts.</li>
            <li>Once the program is running, you will see its icon in the system tray (near the clock).</li>
            <li>To safely remove a device, click on the USB Safely Remove icon in the system tray, then select the device you wish to remove and click "Stop".</li>
        </ol>

        
        
</article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-11" class="tag">windows 11</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/prototype" class="tag">prototype</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Troubleshooting" /><category term="year-2024" /><category term="month-07" /><category term="day-23" /><category term="windows 11" /><category term="prototype" /><summary type="html"><![CDATA[Encountering the Windows Can't Stop Your Generic Volume Device error while trying to safely remove your USB drive or external storage device can be frustrating. This issue usually arises because some files or programs are still accessing the device, preventing Windows from stopping it safely. Our comprehensive guide provides you with effective solutions to resolve this problem and safely eject your devices without risking data loss.]]></summary></entry><entry xml:lang="en"><title type="html">Build Node JS Version 20.15.1 from Source with GNU Make on Ubuntu 22.04 and Debian 12</title><link href="https://hemimorphite.github.io/zh/2024/07/22/build-nodejs-version-20151-from-source-with-gnu-make-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="Build Node JS Version 20.15.1 from Source with GNU Make on Ubuntu 22.04 and Debian 12" /><published>2024-07-22T13:21:00+00:00</published><updated>2024-07-22T13:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/22/build-nodejs-version-20151-from-source-with-gnu-make-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/22/build-nodejs-version-20151-from-source-with-gnu-make-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Build Node JS Version 20.15.1 from Source with GNU Make on Ubuntu 22.04 and Debian 12</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 22, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/build20151-nodejs.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Install necessary dependencies:</p>

        <pre><code class="language-bash hljs">sudo apt-get install -y python3 g++ make python3-pip</code></pre>

        <p>Download Node.js version 20.15.1 source:</p>

        <pre><code class="language-bash hljs">wget https://nodejs.org/dist/v20.5.1/node-v20.15.1.tar.gz</code></pre>

        <p>Extract the Node.js archive in the current directory with the following command:</p>

        <pre><code class="language-bash hljs">tar -xvzf node-v20.15.1.tar.gz</code></pre>

        <p>If the path to your build directory contains a space, the build will likely fail.</p>

        <p>Then run the following to build Node.js:</p>

        <pre><code class="language-bash hljs">sudo apt-get install python3 g++ make python3-pip</code></pre>

        <p>Navigate into the directory node-v20.15.1 after extracting the archive.</p>

        <pre><code class="language-bash hljs">cd node-v20.15.1</code></pre>

        <p>Run the configure script:</p>

        <pre><code class="language-bash hljs">./configure</code></pre>

        <p>Compile the source code:</p>

        <pre><code class="language-bash hljs">make -j4</code></pre>

        <p>Install Node.js:</p>

        <pre><code class="language-bash hljs">sudo make install</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/ubuntu-22-04" class="tag">ubuntu 22.04</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/debian-12" class="tag">debian 12</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/nodejs" class="tag">nodejs</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/build-source-code" class="tag">build source code</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/gnu-make" class="tag">gnu make</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-22" /><category term="ubuntu 22.04" /><category term="debian 12" /><category term="nodejs" /><category term="build source code" /><category term="gnu make" /><summary type="html"><![CDATA[In this guide, we will walk you through the process of building Node.js version 20.15.1 from source using GNU Make on both Ubuntu 22.04 and Debian 12.]]></summary></entry><entry xml:lang="en"><title type="html">Git error RPC failed curl transfer closed with outstanding read data remaining on Ubuntu 22.04 and Debian 12</title><link href="https://hemimorphite.github.io/zh/2024/07/22/git-error-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="Git error RPC failed curl transfer closed with outstanding read data remaining on Ubuntu 22.04 and Debian 12" /><published>2024-07-22T12:21:00+00:00</published><updated>2024-07-22T12:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/22/git-error-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/22/git-error-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Git error RPC failed curl transfer closed with outstanding read data remaining on Ubuntu 22.04 and Debian 12</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 22, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/curltransfer.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error RPC failed; curl transfer closed with outstanding read data remaining typically occurs when you have to clone a large repository from a slow internet connection, and the connection tends to close.</p>

        <p>Do a shallow clone:</p>

        <pre><code class="language-bash hljs">git clone https://github.com/microsoft/TypeScript.git --depth 1</code></pre>

        <p>This option allows you to clone only the latest commits, which can be helpful when dealing with large repositories or slow network connections.</p>

        <p>Navigate in the local repository directory:</p>

        <pre><code class="language-bash hljs">cd TypeScript</code></pre>

        <p>Convert a shallow clone of a Git repository into a complete repository with the full commit history:</p>

        <pre><code class="language-bash hljs">git fetch --unshallow</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/git" class="tag">git</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/gi-clone" class="tag">gi clone</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/git-fetch" class="tag">git fetch</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/ubuntu-22-04" class="tag">ubuntu 22.04</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/debian-12" class="tag">debian 12</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Troubleshooting" /><category term="year-2024" /><category term="month-07" /><category term="day-22" /><category term="git" /><category term="gi clone" /><category term="git fetch" /><category term="ubuntu 22.04" /><category term="debian 12" /><summary type="html"><![CDATA[Explore our expert guide on resolving the Git error RPC failed; curl transfer closed with outstanding read data remaining specifically tailored for Ubuntu 22.04 and Debian 12 users.]]></summary></entry><entry xml:lang="en"><title type="html">Git error RPC failed curl GnuTLS recv error Error decoding the received TLS packet on Ubuntu 22.04 or Debian 12</title><link href="https://hemimorphite.github.io/zh/2024/07/21/git-error-curl-gnutls-recv-error-error-decoding-the-received-tls-packet-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="Git error RPC failed curl GnuTLS recv error Error decoding the received TLS packet on Ubuntu 22.04 or Debian 12" /><published>2024-07-21T15:21:00+00:00</published><updated>2024-07-21T15:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/21/git-error-curl-gnutls-recv-error-error-decoding-the-received-tls-packet-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/21/git-error-curl-gnutls-recv-error-error-decoding-the-received-tls-packet-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Git error RPC failed curl GnuTLS recv error Error decoding the received TLS packet on Ubuntu 22.04 or Debian 12</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 21, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/curlgnutls.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error "RPC failed; curl GnuTLS recv error: Error decoding the received TLS packet" generally indicates an issue with the network connection or the TLS/SSL protocol used by Git and Curl. </p>

        <p>To resolve the "RPC failed; curl GnuTLS recv error: Error decoding the received TLS packet" error, you can recompile Git using <code>libcurl-openssl-dev</code> instead of <code>libcurl4-gnutls-dev</code>.</p>

        <p>Remove Git and its dependencies:</p>

        <pre><code class="language-bash hljs">sudo apt-get -y purge git</code></pre>

        <p>Install necessary dependencies:</p>

        <pre><code class="language-bash hljs">sudo apt-get install build-essential fakeroot dpkg-dev</code></pre>

        <p>Create a directory for compiling git:</p>

        <pre><code class="language-bash hljs">mkdir git-source
cd git-source</code></pre>
        
        <p>open the <code>sources.list</code> file located in the <code>/etc/apt/</code> directory using a vim editor:</p>

        <pre><code class="language-bash hljs">sudo vi /etc/apt/sources.list</code></pre>
        
        <p>For Debian 12, add the following line:</p>

        <pre><code class="language-bash hljs">deb-src http://deb.debian.org/debian bookworm main
deb-src http://deb.debian.org/debian bookworm-updates main</code></pre>
        
        <p>For Ubuntu 22.04, uncomment the following line:</p>

        <pre><code class="language-bash hljs">deb-src http://archive.ubuntu.com/ubuntu/ jammy main restricted
deb-src http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted</code></pre>
        
        <p>Then run the following to update the package index files from their sources:</p>
        
        <pre><code class="language-bash hljs">sudo apt-get update</code></pre>

        <p>Download git source code:</p>
        
        <pre><code class="language-bash hljs">apt-get source git</code></pre>

        <p>Install build dependencies for git:</p>
        
        <pre><code class="language-bash hljs">sudo apt-get build-dep git</code></pre>
        
        <p>Install <code>libcurl4-openssl-dev</code> package:</p>

        <pre><code class="language-bash hljs">sudo apt-get install -y libcurl4-openssl-dev</code></pre>
        
        <p>Enter the git source code directory:</p>
        
        <pre><code class="language-bash hljs">cd git-2.39.2</code></pre>

        <p>Change <code>libcurl4-gnutls-dev</code> to <code>libcurl4-openssl-dev</code> in <code>./debian/control</code>:</p>
        
        <pre><code class="language-bash hljs">sed -i -- 's/libcurl4-gnutls-dev/libcurl4-openssl-dev/' ./debian/control</code></pre>

        <p>Edit <code>./debian/rules</code> to delete the entire line containing <code>TEST=test</code>:</p>

        <pre><code class="language-bash hljs">sed -i -- '/TEST=test/d' ./debian/rules
        </code></pre>

        <p>Build git from the source code.</p>

        <pre><code class="language-bash hljs">sudo dpkg-buildpackage -rfakeroot -b</code></pre>

        <p>Back to the <code>~/git-source</code> directory:</p>

        <pre><code class="language-bash hljs">cd ..</code></pre>

        <p>Install the compiled git package:</p>

        <pre><code class="language-bash hljs">sudo dpkg -i git_2.39.2-1.1_amd64.deb</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/git" class="tag">git</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/git-clone" class="tag">git clone</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/ubuntu-22-04" class="tag">ubuntu 22.04</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/debian-12" class="tag">debian 12</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Troubleshooting" /><category term="year-2024" /><category term="month-07" /><category term="day-21" /><category term="git" /><category term="git clone" /><category term="ubuntu 22.04" /><category term="debian 12" /><summary type="html"><![CDATA[Learn how to troubleshoot and resolve the error: RPC failed; curl GnuTLS recv error: Error decoding the received TLS packet error encountered while using Git on Ubuntu 22.04 or Debian 12. This guide provides step-by-step solutions to fix this issue during Git operations like cloning repositories.]]></summary></entry><entry xml:lang="en"><title type="html">Git error RPC failed curl 92 HTTP/2 stream 0 was not closed cleanly on Ubuntu 22.04 and Debian 12</title><link href="https://hemimorphite.github.io/zh/2024/07/21/git-error-curl-http2-stream-was-not-closed-cleanly-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="Git error RPC failed curl 92 HTTP/2 stream 0 was not closed cleanly on Ubuntu 22.04 and Debian 12" /><published>2024-07-21T05:21:00+00:00</published><updated>2024-07-21T05:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/21/git-error-curl-http2-stream-was-not-closed-cleanly-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/21/git-error-curl-http2-stream-was-not-closed-cleanly-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Git error RPC failed curl 92 HTTP/2 stream 0 was not closed cleanly on Ubuntu 22.04 and Debian 12</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 21, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/http2stream.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error "RPC failed; curl 18 HTTP/2 stream 5 was not closed cleanly" typically indicates a problem with the HTTP/2 protocol during a Git operation, such as cloning or pushing to a repository. This error can be related to network issues, HTTP/2 protocol handling, or configuration problems. </p>

        <p>To resolve the "RPC failed; curl 92 HTTP/2 stream 0 was not closed cleanly" error, you can force Git to use HTTP/1.1 instead of HTTP/2.</p>

        <pre><code class="language-bash hljs">git config --global http.version HTTP/1.1</code></pre>

    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/git" class="tag">git</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/git-clone" class="tag">git clone</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/ubuntu-22-04" class="tag">ubuntu 22.04</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/debian-12" class="tag">debian 12</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Troubleshooting" /><category term="year-2024" /><category term="month-07" /><category term="day-21" /><category term="git" /><category term="git clone" /><category term="ubuntu 22.04" /><category term="debian 12" /><summary type="html"><![CDATA[This comprehensive guide addresses the RPC failed; curl 92 HTTP/2 stream 0 was not closed cleanly error encountered with Git on Ubuntu 22.04 and Debian 12. It provides practical solutions for troubleshooting and resolving this issue during Git operations, such as cloning repositories.]]></summary></entry><entry xml:lang="en"><title type="html">Event Loop in Node.Js</title><link href="https://hemimorphite.github.io/zh/2024/07/18/event-loop-in-nodejs/" rel="alternate" type="text/html" title="Event Loop in Node.Js" /><published>2024-07-18T16:21:00+00:00</published><updated>2024-07-18T16:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/18/event-loop-in-nodejs</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/18/event-loop-in-nodejs/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Event Loop in Node.Js</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 18, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/eventloop-nodejs.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Node.js uses a single-threaded event loop to handle asynchronous operations. This means that all the JavaScript code is executed on a single thread, but the event loop can handle multiple operations concurrently.</p>

        <p>The JavaScript code consists of two lines of execution:</p>

        <ul>
            <li>The mainline: This is the JavaScript that runs when Node first runs your program. It runs from start to finish, and when it is finished, it gives up control to the event loop.</li>
            <li>The event loop: This is where all of your callbacks are run.</li>
        </ul>

        <p>The following diagram shows a simplified overview of the event loop's order of operations.</p>

        <pre><code class="language-bash hljs">    ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘</code></pre>

        <p>The event loop in Node.js does not have a predefined number of iterations; it continues running indefinitely until there are no more tasks to perform. Each iteration of the event loop is referred to as a tick. The event loop will keep ticking as long as there are pending operations, such as:</p>
        
        <ul>
            <li>Promises and other microtasks.</li>
            <li>Pending timers (callbacks scheduled with <code>setTimeout</code> or <code>setInterval</code>).</li>
            <li>Pending I/O operations (e.g., file system operations, network requests).</li>
            <li>Pending callbacks (e.g., deferred I/O callbacks).</li>
            <li><code>setImmediate</code> callbacks.</li>
            <li>Close callbacks.</li>
        </ul>

        <h5 class="post-subtitle">Microtasks</h5>

        <p>All microtasks are placed into a microtask queue, designed specifically for handling them.</p>

        <p>The microtask queue is processed and emptied before every phase iteration of the event loop.</p>

        <p>Microtasks are executed at specific points in the event loop:</p>

        <ol>
            <li>After executing JavaScript code: When the call stack becomes empty, the event loop checks for and executes any pending microtasks before moving to the next phase.</li>
            <li>After processing each phase of the event loop: Once the current phase of the event loop is completed, before moving to the next phase, the event loop processes all the pending microtasks.</li>
        </ol>
    
        <p>Here are the main types of microtasks:</p>

        <ul>
            <li>Promise Callbacks: <code>.then()</code>, <code>.catch()</code>, and <code>.finally()</code> handlers.</li>
            <li><code>queueMicrotask</code>: Both queueMicrotask and Promise Callbacks added to the microtask queue and have similar priority.</li>
            <li><code>process.nextTick</code>: Callbacks scheduled with <code>process.nextTick</code> are executed before promise callbacks or queueMicrotask callbacks. <code>process.nextTick</code> callbacks are added to the beginning of the microtask queue.</li>
        </ul>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');
process.nextTick(console.log, "nextTick 1");
Promise.resolve("Promise 1").then(console.log);
queueMicrotask(() => console.log("queueMicrotask 1"));
Promise.reject("Promise 2").catch(console.log);
queueMicrotask(() => console.log("queueMicrotask 2"));
process.nextTick(console.log, "nextTick 2");
console.log('End');</code></pre>
        
        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick 1
nextTick 2
Promise 1
queueMicrotask 1
Promise 2
queueMicrotask 2</code></pre>

        <p>The execution flow is as follows:</p>
        
        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The executor function within the Promise constructor initializes the promise.</li>
                    <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread executes resolve function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>Calling resolve transitions the promise from the pending state to the fulfilled (or resolved) state.</li>
                    <li>The value "Promise 1" is set as the value of the new promise internally.</li>
                    <li>The main thread removes function execution context for <code>resolve</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>executor function</code> from the call stack.</li>
                    <li>The Promise constructor completes, and its execution context is popped off the call stack.</li>
                    <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread moves the resolve callback function to the microtask queue (or job queue).</li>
                    <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes the second Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The executor function within the second Promise constructor initializes the promise.</li>
                    <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread executes reject function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>Calling resolve transitions the promise from the pending state to the rejected state.</li>
                    <li>The value "Promise 2" is set as the value of the new promise internally.</li>
                    <li>The main thread removes function execution context for <code>reject</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>executor function</code> from the call stack.</li>
                    <li>The second Promise constructor completes, and its execution context is popped off the call stack.</li>
                    <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread moves the resolve callback function to the microtask queue (or job queue).</li>
                    <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
                    <li>The main thread executes the second <code>queueMicrotask</code> function call, a function execution context for the second <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the second <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for the second  <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes the second <code>process.nextTick</code> function call, a function execution context for the second <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the second <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for the second <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li>
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for the first <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"nextTick 1"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for the first <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the second task from the nextTick queue onto the call stack and creates a new function execution context for the second <code>process.nextTick</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"nextTick 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for the second <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for promise <code>then()</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"Promise 1"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for promise <code>then()</code> callback function from the call stack.</li>
                            <li>The event loop pushes the next task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"queueMicrotask 1"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                            <li>The event loop pushes the next task from the microtask queue onto the call stack and creates a new function execution context for promise <code>then()</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"Promise 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for promise <code>then()</code> callback function from the call stack.</li>
                            <li>The event loop pushes the next task from the microtask queue onto the call stack and creates a new function execution context for the second <code>queueMicrotask</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"queueMicrotask 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for the second  <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timers have expired yet (since less than 500 milliseconds have passed).</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Timers</h5>
        
        <p>The first phase of the event loop is the Timers phase. This phase deals with timer callbacks that have reached their scheduled time. Timers in Node.js can be used to schedule code execution after a specified delay or at specific intervals. When a timer's time comes, its callback function is added to the event queue (task queue) to be executed.</p>

        <p>Timers are not guaranteed to execute exactly at their scheduled time, as they are subject to the availability of the system and the event loop. For example, if the event loop is busy processing other events, the timer callback may be delayed until the next iteration of the event loop. Therefore, timers should not be used for precise timing, but rather for approximate timing.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

setTimeout(() => {
    console.log('Timeout callback 1');
}, 1000);

setTimeout(() => {
    console.log('Timeout callback 2');
}, 500);

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback 2
Timeout callback 1</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes the second <code>setTimeout</code> function call, a function execution context for the second <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the second <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for the second <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timers have expired yet (since less than 500 milliseconds have passed).</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase (After 500 milliseconds)<br>
                        <ul>
                            <li>The event loop pushes the task from the callback queue onto the call stack and creates a new function execution context for the second <code>setTimeout</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"Timeout callback 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase (After 1000 milliseconds)<br>
                        <ul>
                            <li>The event loop pushes the task from the callback queue onto the call stack and creates a new function execution context for the first <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback 1"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Pending Callbacks</h5>

        <p>I/O operations execute in the poll phase of the event loop. During the poll phase, some specific I/O operations callbacks defer to the pending phase of the next iteration of the event loop. I/O operations callbacks deferred from the previous iteration run in the pending callbacks phase.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require("fs");

fs.readFile(__filename, (err, data) => {
    if (err) throw err;
    console.log("Pending callback");
});
            
setTimeout(() => {
    console.log('Timeout callback');
}, 0);

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Pending callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>fs</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.readFile</code> function call, a function execution context for <code>fs.readFile</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.readFile</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The file reading process is finished, but its callback is not yet marked to be executed because IO callbacks get queued up only at the IO Poll Phase.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The <code>fs.readFile</code> callback event is collected and added to the I/O queue.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>fs.readFile</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Pending callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>fs.readFile</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Idle Phase</h5>

        <p>The idle phase is not a normal phase of the Node.js event loop. It is a period whereby the event loop has nothing to do but perform background tasks like checking for low-priority results or running garbage collection.</p>

        <h5 class="post-subtitle">Poll Phase</h5>

        <p>The poll phase is where I/O operations execute. I/O  operations transfer data to or from a computer. The event loop checks for new I/O operations and executes them in the poll queue.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require("fs");

fs.readFile(__filename, (err, data) => {
    if (err) throw err;
    console.log("Pending callback");
});

const http = require("http");

http.get("http://localhost", (res) => {
    console.log("Poll callback");
    res.on("data", (chunk) => {
        // Do something with the data
        console.log("Data event listener callback");
    });
});

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Poll callback
Data event listener callback
Pending callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>fs</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.readFile</code> function call, a function execution context for <code>fs.readFile</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>The main thread moves the <code>fs.readFile</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.readFile</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>http</code>.</li>
                    <li>The main thread wraps the contents of <code>http</code> in a function and executes it, a function execution context for <code>http</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>http</code>.</li>
                    <li>The main thread removes function execution context for <code>http</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>http.get</code> function call, a function execution context for <code>http.get</code> is added to the call stack.</li>
                    <li>The main thread initiates initiates an HTTP GET request.</li>
                    <li>The main thread moves the <code>http.get</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>http.get</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The file reading process isn't finished.</li>
                            <li>The HTTP request is sent over the network and waits for the server response.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The file reading process is finished, but its callback is not yet marked to be executed because IO callbacks get queued up only at the IO Poll Phase.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The <code>fs.readFile</code> callback event is collected and added to the I/O queue.</li>
                            <li>When the response headers from the server are received, the event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>http.get</code> callback function.</li>
                            <li>The server <code>localhost</code> responds HTTP GET request, the data starts arriving in chunks.</li>
                            <li>The event loop executes the data event listener call, a function execution context for data event listener is added to the call stack.</li>
                            <li>The event loop moves the calbback function for data event listener to the event queue (task queue).</li>
                            <li>Each chunk of data triggers a data event on the response object.</li>
                            <li>Once the event loop detects the data event, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The data event listener also has no more code to run.</li>     
                            <li>The event loop removes function execution context for data event listener from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>fs.readFile</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Pending callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>fs.readFile</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>  

        <h5 class="post-subtitle">Check Phase</h5>

        <p>The check phase is where the <code>setImmediate</code> timer runs. The Node.js event loop goes to the check phase when there is a <code>setImmediate</code> in the program, and the poll phase becomes idle or when the poll phase completes.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require("fs");

fs.readFile(__filename, (err, data) => {
    if (err) throw err;
    console.log("Pending callback");
});

const http = require("http");

http.get("http://localhost", (res) => {
    console.log("Poll callback");
    res.on("data", (chunk) => {
        // Do something with the data
        console.log("Data event listener callback");
    });
});

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

setImmediate(() => {
    console.log("Check callback");
});

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Check callback
Poll callback
Data event listener callback
Pending callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>fs</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.readFile</code> function call, a function execution context for <code>fs.readFile</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>The main thread moves the <code>fs.readFile</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.readFile</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>http</code>.</li>
                    <li>The main thread wraps the contents of <code>http</code> in a function and executes it, a function execution context for <code>http</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>http</code>.</li>
                    <li>The main thread removes function execution context for <code>http</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>http.get</code> function call, a function execution context for <code>http.get</code> is added to the call stack.</li>
                    <li>The main thread initiates initiates an HTTP GET request.</li>
                    <li>The main thread moves the <code>http.get</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>http.get</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>setImmediate</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>setImmediate</code> callback function to the check queue.</li>
                    <li>The main thread removes function execution context for <code>setImmediate</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The file reading operation isn't finished.</li>
                            <li>The HTTP request is sent over the network and waits for the server response.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the check queue onto the call stack and creates a new function execution context for <code>setImmediate</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Check callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setImmediate</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The file reading operation is finished, but its callback is not yet marked to be executed because IO callbacks get queued up only at the IO Poll Phase.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The <code>fs.readFile</code> callback event is collected and added to the I/O queue.</li>
                            <li>When the response headers from the server are received, the event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>http.get</code> callback function.</li>
                            <li>The server <code>localhost</code> responds HTTP GET request, the data starts arriving in chunks.</li>
                            <li>The event loop executes the data event listener call, a function execution context for data event listener is added to the call stack.</li>
                            <li>The event loop moves the calbback function for data event listener to the event queue (task queue).</li>
                            <li>Each chunk of data triggers a data event on the response object.</li>
                            <li>Once the event loop detects the data event, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The data event listener also has no more code to run.</li>     
                            <li>The event loop removes function execution context for data event listener from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>fs.readFile</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Pending callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>fs.readFile</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Close Callbacks Phase</h5>  

        <p>The close callbacks phase is the last phase of the Node.js event loop. The close callback phase is where callbacks from the close event of a socket and the closing of an HTTP server run.</p>

        <p>The close callbacks phase is designed to handle cleanup operations related to resource closure, such as the closing of TCP connections, file descriptors, and other resources.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require('fs');

const readable = fs.createReadStream(__filename);

readable.on('data', (chunk) => {
    console.log('Data event listener');
});

readable.on('close', () => {
    console.log('Close callback');
});

const http = require("http");

http.get("http://localhost", (res) => {
    console.log("Poll callback");
    res.on("data", (chunk) => {
        // Do something with the data
        console.log("Data event listener callback");
    });
});

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

setImmediate(() => {
    console.log("Check callback");
});

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>  

        <p>The output depends on which operation finishes first, the HTTP request or the file reading operation.</p>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Check callback
Poll callback
Data event listener callback
Pending callback</code></pre>
        
        <p>Or:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Check callback
Data event listener
Poll callback
Data event listener callback
Close callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>readable</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.createReadStream</code> function call, a function execution context for <code>fs.createReadStream</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>This function is synchronous, meaning it runs immediately and returns a Readable stream object assigned to the <code>readable</code>.</li>
                    <li>The main thread moves the <code>fs.createReadStream</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.createReadStream</code> from the call stack.</li>
                    <li>The main thread executes <code>readable.on</code> function call, a function execution context for <code>readable.on</code> is added to the call stack.</li>
                    <li>The main thread moves the callback function to the event queue (task queue) which will be invoked whenever a chunk of data is available to be read from the stream.</li>
                    <li>This callback is an asynchronous event listener, meaning it will be called asynchronously whenever the 'data' event is emitted.</li>
                    <li>The main thread moves the <code>readable.on</code> callback function to the I/O queue.</li>
                    <li>The main thread executes the second <code>readable.on</code> function call, a function execution context for <code>readable.on</code> is added to the call stack.</li>
                    <li>The main thread moves the callback function to the event queue (task queue) which will be  invoked when the stream is closed.</li>
                    <li>This callback is also asynchronous and will be called when the 'close' event is emitted.</li>
                    <li>The main thread moves the <code>readable.on</code> callback function to the I/O queue.</li>

                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>http</code>.</li>
                    <li>The main thread wraps the contents of <code>http</code> in a function and executes it, a function execution context for <code>http</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>http</code>.</li>
                    <li>The main thread removes function execution context for <code>http</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>http.get</code> function call, a function execution context for <code>http.get</code> is added to the call stack.</li>
                    <li>The main thread initiates initiates an HTTP GET request.</li>
                    <li>The main thread moves the <code>http.get</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>http.get</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>setImmediate</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>setImmediate</code> callback function to the check queue.</li>
                    <li>The main thread removes function execution context for <code>setImmediate</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The event loop waits for data from streams.</li>
                            <li>The HTTP request is sent over the network and waits for the server response.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the check queue onto the call stack and creates a new function execution context for <code>setImmediate</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Check callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setImmediate</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>When a chunk of data is received, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>Each chunk of data triggers a data event on the readable stream object.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>When the response headers from the server are received, the event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>http.get</code> callback function.</li>
                            <li>The server <code>localhost</code> responds HTTP GET request, the data starts arriving in chunks.</li>
                            <li>The event loop executes the data event listener call, a function execution context for data event listener is added to the call stack.</li>
                            <li>The event loop moves the calbback function for data event listener to the event queue (task queue).</li>
                            <li>Each chunk of data triggers a data event on the response object.</li>
                            <li>Once the event loop detects the data event, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The data event listener also has no more code to run.</li>     
                            <li>The event loop removes function execution context for data event listener from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>When the entire file is read, the event loop will move the callback function for close event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Close callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/nodejs" class="tag">nodejs</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/event-loop" class="tag">event loop</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/call-stack" class="tag">call stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/nodejs-api" class="tag">nodejs api</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask" class="tag">microtask</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask-queue" class="tag">microtask queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/timers-phase" class="tag">timers phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/pending-callbacks-phase" class="tag">pending callbacks phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/idle-phase" class="tag">idle phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/check-phase" class="tag">check phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/close-callbacks-phase" class="tag">close callbacks phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/timer-queue" class="tag">timer queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/io-queue" class="tag">IO queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/check-queue" class="tag">check queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/close-queue" class="tag">close queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/event-queue-task-queue" class="tag">event queue (task queue)</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-18" /><category term="nodejs" /><category term="event loop" /><category term="call stack" /><category term="nodejs api" /><category term="microtask" /><category term="microtask queue" /><category term="timers phase" /><category term="pending callbacks phase" /><category term="idle phase" /><category term="check phase" /><category term="close callbacks phase" /><category term="timer queue" /><category term="IO queue" /><category term="check queue" /><category term="close queue" /><category term="event queue (task queue)" /><summary type="html"><![CDATA[Explore the intricacies of the event loop in Node.js with our comprehensive guide. This resource delves into the event loop's components, including the call stack, Node.js API, microtasks, microtask queue, timers phase, pending callbacks phase, idle phase, check phase, close callbacks phase, timer queue, IO queue, check queue, close queue, and event queue (task queue). Gain a deeper understanding of how the event loop manages asynchronous operations, and learn how to write efficient and responsive Node.js applications. With clear explanations and practical examples, this guide is your gateway to mastering the event loop in Node.js.]]></summary></entry><entry xml:lang="en"><title type="html">Event Loop in Javascript</title><link href="https://hemimorphite.github.io/zh/2024/07/15/event-loop-in-javascript/" rel="alternate" type="text/html" title="Event Loop in Javascript" /><published>2024-07-15T06:21:00+00:00</published><updated>2024-07-15T06:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Event Loop in Javascript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 15, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/eventloop-javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a single-threaded programming language. This means that JavaScript can do only one thing at a single point in time.</p>

        <p>The main thread is responsible for executing JavaScript code, performing rendering tasks, and handling user interactions. Since JavaScript is single-threaded, it can perform only one task at a time on the main thread.</p>

        <p>The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, and pushes, and pops functions onto and off the call stack in the execution phase.</p>

        <p>If a function takes a long time to execute, you cannot interact with the web browser during the function's execution because the page hangs.</p>

        <p>A function that takes a long time to complete is called a blocking function. Technically, a blocking function blocks all the interactions on the webpage, such as mouse clicks.</p>

        <p>The following example uses a big loop to simulate a blocking function:</p>

        <pre><code class="language-bash hljs">function task(message) {
    // emulate time consuming task
    let n = 10000000000;
    while (n > 0){
        n--;
    }
    console.log(message);
}

console.log('Start script...');
task('Doing a task');
console.log('Done!');</code></pre>

        <p>The script hangs for a few seconds (depending on how fast the computer is) and issues the following output:</p>

        <pre><code class="language-bash hljs">Start script...
Doing a task
Done!</code></pre>
        
        <p>The JavaScript Event Loop is a mechanism that enables JavaScript to perform non-blocking I/O operations despite being single-threaded. It allows asynchronous operations, such as handling user inputs, network requests, and timers, to be executed without blocking the main execution thread.</p>
        
        <p>The Event Loop stands as a crucial element within the JavaScript runtime environment, functioning in the following manner:</p>

        <ul>
            <li>Continuously monitoring the status of the call stack to determine if it's empty.</li>
            <li>Upon encountering an empty call stack, all pending Microtasks from the Microtask Queue are introduced into the call stack.</li>
            <li>When both the call stack and Microtask Queue are devoid of tasks, the event loop proceeds to dequeue tasks from the Task Queue and execute them.</li>
            <li>Ensuring the prevention of a "starved event loop" remains pivotal for maintaining seamless JavaScript execution.</li>
        </ul>

        <p>The Event Loop is a continuous process that coordinates the execution of tasks in JavaScript. It is composed of several components that work together to facilitate asynchronous programming:</p>

        <ul>
            <li>Call Stack</li>
            <li>Web APIs</li>
            <li>Macrotask Queue</li>
            <li>Microtask Queue</li>
        </ul>

        <h5 class="post-subtitle">Call Stack</h5>

        <p>The call stack is a fundamental concept in JavaScript and plays a key role in understanding the language's asynchronous behavior. It is a data structure known as a Last In, First Out (LIFO) stack, which is responsible for keeping track of the function calls and their execution order. Whenever a function is called, it gets added to the call stack, and once it finishes executing, it is removed from the stack (sort of).</p>
        
        <p>JavaScript is single-threaded, meaning it has only one call stack that can handle one task at a time. This is why blocking operations, such as time-consuming calculations or network requests, can freeze the browser's UI until the task is completed.</p>
        
        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">function fifth() { 
    console.log("fifth")
}

function fourth() { 
    console.log("fourth")
    fifth() 
}

function third() { 
    console.log("third")
    fourth() 
}

function second() { 
    console.log("second")
    third() 
}

function first() {
    console.log("first") 
    second() 
}

first();</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>first</code> function call, a function execution context for <code>first</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-01.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>first</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"first"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>second</code> function call, a function execution context for  <code>second</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-02.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>second</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"second"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>third</code> function call, a function execution context for  <code>third</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-03.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>third</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"third"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>fourth</code> function call, a function execution context for  <code>fourth</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-04.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>fourth</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"fourth"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <code>fifth</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-05.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>fifth</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"fifth"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes function execution context for <code>fifth</code>, <code>fourth</code>, <code>third</code>, <code>second</code> and <code>first</code> consecutively from the call stack.</li>
            <li>The main thread removes the global execution context from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Web APIs</h5>

        <p>Web APIs are provided by the browser environment to extend JavaScript's functionality beyond its single-threaded nature. These APIs allow developers to access features like the DOM, timers, and network requests, enabling JavaScript to perform tasks asynchronously without blocking the call stack.</p>

        <p>When a function utilizing a Web API is called, the API handles the task in the background and returns a callback function. This callback is then placed into a queue, waiting to be executed once the call stack is empty.</p>

        <p>Here are some common examples of Web APIs: DOM (Document Object Model) API, Fetch API, Geolocation API, Canvas API, Web Storage API, etc.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 1000);

console.log('End');</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Start"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function call.</li>
            <li>The main thread creates a new function execution context and places it on the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.</li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that counts down in the background within the Web API environment from the specified delay (1000 milliseconds in this case).</li>
            <li>The main thread removes the function execution context from the call stack.</li>
            <li>When the timer expires after the specified delay, the Web API moves the callback function to the callback queue (or task queue).</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"End"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
            <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> <li>The event loop pushes the first task from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Timeout"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Tasks and the Task Queue</h5>
        
        <p>Tasks are scheduled, synchronous blocks of code. While executing, they have exclusive access to the Call Stack and can also enqueue other tasks. Between Tasks, the browser can perform rendering updates. Tasks are stored in the Task Queue, waiting to be executed by their associated functions. These tasks come from:</p>

        <ul>
            <li>Timers (via setTimeout or setInterval)</li>
            <li>Event listeners (when an event is triggered)</li>
            <li>Network operations (when a response is received)</li>
        </ul>

        <p>The Task Queue is a FIFO (First In, First Out) data structure.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">setTimeout(function a() {
    console.log("task A")            
}, 1000);

setTimeout(function b() {
    console.log("task B")
}, 500);

setTimeout(function c() {
    console.log("task C")
}, 0);

function d() {
    console.log("task D")
}

d();</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-10.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the <code>setTimeout</code> callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> function from the call stack.</li>
            <li>The main thread executes the second <code>setTimeout</code> function call, a function execution context for the second <code>setTimeout</code> is added to the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-11.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the second  <code>setTimeout</code> callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution context for the second <code>setTimeout</code> function from the call stack.</li>
            <li>The main thread executes the third <code>setTimeout</code> function call, a function execution context for the third <code>setTimeout</code> is added to the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-13.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the third  <code>setTimeout</code> callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution context for the third <code>setTimeout</code> function from the call stack.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>d</code> function call, a function execution context for <code>d</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-12.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>d</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task D"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes function execution context for <code>d</code> from the call stack.</li>
            <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
            <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li>
            <li>After 0 milliseconds, the event loop the task <code>c</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-14.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the task <code>c</code> from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-15.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task C"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
            <li>After 500 milliseconds, the event loop the task <code>b</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-16.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the task <code>b</code> from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-17.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task B"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
            <li>After 1000 milliseconds, the event loop the task <code>a</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-18.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the next task from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-19.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task A"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Microtasks and the Microtask Queue</h5>

        <p>Microtasks are similar to Tasks in that they're scheduled, synchronous blocks of code with exclusive access to the Call Stack while executing. Additionally, they are stored in their own FIFO (First In, First Out) data structure, the Microtask Queue. Microtasks differ from Tasks, however, in that the Microtask Queue must be emptied out after a Task completes and before re-rendering.</p>

        <p>Microtasks and the Microtask Queue are also referred to as Jobs and the Job Queue.</p>
        
        <p>The microtask queue holds tasks that are prioritized over tasks in the task queue. Microtasks include promises and mutation observer callbacks. When the call stack is empty and before fetching tasks from the task queue, the event loop first processes all tasks in the microtask queue. This ensures that microtasks are executed as soon as possible.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log("Start");

const promise = new Promise((resolve, reject) => {
    console.log("Promise executor function started");
    resolve("Promise resolved successfully");
});

promise.then(function c(result) {
    console.log(result);
});

setTimeout(function d() {
    console.log("task D");
}, 0);

function e() {
    console.log("task E");
}

e();

console.log("End");</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Start"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
            <li>The executor function within the Promise constructor initializes the promise.</li>
            <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Promise executor function started"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes resolve function call, and its execution context is created and pushed onto the call stack.</li>
            <li>Calling resolve transitions the promise from the pending state to the fulfilled (or resolved) state.</li>
            <li>The value <code>"Promise resolved successfully"</code> is set as the value of the promise.</li>
            <li>The main thread removes function execution context for <code>resolve</code> from the call stack.</li>
            <li>The executor function finishes its synchronous execution, and its execution context is popped off the call stack.</li>
            <li>Once the executor function completes its synchronous execution, the promise constructor itself has no more code to run.</li>
            <li>The Promise constructor completes, and its execution context is popped off the call stack.</li>
            <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread moves the callback function <code>c</code> to the microtask queue (or job queue).<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-20.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function calls.</li>
            <li>The main thread creates new function execution contexts and places it on the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-22.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution contexts for <code>setTimeout</code> from the call stack.</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>e</code> function call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task E"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the execution context for <code>e</code> from the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"End"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
            <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The event loop proceeds to handle the microtask queue before handling any macrotasks.</li>
            <li>If there are microtasks in the microtask queue, the event loop moves the microtask <code>c</code> from the microtask queue to the call stack and creates a new function execution context for the resolve callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-23.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Promise resolved successfully"</code> to the console.</li>
            <li>The main thread removes the function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the callback function <code>c</code> from the call stack.</li>
            <li>After all microtasks have been processed, the event loop proceeds to handle macrotasks.</li>
            <li>After 0 milliseconds, the event loop the task <code>d</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-24.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the task <code>d</code> from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-25.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task D"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
        </ul>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/event-loop" class="tag">event loop</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/call-stack" class="tag">call stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/web-api" class="tag">web api</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/macrotask" class="tag">macrotask</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/macrotask-queue" class="tag">macrotask queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask" class="tag">microtask</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask-queue" class="tag">microtask queue</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-15" /><category term="javascript" /><category term="event loop" /><category term="call stack" /><category term="web api" /><category term="macrotask" /><category term="macrotask queue" /><category term="microtask" /><category term="microtask queue" /><summary type="html"><![CDATA[Discover the inner workings of the event loop in JavaScript with our comprehensive guide. Gain insights into the event loop's key components, including the call stack, web API, macrotasks, microtasks, macrotask queue, microtask queue, and more. Through clear explanations and practical examples, this resource offers a deep understanding of how the event loop manages asynchronous operations in JavaScript. Whether you're a beginner or an experienced developer, this guide will equip you with the knowledge to write efficient and responsive JavaScript code.]]></summary></entry><entry xml:lang="en"><title type="html">Execution Context in JavaScript</title><link href="https://hemimorphite.github.io/zh/2024/07/13/execution-context-in-javascript/" rel="alternate" type="text/html" title="Execution Context in JavaScript" /><published>2024-07-13T08:30:00+00:00</published><updated>2024-07-13T08:30:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Execution Context in JavaScript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 13, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a single-threaded programming language. This means that JavaScript can do only one thing at a single point in time.</p>

        <p>The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, and pushes, and pops functions onto and off the call stack in the execution phase.</p>

        <p>When the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code.</p>
        
        <p>JavaScript Execution Context is the environment in which JavaScript code is executed. It contains information about the variables, functions, and objects that are available to the code being executed, as well as the scope chain and the value of the <code>this</code> keyword.</p>
        
        <p>Execution stack, also known as “calling stack” in other programming languages, is a stack with a LIFO (Last in, First out) structure, which is used to store all the execution context created during the code execution.</p>
        <p>There are two types of execution contexts:</p>

        <ul>
            <li><b>Global Execution Context (GEC)</b>: The Global Execution Context is also called the base/default execution. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. Each JavaScript file has only one GEC.</li>
            <li><b>Function Execution Context (FEC)</b>: When a function is called, the JavaScript engine creates a Function Execution Context within the GEC to execute the code within that function. Multiple FECs can exist during script runtime, as each function call has its own FEC. FEC can access the entire code of the GEC, but it is not possible for GEC to access all the code of the FEC. During the GEC code execution.</li>
        </ul>

        <p>When Global Execution Context or Function Execution Context is created. Execution of code is happening in two phases:</p>

        <ul>
            <li><b>Creation Phase</b>, the JavaScript engine sets up the environment for the code to be executed. During this phase, the JavaScript engine creates the following:<br>
                <ul>
                    <li><b>Variable Environment</b>: an Environment Record that holds bindings created by <code>var</code> declarations within this execution context.</li>
                    <li><b>Lexical Environment</b>: an Environment Record
                    used to resolve identifier references, ie. <code>let</code> or <code>const</code>, made by code within this execution context.<br><br>
                    An Environment Record is used to define the association of identifiers to specific variables and functions based upon the lexical nesting structure of the code. Each Environment Record has a reference to the outer environment, which could either point to the Global environment or an outer function environment, enabling the scope chain.<br><br>
                    The <b>Scope Chain</b> is a list of Variable Objects that are accessible in the current scope. Each Variable Object in the Scope Chain represents a higher level of scope.<br><br>
                    There are a few different types of environment records: Global Environment Record, Declarative Environment Record and Object Environment Record.<br><br>
                    The Global Environment Record is a composite environment record, made up of a Declarative Environment Record and an Object Environment Record.<br><br>
                    The Declarative Environment Record is associated with a scope containing variable, <code>const</code>, <code>let</code>, <code>class</code>, <code>module</code>, <code>import</code>, and/or <code>function</code> declarations. A Declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.<br><br>
                    The Object Environment Record is associated with an object called its binding object. Its binding object is the global object, which is window in the case of browsers.<br><br>
                    For every function declaration, a property is added to the record, pointing to that function, and that property is stored in memory. But function expressions are not included. This means all the function declarations will be stored and made accessible inside the execution context, even before the code starts running. This process of storing variables and function declaration in memory prior to the execution of the code is known as Hoisting.</li>
                    <li><b>Determining the value of the <code>this</code> keyword</b>: The value of <code>this</code> is determined and stored in the Execution Context. The value of <code>this</code> depends on how the function is called, and can refer to the global context, the current instance of an object (in the case of methods), or be set explicitly using functions like <code>call</code>, <code>apply</code>, or <code>bind</code>.</li>
                </ul><br>

                In the below code, <code>letter</code> is a binding identifier and the value the variable or binding contains is <code>"a"</code>. Note that variables or bindings contain values, they aren't the values themselves. This is important to understand, variables are containers for values.<br><br>

                <pre><code class="language-bash hljs">const letter = "a"
var number = 1

function greeting() {
    console.log('Welcome to Javascript')
}

const person = {
    name: "John Doe"
}</code></pre><br>
                The below snippet is a pseudo-code representation of execution context.<br><br>
                <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            letter: "a",
            greeting: &lt;ref. to greeting function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;,
            person: {
                name: "John Doe"
            }
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number: 1,
            outer: null
        }
    }
}</code></pre>
            </li>
            <li><b>Execution Phase</b>, the JavaScript engine executes the code line by line. The JavaScript engine reads the code and executes it one line at a time. This phase involves the following steps:<br>
                <ul>
                    <li><b>Assigning Values to Variables</b>: JavaScript engine assigns values to variables. If a variable is not initialized, it has the value of <code>undefined</code>.</li>
                    <li><b>Executing Functions and Code Blocks</b>: JavaScript engine executes functions and code blocks as it encounters them in the code. If a function is called, the engine creates a new execution context for that function and adds it to the call stack.</li>
                    <li><b>Managing the Call Stack</b>:  When a function is called, its execution context is added to the top of the call stack. When the function returns, its execution context is removed from the stack.</li>
                </ul>
            </li>
        </ul>

        <p>The two main components of an execution context in JavaScript are</p>

        <ul>
            <li><b>Memory Component</b> — This refers to the memory space that is allocated for the code and data components within the context. This includes variables, objects, arrays, and other data structures that are used or manipulated by the code. The memory component is also responsible for maintaining the scope chain, which is a list of variable objects that a function has access to, starting with its own variable object and continuing with the variable objects of its parent functions, all the way up to the global variable object.</li>
            <li><b>Code Component</b> — This refers to the actual code that is being executed within the context. It includes any function and variable declarations, as well as any other instructions that make up the code. During the creation phase of the execution context, the JavaScript engine sets up memory space for all variables and function declarations through a process known as hoisting.</li>
        </ul>

        <p>These two components enable the JavaScript engine to execute code and manage data within the program.</p>

        <p>Let's understand the Execution Context with the following code example below:</p>

        <pre><code class="language-bash hljs">function greeting() {
    console.log("Welcome to the JS world!");
}

greeting();

var number1 = 10;
var number2 = 5;

function add(number1, number2) {
    return number1 + number2;
}

function addExtra(number1, number2) {
    var extra = 15;
    return number1 + number2 + extra;
}

var result1 = add(number1, number2);
var result2 = addExtra(number1, number2);

console.log(result1);
console.log(result2);</code></pre>
        
        <p>Using the example code above, let's walk through each stage of what happens during the Memory Creation Phase:</p>

        <ul>
            <li>Javascript engine will create and push a global execution context into the call stack.</li>
            <li>Javascript engine will create the this object and bind it to the global object i.e., <code>window</code> in the web browser or <code>global</code> in Node.js.</li>
            <li>Javascript engine will create a new object called <code>this</code>, which is a reference to the current execution context.</li>
            <li>Javascript engine will set the value of this to the global object, which is the top-most object in the scope chain. In a browser, the global object is the window object, while in a Node.js environment, it's the global object.</li>
            <li>Javascript engine will allocate memory for variables <code>number1</code>, <code>number2</code>, <code>result1</code>, <code>result2</code> and assign undefined to them</li>
            <li>Javascript engine also allocates memory for function <code>greeting</code>, <code>add</code>, <code>addExtra</code> which includes space for the function's code, its name, and its scope.</li>
            <li>The below snippet is a pseudo-code representation of global execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            greeting: &lt;ref. to greeting function object&gt;,
            add: &lt;ref. to add function object&gt;,
            addExtra: &lt;ref. to addExtra function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: undefined,
            number2: undefined,
            outer: null
        }
    }
}</code></pre>
            </li>
        </ul>

        <p>After the memory creation phase is completed, the Javascript engine moves on to the execution phase. The JS engines scan over the function in the code one more time, updating the variable object with the values of the variables and then running the code, which is known as an execution phase.</p>

        <p>Let's look at what happens during the execution phase:</p>

        <ul>
            <li><code>greeting</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>greeting</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 0 as its starting value.</li>
            <li>Javascript engine will create <code>this</code> object and bind to the global object.</li>
            <li>Here is a pseudo-code representation of <code>greeting</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">GreetingFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                length: 0
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>greeting</code> function execution context enters the Execution Phase.</li>
            <li>Javascript engine will display <code>"Welcome to the JS world!"</code> to the console.</li>
            <li>Here is a pseudo-code representation of <code>greeting</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">GreetingFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                length: 0
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>greeting</code> function execution context is returned and the call stack is popped off.</li>
            <li>Control returns to the global execution context.</li>
            <li>Javascript engine will assign 10 to <code>number1</code>.</li>
            <li>Javascript engine will assign 5 to<code>number2</code>.</li>
            <li><code>add</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>add</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 2 as its starting value.</li>
            <li>Assign the value of <code>number1</code> to the first index of the arguments object.</li>
            <li>Assign the value of <code>number2</code> to the second index of the arguments object.</li>
            <li>Javascript engine will create <code>number1</code> and <code>number2</code> variable in the function's local memory and assignthe corresponding values from the arguments object.</li>
            <li>Javascript engine will create <code>this</code> object and bind to the window object.</li>
            <li>Here is a pseudo-code representation of <code>add</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">AddFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>add</code> function execution context enters the Execution Phase.</li>
            <li>The return statement is evaluated.</li>
            <li>Javascript engine will look up <code>number1</code>, <code>number2</code> variables in the function's local memory.</li>
            <li>Javascript engine locates the <code>number1</code>, <code>number2</code> variables in local memory, then swaps the values to the variable references.</li>
            <li>The evaluated result of the <code>add</code> function execution context is returned and the call stack is popped off.</li>
            <li>Here is a pseudo-code representation of <code>add</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">AddFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The control returns to its caller context (the global execution context) with the returned value of 15.</li>
            <li>Javascript engine will assign 15 to <code>result1</code>.</li>
            <li><code>addExtra</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>addExtra</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 2 as its starting value.</li>
            <li>Assign the value of <code>number1</code> to the first index of the arguments object.</li>
            <li>Assign the value of <code>number2</code> to the second index of the arguments object.</li>
            <li>Javascript engine will create <code>number1</code> and <code>number2</code> variables in the function's local memory and assign the corresponding values from the arguments object.</li>
            <li>Javascript engine will create <code>extra</code> variable in the function's local memory and assign undefined to it</li>
            <li>Javascript engine will create <code>this</code> object and bind to the window object.</li>
            <li>Here is a pseudo-code representation of <code>addExtra</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">AddExtraFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            extra: undefined,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>addExtra</code> function execution context enters the Execution Phase.</li>
            <li>Javascript engine will assign 15 to <code>extra</code>.</li>
            <li>The return statement is evaluated.</li>
            <li>Javascript engine will look up <code>number1</code>, <code>number2</code>, <code>extra</code> variables in the function's local memory.</li>
            <li>Javascript engine locates the <code>number1</code>, <code>number2</code>, <code>extra</code> variables in local memory, then swaps the values to the variable references.</li>
            <li>The evaluated result of the <code>addExtra</code> function execution context is returned and the call stack is popped off.</li>
            <li>Here is a pseudo-code representation of <code>addExtra</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">AddExtraFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            extra: 15,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The control returns to its caller context (the global execution context) with the returned value of 30.</li>
            <li>Javascript engine will assign 30 to <code>result2</code>.</li>
            <li>Javascript engine will display <code>15</code> and <code>30</code> to the console.</li>
            <li>The below snippet is a pseudo-code representation of global execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            greeting: &lt;ref. to greeting function object&gt;,
            add: &lt;ref. to add function object&gt;,
            addExtra: &lt;ref. to addExtra function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            result1: 10,
            result2: 30,
            outer: null
        }
    }
}</code></pre>
            </li>
            <li>The global execution context is removed from the call stack or the call stack is popped off.</li>
        </ul>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/global-execution-context" class="tag">global execution context</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/function-execution-context" class="tag">function execution context</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/creation-phase" class="tag">creation phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/execution-phase" class="tag">execution phase</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-13" /><category term="javascript" /><category term="global execution context" /><category term="function execution context" /><category term="creation phase" /><category term="execution phase" /><summary type="html"><![CDATA[Execution context in JavaScript refers to the environment in which code is executed. This includes the global execution context, which encompasses code not within any function, and function execution contexts, which are created when functions are invoked. The execution context goes through two phases: the creation phase, where the JavaScript engine sets up the environment, and the execution phase, where the code is run. Understanding these concepts is crucial for effectively scoping variables and functions and comprehending how JavaScript code is processed.]]></summary></entry></feed>