<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hemimorphite.github.io/zh/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hemimorphite.github.io/zh/" rel="alternate" type="text/html" /><updated>2024-07-22T14:54:35+00:00</updated><id>https://hemimorphite.github.io/feed.xml</id><title type="html">Hemimorphite</title><subtitle>Gain a better understanding of mathematics, chemistry, physics, and computer science. Our tutorials provide clear explanations and practical examples to help you learn and master these subjects. Helping learners of all levels to grasp fundamental concepts and hone their skills.</subtitle><entry><title type="html"></title><link href="https://hemimorphite.github.io/zh/2024/07/22/2024-07-21-git-error-rpc-failed-curl-gnutls-recv-error-error-decoding-the-received-tls-packet-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="" /><published>2024-07-22T14:54:35+00:00</published><updated>2024-07-22T14:54:35+00:00</updated><id>https://hemimorphite.github.io/2024/07/22/2024-07-21-git-error-rpc-failed-curl-gnutls-recv-error-error-decoding-the-received-tls-packet-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/22/2024-07-21-git-error-rpc-failed-curl-gnutls-recv-error-error-decoding-the-received-tls-packet-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title"></h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 22, 2024</span><br><span class="name">By </span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error "RPC failed; curl GnuTLS recv error: Error decoding the received TLS packet" generally indicates an issue with the network connection or the TLS/SSL protocol used by Git and Curl. </p>

        <p>To resolve the "RPC failed; curl GnuTLS recv error: Error decoding the received TLS packet" error, you can recompile Git using <code>libcurl-openssl-dev</code> instead of <code>libcurl4-gnutls-dev</code>.</p>

        <p>Remove Git and its dependencies:</p>

        <pre><code class="language-bash hljs">sudo apt-get -y purge git</code></pre>

        <p>Install necessary dependencies:</p>

        <pre><code class="language-bash hljs">sudo apt-get install build-essential fakeroot dpkg-dev</code></pre>

        <p>Create a directory for compiling git:</p>

        <pre><code class="language-bash hljs">mkdir git-source
cd git-source</code></pre>
        
        <p>open the <code>sources.list</code> file located in the <code>/etc/apt/</code> directory using a vim editor:</p>

        <pre><code class="language-bash hljs">sudo vi /etc/apt/sources.list</code></pre>
        
        <p>For Debian 12, add the following line:</p>

        <pre><code class="language-bash hljs">deb-src http://deb.debian.org/debian bookworm main
deb-src http://deb.debian.org/debian bookworm-updates main</code></pre>
        
        <p>For Ubuntu 22.04, uncomment the following line:</p>

        <pre><code class="language-bash hljs">deb-src http://archive.ubuntu.com/ubuntu/ jammy main restricted
deb-src http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted</code></pre>
        
        <p>Then run the following to update the package index files from their sources:</p>
        
        <pre><code class="language-bash hljs">sudo apt-get update</code></pre>

        <p>Download git source code:</p>
        
        <pre><code class="language-bash hljs">apt-get source git</code></pre>

        <p>Install build dependencies for git:</p>
        
        <pre><code class="language-bash hljs">sudo apt-get build-dep git</code></pre>
        
        <p>Install <code>libcurl4-openssl-dev</code> package:</p>

        <pre><code class="language-bash hljs">sudo apt-get install -y libcurl4-openssl-dev</code></pre>
        
        <p>Enter the git source code directory:</p>
        
        <pre><code class="language-bash hljs">cd git-2.39.2</code></pre>

        <p>Change <code>libcurl4-gnutls-dev</code> to <code>libcurl4-openssl-dev</code> in <code>./debian/control</code>:</p>
        
        <pre><code class="language-bash hljs">sed -i -- 's/libcurl4-gnutls-dev/libcurl4-openssl-dev/' ./debian/control</code></pre>

        <p>Edit <code>./debian/rules</code> to delete the entire line containing <code>TEST=test</code>:</p>

        <pre><code class="language-bash hljs">sed -i -- '/TEST=test/d' ./debian/rules
        </code></pre>

        <p>Build git from the source code.</p>

        <pre><code class="language-bash hljs">sudo dpkg-buildpackage -rfakeroot -b</code></pre>

        <p>Back to the <code>~/git-source</code> directory:</p>

        <pre><code class="language-bash hljs">cd ..</code></pre>

        <p>Install the compiled git package:</p>

        <pre><code class="language-bash hljs">sudo dpkg -i git_2.39.2-1.1_amd64.deb</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://hemimorphite.github.io/zh/2024/07/22/2024-07-21-git-error-rpc-failed-curl-http2-stream-was-not-closed-cleanly-on-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="" /><published>2024-07-22T14:54:35+00:00</published><updated>2024-07-22T14:54:35+00:00</updated><id>https://hemimorphite.github.io/2024/07/22/2024-07-21-git-error-rpc-failed-curl-http2-stream-was-not-closed-cleanly-on-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/22/2024-07-21-git-error-rpc-failed-curl-http2-stream-was-not-closed-cleanly-on-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title"></h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 22, 2024</span><br><span class="name">By </span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error "RPC failed; curl 18 HTTP/2 stream 5 was not closed cleanly" typically indicates a problem with the HTTP/2 protocol during a Git operation, such as cloning or pushing to a repository. This error can be related to network issues, HTTP/2 protocol handling, or configuration problems. </p>

        <p>To resolve the "RPC failed; curl 92 HTTP/2 stream 0 was not closed cleanly" error, you can force Git to use HTTP/1.1 instead of HTTP/2.</p>

        <pre><code class="language-bash hljs">git config --global http.version HTTP/1.1</code></pre>

    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://hemimorphite.github.io/zh/2024/07/22/2024-07-21-git-error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="" /><published>2024-07-22T14:54:35+00:00</published><updated>2024-07-22T14:54:35+00:00</updated><id>https://hemimorphite.github.io/2024/07/22/2024-07-21-git-error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/22/2024-07-21-git-error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title"></h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 22, 2024</span><br><span class="name">By </span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error RPC failed; curl transfer closed with outstanding read data remaining typically occurs when you have to clone a large repository from a slow internet connection, and the connection tends to close.</p>

        <p>Do a shallow clone:</p>

        <pre><code class="language-bash hljs">git clone https://github.com/microsoft/TypeScript.git --depth 1</code></pre>

        <p>This option allows you to clone only the latest commits, which can be helpful when dealing with large repositories or slow network connections.</p>

        <p>Navigate in the local repository directory:</p>

        <pre><code class="language-bash hljs">cd TypeScript</code></pre>

        <p>Convert a shallow clone of a Git repository into a complete repository with the full commit history:</p>

        <pre><code class="language-bash hljs">git fetch --unshallow</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://hemimorphite.github.io/zh/2024/07/22/2024-07-22-git-error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12/" rel="alternate" type="text/html" title="" /><published>2024-07-22T14:54:35+00:00</published><updated>2024-07-22T14:54:35+00:00</updated><id>https://hemimorphite.github.io/2024/07/22/2024-07-22-git-error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/22/2024-07-22-git-error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining-ubuntu-2204-and-debian-12/"><![CDATA[<div class="blog-post">
    <h2 class="post-title"></h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 22, 2024</span><br><span class="name">By </span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The error RPC failed; curl transfer closed with outstanding read data remaining typically occurs when you have to clone a large repository from a slow internet connection, and the connection tends to close.</p>

        <p>Do a shallow clone:</p>

        <pre><code class="language-bash hljs">git clone https://github.com/microsoft/TypeScript.git --depth 1</code></pre>

        <p>This option allows you to clone only the latest commits, which can be helpful when dealing with large repositories or slow network connections.</p>

        <p>Navigate in the local repository directory:</p>

        <pre><code class="language-bash hljs">cd TypeScript</code></pre>

        <p>Convert a shallow clone of a Git repository into a complete repository with the full commit history:</p>

        <pre><code class="language-bash hljs">git fetch --unshallow</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name></name></author></entry><entry xml:lang="en"><title type="html">Event Loop in Node.Js</title><link href="https://hemimorphite.github.io/zh/2024/07/18/event-loop-in-nodejs/" rel="alternate" type="text/html" title="Event Loop in Node.Js" /><published>2024-07-18T16:21:00+00:00</published><updated>2024-07-18T16:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/18/event-loop-in-nodejs</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/18/event-loop-in-nodejs/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Event Loop in Node.Js</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 18, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/eventloop-nodejs.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Node.js uses a single-threaded event loop to handle asynchronous operations. This means that all the JavaScript code is executed on a single thread, but the event loop can handle multiple operations concurrently.</p>

        <p>The JavaScript code consists of two lines of execution:</p>

        <ul>
            <li>The mainline: This is the JavaScript that runs when Node first runs your program. It runs from start to finish, and when it is finished, it gives up control to the event loop.</li>
            <li>The event loop: This is where all of your callbacks are run.</li>
        </ul>

        <p>The following diagram shows a simplified overview of the event loop's order of operations.</p>

        <pre><code class="language-bash hljs">    ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘</code></pre>

        <p>The event loop in Node.js does not have a predefined number of iterations; it continues running indefinitely until there are no more tasks to perform. Each iteration of the event loop is referred to as a tick. The event loop will keep ticking as long as there are pending operations, such as:</p>
        
        <ul>
            <li>Promises and other microtasks.</li>
            <li>Pending timers (callbacks scheduled with <code>setTimeout</code> or <code>setInterval</code>).</li>
            <li>Pending I/O operations (e.g., file system operations, network requests).</li>
            <li>Pending callbacks (e.g., deferred I/O callbacks).</li>
            <li><code>setImmediate</code> callbacks.</li>
            <li>Close callbacks.</li>
        </ul>

        <h5 class="post-subtitle">Microtasks</h5>

        <p>All microtasks are placed into a microtask queue, designed specifically for handling them.</p>

        <p>The microtask queue is processed and emptied before every phase iteration of the event loop.</p>

        <p>Microtasks are executed at specific points in the event loop:</p>

        <ol>
            <li>After executing JavaScript code: When the call stack becomes empty, the event loop checks for and executes any pending microtasks before moving to the next phase.</li>
            <li>After processing each phase of the event loop: Once the current phase of the event loop is completed, before moving to the next phase, the event loop processes all the pending microtasks.</li>
        </ol>
    
        <p>Here are the main types of microtasks:</p>

        <ul>
            <li>Promise Callbacks: <code>.then()</code>, <code>.catch()</code>, and <code>.finally()</code> handlers.</li>
            <li><code>queueMicrotask</code>: Both queueMicrotask and Promise Callbacks added to the microtask queue and have similar priority.</li>
            <li><code>process.nextTick</code>: Callbacks scheduled with <code>process.nextTick</code> are executed before promise callbacks or queueMicrotask callbacks. <code>process.nextTick</code> callbacks are added to the beginning of the microtask queue.</li>
        </ul>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');
process.nextTick(console.log, "nextTick 1");
Promise.resolve("Promise 1").then(console.log);
queueMicrotask(() => console.log("queueMicrotask 1"));
Promise.reject("Promise 2").catch(console.log);
queueMicrotask(() => console.log("queueMicrotask 2"));
process.nextTick(console.log, "nextTick 2");
console.log('End');</code></pre>
        
        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick 1
nextTick 2
Promise 1
queueMicrotask 1
Promise 2
queueMicrotask 2</code></pre>

        <p>The execution flow is as follows:</p>
        
        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The executor function within the Promise constructor initializes the promise.</li>
                    <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread executes resolve function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>Calling resolve transitions the promise from the pending state to the fulfilled (or resolved) state.</li>
                    <li>The value "Promise 1" is set as the value of the new promise internally.</li>
                    <li>The main thread removes function execution context for <code>resolve</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>executor function</code> from the call stack.</li>
                    <li>The Promise constructor completes, and its execution context is popped off the call stack.</li>
                    <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread moves the resolve callback function to the microtask queue (or job queue).</li>
                    <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes the second Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The executor function within the second Promise constructor initializes the promise.</li>
                    <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread executes reject function call, and its execution context is created and pushed onto the call stack.</li>
                    <li>Calling resolve transitions the promise from the pending state to the rejected state.</li>
                    <li>The value "Promise 2" is set as the value of the new promise internally.</li>
                    <li>The main thread removes function execution context for <code>reject</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>executor function</code> from the call stack.</li>
                    <li>The second Promise constructor completes, and its execution context is popped off the call stack.</li>
                    <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
                    <li>The main thread moves the resolve callback function to the microtask queue (or job queue).</li>
                    <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
                    <li>The main thread executes the second <code>queueMicrotask</code> function call, a function execution context for the second <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the second <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for the second  <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes the second <code>process.nextTick</code> function call, a function execution context for the second <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the second <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for the second <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li>
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for the first <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"nextTick 1"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for the first <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the second task from the nextTick queue onto the call stack and creates a new function execution context for the second <code>process.nextTick</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"nextTick 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for the second <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for promise <code>then()</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"Promise 1"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for promise <code>then()</code> callback function from the call stack.</li>
                            <li>The event loop pushes the next task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"queueMicrotask 1"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                            <li>The event loop pushes the next task from the microtask queue onto the call stack and creates a new function execution context for promise <code>then()</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"Promise 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for promise <code>then()</code> callback function from the call stack.</li>
                            <li>The event loop pushes the next task from the microtask queue onto the call stack and creates a new function execution context for the second <code>queueMicrotask</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"queueMicrotask 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for the second  <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timers have expired yet (since less than 500 milliseconds have passed).</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Timers</h5>
        
        <p>The first phase of the event loop is the Timers phase. This phase deals with timer callbacks that have reached their scheduled time. Timers in Node.js can be used to schedule code execution after a specified delay or at specific intervals. When a timer's time comes, its callback function is added to the event queue (task queue) to be executed.</p>

        <p>Timers are not guaranteed to execute exactly at their scheduled time, as they are subject to the availability of the system and the event loop. For example, if the event loop is busy processing other events, the timer callback may be delayed until the next iteration of the event loop. Therefore, timers should not be used for precise timing, but rather for approximate timing.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

setTimeout(() => {
    console.log('Timeout callback 1');
}, 1000);

setTimeout(() => {
    console.log('Timeout callback 2');
}, 500);

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback 2
Timeout callback 1</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes the second <code>setTimeout</code> function call, a function execution context for the second <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the second <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for the second <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timers have expired yet (since less than 500 milliseconds have passed).</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase (After 500 milliseconds)<br>
                        <ul>
                            <li>The event loop pushes the task from the callback queue onto the call stack and creates a new function execution context for the second <code>setTimeout</code> callback function.</li>
                            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The main thread logs <code>"Timeout callback 2"</code> to the console.</li>
                            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The main thread removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase (After 1000 milliseconds)<br>
                        <ul>
                            <li>The event loop pushes the task from the callback queue onto the call stack and creates a new function execution context for the first <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback 1"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Pending Callbacks</h5>

        <p>I/O operations execute in the poll phase of the event loop. During the poll phase, some specific I/O operations callbacks defer to the pending phase of the next iteration of the event loop. I/O operations callbacks deferred from the previous iteration run in the pending callbacks phase.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require("fs");

fs.readFile(__filename, (err, data) => {
    if (err) throw err;
    console.log("Pending callback");
});
            
setTimeout(() => {
    console.log('Timeout callback');
}, 0);

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Pending callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>fs</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.readFile</code> function call, a function execution context for <code>fs.readFile</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.readFile</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The file reading process is finished, but its callback is not yet marked to be executed because IO callbacks get queued up only at the IO Poll Phase.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The <code>fs.readFile</code> callback event is collected and added to the I/O queue.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>fs.readFile</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Pending callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>fs.readFile</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Idle Phase</h5>

        <p>The idle phase is not a normal phase of the Node.js event loop. It is a period whereby the event loop has nothing to do but perform background tasks like checking for low-priority results or running garbage collection.</p>

        <h5 class="post-subtitle">Poll Phase</h5>

        <p>The poll phase is where I/O operations execute. I/O  operations transfer data to or from a computer. The event loop checks for new I/O operations and executes them in the poll queue.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require("fs");

fs.readFile(__filename, (err, data) => {
    if (err) throw err;
    console.log("Pending callback");
});

const http = require("http");

http.get("http://localhost", (res) => {
    console.log("Poll callback");
    res.on("data", (chunk) => {
        // Do something with the data
        console.log("Data event listener callback");
    });
});

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Poll callback
Data event listener callback
Pending callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>fs</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.readFile</code> function call, a function execution context for <code>fs.readFile</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>The main thread moves the <code>fs.readFile</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.readFile</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>http</code>.</li>
                    <li>The main thread wraps the contents of <code>http</code> in a function and executes it, a function execution context for <code>http</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>http</code>.</li>
                    <li>The main thread removes function execution context for <code>http</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>http.get</code> function call, a function execution context for <code>http.get</code> is added to the call stack.</li>
                    <li>The main thread initiates initiates an HTTP GET request.</li>
                    <li>The main thread moves the <code>http.get</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>http.get</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The file reading process isn't finished.</li>
                            <li>The HTTP request is sent over the network and waits for the server response.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The file reading process is finished, but its callback is not yet marked to be executed because IO callbacks get queued up only at the IO Poll Phase.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The <code>fs.readFile</code> callback event is collected and added to the I/O queue.</li>
                            <li>When the response headers from the server are received, the event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>http.get</code> callback function.</li>
                            <li>The server <code>localhost</code> responds HTTP GET request, the data starts arriving in chunks.</li>
                            <li>The event loop executes the data event listener call, a function execution context for data event listener is added to the call stack.</li>
                            <li>The event loop moves the calbback function for data event listener to the event queue (task queue).</li>
                            <li>Each chunk of data triggers a data event on the response object.</li>
                            <li>Once the event loop detects the data event, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The data event listener also has no more code to run.</li>     
                            <li>The event loop removes function execution context for data event listener from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>fs.readFile</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Pending callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>fs.readFile</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>  

        <h5 class="post-subtitle">Check Phase</h5>

        <p>The check phase is where the <code>setImmediate</code> timer runs. The Node.js event loop goes to the check phase when there is a <code>setImmediate</code> in the program, and the poll phase becomes idle or when the poll phase completes.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require("fs");

fs.readFile(__filename, (err, data) => {
    if (err) throw err;
    console.log("Pending callback");
});

const http = require("http");

http.get("http://localhost", (res) => {
    console.log("Poll callback");
    res.on("data", (chunk) => {
        // Do something with the data
        console.log("Data event listener callback");
    });
});

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

setImmediate(() => {
    console.log("Check callback");
});

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Check callback
Poll callback
Data event listener callback
Pending callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>fs</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.readFile</code> function call, a function execution context for <code>fs.readFile</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>The main thread moves the <code>fs.readFile</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.readFile</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>http</code>.</li>
                    <li>The main thread wraps the contents of <code>http</code> in a function and executes it, a function execution context for <code>http</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>http</code>.</li>
                    <li>The main thread removes function execution context for <code>http</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>http.get</code> function call, a function execution context for <code>http.get</code> is added to the call stack.</li>
                    <li>The main thread initiates initiates an HTTP GET request.</li>
                    <li>The main thread moves the <code>http.get</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>http.get</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>setImmediate</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>setImmediate</code> callback function to the check queue.</li>
                    <li>The main thread removes function execution context for <code>setImmediate</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The file reading operation isn't finished.</li>
                            <li>The HTTP request is sent over the network and waits for the server response.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the check queue onto the call stack and creates a new function execution context for <code>setImmediate</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Check callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setImmediate</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The file reading operation is finished, but its callback is not yet marked to be executed because IO callbacks get queued up only at the IO Poll Phase.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The <code>fs.readFile</code> callback event is collected and added to the I/O queue.</li>
                            <li>When the response headers from the server are received, the event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>http.get</code> callback function.</li>
                            <li>The server <code>localhost</code> responds HTTP GET request, the data starts arriving in chunks.</li>
                            <li>The event loop executes the data event listener call, a function execution context for data event listener is added to the call stack.</li>
                            <li>The event loop moves the calbback function for data event listener to the event queue (task queue).</li>
                            <li>Each chunk of data triggers a data event on the response object.</li>
                            <li>Once the event loop detects the data event, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The data event listener also has no more code to run.</li>     
                            <li>The event loop removes function execution context for data event listener from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>fs.readFile</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Pending callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>fs.readFile</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>No I/O events to process.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h5 class="post-subtitle">Close Callbacks Phase</h5>  

        <p>The close callbacks phase is the last phase of the Node.js event loop. The close callback phase is where callbacks from the close event of a socket and the closing of an HTTP server run.</p>

        <p>The close callbacks phase is designed to handle cleanup operations related to resource closure, such as the closing of TCP connections, file descriptors, and other resources.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

const fs = require('fs');

const readable = fs.createReadStream(__filename);

readable.on('data', (chunk) => {
    console.log('Data event listener');
});

readable.on('close', () => {
    console.log('Close callback');
});

const http = require("http");

http.get("http://localhost", (res) => {
    console.log("Poll callback");
    res.on("data", (chunk) => {
        // Do something with the data
        console.log("Data event listener callback");
    });
});

setTimeout(() => {
    console.log('Timeout callback');
}, 0);

setImmediate(() => {
    console.log("Check callback");
});

process.nextTick(console.log, "nextTick callback");

queueMicrotask(() => console.log("queueMicrotask callback"));

console.log('End');</code></pre>  

        <p>The output depends on which operation finishes first, the HTTP request or the file reading operation.</p>

        <p>The output would be:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Check callback
Poll callback
Data event listener callback
Pending callback</code></pre>
        
        <p>Or:</p>

        <pre><code class="language-bash hljs">Start
End
nextTick callback
queueMicrotask callback
Timeout callback
Check callback
Data event listener
Poll callback
Data event listener callback
Close callback</code></pre>
        
        <p>The execution flow is as follows:</p>

        <ul>
            <li>The mainline<br>
                <ul>
                    <li>The main thread starts by creating the global execution context and pushes it onto the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"Start"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>fs</code>.</li>
                    <li>The main thread wraps the contents of <code>fs</code> in a function and executes it, a function execution context for <code>fs</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>readable</code>.</li>
                    <li>The main thread removes function execution context for <code>fs</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>fs.createReadStream</code> function call, a function execution context for <code>fs.createReadStream</code> is added to the call stack.</li>
                    <li>The main thread initiates a non-blocking file system operation to read the current file.</li>
                    <li>This function is synchronous, meaning it runs immediately and returns a Readable stream object assigned to the <code>readable</code>.</li>
                    <li>The main thread moves the <code>fs.createReadStream</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>fs.createReadStream</code> from the call stack.</li>
                    <li>The main thread executes <code>readable.on</code> function call, a function execution context for <code>readable.on</code> is added to the call stack.</li>
                    <li>The main thread moves the callback function to the event queue (task queue) which will be invoked whenever a chunk of data is available to be read from the stream.</li>
                    <li>This callback is an asynchronous event listener, meaning it will be called asynchronously whenever the 'data' event is emitted.</li>
                    <li>The main thread moves the <code>readable.on</code> callback function to the I/O queue.</li>
                    <li>The main thread executes the second <code>readable.on</code> function call, a function execution context for <code>readable.on</code> is added to the call stack.</li>
                    <li>The main thread moves the callback function to the event queue (task queue) which will be  invoked when the stream is closed.</li>
                    <li>This callback is also asynchronous and will be called when the 'close' event is emitted.</li>
                    <li>The main thread moves the <code>readable.on</code> callback function to the I/O queue.</li>

                    <li>The main thread executes <code>require</code> function call, a function execution context for <code>require</code> is added to the call stack.</li>
                    <li>The main thread starts resolving the module identifier <code>http</code>.</li>
                    <li>The main thread wraps the contents of <code>http</code> in a function and executes it, a function execution context for <code>http</code> is added to the call stack.</li>
                    <li>The <code>module.exports</code> object is returned and assigned to <code>http</code>.</li>
                    <li>The main thread removes function execution context for <code>http</code> from the call stack.</li>
                    <li>The main thread removes function execution context for <code>require</code> from the call stack.</li>
                    <li>The main thread executes <code>http.get</code> function call, a function execution context for <code>http.get</code> is added to the call stack.</li>
                    <li>The main thread initiates initiates an HTTP GET request.</li>
                    <li>The main thread moves the <code>http.get</code> callback function to the I/O queue.</li>
                    <li>The main thread removes the function execution context for the first <code>http.get</code> from the call stack.</li>
                    <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
                    <li>The main thread adds the <code>setTimeout</code> callback function to the timer queue.</li>
                    <li>The event loop continuously checks the timer queue. When the specified delay has elapsed, the callback function is moved to the appropriate phase of the event loop.</li>
                    <li>The main thread removes the function execution context for <code>setTimeout</code> from the call stack.</li>
                    <li>The main thread executes <code>setImmediate</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>setImmediate</code> callback function to the check queue.</li>
                    <li>The main thread removes function execution context for <code>setImmediate</code> from the call stack.</li>
                    <li>The main thread executes <code>process.nextTick</code> function call, a function execution context for <code>process.nextTick</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>process.nextTick</code> callback function to the next tick queue.</li>
                    <li>The main thread removes the function execution context for <code>process.nextTick</code> from the call stack.</li>
                    <li>The main thread executes <code>queueMicrotask</code> function call, a function execution context for <code>queueMicrotask</code> is added to the call stack.</li>
                    <li>The main thread moves the <code>queueMicrotask</code> callback function to the microtask queue.</li>
                    <li>The main thread removes the function execution context for <code>queueMicrotask</code> from the call stack.</li>
                    <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                    <li>The main thread logs <code>"End"</code> to the console.</li>
                    <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
                    <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
                    <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
                </ul>
            </li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The first loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue. The nextTick queue gets priority over the microtask queue.<br>
                        <ul>
                            <li>The event loop pushes the task from the nextTick queue onto the call stack and creates a new function execution context for <code>process.nextTick</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"nextTick callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The event loop removes the function execution context for <code>process.nextTick</code> callback function from the call stack.</li>
                            <li>The event loop pushes the task from the microtask queue onto the call stack and creates a new function execution context for <code>queueMicrotask</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"queueMicrotask callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>queueMicrotask</code> callback function from the call stack.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the timer queue onto the call stack and creates a new function execution context for <code>setTimeout</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Timeout callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>The event loop waits for data from streams.</li>
                            <li>The HTTP request is sent over the network and waits for the server response.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>The event loop pushes the task from the check queue onto the call stack and creates a new function execution context for <code>setImmediate</code> callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Check callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes the function execution context for <code>setImmediate</code> callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>No close callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                The event loop will continue to loop.
            </li>
            <li>The next loop<br>
                <ul>
                    <li>The first loop starts by running the microtasks queue.<br>
                        <ul>
                            <li>No microtasks to execute.</li>
                        </ul>
                    </li>
                    <li>Timers Phase<br>
                        <ul>
                            <li>No timeout callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Pending Callbacks Phase<br>
                        <ul>
                            <li>No pending callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Poll Phase<br>
                        <ul>
                            <li>When a chunk of data is received, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>Each chunk of data triggers a data event on the readable stream object.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>When the response headers from the server are received, the event loop pushes the task from the I/O queue onto the call stack and creates a new function execution context for <code>http.get</code> callback function.</li>
                            <li>The server <code>localhost</code> responds HTTP GET request, the data starts arriving in chunks.</li>
                            <li>The event loop executes the data event listener call, a function execution context for data event listener is added to the call stack.</li>
                            <li>The event loop moves the calbback function for data event listener to the event queue (task queue).</li>
                            <li>Each chunk of data triggers a data event on the response object.</li>
                            <li>Once the event loop detects the data event, the event loop will move the callback function for data event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Data event listener callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The data event listener also has no more code to run.</li>     
                            <li>The event loop removes function execution context for data event listener from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Check Phase<br>
                        <ul>
                            <li>No check callbacks to execute.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                    <li>Close Callbacks Phase<br>
                        <ul>
                            <li>When the entire file is read, the event loop will move the callback function for close event listener from the event queue (task queue) to the call stack to be executed and create a new function execution context for callback function.</li>
                            <li>The event loop executes <code>console.log</code> function call, a function execution context for <code>console.log</code> is added to the call stack.</li>
                            <li>The event loop logs <code>"Close callback"</code> to the console.</li>
                            <li>The event loop removes function execution context for <code>console.log</code> from the call stack.</li>
                            <li>The callback function has no more code to run.</li>
                            <li>The event loop removes function execution context for callback function from the call stack.</li>
                            <li>The event loop checks for any new callbacks added to the microtasks queue.</li>
                            <li>If no any new callbacks added to the microtasks queue, the event loop continues to next phase.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/nodejs" class="tag">nodejs</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/event-loop" class="tag">event loop</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/call-stack" class="tag">call stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/nodejs-api" class="tag">nodejs api</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask" class="tag">microtask</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask-queue" class="tag">microtask queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/timers-phase" class="tag">timers phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/pending-callbacks-phase" class="tag">pending callbacks phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/idle-phase" class="tag">idle phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/check-phase" class="tag">check phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/close-callbacks-phase" class="tag">close callbacks phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/timer-queue" class="tag">timer queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/io-queue" class="tag">IO queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/check-queue" class="tag">check queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/close-queue" class="tag">close queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/event-queue-task-queue" class="tag">event queue (task queue)</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-18" /><category term="nodejs" /><category term="event loop" /><category term="call stack" /><category term="nodejs api" /><category term="microtask" /><category term="microtask queue" /><category term="timers phase" /><category term="pending callbacks phase" /><category term="idle phase" /><category term="check phase" /><category term="close callbacks phase" /><category term="timer queue" /><category term="IO queue" /><category term="check queue" /><category term="close queue" /><category term="event queue (task queue)" /><summary type="html"><![CDATA[Explore the intricacies of the event loop in Node.js with our comprehensive guide. This resource delves into the event loop's components, including the call stack, Node.js API, microtasks, microtask queue, timers phase, pending callbacks phase, idle phase, check phase, close callbacks phase, timer queue, IO queue, check queue, close queue, and event queue (task queue). Gain a deeper understanding of how the event loop manages asynchronous operations, and learn how to write efficient and responsive Node.js applications. With clear explanations and practical examples, this guide is your gateway to mastering the event loop in Node.js.]]></summary></entry><entry xml:lang="en"><title type="html">Event Loop in Javascript</title><link href="https://hemimorphite.github.io/zh/2024/07/15/event-loop-in-javascript/" rel="alternate" type="text/html" title="Event Loop in Javascript" /><published>2024-07-15T06:21:00+00:00</published><updated>2024-07-15T06:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Event Loop in Javascript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 15, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/eventloop-javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a single-threaded programming language. This means that JavaScript can do only one thing at a single point in time.</p>

        <p>The main thread is responsible for executing JavaScript code, performing rendering tasks, and handling user interactions. Since JavaScript is single-threaded, it can perform only one task at a time on the main thread.</p>

        <p>The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, and pushes, and pops functions onto and off the call stack in the execution phase.</p>

        <p>If a function takes a long time to execute, you cannot interact with the web browser during the function's execution because the page hangs.</p>

        <p>A function that takes a long time to complete is called a blocking function. Technically, a blocking function blocks all the interactions on the webpage, such as mouse clicks.</p>

        <p>The following example uses a big loop to simulate a blocking function:</p>

        <pre><code class="language-bash hljs">function task(message) {
    // emulate time consuming task
    let n = 10000000000;
    while (n > 0){
        n--;
    }
    console.log(message);
}

console.log('Start script...');
task('Doing a task');
console.log('Done!');</code></pre>

        <p>The script hangs for a few seconds (depending on how fast the computer is) and issues the following output:</p>

        <pre><code class="language-bash hljs">Start script...
Doing a task
Done!</code></pre>
        
        <p>The JavaScript Event Loop is a mechanism that enables JavaScript to perform non-blocking I/O operations despite being single-threaded. It allows asynchronous operations, such as handling user inputs, network requests, and timers, to be executed without blocking the main execution thread.</p>
        
        <p>The Event Loop stands as a crucial element within the JavaScript runtime environment, functioning in the following manner:</p>

        <ul>
            <li>Continuously monitoring the status of the call stack to determine if it's empty.</li>
            <li>Upon encountering an empty call stack, all pending Microtasks from the Microtask Queue are introduced into the call stack.</li>
            <li>When both the call stack and Microtask Queue are devoid of tasks, the event loop proceeds to dequeue tasks from the Task Queue and execute them.</li>
            <li>Ensuring the prevention of a "starved event loop" remains pivotal for maintaining seamless JavaScript execution.</li>
        </ul>

        <p>The Event Loop is a continuous process that coordinates the execution of tasks in JavaScript. It is composed of several components that work together to facilitate asynchronous programming:</p>

        <ul>
            <li>Call Stack</li>
            <li>Web APIs</li>
            <li>Macrotask Queue</li>
            <li>Microtask Queue</li>
        </ul>

        <h5 class="post-subtitle">Call Stack</h5>

        <p>The call stack is a fundamental concept in JavaScript and plays a key role in understanding the language's asynchronous behavior. It is a data structure known as a Last In, First Out (LIFO) stack, which is responsible for keeping track of the function calls and their execution order. Whenever a function is called, it gets added to the call stack, and once it finishes executing, it is removed from the stack (sort of).</p>
        
        <p>JavaScript is single-threaded, meaning it has only one call stack that can handle one task at a time. This is why blocking operations, such as time-consuming calculations or network requests, can freeze the browser's UI until the task is completed.</p>
        
        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">function fifth() { 
    console.log("fifth")
}

function fourth() { 
    console.log("fourth")
    fifth() 
}

function third() { 
    console.log("third")
    fourth() 
}

function second() { 
    console.log("second")
    third() 
}

function first() {
    console.log("first") 
    second() 
}

first();</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>first</code> function call, a function execution context for <code>first</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-01.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>first</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"first"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>second</code> function call, a function execution context for  <code>second</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-02.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>second</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"second"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>third</code> function call, a function execution context for  <code>third</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-03.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>third</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"third"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>fourth</code> function call, a function execution context for  <code>fourth</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-04.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>fourth</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"fourth"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <code>fifth</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-05.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>fifth</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"fifth"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes function execution context for <code>fifth</code>, <code>fourth</code>, <code>third</code>, <code>second</code> and <code>first</code> consecutively from the call stack.</li>
            <li>The main thread removes the global execution context from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Web APIs</h5>

        <p>Web APIs are provided by the browser environment to extend JavaScript's functionality beyond its single-threaded nature. These APIs allow developers to access features like the DOM, timers, and network requests, enabling JavaScript to perform tasks asynchronously without blocking the call stack.</p>

        <p>When a function utilizing a Web API is called, the API handles the task in the background and returns a callback function. This callback is then placed into a queue, waiting to be executed once the call stack is empty.</p>

        <p>Here are some common examples of Web APIs: DOM (Document Object Model) API, Fetch API, Geolocation API, Canvas API, Web Storage API, etc.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 1000);

console.log('End');</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Start"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function call.</li>
            <li>The main thread creates a new function execution context and places it on the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.</li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that counts down in the background within the Web API environment from the specified delay (1000 milliseconds in this case).</li>
            <li>The main thread removes the function execution context from the call stack.</li>
            <li>When the timer expires after the specified delay, the Web API moves the callback function to the callback queue (or task queue).</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"End"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
            <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> <li>The event loop pushes the first task from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Timeout"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for <code>setTimeout</code> callback function from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Tasks and the Task Queue</h5>
        
        <p>Tasks are scheduled, synchronous blocks of code. While executing, they have exclusive access to the Call Stack and can also enqueue other tasks. Between Tasks, the browser can perform rendering updates. Tasks are stored in the Task Queue, waiting to be executed by their associated functions. These tasks come from:</p>

        <ul>
            <li>Timers (via setTimeout or setInterval)</li>
            <li>Event listeners (when an event is triggered)</li>
            <li>Network operations (when a response is received)</li>
        </ul>

        <p>The Task Queue is a FIFO (First In, First Out) data structure.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">setTimeout(function a() {
    console.log("task A")            
}, 1000);

setTimeout(function b() {
    console.log("task B")
}, 500);

setTimeout(function c() {
    console.log("task C")
}, 0);

function d() {
    console.log("task D")
}

d();</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function call, a function execution context for <code>setTimeout</code> is added to the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-10.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the <code>setTimeout</code> callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> function from the call stack.</li>
            <li>The main thread executes the second <code>setTimeout</code> function call, a function execution context for the second <code>setTimeout</code> is added to the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-11.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the second  <code>setTimeout</code> callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution context for the second <code>setTimeout</code> function from the call stack.</li>
            <li>The main thread executes the third <code>setTimeout</code> function call, a function execution context for the third <code>setTimeout</code> is added to the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-13.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the third  <code>setTimeout</code> callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution context for the third <code>setTimeout</code> function from the call stack.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>d</code> function call, a function execution context for <code>d</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-12.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>d</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task D"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes function execution context for <code>d</code> from the call stack.</li>
            <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
            <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li>
            <li>After 0 milliseconds, the event loop the task <code>c</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-14.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the task <code>c</code> from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-15.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task C"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
            <li>After 500 milliseconds, the event loop the task <code>b</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-16.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the task <code>b</code> from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-17.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task B"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
            <li>After 1000 milliseconds, the event loop the task <code>a</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-18.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the next task from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-19.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task A"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Microtasks and the Microtask Queue</h5>

        <p>Microtasks are similar to Tasks in that they're scheduled, synchronous blocks of code with exclusive access to the Call Stack while executing. Additionally, they are stored in their own FIFO (First In, First Out) data structure, the Microtask Queue. Microtasks differ from Tasks, however, in that the Microtask Queue must be emptied out after a Task completes and before re-rendering.</p>

        <p>Microtasks and the Microtask Queue are also referred to as Jobs and the Job Queue.</p>
        
        <p>The microtask queue holds tasks that are prioritized over tasks in the task queue. Microtasks include promises and mutation observer callbacks. When the call stack is empty and before fetching tasks from the task queue, the event loop first processes all tasks in the microtask queue. This ensures that microtasks are executed as soon as possible.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log("Start");

const promise = new Promise((resolve, reject) => {
    console.log("Promise executor function started");
    resolve("Promise resolved successfully");
});

promise.then(function c(result) {
    console.log(result);
});

setTimeout(function d() {
    console.log("task D");
}, 0);

function e() {
    console.log("task E");
}

e();

console.log("End");</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Start"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
            <li>The executor function within the Promise constructor initializes the promise.</li>
            <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Promise executor function started"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes resolve function call, and its execution context is created and pushed onto the call stack.</li>
            <li>Calling resolve transitions the promise from the pending state to the fulfilled (or resolved) state.</li>
            <li>The value <code>"Promise resolved successfully"</code> is set as the value of the promise.</li>
            <li>The main thread removes function execution context for <code>resolve</code> from the call stack.</li>
            <li>The executor function finishes its synchronous execution, and its execution context is popped off the call stack.</li>
            <li>Once the executor function completes its synchronous execution, the promise constructor itself has no more code to run.</li>
            <li>The Promise constructor completes, and its execution context is popped off the call stack.</li>
            <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread moves the callback function <code>c</code> to the microtask queue (or job queue).<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-20.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function calls.</li>
            <li>The main thread creates new function execution contexts and places it on the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-22.jpg" alt="call stack">
                </figure>
            </li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that count down in the background within the Web API environment from the specified delay.</li>
            <li>When the timer expires after the specified delay, the Web API moves the callback function to the callback queue (or task queue).</li>
            <li>The main thread removes the function execution contexts for <code>setTimeout</code> from the call stack.</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>e</code> function call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task E"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the execution context for <code>e</code> from the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"End"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>Once all the synchronous code has executed, the main thread removes the global execution context from the call stack.</li>
            <li>The call stack is now empty, waiting for asynchronous callbacks to be executed.</li>
            <li>The event loop starts processing the asynchronous callbacks that have been registered.</li> 
            <li>The event loop proceeds to handle the microtask queue before handling any macrotasks.</li>
            <li>If there are microtasks in the microtask queue, the event loop moves the microtask <code>c</code> from the microtask queue to the call stack and creates a new function execution context for the resolve callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-23.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Promise resolved successfully"</code> to the console.</li>
            <li>The main thread removes the function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the callback function <code>c</code> from the call stack.</li>
            <li>After all microtasks have been processed, the event loop proceeds to handle macrotasks.</li>
            <li>After 0 milliseconds, the event loop the task <code>d</code> from Web API to the callback queue.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-24.jpg" alt="call stack">
                </figure>
            </li>
            <li>The event loop pushes the task <code>d</code> from the callback queue onto the call stack and creates a new function execution context for the <code>setTimeout</code> callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-25.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task D"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
        </ul>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/event-loop" class="tag">event loop</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/call-stack" class="tag">call stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/web-api" class="tag">web api</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/macrotask" class="tag">macrotask</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/macrotask-queue" class="tag">macrotask queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask" class="tag">microtask</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/microtask-queue" class="tag">microtask queue</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-15" /><category term="javascript" /><category term="event loop" /><category term="call stack" /><category term="web api" /><category term="macrotask" /><category term="macrotask queue" /><category term="microtask" /><category term="microtask queue" /><summary type="html"><![CDATA[Discover the inner workings of the event loop in JavaScript with our comprehensive guide. Gain insights into the event loop's key components, including the call stack, web API, macrotasks, microtasks, macrotask queue, microtask queue, and more. Through clear explanations and practical examples, this resource offers a deep understanding of how the event loop manages asynchronous operations in JavaScript. Whether you're a beginner or an experienced developer, this guide will equip you with the knowledge to write efficient and responsive JavaScript code.]]></summary></entry><entry xml:lang="en"><title type="html">Execution Context in JavaScript</title><link href="https://hemimorphite.github.io/zh/2024/07/13/execution-context-in-javascript/" rel="alternate" type="text/html" title="Execution Context in JavaScript" /><published>2024-07-13T08:30:00+00:00</published><updated>2024-07-13T08:30:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Execution Context in JavaScript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 13, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a single-threaded programming language. This means that JavaScript can do only one thing at a single point in time.</p>

        <p>The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, and pushes, and pops functions onto and off the call stack in the execution phase.</p>

        <p>When the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code.</p>
        
        <p>JavaScript Execution Context is the environment in which JavaScript code is executed. It contains information about the variables, functions, and objects that are available to the code being executed, as well as the scope chain and the value of the <code>this</code> keyword.</p>
        
        <p>Execution stack, also known as “calling stack” in other programming languages, is a stack with a LIFO (Last in, First out) structure, which is used to store all the execution context created during the code execution.</p>
        <p>There are two types of execution contexts:</p>

        <ul>
            <li><b>Global Execution Context (GEC)</b>: The Global Execution Context is also called the base/default execution. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. Each JavaScript file has only one GEC.</li>
            <li><b>Function Execution Context (FEC)</b>: When a function is called, the JavaScript engine creates a Function Execution Context within the GEC to execute the code within that function. Multiple FECs can exist during script runtime, as each function call has its own FEC. FEC can access the entire code of the GEC, but it is not possible for GEC to access all the code of the FEC. During the GEC code execution.</li>
        </ul>

        <p>When Global Execution Context or Function Execution Context is created. Execution of code is happening in two phases:</p>

        <ul>
            <li><b>Creation Phase</b>, the JavaScript engine sets up the environment for the code to be executed. During this phase, the JavaScript engine creates the following:<br>
                <ul>
                    <li><b>Variable Environment</b>: an Environment Record that holds bindings created by <code>var</code> declarations within this execution context.</li>
                    <li><b>Lexical Environment</b>: an Environment Record
                    used to resolve identifier references, ie. <code>let</code> or <code>const</code>, made by code within this execution context.<br><br>
                    An Environment Record is used to define the association of identifiers to specific variables and functions based upon the lexical nesting structure of the code. Each Environment Record has a reference to the outer environment, which could either point to the Global environment or an outer function environment, enabling the scope chain.<br><br>
                    The <b>Scope Chain</b> is a list of Variable Objects that are accessible in the current scope. Each Variable Object in the Scope Chain represents a higher level of scope.<br><br>
                    There are a few different types of environment records: Global Environment Record, Declarative Environment Record and Object Environment Record.<br><br>
                    The Global Environment Record is a composite environment record, made up of a Declarative Environment Record and an Object Environment Record.<br><br>
                    The Declarative Environment Record is associated with a scope containing variable, <code>const</code>, <code>let</code>, <code>class</code>, <code>module</code>, <code>import</code>, and/or <code>function</code> declarations. A Declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.<br><br>
                    The Object Environment Record is associated with an object called its binding object. Its binding object is the global object, which is window in the case of browsers.<br><br>
                    For every function declaration, a property is added to the record, pointing to that function, and that property is stored in memory. But function expressions are not included. This means all the function declarations will be stored and made accessible inside the execution context, even before the code starts running. This process of storing variables and function declaration in memory prior to the execution of the code is known as Hoisting.</li>
                    <li><b>Determining the value of the <code>this</code> keyword</b>: The value of <code>this</code> is determined and stored in the Execution Context. The value of <code>this</code> depends on how the function is called, and can refer to the global context, the current instance of an object (in the case of methods), or be set explicitly using functions like <code>call</code>, <code>apply</code>, or <code>bind</code>.</li>
                </ul><br>

                In the below code, <code>letter</code> is a binding identifier and the value the variable or binding contains is <code>"a"</code>. Note that variables or bindings contain values, they aren't the values themselves. This is important to understand, variables are containers for values.<br><br>

                <pre><code class="language-bash hljs">const letter = "a"
var number = 1

function greeting() {
    console.log('Welcome to Javascript')
}

const person = {
    name: "John Doe"
}</code></pre><br>
                The below snippet is a pseudo-code representation of execution context.<br><br>
                <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            letter: "a",
            greeting: &lt;ref. to greeting function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;,
            person: {
                name: "John Doe"
            }
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number: 1,
            outer: null
        }
    }
}</code></pre>
            </li>
            <li><b>Execution Phase</b>, the JavaScript engine executes the code line by line. The JavaScript engine reads the code and executes it one line at a time. This phase involves the following steps:<br>
                <ul>
                    <li><b>Assigning Values to Variables</b>: JavaScript engine assigns values to variables. If a variable is not initialized, it has the value of <code>undefined</code>.</li>
                    <li><b>Executing Functions and Code Blocks</b>: JavaScript engine executes functions and code blocks as it encounters them in the code. If a function is called, the engine creates a new execution context for that function and adds it to the call stack.</li>
                    <li><b>Managing the Call Stack</b>:  When a function is called, its execution context is added to the top of the call stack. When the function returns, its execution context is removed from the stack.</li>
                </ul>
            </li>
        </ul>

        <p>The two main components of an execution context in JavaScript are</p>

        <ul>
            <li><b>Memory Component</b> — This refers to the memory space that is allocated for the code and data components within the context. This includes variables, objects, arrays, and other data structures that are used or manipulated by the code. The memory component is also responsible for maintaining the scope chain, which is a list of variable objects that a function has access to, starting with its own variable object and continuing with the variable objects of its parent functions, all the way up to the global variable object.</li>
            <li><b>Code Component</b> — This refers to the actual code that is being executed within the context. It includes any function and variable declarations, as well as any other instructions that make up the code. During the creation phase of the execution context, the JavaScript engine sets up memory space for all variables and function declarations through a process known as hoisting.</li>
        </ul>

        <p>These two components enable the JavaScript engine to execute code and manage data within the program.</p>

        <p>Let's understand the Execution Context with the following code example below:</p>

        <pre><code class="language-bash hljs">function greeting() {
    console.log("Welcome to the JS world!");
}

greeting();

var number1 = 10;
var number2 = 5;

function add(number1, number2) {
    return number1 + number2;
}

function addExtra(number1, number2) {
    var extra = 15;
    return number1 + number2 + extra;
}

var result1 = add(number1, number2);
var result2 = addExtra(number1, number2);

console.log(result1);
console.log(result2);</code></pre>
        
        <p>Using the example code above, let's walk through each stage of what happens during the Memory Creation Phase:</p>

        <ul>
            <li>Javascript engine will create and push a global execution context into the call stack.</li>
            <li>Javascript engine will create the this object and bind it to the global object i.e., <code>window</code> in the web browser or <code>global</code> in Node.js.</li>
            <li>Javascript engine will create a new object called <code>this</code>, which is a reference to the current execution context.</li>
            <li>Javascript engine will set the value of this to the global object, which is the top-most object in the scope chain. In a browser, the global object is the window object, while in a Node.js environment, it's the global object.</li>
            <li>Javascript engine will allocate memory for variables <code>number1</code>, <code>number2</code>, <code>result1</code>, <code>result2</code> and assign undefined to them</li>
            <li>Javascript engine also allocates memory for function <code>greeting</code>, <code>add</code>, <code>addExtra</code> which includes space for the function's code, its name, and its scope.</li>
            <li>The below snippet is a pseudo-code representation of global execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            greeting: &lt;ref. to greeting function object&gt;,
            add: &lt;ref. to add function object&gt;,
            addExtra: &lt;ref. to addExtra function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: undefined,
            number2: undefined,
            outer: null
        }
    }
}</code></pre>
            </li>
        </ul>

        <p>After the memory creation phase is completed, the Javascript engine moves on to the execution phase. The JS engines scan over the function in the code one more time, updating the variable object with the values of the variables and then running the code, which is known as an execution phase.</p>

        <p>Let's look at what happens during the execution phase:</p>

        <ul>
            <li><code>greeting</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>greeting</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 0 as its starting value.</li>
            <li>Javascript engine will create <code>this</code> object and bind to the global object.</li>
            <li>Here is a pseudo-code representation of <code>greeting</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">GreetingFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                length: 0
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>greeting</code> function execution context enters the Execution Phase.</li>
            <li>Javascript engine will display <code>"Welcome to the JS world!"</code> to the console.</li>
            <li>Here is a pseudo-code representation of <code>greeting</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">GreetingFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                length: 0
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>greeting</code> function execution context is returned and the call stack is popped off.</li>
            <li>Control returns to the global execution context.</li>
            <li>Javascript engine will assign 10 to <code>number1</code>.</li>
            <li>Javascript engine will assign 5 to<code>number2</code>.</li>
            <li><code>add</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>add</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 2 as its starting value.</li>
            <li>Assign the value of <code>number1</code> to the first index of the arguments object.</li>
            <li>Assign the value of <code>number2</code> to the second index of the arguments object.</li>
            <li>Javascript engine will create <code>number1</code> and <code>number2</code> variable in the function's local memory and assignthe corresponding values from the arguments object.</li>
            <li>Javascript engine will create <code>this</code> object and bind to the window object.</li>
            <li>Here is a pseudo-code representation of <code>add</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">AddFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>add</code> function execution context enters the Execution Phase.</li>
            <li>The return statement is evaluated.</li>
            <li>Javascript engine will look up <code>number1</code>, <code>number2</code> variables in the function's local memory.</li>
            <li>Javascript engine locates the <code>number1</code>, <code>number2</code> variables in local memory, then swaps the values to the variable references.</li>
            <li>The evaluated result of the <code>add</code> function execution context is returned and the call stack is popped off.</li>
            <li>Here is a pseudo-code representation of <code>add</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">AddFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The control returns to its caller context (the global execution context) with the returned value of 15.</li>
            <li>Javascript engine will assign 15 to <code>result1</code>.</li>
            <li><code>addExtra</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>addExtra</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 2 as its starting value.</li>
            <li>Assign the value of <code>number1</code> to the first index of the arguments object.</li>
            <li>Assign the value of <code>number2</code> to the second index of the arguments object.</li>
            <li>Javascript engine will create <code>number1</code> and <code>number2</code> variables in the function's local memory and assign the corresponding values from the arguments object.</li>
            <li>Javascript engine will create <code>extra</code> variable in the function's local memory and assign undefined to it</li>
            <li>Javascript engine will create <code>this</code> object and bind to the window object.</li>
            <li>Here is a pseudo-code representation of <code>addExtra</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">AddExtraFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            extra: undefined,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The <code>addExtra</code> function execution context enters the Execution Phase.</li>
            <li>Javascript engine will assign 15 to <code>extra</code>.</li>
            <li>The return statement is evaluated.</li>
            <li>Javascript engine will look up <code>number1</code>, <code>number2</code>, <code>extra</code> variables in the function's local memory.</li>
            <li>Javascript engine locates the <code>number1</code>, <code>number2</code>, <code>extra</code> variables in local memory, then swaps the values to the variable references.</li>
            <li>The evaluated result of the <code>addExtra</code> function execution context is returned and the call stack is popped off.</li>
            <li>Here is a pseudo-code representation of <code>addExtra</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">AddExtraFunctionExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        },
        ObjectEnvironmentRecord: {
            arguments: {
                0: 10,
                1: 5,
                length: 2
            },
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            extra: 15,
            outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
        }
    }
}</code></pre></li>
            <li>The control returns to its caller context (the global execution context) with the returned value of 30.</li>
            <li>Javascript engine will assign 30 to <code>result2</code>.</li>
            <li>Javascript engine will display <code>15</code> and <code>30</code> to the console.</li>
            <li>The below snippet is a pseudo-code representation of global execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            greeting: &lt;ref. to greeting function object&gt;,
            add: &lt;ref. to add function object&gt;,
            addExtra: &lt;ref. to addExtra function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number1: 10,
            number2: 5,
            result1: 10,
            result2: 30,
            outer: null
        }
    }
}</code></pre>
            </li>
            <li>The global execution context is removed from the call stack or the call stack is popped off.</li>
        </ul>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/global-execution-context" class="tag">global execution context</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/function-execution-context" class="tag">function execution context</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/creation-phase" class="tag">creation phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/execution-phase" class="tag">execution phase</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-13" /><category term="javascript" /><category term="global execution context" /><category term="function execution context" /><category term="creation phase" /><category term="execution phase" /><summary type="html"><![CDATA[Execution context in JavaScript refers to the environment in which code is executed. This includes the global execution context, which encompasses code not within any function, and function execution contexts, which are created when functions are invoked. The execution context goes through two phases: the creation phase, where the JavaScript engine sets up the environment, and the execution phase, where the code is run. Understanding these concepts is crucial for effectively scoping variables and functions and comprehending how JavaScript code is processed.]]></summary></entry><entry xml:lang="en"><title type="html">Handling Asynchronous Operations in Node.js</title><link href="https://hemimorphite.github.io/zh/2024/07/09/handling-asynchronous-operations-in-nodejs/" rel="alternate" type="text/html" title="Handling Asynchronous Operations in Node.js" /><published>2024-07-09T05:21:00+00:00</published><updated>2024-07-09T05:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/09/handling-asynchronous-operations-in-nodejs</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/09/handling-asynchronous-operations-in-nodejs/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Handling Asynchronous Operations in Node.js</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 09, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/nodejs.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>In Node JS, asynchronous operations allow us to perform tasks without blocking the main thread, enabling the application to handle multiple requests concurrently. These operations include reading/writing files, making HTTP requests, querying databases, and more.</p>

        <h5 class="post-subtitle">Callbacks</h5>

        <p>A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.</p>

        <p>Synchronous callback functions execute instantly, but asynchronous callback functions execute at a later time.</p>

        <p>In this example, we have two functions: <code>greet</code> and <code>sayGoodbye</code>. The greet function takes two arguments: <code>name</code> (a string) and <code>callback</code> (a function).</p>

        <pre><code class="language-bash hljs">function greet(name, callback) {
    console.log(`Hello, ${name}!`);
    callback();
}

function sayGoodbye() {
    console.log("Goodbye!");
}; 

greet("Alice", sayGoodbye);</code></pre>

        <p>It will output:</p>

        <pre><code class="language-bash hljs">Hello, Alice!
Goodbye!</code></pre>

        <p>The <code>sayGoodbye</code> function is called immediately following the <code>greet</code> function's completion, making it an example of a synchronous callback function.</p>

        <p>In the next example, the <code>asyncOperation</code> function uses <code>setTimeout</code> to simulate an asynchronous task. The callback is executed after a delay of 1 second.</p>
        
        <p><code>setTimeout()</code> takes a callback function as an argument and executes the callback function after a specified amount of time.</p>

        <pre><code class="language-bash hljs">function asyncOperation(callback) {
    console.log("Start operation");
    setTimeout(function() {
        callback();
    }, 1000);
    console.log("End operation");
};

function callback() {
    console.log("Callback executed");
}

asyncOperation(callback);</code></pre>

        <p>It will output:</p>

        <pre><code class="language-bash hljs">Start operation
End operation
Callback executed</code></pre>

        <p>Callbacks can lead to callback hell or pyramid of doom, where multiple nested callbacks can make code hard to read and maintain.</p>
        
        <p>Here is a example of nested callbacks:</p>

        <pre><code class="language-bash hljs">function pyramidOfDoom() {
    setTimeout(() => {
        console.log(1);
        setTimeout(() => {
            console.log(2);
            setTimeout(() => {
                console.log(3);
                setTimeout(() => {
                    console.log(4);
                    setTimeout(() => {
                        console.log(5);
                    }, 3500);
                }, 1500);
            }, 500);
        }, 2000);
    }, 1000);
}</code></pre>

        <p>In the above code, each new <code>setTimeout</code> is nested inside a higher order function, creating a pyramid shape of deeper and deeper callbacks.</p>

        <p>Let's look at another example, say we have a list of users, their posts and their respective comments, like this:</p>

        <pre><code class="language-bash hljs">const users = [
    { id: 1, name: 'Luther Hargreeves' },
    { id: 2, name: 'Diego Hargreeves' },
    { id: 3, name: 'Allison Hargreeves' },
];
const posts = [
    { id: 1, title: 'First Post', user_id: 2 },
    { id: 2, title: 'Second Post', user_id: 1 },
    { id: 3, title: 'Third Post', user_id: 2 },
    { id: 4, title: 'Fourth Post', user_id: 2 },
    { id: 5, title: 'Fifth Post', user_id: 3 },
];

const comments = [
    { user_id: 2, post_id: 2, text: 'Great!'},
    { user_id: 3, post_id: 2, text: 'Nice Post!'},
    { user_id: 1, post_id: 3, text: 'Awesome Post!'},
];</code></pre>
        
        <p>Now, we will write a function to get a post by passing the post id. If the post is found, we will retrieve the comments related to that post.</p>

        <pre><code class="language-bash hljs">const getPost = (post_id, callback) => {
    const post = posts.find( post => post.id === post_id);
    setTimeout(() => {
        if(post) {
            callback(null, post);
        } else {
            callback("No such post found", undefined);
        }
    }, 1000);
};

const getUser = (user_id, callback) => {
    const user = users.find( user => user.id === user_id);
    setTimeout(() => {
        if(user) {
            callback(null, user);
        } else {
            callback("No such user found", undefined);
        }
    }, 500);
};

const getComments = (post_id, callback) => {
    const result = comments.filter( comment => comment.post_id === post_id);
    setTimeout(() => {
        if(result) {
            callback(null, result);
        } else {
            callback("No comments found", undefined);
        }
    }, 100);
}

getPost(2, (err, post) => {
    if (err) {
        console.error('Error getting post:', err);
    } else {
        getUser(post.user_id, (err, user) => {
            if (err) {
                console.error('Error getting user:', err);
            } else {
                console.log(`${user.name} created a post with title ${post.title}`);
                getComments(post.id, (err, comments) => {
                    if (err) {
                        console.error('Error getting comment:', err);
                    } else {
                        comments.forEach((comment) => {
                            getUser(comment.user_id, (err, user) => {
                                if(err) {
                                    console.error('Error getting user:', err);
                                }
                                else {
                                    console.log(`${user.name} comments: ${comment.text}`);
                                }
                            });
                        });
                    }
                });
            }
        });
    }
});</code></pre>

        <p>After executing the above code, you will see the following output:</p>

        <pre><code class="language-bash hljs">Luther Hargreeves created a post with title Second Post
Luther Hargreeves comment: Great! 
Allison Hargreeves comment: Nice Post!</code></pre>

        <h5 class="post-subtitle">Promises</h5>

        <p>Promises help in solving the callback hell problem. A promise represents a value that may not be available yet but will be resolved in the future, either successfully with a value or unsuccessfully with an error.</p>

        <p>You can initialize a promise with the <code>new Promise</code> syntax, and you must initialize it with a function. The function that gets passed to a promise has <code>resolve</code> and <code>reject</code> parameters. The <code>resolve</code> and <code>reject</code> functions handle the success and failure of an operation, respectively.</p>
        
        <p>When we initialize a promise, it has a <code>pending</code> state and <code>undefined</code> value:</p>

        <pre><code class="language-bash hljs">// Initialize a promise
const promise = new Promise((resolve, reject) => {})
console.log(promise);
// Promise { &lt;state&gt;: "pending" }</code></pre>
        
        <p>When we call the <code>resolve</code> function and pass a value, it has a <code>fulfilled</code> state and a value.</p>
        
        <pre><code class="language-bash hljs">const promise = new Promise((resolve, reject) => {
    resolve('result value');
});
console.log(promise);
// Promise { &lt;state&gt;: "fulfilled", &lt;value&gt;: "result value" }</code></pre>
        
        <p>If we call <code>reject</code> function and pass a value, it will has a <code>rejected</code> state and a value.</p>

        <pre><code class="language-bash hljs">const promise = new Promise((resolve, reject) => {
    reject('error value');
});
console.log(promise);
// Promise { &lt;state&gt;: "rejected", &lt;value&gt;: "error value" }</code></pre>

        <p>A promise can have three possible states: pending, fulfilled, and rejected.</p>

        <ul>
            <li>Pending - Initial state before being resolved or rejected</li>
            <li>Fulfilled - Successful operation, promise has resolved</li>
            <li>Rejected - Failed operation, promise has rejected</li>
        </ul>

        <p>To get the result of the successful promise execution, we need to register a callback handler using <code>.then</code> like this:</p>

        <pre><code class="language-bash hljs">promise.then(function(result) {
    console.log(result); // result value
});</code></pre>

        <p>To catch the error, we need to register another callback using <code>.catch</code> like this:</p>

        <pre><code class="language-bash hljs">promise.then(function(result) {
    console.log(result); // result value
}).catch(function(error) {
    console.log(error);  // error value
});</code></pre>

        <p>For reference, here is a table with the handler methods on <code>Promise</code> objects:</p>

        <table>
            <thead>
                <tr>
                    <th>Method</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>then()</code>
                    </td>
                    <td>Handles a <code>resolve</code>. Returns a promise, and calls <code>onFulfilled</code> function asynchronously </td>
                </tr>
                <tr>
                    <td>
                        <code>catch()</code>
                    </td>
                    <td>Handles a <code>reject</code>. Returns a promise, and calls <code>onRejected</code> function asynchronously </td>
                </tr>
                <tr>
                    <td>
                        <code>finally()</code>
                    </td>
                    <td>Called when a promise is settled. Returns a promise, and calls <code>onFinally</code> function asynchronously </td>
                </tr>
            </tbody>
        </table>


        <p>One of the most useful and frequently used Web APIs that returns a promise is the Fetch API, which allows you to make an asynchronous resource request over a network. fetch is a two-part process, and therefore requires chaining then. This example demonstrates hitting the GitHub API to fetch a user's data, while also handling any potential error:</p>

        <pre><code class="language-bash hljs">// Fetch a user from the GitHub API
fetch('https://api.github.com/users/octocat')
    .then((response) => {
    return response.json()
    })
    .then((data) => {
    console.log(data)
    })
    .catch((error) => {
    console.error(error)
    });</code></pre>

        <p>The fetch request is sent to the <code>https://api.github.com/users/octocat</code> URL, which asynchronously waits for a response. The first then passes the response to an anonymous function that formats the response as JSON data, then passes the JSON to a second then that logs the data to the console. The catch statement logs any error to the console.</p>

        <p>Sometimes, you want to execute two or more related asynchronous operations, where the next operation starts with the result from the previous one. For example:</p>

        <pre><code class="language-bash hljs">let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 1000);
});

p.then((result) => {
    console.log(result); // 10
    return result * 2;
}).then((result) => {
    console.log(result); // 20
    return result * 3;
}).then((result) => {
    console.log(result); // 60
    return result * 4;
});</code></pre>

        <p>In the above example, the return value in the first <code>then()</code> method is passed to the second <code>then()</code> method and the return value in the second <code>then()</code> method is passed the third <code>then()</code>. Because the <code>then()</code> method returns a new <code>Promise</code> with a value resolved to a value, you can call the <code>then()</code> method on the return <code>Promise</code>.</p>

        <p>The way we call the <code>then()</code> method like this is often referred to as a promise chain.</p>

        <p>When you call the <code>then()</code> method multiple times on a promise, it is not the promise chaining. For example:</p>

        <pre><code class="language-bash hljs">let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 1000);
});
        
p.then((result) => {
    console.log(result); // 10
    return result * 2;
})

p.then((result) => {
    console.log(result); // 10
    return result * 3;
})

p.then((result) => {
    console.log(result); // 10
    return result * 4;
});</code></pre>

        <p>Here is the modified code of callback function example that uses Promises instead of callbacks:</p>

        <pre><code class="language-bash hljs">const users = [  
    { id: 1, name: 'Luther Hargreeves' },  
    { id: 2, name: 'Diego Hargreeves' },  
    { id: 3, name: 'Allison Hargreeves' },  
];  

const posts = [  
    { id: 1, title: 'First Post', user_id: 2 },  
    { id: 2, title: 'Second Post', user_id: 1 },  
    { id: 3, title: 'Third Post', user_id: 2 },  
    { id: 4, title: 'Fourth Post', user_id: 2 },  
    { id: 5, title: 'Fifth Post', user_id: 3 },  
];  

const comments = [  
    { user_id: 2, post_id: 2, text: 'Great!'},  
    { user_id: 3, post_id: 2, text: 'Nice Post!'},  
    { user_id: 1, post_id: 3, text: 'Awesome Post!'},  
];  

const getPost = (post_id) => {  
    return new Promise((resolve, reject) => {  
        const post = posts.find(post => post.id === post_id);  
        setTimeout(() => {  
            if (post) {  
                resolve(post);  
            } else {  
                reject("No such post found");  
            }  
        }, 1000);  
    });  
};  

const getUser = (user_id) => {  
    return new Promise((resolve, reject) => {  
        const user = users.find(user => user.id === user_id);  
        setTimeout(() => {  
            if (user) {  
                resolve(user);  
            } else {  
                reject("No such user found");  
            }  
        }, 500);  
    });  
};  

const getComments = (post_id) => {  
    return new Promise((resolve, reject) => {  
        const result = comments.filter(comment => comment.post_id === post_id);  
        setTimeout(() => {  
            if (result) {  
                resolve(result);  
            } else {  
                reject("No comments found");  
            }  
        }, 100);  
    });  
};  

getPost(2)  
    .then(post => {  
        return getUser(post.user_id)  
            .then(user => {  
                console.log(`${user.name} created a post with title ${post.title}`);  
                return getComments(post.id);  
            });  
    })  
    .then(comments => {  
        comments.forEach(comment => {  
            getUser(comment.user_id)  
                .then(user => {  
                    console.log(`${user.name} comments: ${comment.text}`);  
                })  
                .catch(err => {  
                    console.error('Error getting user:', err);  
                });  
        });  
    })  
    .catch(err => {  
        console.error('Error:', err);  
    }); </code></pre>

        <h5 class="post-subtitle">Async/Await</h5>

        <p>An <code>async</code> function allows you to handle asynchronous code in a manner that appears synchronous. <code>async</code> functions still use promises under the hood, but have a more traditional JavaScript syntax.</p>

        <p>The <code>async</code> keyword allows you to define a function that handles asynchronous operations.</p>

        <p>To define an <code>async</code> function, you place the <code>async</code> keyword in front of the function as follows:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return `Hello, ${name}`;
}</code></pre>

        <p>Since <code>async</code> functions always returns a <code>Promise</code>, you can use <code>then()</code> method to consume it, like this:</p>

        <pre><code class="language-bash hljs">greet('Alison').then(console.log);</code></pre>

        <p>You can also explicitly return a <code>Promise</code> from the <code>greet()</code> function as shown in the following code:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.resolve(`Hello, ${name}`);
}</code></pre>

        <p>Besides the regular functions, you can use the <code>async</code> keyword in the function expressions:</p>

        <pre><code class="language-bash hljs">let greet = async function (name) {
    return `Hello, ${name}`;
}</code></pre>

        <p>Or in arrow functions:</p>

        <pre><code class="language-bash hljs">let greet = async (name) => `Hello, ${name}`;</code></pre>

        <p>Or in methods of classes:</p>

        <pre><code class="language-bash hljs">class person {
    async greet(name) {
        return `Hello, ${name}`;
    }
}</code></pre>

        <p>You use the <code>await</code> keyword to wait for a <code>Promise</code> to settle either in a resolved or rejected state.</p>
        
        <p>You cannot use the <code>await</code> keyword inside a sync function:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.resolve(`Hello, ${name}`);
}
function print() {
    let result = await greet('Alison');
    console.log(result);
}
print();
// SyntaxError: await is only valid in async functions, async generators and modules</code></pre>

        <p>You use the <code>await</code> keyword only inside an <code>async</code> function:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.resolve(`Hello, ${name}`);
}
async function print() {
    let result = await greet('Alison');
    console.log(result);
}

print(); // Hello, Alison</code></pre>

        <p>You cannot use the <code>await</code> keyword at the top level of a script:</p>

        <pre><code class="language-bash hljs">&lt;script&gt;
    async function greet(name) {
        return Promise.resolve(`Hello, ${name}`);
    }
    
    let result = await greet('Alison');
    // SyntaxError: await is only valid in async functions, async generators and modules
&lt;/script&gt;</code></pre>
        
        <p>Instead, make the script a module:</p>

        <pre><code class="language-bash hljs">&lt;script type="module"&gt;
    async function greet(name) {
        return Promise.resolve(`Hello, ${name}`);
    }
    
    let result = await greet('Alison');
    // SyntaxError: await is only valid in async functions, async generators and modules
&lt;/script&gt;</code></pre>

        <p>If a promise resolves normally, then <code>await promise</code> returns the result. But in case of a promise is rejected, it throws the error, just as if there were a <code>throw</code> statement at that line.</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.reject(new Error('Invalid name'));
}
async function print() {
    let result = await greet('Alison');
    console.log(result);
}

print(); // Uncaught (in promise) Error: Invalid name</code></pre>

        <p>The above code is the same as this:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    throw new Error('Invalid name');
}
async function print() {
    let result = await greet('Alison');
    console.log(result);
}

print(); // Uncaught (in promise) Error: Invalid name</code></pre>

        <p>You can catch the error by using the <code>try...catch</code> statement, the same way as a regular <code>throw</code> statement:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.reject(new Error('Invalid name'));
}
async function print() {
    try {
        let result = await greet('Alison');
        console.log(result);
    } catch(error) {
        console.log(error);
    }
}

print(); // Uncaught (in promise) Error: Invalid name</code></pre>

        <p>Here is the modified code of callback function example that uses async/await instead of callbacks:</p>

        <pre><code class="language-bash hljs">const users = [  
    { id: 1, name: 'Luther Hargreeves' },  
    { id: 2, name: 'Diego Hargreeves' },  
    { id: 3, name: 'Allison Hargreeves' },  
];  

const posts = [  
    { id: 1, title: 'First Post', user_id: 2 },  
    { id: 2, title: 'Second Post', user_id: 1 },  
    { id: 3, title: 'Third Post', user_id: 2 },  
    { id: 4, title: 'Fourth Post', user_id: 2 },  
    { id: 5, title: 'Fifth Post', user_id: 3 },  
];  

const comments = [  
    { user_id: 2, post_id: 2, text: 'Great!'},  
    { user_id: 3, post_id: 2, text: 'Nice Post!'},  
    { user_id: 1, post_id: 3, text: 'Awesome Post!'},  
];  
  
const getPost = async (post_id) => {  
    return new Promise((resolve, reject) => {  
        const post = posts.find(post => post.id === post_id);  
        setTimeout(() => {  
            if (post) {  
            resolve(post);  
            } else {  
            reject("No such post found");  
            }  
        }, 1000);  
    });  
};  
  
const getUser = async (user_id) => {  
    return new Promise((resolve, reject) => {  
        const user = users.find(user => user.id === user_id);  
        setTimeout(() => {  
            if (user) {  
            resolve(user);  
            } else {  
            reject("No such user found");  
            }  
        }, 500);  
    });  
};  
  
const getComments = async (post_id) => {  
    return new Promise((resolve, reject) => {  
        const result = comments.filter(comment => comment.post_id === post_id);  
        setTimeout(() => {  
            if (result) {  
                resolve(result);  
            } else {  
                reject("No comments found");  
            }  
        }, 100);  
    });  
};  
  
async function main() {  
    try {  
        const post = await getPost(2);  
        const user = await getUser(post.user_id);  
        console.log(`${user.name} created a post with title ${post.title}`);  
        const comments = await getComments(post.id);  
        comments.forEach(async (comment) => {  
            const user = await getUser(comment.user_id);  
            console.log(`${user.name} comments: ${comment.text}`);  
        });  
    } catch (err) {  
        console.error('Error:', err);  
    }  
}  
  
main();</code></pre>
        </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/nodejs" class="tag">nodejs</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/async" class="tag">async</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/await" class="tag">await</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/promise" class="tag">promise</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/callback" class="tag">callback</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-09" /><category term="javascript" /><category term="nodejs" /><category term="async" /><category term="await" /><category term="promise" /><category term="callback" /><summary type="html"><![CDATA[Learn how to handle asynchronous operations in Node.js using callback functions, async/await, and promises. Get detailed explanations and examples to enhance your understanding.]]></summary></entry><entry xml:lang="en"><title type="html">__proto__ VS Prototype in Javascript</title><link href="https://hemimorphite.github.io/zh/2024/07/07/proto-vs-prototype-in-javascript/" rel="alternate" type="text/html" title="__proto__ VS Prototype in Javascript" /><published>2024-07-07T11:21:00+00:00</published><updated>2024-07-07T11:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/07/proto-vs-prototype-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/07/proto-vs-prototype-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">__proto__ VS Prototype in Javascript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 07, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, <code>null</code> has no prototype and acts as the final link in this prototype chain.</p>

        <p>Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has <code>null</code> for its own prototype.</p>

        <p>When you try to access a property of an object: if the property can't be found in the object itself, the prototype is searched for the property. If the property still can't be found, then the prototype's prototype is searched, and so on until either the property is found, or the end of the chain is reached, in which case <code>undefined</code> is returned.</p>

        <p>So when we call <code>myObject.toString()</code>, the Javascript engine follows the prototype chain to resolve the method:</p>

        <ul>
            <li>looks for <code>toString()</code> method in <code>myObject</code></li>
            <li>if the Javascript engine can't find it there, the Javascript engine looks into the prototype object of <code>myObject</code> for <code>toString()</code> method</li>
            <li>if the Javascript engine finds it there, the Javascript engine calls the <code>toString()</code> method.</li>
        </ul>

        <p>In JavaScript, <code>__proto__</code> and <code>prototype</code> are two related but distinct concepts that are often confused with each other.</p>

        <p><code>__proto__</code> (also called the Dunder Proto or Double Underscore Prototype) is a property of an object that points to its prototype. This property is used internally by the JavaScript engine to search for properties and methods on an object's prototype chain.</p>

        <p>The <code>__proto__</code> is not part of the ECMAScript standard, but is supported by browsers.</p>

        <p><code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> are the modern ways of getting access to and setting an object's prototype.</p>

        <p>Let's create an object literal:</p>

        <pre><code class="language-bash hljs">const myObject = {
    name: "John Doe",
    greet() {
        console.log(`Hello ${this.name}`);
    },
};
myObject.greet(); // Hello John Doe
myObject.__proto__ // Object { }
Object.getPrototypeOf(myObject); // Object { }</code></pre>

        <p><code>Object.prototype</code> is the most basic prototype, that all objects have by default. The prototype of <code>Object.prototype</code> is <code>null</code>, so it's at the end of the prototype chain.</p>

        <p>The prototype of an object is not always <code>Object.prototype</code>. For example:</p>

        <pre><code class="language-bash hljs">const myDate = new Date();
let object = myDate;

do {
    object = Object.getPrototypeOf(object);
    console.log(object);
} while (object);

// Date.prototype
// Object { }
// null</code></pre>

        <p><code>prototype</code> is a built-in property when you create an object from a constructor function. This is like a blueprint for all the objects created from that constructor function. It defines the shared properties and methods that all instances of that object will have.</p>

        <p>Let's create a constructor function:</p>

        <pre><code class="language-bash hljs">function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.getArea = function() {
    return Math.PI * Math.pow(this.radius, 2);
};

const circle1 = new Circle(5);
circle1.getArea();   // 78.53981633974483
const circle2 = new Circle(6);
circle2.getArea();   // 113.09733552923255
console.log(circle1.__proto__ === Circle.prototype); // true
console.log(circle2.__proto__ === Circle.prototype); // true</code></pre>

        <p>In the code above, the <code>getArea</code> method is contained in an object called <code>Circle.prototype</code>. When a new <code>Circle</code> instance is created, its <code>__proto__</code> property is set to <code>Circle.prototype</code>.</p>

        <pre><code class="language-bash hljs">circle1.getCircumference = function () {
    return Math.PI * 2 * this.radius;
}
circle1.getCircumference(); // 31.41592653589793
circle2.getCircumference(); // Uncaught TypeError: circle2.getCircumference is not a function</code></pre>

        <p>In the code above, the <code>getCircumference()</code> method is added to only <code>circle1</code> object and not on <code>Circle.prototype</code> or <code>circle2</code>.</p>

        <p>Here we are comparing the <code>__proto__</code> (which is the prototype from which the object was created), with the <code>prototype</code> (a property that only exists in constructor functions).</p>

        <pre><code class="language-bash hljs">const fn = () => {};
fn.__proto__ === Function.prototype;   // Output: true</code></pre>

        <p>Every function has a prototype property that points to the <code>Function.prototype</code> object. <code>fn</code> is an anonymous function created using the arrow function syntax. This means that <code>fn</code> inherits properties and methods from <code>Function.prototype</code>. For example, <code>fn</code> can use methods like <code>call()</code>, <code>apply()</code>, and <code>bind()</code> because they are defined on <code>Function.prototype</code>.</p>

        <pre><code class="language-bash hljs">const fn = () => {};
fn.__proto__ === new Function().__proto__ // Output: true</code></pre>
        
        <p><code>fn</code> is an anonymous function created using the arrow function syntax. <code>new Function()</code> creates a new function object using the Function constructor. The <code>__proto__</code> property of <code>fn</code> points to the same object as the <code>__proto__</code> property of the newly created function object using <code>new Function()</code>.</p>

        <pre><code class="language-bash hljs">const arr = [];
arr.__proto__ === Array.prototype;     // Output: true</code></pre>

        <p>Every array in JavaScript has a prototype property that points to the <code>Array.prototype</code> object. <code>arr</code> is an array created using the array literal syntax <code>[]</code>. This means that <code>arr</code> inherits properties and methods from <code>Array.prototype</code>, such as <code>push()</code>, <code>pop()</code>, and <code>forEach()</code>.</p>
        
        <pre><code class="language-bash hljs">const arr = [];
arr.__proto__ === new Array().__proto__;     // Output: true</code></pre>

        <p><code>arr</code> is an array created using the array literal syntax <code>[]</code>. <code>new Array()</code> creates a new array object using the Array constructor. The <code>__proto__</code> property of <code>arr</code> points to the same object as the <code>__proto__</code> property of the newly created array object using <code>new Array()</code>.</p>

        <pre><code class="language-bash hljs">const obj = {};
obj.__proto__ === Object.prototype;     // Output: true</code></pre>

        <p>Every object in JavaScript has a prototype property that points to the <code>Object.prototype</code> object. <code>obj</code> is an object created using the object literal syntax <code>{}</code>. This means that <code>obj</code> inherits properties and methods from <code>Object.prototype</code>, such as <code>toString()</code> and <code>hasOwnProperty()</code>.</p>
        
        <pre><code class="language-bash hljs">const obj = {};
obj.__proto__ === new Object().__proto__;     // Output: true</code></pre>
        
        <p><code>obj</code> is an object created using the object literal syntax <code>{}</code>. <code>new Object()</code> creates a new object using the Object constructor. The <code>__proto__</code> property of <code>obj</code> points to the same object as the <code>__proto__</code> property of the newly created object using <code>new Object()</code>.</p>

        <pre><code class="language-bash hljs">const str = 'Hello';
str.__proto__ === String.prototype;     // Output: true</code></pre>

        <p>Strings in Javascript have a prototype property that points to the <code>String.prototype</code> object. <code>str</code> is a string created using the string literal syntax <code>'Hello'</code>. This means that <code>str</code> inherits properties and methods from <code>String.prototype</code>, such as <code>toUpperCase()</code> and <code>substr()</code>.</p>
        
        <pre><code class="language-bash hljs">const str = 'Hello';
str.__proto__ === String.prototype;     // Output: true</code></pre>
        
        <p><code>str</code> is a string created using the string literal syntax <code>'Hello'</code>. <code>new String()</code> creates a new string object using the String constructor. The <code>__proto__</code> property of <code>str</code> points to the same object as the <code>__proto__</code> property of the newly created string object using <code>new String()</code>.</p>

        <pre><code class="language-bash hljs">const num = 123;
num.__proto__ === Number.prototype;     // Output: true</code></pre>
        
        <p>Numbers in JavaScript have a prototype property that points to the <code>Number.prototype</code> object. <code>num</code> is a number created using the number literal syntax 123. This means that <code>num</code> inherits properties and methods from <code>Number.prototype</code>, such as <code>toFixed()</code> and <code>toExponential()</code>.</p>
        
        <pre><code class="language-bash hljs">const num = 123;
num.__proto__ === new Number().__proto__;     // Output: true</code></pre>

        <p><code>num</code> is a number created using the number literal syntax 123. <code>new Number()</code> creates a new number object using the Number constructor. The <code>__proto__</code> property of <code>num</code> points to the same object as the <code>__proto__</code> property of the newly created number object using <code>new Number()</code>.</p>

        <pre><code class="language-bash hljs">const bool = true;
bool.__proto__ === Boolean.prototype;     // Output: true</code></pre>
        
        <p>Booleans in JavaScript have a prototype property that points to the <code>Boolean.prototype</code> object. <code>bool</code> is a boolean created using the boolean literal syntax <code>true</code>. This means that <code>bool</code> inherits properties and methods from <code>Boolean.prototype</code>, such as <code>toString()</code> and <code>valueOf()</code>.</p>
        
        <pre><code class="language-bash hljs">const bool = true;
bool.__proto__ === new Boolean().__proto__;     // Output: true</code></pre>

        <p><code>bool</code> is a boolean created using the boolean literal syntax <code>true</code>. <code>new Boolean()</code> creates a new boolean object using the Boolean constructor. The <code>__proto__</code> property of <code>bool</code> points to the same object as the <code>__proto__</code> property of the newly created boolean object using <code>new Boolean()</code>.</p>

</article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/prototype" class="tag">prototype</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/proto" class="tag">__proto__</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/inheritance" class="tag">inheritance</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/prototype-chain" class="tag">prototype chain</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-07" /><category term="javascript" /><category term="prototype" /><category term="__proto__" /><category term="inheritance" /><category term="prototype chain" /><summary type="html"><![CDATA[Understanding the difference between __proto__ and prototype in JavaScript is crucial for grasping prototype-based inheritance. Learn the distinction, see examples, and gain clarity on these concepts.]]></summary></entry><entry xml:lang="en"><title type="html">Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations</title><link href="https://hemimorphite.github.io/zh/2024/07/05/javascript-language-specification-abstract-operations-of-bigint-type-binary-and-arithmetic-operations/" rel="alternate" type="text/html" title="Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations" /><published>2024-07-05T11:21:00+00:00</published><updated>2024-07-05T11:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-bigint-type-binary-and-arithmetic-operations</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-bigint-type-binary-and-arithmetic-operations/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 05, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>An abstract operation is a conceptual operation that is not an actual operation in the language but is used to aid in the specification and understanding of a programming concept or system.</p>

        <p>The following abstract operations are defined over the BigInt type:</p>

        <table>
            <tbody>
                <tr>
                    <th>Operation</th>
                    <th>Example</th>
                    <th>Invoked by</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::unaryMinus</code>
                    </td>
                    <td>
                        <code>-x</code>
                    </td>
                    <td>
                        Unary <code>-</code> Operator
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseNOT</code>
                    </td>
                    <td>
                        <code>~x</code>
                    </td>
                    <td>
                        Bitwise NOT Operator (<code>~</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::exponentiate</code>
                    </td>
                    <td>
                        <code>x&nbsp;**&nbsp;y</code>
                    </td>
                    <td>
                        Exponentiation Operator (<code>**</code>)
                        and <code>Math.pow(base, exponent)</code>
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::multiply</code>
                    </td>
                    <td>
                        <code>x&nbsp;*&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::divide</code>
                    </td>
                    <td>
                        <code>x&nbsp;/&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                
                <tr>
                    <td>
                        <code>BigInt::remainder</code>
                    </td>
                    <td>
                        <code>x&nbsp;%&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::add</code>
                    </td>
                    <td>
                        <code>x ++</code>
                        <br>
                        <code>++ x</code>
                        <br>
                        <code>x&nbsp;+&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Increment Operator, Prefix Increment Operator, and The Addition Operator (<code>+</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                
                <tr>
                    <td>
                        <code>BigInt::subtract</code>
                    </td>
                    <td>
                        <code>x --</code>
                        <br>
                        <code>-- x</code>
                        <br>
                        <code>x&nbsp;-&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Decrement Operator, Prefix Decrement Operator, and The Subtraction Operator (<code>-</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::leftShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&lt;&nbsp;y</code>
                    </td>
                    <td>
                        The Left Shift Operator(<code>&lt;&lt;</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::signedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Signed Right Shift Operator(<code>&gt;&gt;</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td>  a throw completion  </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::lessThan</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&lt;=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;=&nbsp;y</code>
                    </td>
                    <td>
                        Relational Operators, via <code>IsLessThan (x, y, LeftFirst)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::equal</code>
                    </td>
                    <td>
                        <code>x&nbsp;==&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;===&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!==&nbsp;y</code>
                    </td>
                    <td>
                        Equality Operators, via <code>IsStrictlyEqual (x, y)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::sameValue</code>
                    </td>
                    <td>
                        <code>Object.is(x, y)</code>
                    </td>
                    <td> 
                        Object internal methods, via <code>SameValue (x, y)</code>, to test exact value equality 
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::sameValueZero</code>
                    </td>
                    <td>
                        <code>[x].includes(y)</code>
                    </td>
                    <td> 
                        Array, Map, and Set methods, via <code>SameValueZero (x, y)</code>, to test value equality, ignoring the difference between +0 and -0
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseAND</code>
                    </td>
                    <td>
                        <code>x&nbsp;&amp;&nbsp;y</code>
                    </td>
                    <td rowspan="3">
                        Binary Bitwise Operators
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseXOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;^&nbsp;y</code>
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;|&nbsp;y</code>
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::toString</code>
                    </td>
                    <td>
                        <code>String(x)</code>
                    </td>
                    <td> Many expressions and built-in functions, via <code>ToString (argument)</code> 
                    </td>
                    <td> String </td>
                </tr>
            </tbody>
        </table>

        <h6>BigInt::unaryMinus (x)</h6>

        <p>The abstract operation <code>BigInt::unaryMinus</code> takes argument <code>x</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is 0, return 0.</li>
            <li>Return the BigInt value that represents the negation of <code>x</code>.</li>
        </ol>

        <pre><code class="language-bash hljs">BigInt.unaryMinus = function (x) {
    if(x === 0n) {
        return BigInt(x);
    }
    return -BigInt(x);
}
BigInt.unaryMinus(100n);</code></pre>
        
        <h6>BigInt::bitwiseNOT (x)</h6>

        <p>The abstract operation <code>BigInt::bitwiseNOT</code> takes argument <code>x</code> (a BigInt) and returns a BigInt. It returns the one's complement of x. It performs the following steps when called:</p>

        <ol>
            <li>Return -x - 1.</li>
            <li>Return the BigInt value that represents the negation of <code>x</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.bitwiseNOT = function (x) {
    return -BigInt(x) - 1;
}
BigInt.bitwiseNOT(100n);</code></pre>

        <h6>BigInt::exponentiate (base, exponent)</h6>

        <p>The abstract operation <code>BigInt::exponentiate</code> takes arguments <code>base</code> (a BigInt) and <code>exponent</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>exponent</code> < 0, throw a <code>RangeError</code> exception.</li>
            <li>If <code>base</code> is 0 and <code>exponent</code> is 0, return 1.</li>
            <li>Return the BigInt value that represents <code>base</code> raised to the power <code>exponent</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.exponentiate = function (base, exponent) {
    if(BigInt(exponent) < 0n) {
        // If exponent < 0, throw a RangeError exception
        throw new RangeError("The exponent must be greater than 0.");
    }
    if(BigInt(base) === 0n && BigInt(exponent) === 0n) {
        // If base is 0 and exponent is 0, return 1
        return BigInt(1);
    }

    // Return the BigInt value that represents base raised to the power exponent
    return BigInt(base) ** BigInt(exponent);
}
BigInt.exponentiate(100n, 100n);</code></pre>

        <h6>BigInt::multiply  (x, y)</h6>

        <p>The abstract operation <code>BigInt::multiply</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the product of <code>x</code> and <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.multiply = function (x, y) {
    // Return the BigInt value that represents the product of x and y
    return BigInt(x) * BigInt(y);
}
BigInt.multiply(100n, 100n);</code></pre>

        <h6>BigInt::divide (x, y)</h6>

        <p>The abstract operation <code>BigInt::divide</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>y</code> is 0, throw a <code>RangeError</code> exception.</li>
            <li>Let <code>quotient</code> be <code>x</code> / <code>y</code>.</li>
            <li>Return <code>truncate(quotient)</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.divide = function (x, y) {
    // If y is 0, throw a RangeError exception.
    if(BigInt(y) === 0n) {
        throw new RangeError("The divisor must be greater than 0.");
    }

    // Let quotient be x / y
    let quotient = BigInt(x) / BigInt(y);

    // Return truncate(quotient)
    return BigInt(quotient);
}
BigInt.divide(100n, 2n);</code></pre>

        <h6>BigInt::remainder (n, d)</h6>

        <p>The abstract operation <code>BigInt::remainder</code> takes arguments <code>n</code> (a BigInt) and <code>d</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>d</code> is 0, throw a <code>RangeError</code> exception.</li>
            <li>If <code>n</code> is 0, return 0.</li>
            <li>Let <code>quotient</code> be <code>n</code> / <code>d</code>.</li>
            <li>Let <code>q</code> be <code>truncate(quotient)</code>.</li>
            <li>Return <code>n</code> - (<code>d</code> × <code>q</code>).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.remainder = function (n, d) {
    // If d is 0, throw a RangeError exception
    if(BigInt(d) === 0n) {
        throw new RangeError("The divisor must be greater than 0.");
    }

    // If n is 0, return 0
    if(BigInt(n) === 0n) {
        return BigInt(0);
    }

    // Let quotient be n / d
    let quotient = BigInt(n) / BigInt(d);

    // Let q be truncate(quotient)
    let q = quotient;

    // Return n - (d × q)
    return BigInt(n) - (BigInt(d) * BigInt(q));
}
BigInt.remainder(13n, 3n);</code></pre>

        <h6>BigInt::add (x, y)</h6>

        <p>The abstract operation <code>BigInt::add</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the sum of <code>x</code> and <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.add = function (x, y) {
    // Return the BigInt value that represents the sum of x and y
    return BigInt(x) + BigInt(y);
}
BigInt.add(13n, 3n);</code></pre>

        <h6>BigInt::subtract (x, y)</h6>

        <p>The abstract operation <code>BigInt::subtract</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the difference <code>x</code> minus <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.subtract = function (x, y) {
    // Return the BigInt value that represents the difference x minus y
    return BigInt(x) - BigInt(y);
}
BigInt.add(13n, 3n);</code></pre>

        <h6>BigInt::leftShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::leftShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>If <code>y</code> < 0, then<br>
                <ol>
                    <li>Return the BigInt value that represents $$x / 2^-y$$, rounding down to the nearest integer, including for negative numbers.</li>
                </ol>
            </li>
            <li>Return the BigInt value that represents $$x × 2^y$$.</li>
        </ol>
        
        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.leftShift = function (x, y) {
    if(y < 0) {
        // If y < 0, then return the BigInt value that represents x / 2^-y, rounding down to the nearest integer, including for negative numbers.
        return BigInt(x) / BigInt(2) ** BigInt(-y);
    }

    // Return the BigInt value that represents x × 2^y.
    return BigInt(x) * BigInt(2) ** BigInt(y);
}
BigInt.leftShift(13n, -3n);</code></pre>

        <h6>BigInt::signedRightShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::signedRightShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return <code>BigInt::leftShift(x, -y)</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.leftShift = function (x, y) {
    if(y < 0) {
        // If y < 0, then return the BigInt value that represents x / 2^-y, rounding down to the nearest integer, including for negative numbers.
        return BigInt(x) / BigInt(2) ** BigInt(-y);
    }

    // Return the BigInt value that represents x × 2^y.
    return BigInt(x) * BigInt(2) ** BigInt(y);
};
BigInt.signedRightShift = function (x, y) {
    // Return BigInt::leftShift(x, -y).
    return BigInt.leftShift(x, -y);
};
BigInt.signedRightShift(13n, -3n);</code></pre>


        <h6>BigInt::unsignedRightShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::unsignedRightShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>Throw a <code>TypeError</code> exception.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.unsignedRightShift = function (x, y) {
    throw new TypeError("Invalid operator") 
};
BigInt.unsignedRightShift(13n, -3n);</code></pre>

        <h6>BigInt::lessThan (x, y)</h6>

        <p>The abstract operation <code>BigInt::lessThan</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> < <code>y</code>, return <code>true</code>; otherwise return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.lessThan = function (x, y) {
    if(BigInt(x) < BigInt(y)) {
        // If x < y, return true; 
        return true;
    }else {
        // otherwise return false
        return false;
    }
};
BigInt.lessThan(13n, -13n);</code></pre>

        <h6>BigInt::equal (x, y)</h6>

        <p>The abstract operation <code>BigInt::equal</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> = <code>y</code>, return <code>true</code>; otherwise return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.lessThan = function (x, y) {
    if(BigInt(x) === BigInt(y)) {
        // If x = y, return true; 
        return true;
    }else {
        // otherwise return false
        return false;
    }
};
BigInt.lessThan(13n, -13n);</code></pre>

        <h6>BinaryAnd (x, y)</h6>

        <p>The abstract operation <code>BinaryAnd</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 and y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryAnd(x, y) {
    if(x === BigInt(1) && y === BigInt(1)) {
        // If x = 1 and y = 1, return 1;
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
BinaryAnd(1n, 0n);</code></pre>

        <h6>BinaryOr (x, y)</h6>

        <p>The abstract operation <code>BinaryOr</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 or y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryOr(x, y) {
    if(x === BigInt(1) || y === BigInt(1)) {
        // If x = 1 or y = 1, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
BinaryOr(1n, 0n);</code></pre>

        <h6>BinaryXor (x, y)</h6>

        <p>The abstract operation <code>BinaryXor</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 and y = 0, return 1.</li>
            <li>Else if x = 0 and y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryXor(x, y) {
    if(x === BigInt(1) && y === BigInt(0)) {
        // If x = 1 and y = 0, return 1 
        return BigInt(1);
    } else if(x === BigInt(0) && y === BigInt(1)) {
        // Else if x = 0 and y = 1, return 1
        return BigInt(1);
    } else {
        // Else, return 0
        return BigInt(0);
    }
};
BinaryXor(1n, 0n);</code></pre>


        <h6>BigIntBitwiseOp (op, x, y)</h6>

        <p>The abstract operation <code>BigIntBitwiseOp</code> takes arguments <code>op</code> (<code>&</code>, <code>^</code>, or <code>|</code>), <code>x</code> (a BigInt), and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Set <code>x</code> to <code>x</code>.</li>
            <li>Set <code>y</code> to <code>y</code>.</li>
            <li>Let <code>result</code> be 0.</li>
            <li>Let <code>shift</code> be 0.</li>
            <li>Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1),<br>
                <ol>
                    <li>Let <code>xDigit</code> be <code>x</code> modulo 2.</li>
                    <li>Let <code>yDigit</code> be <code>y</code> modulo 2.</li>
                    <li>If <code>op</code> is <code>&</code>, set <code>result</code> to $$result + 2^shift × BinaryAnd(xDigit, yDigit)$$.</li>
                    <li>Else if <code>op</code> is <code>|</code>, set <code>result</code> to $$result + 2^shift × BinaryOr(xDigit, yDigit)$$.</li>
                    <li>Else<br>
                        <ol>
                            <li>Assert: <code>op</code> is <code>^</code>.</li>
                            <li>Set <code>result</code> to $$result + 2^shift × BinaryXor(xDigit, yDigit)$$.</li>
                        </ol>
                    </li>
                    <li>Set <code>shift</code> to <code>shift</code> + 1.</li>
                    <li>Set <code>x</code> to $$(x - xDigit) / 2$$.</li>
                    <li>Set <code>y</code> to $$(y - yDigit) / 2$$.</li>
                </ol>
            </li>
            <li>If <code>op</code> is <code>&</code>, let <code>tmp</code> be <code>BinaryAnd(x modulo 2, y modulo 2)</code>.</li>
            <li>Else if <code>op</code> is <code>|</code>, let <code>tmp</code> be <code>BinaryOr(x modulo 2, y modulo 2)</code>.</li>
            <li>Else,<br>
                <ol>
                    <li>Assert: <code>op</code> is <code>^</code>.</li>
                    <li>Let <code>tmp</code> be <code>BinaryXor(x modulo 2, y modulo 2)</code>.</li>
                </ol>
            </li>
            <li>If <code>tmp</code> ≠ 0, then<br>
                <ol>
                    <li>Set <code>result</code> to $$result - 2^shift$$.</li>
                    <li>NOTE: This extends the sign.</li>
                </ol>
            </li>
            <li>Return the BigInt value for <code>result</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};</code></pre>

        <h6>BigInt::bitwiseAND (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseAND</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(&, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryAnd(x, y) {
    if(x === BigInt(1) && y === BigInt(1)) {
        // If x = y, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseAND = function (x, y) {
    return BigIntBitwiseOp('&', x, y);
}
BigInt.bitwiseAND(102n, 875n);</code></pre>

        <h6>BigInt::bitwiseXOR (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseXOR</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(^, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryXor(x, y) {
    if(x === BigInt(1) && y === BigInt(0)) {
        // If x = 1 and y = 0, return 1 
        return BigInt(1);
    } else if(x === BigInt(0) && y === BigInt(1)) {
        // Else if x = 0 and y = 1, return 1
        return BigInt(1);
    } else {
        // Else, return 0
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseXOR = function (x, y) {
    return BigIntBitwiseOp('^', x, y);
}
BigInt.bitwiseXOR(102n, 875n);</code></pre>

        <h6>BigInt::bitwiseOR (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseOR</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(|, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryOr(x, y) {
    if(x === BigInt(1) || y === BigInt(1)) {
        // If x = 1 or y = 1, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseOR = function (x, y) {
    return BigIntBitwiseOp('|', x, y);
}
BigInt.bitwiseOR(102n, 875n);</code></pre>

        <h6>BigInt::toString (x, radix)</h6>

        <p>The abstract operation <code>BigInt::toString</code> takes arguments <code>x</code> (a BigInt) and <code>radix</code> (an integer in the inclusive interval from 2 to 36) and returns a String. It represents <code>x</code> as a String using a positional numeral system with radix <code>radix</code>. The digits used in the representation of a BigInt using radix <code>r</code> are taken from the first <code>r</code> code units of <b>"0123456789abcdefghijklmnopqrstuvwxyz"</b> in order. The representation of BigInts other than 0 never includes leading zeroes. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> < 0, return the string-concatenation of <code>"-"</code> and <code>BigInt::toString(-x, radix)</code>.</li>
            <li>Return the String value consisting of the representation of <code>x</code> using radix <code>radix</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.toString = function (x, radix) {
    if(x < BigInt(0)) {
        return "-" + BigInt.toString(-x, radix);
    }

    let result = "";
    let number = BigInt(x);

    while(number > BigInt(0n)) {    
        let remainder = number % BigInt(radix);
            
        if (remainder === BigInt(10n)) {
            result = "A" + result;
        } else if (remainder === BigInt(11n)) {
            result = "B" + result;
        } else if (remainder === BigInt(12n)) {
            result = "C" + result;
        } else if (remainder === BigInt(13n)) {
            result = "D" + result;
        } else if (remainder === BigInt(14n)) {
            result = "E" + result;
        } else if (remainder === BigInt(15n)) {
            result = "F" + result;
        } else if (remainder === BigInt(16n)) {
            result = "G" + result;
        } else if (remainder === BigInt(17n)) {
            result = "H" + result;
        } else if (remainder === BigInt(18n)) {
            result = "I" + result;
        } else if (remainder === BigInt(19n)) {
            result = "J" + result;
        } else if (remainder === BigInt(20n)) {
            result = "K" + result;
        } else if (remainder === BigInt(21n)) {
            result = "L" + result;
        } else if (remainder === BigInt(22n)) {
            result = "M" + result;
        } else if (remainder === BigInt(23n)) {
            result = "N" + result;
        } else if (remainder === BigInt(24n)) {
            result = "O" + result;
        } else if (remainder === BigInt(25n)) {
            result = "P" + result;
        } else if (remainder === BigInt(26n)) {
            result = "Q" + result;
        } else if (remainder === BigInt(27n)) {
            result = "R" + result;
        } else if (remainder === BigInt(28n)) {
            result = "S" + result;
        } else if (remainder === BigInt(29n)) {
            result = "T" + result;
        } else if (remainder === BigInt(30n)) {
            result = "U" + result;
        } else if (remainder === BigInt(31n)) {
            result = "V" + result;
        } else if (remainder === BigInt(32n)) {
            result = "W" + result;
        } else if (remainder === BigInt(33n)) {
            result = "X" + result;
        } else if (remainder === BigInt(34n)) {
            result = "Y" + result;
        } else if (remainder === BigInt(35n)) {
            result = "Z" + result;
        } else {
            result = remainder + result;
        }    
        
        number = number / radix;
    }
    return result;
}
BigInt.toString(123456789012345678901234567890n, 16n);</code></pre>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/abstract-operation" class="tag">abstract operation</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Complete Reference" /><category term="year-2024" /><category term="month-07" /><category term="day-05" /><category term="javascript" /><category term="abstract operation" /><summary type="html"><![CDATA[Learn about the abstract operations of the BigInt type in JavaScript, focusing on binary and arithmetic operations. This article provides examples, algorithms, and explanations to help you understand these concepts better.]]></summary></entry></feed>