<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hemimorphite.github.io/zh/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hemimorphite.github.io/zh/" rel="alternate" type="text/html" /><updated>2025-05-18T07:34:04+00:00</updated><id>https://hemimorphite.github.io/feed.xml</id><title type="html">Hemimorphite</title><subtitle>Gain a better understanding of mathematics, chemistry, physics, and computer science. Our tutorials provide clear explanations and practical examples to help you learn and master these subjects. Helping learners of all levels to grasp fundamental concepts and hone their skills.</subtitle><entry xml:lang="en"><title type="html">Switch from Microsoft account to local account on Windows 11 After Installation</title><link href="https://hemimorphite.github.io/zh/2025/05/18/switch-from-microsoft-account-to-local-account-on-windows-11/" rel="alternate" type="text/html" title="Switch from Microsoft account to local account on Windows 11 After Installation" /><published>2025-05-18T06:38:50+00:00</published><updated>2025-05-18T06:38:50+00:00</updated><id>https://hemimorphite.github.io/2025/05/18/switch-from-microsoft-account-to-local-account-on-windows-11</id><content type="html" xml:base="https://hemimorphite.github.io/2025/05/18/switch-from-microsoft-account-to-local-account-on-windows-11/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Switch from Microsoft account to local account on Windows 11 After Installation</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published May 18, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/windowsdisplay.png" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>On Windows 11, using a Microsoft account is the default option during setup, providing enhanced security, seamless integration with Microsoft services, and automatic syncing of files, apps, and settings across all your devices.</p>

        <p>If you prefer a traditional local account, switching from a Microsoft account is easy through the Settings app. Alternatively, you can create a new local administrator account and transfer your files to it, rather than disconnecting from your cloud-based Microsoft account.</p>
		
		<p>To create a local administrator account on Windows 11, follow these steps:</p>
		
		<p>Open <strong>Settings</strong> on Windows 11.</p>
		
		<p>Click on <strong>Accounts</strong>.</p>
		
		<p>Click the <strong>Other users</strong> tab.</p>
		
		<p>Click the <strong>Add account</strong> button.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/addaccount.png" alt="Add button">
        </figure>
		
		<p>Click the <strong>I don't have this person's sign-in information</strong> option.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/windowsignin.png" alt="How will this person sign-in">
        </figure>
		
		<p>Click the <strong>Add a user without a Microsoft account</strong> option.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/adduser.png" alt="Create Account">
        </figure>
		
		<p>Create a Windows 11 account by confirming a name and password.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/createuser.png" alt="Create User">
        </figure>
		
		<p>Click the <strong>Next</strong> button.</p>
		
		<p>Select the newly created account and click the <strong>Change account type</strong> button to change the account from <strong>Standard</strong> to <strong>Administrator</strong>.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/createuser.png" alt="Create User">
        </figure>
		
		<p>Choose the <strong>Administrator</strong> option using the <strong>Account type</strong> setting. </p>
		
		<figure class="post-figure">
            <img src="/assets/images/accountype.png" alt="Account type">
        </figure>
		
		<figure class="post-figure">
            <img src="/assets/images/changeaccountype.png" alt="Change Account type">
        </figure>
		
		<p>Click the <strong>OK</strong> button.</p>
		
		
        <p>Open the <strong>Start</strong> menu, click your user account icon, and select the <strong>Sign out</strong> option.</p> 
		
		<figure class="post-figure">
            <img src="/assets/images/signout.png" alt="Sign out">
        </figure>
		
        <p>Select the new local account and sign in.</p>
		
        <p>Open <strong>Settings</strong>.</p> 

        <p>Click on <strong>Accounts</strong>.</p>
		
		<p>Click the <strong>Other users</strong> page.</p>
		
		<p>Select the account and click the <strong>Remove</strong> button.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/removeuser.png" alt="Remove">
        </figure>
		
        <p>Click the <strong>Delete account and data</strong> button.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/deleteaccount.png" alt="Delete account and data">
        </figure>
		
        <p>After you complete the steps, you can start using the new local account disconnected from the Microsoft cloud services.</p>
    </article>

  <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows" class="tag">windows</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-11" class="tag">windows 11</a></li>
		
	</ul>
</div>


  <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/05/18/switch-from-microsoft-account-to-local-account-on-windows-11/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/05/18/switch-from-microsoft-account-to-local-account-on-windows-11/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/05/18/switch-from-microsoft-account-to-local-account-on-windows-11/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorials" /><category term="year-2025" /><category term="month-05" /><category term="day-18" /><category term="windows" /><category term="windows 11" /><summary type="html"><![CDATA[Easily switch from a Microsoft account to a local account on Windows 11 after setup. Follow this step-by-step guide to gain more privacy, work offline, and manage your PC without cloud integration.]]></summary></entry><entry xml:lang="en"><title type="html">No Drives Can Be Found During Windows 10/11 Installation</title><link href="https://hemimorphite.github.io/zh/2025/05/18/no-drives-can-be-found-during-windows-11-installation/" rel="alternate" type="text/html" title="No Drives Can Be Found During Windows 10/11 Installation" /><published>2025-05-18T04:38:50+00:00</published><updated>2025-05-18T04:38:50+00:00</updated><id>https://hemimorphite.github.io/2025/05/18/no-drives-can-be-found-during-windows-11-installation</id><content type="html" xml:base="https://hemimorphite.github.io/2025/05/18/no-drives-can-be-found-during-windows-11-installation/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">No Drives Can Be Found During Windows 10/11 Installation</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published May 18, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/loaddriver.png" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Intel 11th (Tiger Lake), 12th (Alder Lake), and 13th (Raptor Lake) generation processors use Intel Volume Management Device (VMD) technology to improve storage performance and power efficiency. On systems with VMD enabled by default (which is often not configurable in BIOS/UEFI), the Windows 10/11 retail installer cannot detect NVMe drives unless the Intel Rapid Storage Technology (IRST) driver is manually loaded during installation. To proceed, you must download the appropriate IRST (VMD) driver, place it on a USB drive, and load it when prompted by the installer to detect available storage devices.</p>

        <p>In this tutorial, you will learn how to install windows 10/11 with Intel VMD technology enabled.</p>
		
		<h5 class="post-subtitle">Step 1: Download the Intel IRST/VMD driver from your laptop/pc manufacturer's site</h5>
		
        <p>Here are the official driver download pages for Acer, ASUS, Dell, Lenovo, and HP:</p> 
		
		<ul>
			<li>
				<strong>Acer:</strong>
				<a href="https://www.acer.com/us-en/support/drivers-and-manuals" target="_blank">
					https://www.acer.com/us-en/support/drivers-and-manuals
				</a>
			</li>
			<li>
				<strong>ASUS:</strong>
				<a href="https://www.asus.com/support/download-center/" target="_blank">
					https://www.asus.com/support/Download-Center/
				</a>
			</li>
			<li>
				<strong>Dell:</strong>
				<a href="https://www.dell.com/support/home/en-id?app=drivers" target="_blank">
					https://www.dell.com/support/home/en-id?app=drivers
				</a>
			</li>
			<li>
				<strong>Lenovo:</strong>
				<a href="https://pcsupport.lenovo.com/us/en/products/laptops-and-netbooks/3-series/ideapad-3-15iil05/81we/videos/vid100754-how-to-download-and-install-a-driver-from-the-lenovo-support-site" target="_blank">
					https://pcsupport.lenovo.com/us/en/products/laptops-and-netbooks/3-series/ideapad-3-15iil05/81we/videos/vid100754-how-to-download-and-install-a-driver-from-the-lenovo-support-site
				</a>
			</li>
			<li>
				<strong>HP:</strong>
				<a href="https://support.hp.com/us-en/drivers" target="_blank">
					https://support.hp.com/us-en/drivers
				</a>
			</li>
		</ul>

        <p>Most often the drivers come as a self-extracting executable (.exe) or archived (.zip) file. Extract the downloaded IRST driver files and copy to your USB installation media.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/irstdriver.png" alt="Copy IRST driver to USB installation media">
        </figure>
		
		<h5 class="post-subtitle">Step 2: Boot into Windows Installation</h5>
		
        <p>Plug in your Windows USB installer and power on the laptop/PC.</p> 
		
        <p>During startup, press the boot menu key (this is usually F12, F9, Esc, or another key depending on your laptop/PC brand) to open the boot options menu.</p>
		
		<p>From the list, select the USB device to boot from your Windows installation media.</p>
		
		<p>When prompted where do you want to install Windows, click <strong>Load driver</strong>.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/loaddriver.png" alt="Load Driver">
        </figure>
		
		<p>Click Browse.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/browse.png" alt="Browse">
        </figure>
        
		<p>Navigate and select the folder where you placed the driver files, and click <strong>OK</strong>.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/selectdriver.png" alt="Select Driver">
        </figure>
		
		<p>Choose the driver shown on the list, and click <strong>Install</strong>.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/installdriver.png" alt="Install Driver">
        </figure>
		
		<p>Once the driver is loaded successfully, you should see your drives listed.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/installwindows.png" alt="Install Windows">
        </figure>
		
		<p>You can now continue with the rest of the Windows installation as usual.</p>
    </article>

  <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows" class="tag">windows</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-11" class="tag">windows 11</a></li>
		
	</ul>
</div>


  <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/05/18/no-drives-can-be-found-during-windows-11-installation/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/05/18/no-drives-can-be-found-during-windows-11-installation/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/05/18/no-drives-can-be-found-during-windows-11-installation/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorials" /><category term="year-2025" /><category term="month-05" /><category term="day-18" /><category term="windows" /><category term="windows 11" /><summary type="html"><![CDATA[Intel 11th (Tiger Lake), 12th (Alder Lake), and 13th (Raptor Lake) generation processors use Intel Volume Management Device (VMD) technology to improve storage performance and power efficiency. On systems with VMD enabled by default (which is often not configurable in BIOS/UEFI), the Windows 10/11 retail installer cannot detect NVMe drives unless the Intel Rapid Storage Technology (IRST) driver is manually loaded during installation. To proceed, you must download the appropriate IRST (VMD) driver, place it on a USB drive, and load it when prompted by the installer to detect available storage devices.]]></summary></entry><entry xml:lang="en"><title type="html">Add or Remove Drivers on a Windows Image</title><link href="https://hemimorphite.github.io/zh/2025/05/17/add-or-remove-drivers-on-a-windows-offline-image/" rel="alternate" type="text/html" title="Add or Remove Drivers on a Windows Image" /><published>2025-05-17T16:58:50+00:00</published><updated>2025-05-17T16:58:50+00:00</updated><id>https://hemimorphite.github.io/2025/05/17/add-or-remove-drivers-on-a-windows-offline-image</id><content type="html" xml:base="https://hemimorphite.github.io/2025/05/17/add-or-remove-drivers-on-a-windows-offline-image/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Add or Remove Drivers on a Windows Image</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published May 17, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/adddrivers.png" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Servicing an offline image means making changes to a Windows installation file before actually installing Windows on a computer. The installation file is called an offline image because it's not currently running or installed.</p>

        <p>To do this, you use a Windows tool called DISM (Deployment Image Servicing and Management). DISM lets you customize the Windows installation by making different kinds of changes to the offline image. For example, you can add or remove drivers.</p>

        <p>In this tutorial, you will learn how to add or remove drivers from a Windows image.</p>
		
		<h5 class="post-subtitle">Step 1: Download required drivers from your laptop/pc manufacturer's site</h5>
		
        <p>Here are the official driver download pages for Acer, ASUS, Dell, Lenovo, and HP:</p> 
		
		<ul>
			<li>
				<strong>Acer:</strong>
				<a href="https://www.acer.com/us-en/support/drivers-and-manuals" target="_blank">
					https://www.acer.com/us-en/support/drivers-and-manuals
				</a>
			</li>
			<li>
				<strong>ASUS:</strong>
				<a href="https://www.asus.com/support/download-center/" target="_blank">
					https://www.asus.com/support/Download-Center/
				</a>
			</li>
			<li>
				<strong>Dell:</strong>
				<a href="https://www.dell.com/support/home/en-id?app=drivers" target="_blank">
					https://www.dell.com/support/home/en-id?app=drivers
				</a>
			</li>
			<li>
				<strong>Lenovo:</strong>
				<a href="https://pcsupport.lenovo.com/us/en/products/laptops-and-netbooks/3-series/ideapad-3-15iil05/81we/videos/vid100754-how-to-download-and-install-a-driver-from-the-lenovo-support-site" target="_blank">
					https://pcsupport.lenovo.com/us/en/products/laptops-and-netbooks/3-series/ideapad-3-15iil05/81we/videos/vid100754-how-to-download-and-install-a-driver-from-the-lenovo-support-site
				</a>
			</li>
			<li>
				<strong>HP:</strong>
				<a href="https://support.hp.com/us-en/drivers" target="_blank">
					https://support.hp.com/us-en/drivers
				</a>
			</li>
		</ul>
	
        <p>Most often the drivers come as a self-extracting executable (.exe) or archived (.zip) file. You must extract drivers first, an archive file can't be used. To be able to add an individual driver, you will need its <code>.inf</code> file</p>
		
		<p>Create a folder to place all the downloaded drivers. In this example I create the folder on drive <code>D:</code> naming it <code>Drivers</code>.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/drivers.png" alt="Drivers">
        </figure>
		
		<h5 class="post-subtitle">Step 2: Add drivers to image</h5>
		
        <p>Create a new folder to temporarily store the contents of Windows 10/11 ISO image. In this example I create the folder on drive <code>D:</code> naming it <code>ISO_Files</code>.</p>
		
        <p>Mount the Windows 10/11 ISO file by double-clicking it to open it as a virtual DVD. In File Explorer, open the mounted ISO, press <code>Ctrl + A</code> to select all files and folders, then press <code>Ctrl + C</code> to copy them. Navigate to your <code>ISO_Files</code> folder and press <code>Ctrl + V</code> to paste the contents of the ISO.</p>
		
		<figure class="post-figure">
            <img src="/assets/images/virtualDVD.png" alt="Virtual DVD">
        </figure>
		
		<figure class="post-figure">
            <img src="/assets/images/windowsisofiles.png" alt="Windows 11 ISO Files">
        </figure>
		
		<p>Create a folder to mount offline image. In this example I create the folder on drive <code>D:</code> naming it <code>Mount</code>.</p>
		
        <p>Open a PowerShell window (run as Administrator). Then enter the following command to see which Windows editions are included in the image:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Get-WimInfo /WimFile:D:\ISO_Files\Sources\install.wim</code></pre>
		
		<figure class="post-figure">
            <img src="/assets/images/listalleditions.png" alt="List All Editions">
        </figure>
		
		<p>Mount the image of your preferred Windows 10/11 edition using its index number (retrieved from the previous step). Use the following command to mount the image:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Mount-Wim /WimFile:D:\ISO_Files\Sources\install.wim /index:6 /MountDir:D:\Mount</code></pre>
		
		<figure class="post-figure">
            <img src="/assets/images/mountwindowsimage.png" alt="Mount Windwos Image">
        </figure>
		
		<p>Replace <code>6</code> with the index number of the edition you want to mount.</p>
		
		<p>You can check which third-party drivers are already present in the mounted offline Windows image by running the following command:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Image:D:\Mount /Get-Drivers</code></pre>
		
		<figure class="post-figure">
            <img src="/assets/images/listalldrivers.png" alt="List All Drivers">
        </figure>
		
		<p>You can now add all the drivers to the offline mounted Windows image using the following command:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Image:D:\Mount /Add-Driver /Driver:D:\Drivers /Recurse</code></pre>
		
		<figure class="post-figure">
            <img src="/assets/images/adddrivers.png" alt="Add All Drivers">
        </figure>
		
		<p>If you prefer to add drivers one by one to your offline mounted Windows image, you can use the following command for each individual <code>.inf</code> file:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Image:D:\Mount /Add-Driver /Driver:D:\Drivers\DriverName1\YourDriver1.inf /Driver:D:\Drivers\DriverName2\YourDriver2.inf</code></pre>
		
		<p>If you want to remove a driver from offline image, use the following command:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Image:D:\Mount /Remove-Driver /Driver:D:\Drivers\DriverName1\YourDriver1.inf /Driver:D:\Drivers\DriverName2\YourDriver2.inf</code></pre>
		
		<p>Once all drivers have been added, you can save the changes and unmount the offline image using the following command:</p>
		
		<pre><code class="language-plaintext hljs">Dism /Unmount-Wim /MountDir:D:\Mount /Commit</code></pre>
		
		<figure class="post-figure">
            <img src="/assets/images/unmountwindowsimage.png" alt="Unmount Windows Image">
        </figure>
		
		<h5 class="post-subtitle">Step 3: Create an Updated Windows ISO</h5>
		
		<p>Download the latest Windows Assessment and Deployment Kit (ADK): <a href="https://learn.microsoft.com/en-us/windows-hardware/get-started/adk-install" target="_blank">Microsoft Windows ADK download page</a>.</p>
		
		<p>The Windows Assessment and Deployment Kit (Windows ADK) installer allows you to pick individual components to install. If you want to install only <code>oscdimg.exe</code>, in the list of features, uncheck all options except <strong>Deployment Tools</strong>.</p>
		
		<p>After you install the Deployment Tools component of the Windows ADK (which includes oscdimg.exe), you can access the special command-line environment by clicking <strong>Start</strong> and typing <strong>Deployment and Imaging Tools Environment</strong>, and then right-clicking it to select Run as administrator.</p>
		
		<p>Run the following command and this command will create an ISO that boots on both legacy BIOS and UEFI systems.</p>
		
		<pre><code class="language-plaintext hljs">oscdimg.exe -m -o -u2 -udfver102 -bootdata:2#p0,e,bD:\ISO_files\boot\etfsboot.com#pEF,e,bD:\ISO_files\efi\microsoft\boot\efisys.bin D:\ISO_files D:\Win11_24H2_v2_English_x64.iso</code></pre>
		
		<figure class="post-figure">
            <img src="/assets/images/createwindowsiso.png" alt="Create an Updated Windows ISO">
        </figure>
		
		<table class="table table-bordered border-primary">
			<thead>
				<tr>
					<th>Switch</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr><td><code>oscdimg.exe</code></td><td>The tool that creates the ISO image (part of the Windows ADK).</td></tr>
				<tr><td><code>-m</code></td><td>Ignores the maximum size limit for a CD (700MB). Needed for DVDs/USBs.</td></tr>
				<tr><td><code>-o</code></td><td>Optimizes storage by eliminating duplicate files during ISO creation.</td></tr>
				<tr><td><code>-u2</code></td><td>Sets the UDF (Universal Disk Format) version to 2.01 (required for large files and newer systems).</td></tr>
				<tr><td><code>-udfver102</code></td><td>Also sets the UDF version explicitly to 1.02 for better compatibility. Used redundantly here, but sometimes required for older systems.</td></tr>
				<tr><td><code>-bootdata:2#</code></td><td>Tells <code>oscdimg</code> to build two boot entries so that the ISO can boot in both legacy BIOS and modern UEFI systems.</td></tr>
				<tr><td><code>p0</code></td><td>Partition 0 — standard for BIOS boot.</td></tr>
				<tr><td><code>e</code></td><td>Marks it as bootable.</td></tr>
				<tr><td><code>bD:\ISO_files\boot\etfsboot.com</code></td><td>Specifies the boot sector file — etfsboot.com is the boot image for BIOS systems.</td></tr>
				<tr><td><code>pEF</code></td><td>EFI boot partition.</td></tr>
				<tr><td><code>e</code></td><td>Marks it as bootable.</td></tr>
				<tr><td><code>bD:\ISO_files\efi\microsoft\boot\efisys.bin</code></td><td>Path to the UEFI boot sector image — efisys.bin.</td></tr>
				<tr><td><code>D:\14986PROx64.iso</code></td><td>The source folder containing all Windows setup files.</td></tr>
				<tr><td><code>D:\Win11_24H2_v2_English_x64.iso</code></td><td>The output ISO that will be created.</td></tr>
			</tbody>
        </table>
		
		<figure class="post-figure">
            <img src="/assets/images/createwindowsiso.png" alt="Create an updated ISO">
        </figure>
    </article>

  <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows" class="tag">windows</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-10" class="tag">windows 10</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-11" class="tag">windows 11</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/dism" class="tag">dism</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/oscdimg" class="tag">oscdimg</a></li>
		
	</ul>
</div>


  <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/05/17/add-or-remove-drivers-on-a-windows-offline-image/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/05/17/add-or-remove-drivers-on-a-windows-offline-image/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/05/17/add-or-remove-drivers-on-a-windows-offline-image/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorials" /><category term="year-2025" /><category term="month-05" /><category term="day-17" /><category term="windows" /><category term="windows 10" /><category term="windows 11" /><category term="dism" /><category term="oscdimg" /><summary type="html"><![CDATA[Learn how to add or remove drivers in a Windows image using DISM. This step-by-step guide helps you customize Windows installation media by integrating or deleting drivers for better compatibility with modern hardware.]]></summary></entry><entry xml:lang="en"><title type="html">Windows Edition Selection not Showing While Installing Windows 10/11</title><link href="https://hemimorphite.github.io/zh/2025/05/17/windows-edition-selection-not-showing-while-installing-windows-11/" rel="alternate" type="text/html" title="Windows Edition Selection not Showing While Installing Windows 10/11" /><published>2025-05-17T11:38:50+00:00</published><updated>2025-05-17T11:38:50+00:00</updated><id>https://hemimorphite.github.io/2025/05/17/windows-edition-selection-not-showing-while-installing-windows-11</id><content type="html" xml:base="https://hemimorphite.github.io/2025/05/17/windows-edition-selection-not-showing-while-installing-windows-11/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Windows Edition Selection not Showing While Installing Windows 10/11</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published May 17, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/windowsedition.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>When you install Windows 10 or 11 on a custom-built PC or a new PC without Windows pre-installed, users have the option to install the specific edition of Windows that matches the license key they have purchased(eg Windows Home, Pro, Education, etc.).</p>
		
		<figure class="post-figure">
            <img src="/assets/images/windowsedition.jpg" alt="Windows 11 Edition">
        </figure>
		
        <p>However, on pre-installed Windows 10/11 PCs, users are not given the option to select a different edition during installation. The reason is that these PCs come with a Windows license key embedded in the BIOS/UEFI firmware, which the installer automatically detects. As a result, Windows installs the edition that matches the embedded key, without prompting the user to choose.</p>

        <p>In this tutorial you will learn how to be able to install a different version of Windows than the one that is preinstalled.</p>
		
		<h5 class="post-subtitle">Step 1: Create a Windows 10/11 USB Installation media.</h5>

        <p>For instructions, see this article: How to create a bootable Windows 10/11 USB installation media.</p>
		
		<h5 class="post-subtitle">Step 2: Add an <code>ei.cfg</code> file to your installation media</h5>
		
        <p>The <code>ei.cfg</code> file tells the Windows installer not to use the product key embedded in the BIOS/UEFI, allowing you to manually select the Windows edition during setup.</p>
		
		<p>Open Notepad and then copy and paste the following lines:</p>
		
		<pre><code class="language-plaintext hljs">[EditionID]
Professional
[Channel]
Retail</code></pre>
		
		<p>Here's a list of common Windows <code>EditionID</code> values that are used in <code>ei.cfg</code> files:</p>
		
		<table class="table table-bordered border-primary">
            <caption>Windows 10 Editions</caption>
			<thead>
				<tr>
					<th>Edition Name</th>
					<th>EditionID</th>
				</tr>
			</thead>
			<tbody>
				<tr><td>Windows 10 Home</td><td><code>Core</code></td></tr>
				<tr><td>Windows 10 Home N</td><td><code>CoreN</code></td></tr>
				<tr><td>Windows 10 Home Single Language</td><td><code>CoreSingleLanguage</code></td></tr>
				<tr><td>Windows 10 Pro</td><td><code>Professional</code></td></tr>
				<tr><td>Windows 10 Pro N</td><td><code>ProfessionalN</code></td></tr>
				<tr><td>Windows 10 Education</td><td><code>Education</code></td></tr>
				<tr><td>Windows 10 Education N</td><td><code>EducationN</code></td></tr>
				<tr><td>Windows 10 Enterprise</td><td><code>Enterprise</code></td></tr>
				<tr><td>Windows 10 Enterprise N</td><td><code>EnterpriseN</code></td></tr>
				<tr><td>Windows 10 Pro Education</td><td><code>ProfessionalEducation</code></td></tr>
				<tr><td>Windows 10 Pro for Workstations</td><td><code>ProfessionalWorkstation</code></td></tr>
				<tr><td>Windows 10 Pro N for Workstations</td><td><code>ProfessionalWorkstationN</code></td></tr>
			</tbody>
        </table>
		
		<table class="table table-bordered border-primary">
            <caption>Windows 11 Editions</caption>
			<thead>
				<tr>
					<th>Edition Name</th>
					<th>EditionID</th>
				</tr>
			</thead>
			<tbody>
				<tr><td>Windows 11 Home</td><td><code>Core</code></td></tr>
				<tr><td>Windows 11 Home N</td><td><code>CoreN</code></td></tr>
				<tr><td>Windows 11 Home Single Language</td><td><code>CoreSingleLanguage</code></td></tr>
				<tr><td>Windows 11 Pro</td><td><code>Professional</code></td></tr>
				<tr><td>Windows 11 Pro N</td><td><code>ProfessionalN</code></td></tr>
				<tr><td>Windows 11 Education</td><td><code>Education</code></td></tr>
				<tr><td>Windows 11 Education N</td><td><code>EducationN</code></td></tr>
				<tr><td>Windows 11 Enterprise</td><td><code>Enterprise</code></td></tr>
				<tr><td>Windows 11 Enterprise N</td><td><code>EnterpriseN</code></td></tr>
				<tr><td>Windows 11 Pro Education</td><td><code>ProfessionalEducation</code></td></tr>
				<tr><td>Windows 11 Pro for Workstations</td><td><code>ProfessionalWorkstation</code></td></tr>
				<tr><td>Windows 11 Pro N for Workstations</td><td><code>ProfessionalWorkstationN</code></td></tr>
			</tbody>
        </table>
		
		<p>When you're finished creating the configuration file, go to the <code>File</code> menu and choose <code>Save As</code>. In the save dialog that appears, navigate to the Windows USB installation media on the left-hand panel. Once there, open the <code>sources</code> folder on the right side.</p>
		
		<p>In the File name field, type <code>"ei.cfg"</code> — make sure to include the quotation marks exactly as shown. This ensures the file is saved with the correct <code>.cfg</code> extension and not accidentally as a <code>.txt</code> file. Finally, click <code>Save</code> to complete the process.</p>
		
		<h5 class="post-subtitle">Step 3: Add an <code>PID.txt</code> file to your installation media</h5>
		
		<p>The <code>PID.txt</code> file tells the Windows installer which product key to use during installation. If your system has a pre-installed OEM key embedded in the BIOS/UEFI (such as for Windows 10 Home), and you want to install a different edition like Windows 10 Pro, including a <code>PID.txt</code> file with a valid Pro product key will override the embedded key and force the installer to proceed with the Pro edition.</p>
		
		<p>Open Notepad and then copy and paste the following lines:</p>
		
		<pre><code class="language-plaintext hljs">[PID]
value=VK7JG-NPHTM-C97JM-9MPGT-3V66T</code></pre>
		
		<p>The PID value can be either a generic key or a KMS client key, depending on what you're trying to do.</p>
		
		<p>Generic Keys are default product keys provided by Microsoft that can be used to install and test Windows operating systems without activating them. These keys do not activate Windows, but allow you to complete the installation process.</p>
		
		<p>KMS Client Keys are special product keys provided by Microsoft that allow Windows computers to be activated via a Key Management Service (KMS). Instead of activating each PC individually via the internet, computers activate locally by talking to a KMS server inside the company network. This allows organizations to manage activations centrally for many machines.</p>
		
		<p>Here's a list of common Generic Keys values that can be used in <code>PID.txt</code> files:</p>
		
		<table class="table table-bordered border-primary">
            <caption>Windows 10 Editions</caption>
			<thead>
				<tr>
					<th>Edition Name</th>
					<th>Generic Key</th>
				</tr>
			</thead>
			<tbody>
				<tr><td>Windows 10 Home</td><td>YTMG3-N6DKC-DKB77-7M9GH-8HVX7</td></tr>
				<tr><td>Windows 10 Home N</td><td>4CPRK-NM3K3-X6XXQ-RXX86-WXCHW</td></tr>
				<tr><td>Windows 10 Home Single Language</td><td>BT79Q-G7N6G-PGBYW-4YWX6-6F4BT</td></tr>
				<tr><td>Windows 10 Pro</td><td>VK7JG-NPHTM-C97JM-9MPGT-3V66T</td></tr>
				<tr><td>Windows 10 Pro N</td><td>2B87N-8KFHP-DKV6R-Y2C8J-PKCKT</td></tr>
				<tr><td>Windows 10 Pro for Workstations</td><td>DXG7C-N36C4-C4HTG-X4T3X-2YV77</td></tr>
				<tr><td>Windows 10 Pro N for Workstations</td><td>WYPNQ-8C467-V2W6J-TX4WX-WT2RQ</td></tr>
				<tr><td>Windows 10 S</td><td>3NF4D-GF9GY-63VKH-QRC3V-7QW8P</td></tr>
				<tr><td>Windows 10 Education</td><td>YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY</td></tr>
				<tr><td>Windows 10 Education N</td><td>84NGF-MHBT6-FXBX8-QWJK7-DRR8H</td></tr>
				<tr><td>Windows 10 Pro Education</td><td>8PTT6-RNW4C-6V7J2-C2D3X-MHBPB</td></tr>
				<tr><td>Windows 10 Pro Education N</td><td>GJTYN-HDMQY-FRR76-HVGC7-QPF8P</td></tr>
				<tr><td>Windows 10 Enterprise</td><td>XGVPP-NMH47-7TTHJ-W3FW7-8HV2C</td></tr>
				<tr><td>Windows 10 Enterprise G N</td><td>FW7NV-4T673-HF4VX-9X4MM-B4H4T</td></tr>
				<tr><td>Windows 10 Enterprise N</td><td>WGGHN-J84D6-QYCPR-T7PJ7-X766F</td></tr>
				<tr><td>Windows 10 Enterprise S</td><td>NK96Y-D9CD8-W44CQ-R8YTK-DYJWX</td></tr>
			</tbody>
        </table>
		
		<table class="table table-bordered border-primary">
            <caption>Windows 11 Editions</caption>
			<thead>
				<tr>
					<th>Edition Name</th>
					<th>Generic Key</th>
				</tr>
			</thead>
			<tbody>
				<tr><td>Windows 11 Home</td><td>YTMG3-N6DKC-DKB77-7M9GH-8HVX7</td></tr>
				<tr><td>Windows 11 Home N</td><td>4CPRK-NM3K3-X6XXQ-RXX86-WXCHW</td></tr>
				<tr><td>Windows 11 Home Single Language</td><td>BT79Q-G7N6G-PGBYW-4YWX6-6F4BT</td></tr>
				<tr><td>Windows 11 Home Country Specific</td><td>N2434-X9D7W-8PF6X-8DV9T-8TYMD</td></tr>
				<tr><td>Windows 11 Pro</td><td>VK7JG-NPHTM-C97JM-9MPGT-3V66T</td></tr>
				<tr><td>Windows 11 Pro N</td><td>2B87N-8KFHP-DKV6R-Y2C8J-PKCKT</td></tr>
				<tr><td>Windows 11 Pro for Workstations</td><td>DXG7C-N36C4-C4HTG-X4T3X-2YV77</td></tr>
				<tr><td>Windows 11 Pro for Workstations N</td><td>WYPNQ-8C467-V2W6J-TX4WX-WT2RQ</td></tr>
				<tr><td>Windows 11 Pro Education</td><td>8PTT6-RNW4C-6V7J2-C2D3X-MHBPB</td></tr>
				<tr><td>Windows 11 Pro Education N</td><td>GJTYN-HDMQY-FRR76-HVGC7-QPF8P</td></tr>
				<tr><td>Windows 11 Education</td><td>YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY</td></tr>
				<tr><td>Windows 11 Education N</td><td>84NGF-MHBT6-FXBX8-QWJK7-DRR8H</td></tr>
				<tr><td>Windows 11 Enterprise</td><td>XGVPP-NMH47-7TTHJ-W3FW7-8HV2C</td></tr>
				<tr><td>Windows 11 Enterprise N</td><td>WGGHN-J84D6-QYCPR-T7PJ7-X766F</td></tr>
				<tr><td>Windows 11 Enterprise G N</td><td>FW7NV-4T673-HF4VX-9X4MM-B4H4T</td></tr>
			</tbody>
        </table>
		
		<p>When you're finished creating the PID file, go to the <code>File</code> menu and choose <code>Save As</code>. In the save dialog that appears, navigate to the Windows USB installation media on the left-hand panel. Once there, open the <code>sources</code> folder on the right side.</p>
		
		<p>In the File name field, type <code>"PID.txt"</code> — make sure to include the quotation marks exactly as shown. This ensures the file is saved with the correct <code>.txt</code> extension and not accidentally as a <code>.txt.txt</code> file. Finally, click <code>Save</code> to complete the process.</p>
		
		<p>After setting up the <code>ei.cfg</code> and <code>PID.txt</code> files correctly in the sources folder of your USB installation media, boot your PC from the USB. During the clean installation process, you will now be able to choose the edition of Windows 11 or Windows 10 that you want to install.</p>
    </article>
		
  <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows" class="tag">windows</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-10" class="tag">windows 10</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/windows-11" class="tag">windows 11</a></li>
		
	</ul>
</div>


  <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/05/17/windows-edition-selection-not-showing-while-installing-windows-11/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/05/17/windows-edition-selection-not-showing-while-installing-windows-11/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/05/17/windows-edition-selection-not-showing-while-installing-windows-11/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorials" /><category term="year-2025" /><category term="month-05" /><category term="day-17" /><category term="windows" /><category term="windows 10" /><category term="windows 11" /><summary type="html"><![CDATA[Learn how to fix the common issue where the Windows Edition selection screen fails to appear during the installation of Windows 10 or Windows 11. This comprehensive guide provides clear, step-by-step solutions to help you troubleshoot and resolve the problem, ensuring you can select the correct Windows edition before the installation process completes.]]></summary></entry><entry xml:lang="en"><title type="html">Circular Singly Linked List Data Structure</title><link href="https://hemimorphite.github.io/zh/2025/02/04/circular-singly-linked-list-data-structure/" rel="alternate" type="text/html" title="Circular Singly Linked List Data Structure" /><published>2025-02-04T16:20:00+00:00</published><updated>2025-02-04T16:20:00+00:00</updated><id>https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Circular Singly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published February 04, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/circularsinglylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Circular Singly Linked List</h3>

		<p>A circular singly linked list is a variation of a singly linked list where the last node points back to the first node, forming a circular structure. It is a linear data structure consisting of a sequence of elements, called nodes, where each node points to the next node in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations. Each node contains two fields:</p>

		<ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence. In the case of the last node, the next pointer points back to the first node.</li>
		</ul>

        <p>The circular singly linked list forms a linear collection of elements where each node points to its successor, and the last node points back to the first node, creating a circular structure. It is a dynamic data structure, meaning it can grow or shrink in size during runtime, as nodes can be added or removed without requiring memory to be reallocated.</p>

		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. In a circular singly linked list, the last node points back to the head, forming a loop. If the list is empty, the head points to <code>NULL</code>.</p>

		<p>Unlike arrays that have a fixed size, a circular singly linked list dynamically allocates memory for each node when it is created. This means the size of the list can grow or shrink as nodes are added or removed at runtime.</p>

		<p>Insertions and deletions of nodes, particularly at the beginning or middle of the list, are more efficient compared to arrays since you do not need to shift elements.</p>

		<p>Circular singly linked lists can be traversed in a loop starting from the head and continuing back to the head after reaching the tail. However, there is no way to traverse backward, which can be a limitation in some use cases.</p>

		<p>The nodes in a circular singly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next through pointers, and they can be located anywhere in memory.</p>

		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>

		<p>Each node in a circular singly linked list requires extra memory for the pointer (next reference), which slightly increases memory usage compared to arrays.</p>

		<p>The last node in a circular singly linked list points back to the head, instead of having its next pointer set to <code>NULL</code>.</p>

		<p>Here's a visual representation of a circular singly linked list:</p>

		<pre><code class="language-bash hljs">Head -&gt; [Data | Next] -&gt; [Data | Next] -&gt; [Data | Next] -&gt; Head</code></pre>

		<p>In the above representation:</p>

		<ul>
			<li>The <code>Head</code> points to the first node of the list.</li>
			<li>Each node contains <code>Data</code> and a <code>Next</code> pointer to the next node.</li>
			<li>The last node's <code>Next</code> pointer points back to the <code>Head</code>, indicating the circular structure.</li>
		</ul>

		
		<p>A simple circular singly linked list with three nodes could look like this:</p>

		<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>

		<p>In the above example:</p>

		<ul>
			<li>The <code>Head</code> points to the first node containing the data <code>10</code>.</li>
			<li>The second node contains the data <code>20</code> and points to the third node.</li>
			<li>The third node contains the data <code>30</code> and points back to the <code>Head</code>, indicating the circular structure of the list.</li>
		</ul>

		
		<p>Here's a detailed breakdown of common circular singly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a circular singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [5 | Next] -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a circular singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>If the list is not empty, set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list). If the list is empty, set the <code>next</code> pointer of the new node to point to itself, creating a circular structure.</li>
							<li>Update the head pointer to point to the new node.</li>
							<li>If the list is not empty, the last node's <code>next</code> pointer should be updated to point to the new head.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a circular singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a circular singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; [40 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a circular singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning. The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to point to itself, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer points to the head).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to point to the head.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a circular singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [25 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a circular singly linked list immediately after a given node. If the target node doesn't exist, the function does nothing and simply returns control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [25 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node after a given node in a circular singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node after a node in a circular singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a circular singly linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [35 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a circular singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target position).</li>
							<li>Update the <code>next</code> pointer of the new node to point to the next node in the sequence.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointers takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a new node at a specified position in a circular singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a circular singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [20 | Next] -&gt; [30 | Next]-&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the beginning of a circular singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>If the list is empty, return.</li>
							<li>If there is only one node, set the head to <code>NULL</code> (empty list).</li>
							<li>Otherwise:
								<ul>
									<li>Find the last node in the list (the node pointing to head).</li>
									<li>Update the last node's <code>next</code> pointer to point to the second node.</li>
									<li>Set the head pointer to the second node.</li>
									<li>Deallocate the memory of the old head node.</li>
								</ul>
							</li>
						</ul>
						Since no traversal is required in the case of a one-node list, and only a single traversal is required for a multi-node list, this operation still takes \(O(1)\) on average.
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a circular singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a circular singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a circular singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>If the list is empty, return.</li>
							<li>If there is only one node, set the head to <code>NULL</code> (empty list).</li>
							<li>Otherwise:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list to find the second-to-last node (the node whose <code>next</code> pointer points to the last node).</li>
									<li>Update the <code>next</code> pointer of the second-to-last node to point to the head, maintaining the circular structure.</li>
									<li>Deallocate the memory for the old last node.</li>
								</ul>
							</li>
						</ul>
						Since traversal is required to reach the second-to-last node, the worst-case time complexity is \(O(n)\), where \(n\) is the number of nodes in the list.
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a circular singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a circular singly linked list. Positions are usually indexed starting from 0 or 1. If the position is 0 (or 1, based on indexing), it means the head node should be removed. If the specified position is out of bounds, a message is printed, and no changes are made to the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to remove the node at position <code>2</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a circular singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>If the list is empty, return.</li>
							<li>If the position is 0 (or 1, based on indexing), remove the head node:
								<ul>
									<li>If there is only one node, set <code>head = NULL</code>.</li>
									<li>Otherwise, find the last node (the node whose <code>next</code> points to the head).</li>
									<li>Update the head pointer to the next node.</li>
									<li>Update the last node's <code>next</code> pointer to point to the new head.</li>
									<li>Deallocate the memory of the removed node.</li>
								</ul>
							</li>
							<li>If the position is greater than 0, traverse the list to find the node before the target node.</li>
							<li>Update its <code>next</code> pointer to skip the target node and point to the node after it.</li>
							<li>Deallocate the memory of the removed node.</li>
						</ul>
						Since traversal is required to reach the node before the target, the worst-case time complexity is \(O(n)\), where \(n\) is the number of nodes in the list.
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a circular singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references, and it does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a circular singly linked list and performs an action, such as printing the node's value. Unlike a singly linked list, traversal starts at the head and continues until the head is encountered again, ensuring the circular structure is maintained.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>traverse()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, from the head back to the head. Since every node is visited once, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>traverse()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>

			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a circular singly linked list. Unlike a regular singly linked list, the last node's <code>next</code> pointer must be correctly updated to point to the new head, ensuring the circular structure is maintained.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [30 | Next] -&gt; [20 | Next] -&gt; [10 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of the <code>reverse()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses each node exactly once and updates pointers accordingly.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>reverse()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes, regardless of the list size.</li>
				</ul>
			</li>

			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a circular singly linked list. Unlike a regular singly linked list, the traversal must stop when the search wraps around back to the head, ensuring we do not loop indefinitely.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>search()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function may need to examine every node in the list before finding the key (or determining that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of the <code>search()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space to store variables, such as a pointer to the current node. No additional data structures are used.</li>
				</ul>
			</li>

			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a circular singly linked list. Unlike a regular singly linked list, traversal must stop when the function loops back to the head to avoid infinite loops.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>size()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the entire linked list once to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>size()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function uses only a fixed amount of extra space for variables, regardless of the size of the list.</li>
				</ul>
			</li>

			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a circular singly linked list at a specified index. Since the list is circular, traversal stops when the head is encountered again. If the index is out of range, a message is printed indicating that the index is invalid.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>get()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the list until it reaches the specified index, stopping if it loops back to the head before finding the index.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>get()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space for variables, regardless of the list size.</li>
				</ul>
			</li>

			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a circular singly linked list. Since the list is circular, traversal stops when the head is encountered again. If the index is out of range, a message is printed indicating that the index is invalid.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>set()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the list until it reaches the specified index, stopping if it loops back to the head before finding the index.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>set()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space for variables, regardless of the list size.</li>
				</ul>
			</li>

			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a circular singly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>isEmpty()</code> function in a circular singly linked list is \(O(1)\) (constant time). The function only checks if the head pointer is <code>NULL</code>, which takes constant time.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>isEmpty()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function does not use any additional memory beyond a single pointer check.</li>
				</ul>
			</li>

			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted circular singly linked lists into a single sorted circular singly linked list while maintaining circularity.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>merge()</code> function in a circular singly linked list is \(O(n + m)\) (linear time). Each node from both lists is visited exactly once, and linking operations are performed in constant time. Where \(n\) is the number of nodes in the first circular linked list and \(m\) is the number of nodes in the second circular linked list.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>merge()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function uses a fixed number of pointers without any additional data structures, ensuring that the space required does not depend on the size of the input lists.</li>
				</ul>
			</li>

			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a circular singly linked list in a specific order (typically ascending or descending) while maintaining its circular nature.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>sort()</code> function in a circular singly linked list, when using merge sort, is \(O(n \log n)\) (linearithmic time). The algorithm recursively divides the list into halves and requires \(O(n)\) time to merge them back together. The logarithmic factor \(\log n\) results from the number of times the list is split in half.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>sort()</code> function in a circular singly linked list, using Merge Sort, is \(O(\log n)\) (logarithmic space) due to recursion depth. If implemented iteratively, space complexity can be reduced to \(O(1)\), ensuring no extra space is used beyond a few pointers.</li>
				</ul>
			</li>

			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from a circular singly linked list, freeing up the memory they occupy and making the list empty. The head pointer is set to <code>NULL</code>, breaking the circular link.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>clear()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the list once, freeing each node's memory.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>clear()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of space for temporary pointers during traversal, regardless of the list size.</li>
				</ul>
			</li>

        </ul>
		
		<h3 class="post-subtitle">Non-Generic Circular Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic circular singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Defines a structure to represent a node in a circular singly linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = newNode;  // Points to itself initially (circular behavior)
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
    } else {
        Node* temp = *headRef;
        while (temp-&gt;next != *headRef) {  // Traverse until we find the last node
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;  // Update last node's next to new node
        newNode-&gt;next = *headRef;  // New node points to head
        *headRef = newNode;  // Update head
    }
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    if (*headRef == NULL) {
        *headRef = createNode(data);
    } else {
        Node* temp = *headRef;
        while (temp-&gt;next != *headRef) {  // Traverse until we find the last node
            temp = temp-&gt;next;
        }
        Node* newNode = createNode(data);
        temp-&gt;next = newNode;
        newNode-&gt;next = *headRef;  // Make the new node point to the head
    }
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }
    
    Node* newNode = createNode(data);
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(data);
    
    if (*headRef == nextNode) {  // If the nextNode is the head, insert at beginning
        insertAtBeginning(headRef, data);
        return;
    }

    Node* temp = *headRef;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    if (position == 0) {  // Insert at the beginning
        insertAtBeginning(headRef, data);
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *headRef;
    if (temp-&gt;next == *headRef) {  // If there's only one node
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the last node
    Node* last = *headRef;
    while (last-&gt;next != *headRef) {
        last = last-&gt;next;
    }

    last-&gt;next = (*headRef)-&gt;next;  // Last node's next points to second node
    *headRef = (*headRef)-&gt;next;  // Update head
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    if (temp-&gt;next == *headRef) {  // Only one node
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the second last node
    Node* last = *headRef;
    while (last-&gt;next != *headRef) {
        last = last-&gt;next;
    }

    // Delete last node
    Node* secondLast = *headRef;
    while (secondLast-&gt;next != last) {
        secondLast = secondLast-&gt;next;
    }

    secondLast-&gt;next = *headRef;  // Second last node points to head
    free(last);
}

// Function to delete a node at a specific position (0-based index) in a circular singly linked list
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    // If the position is 0, we need to delete the head
    if (position == 0) {
        // If there is only one node in the list
        if (temp-&gt;next == *headRef) {
            free(temp);
            *headRef = NULL;
            return;
        }

        // Traverse to the last node
        Node* last = *headRef;
        while (last-&gt;next != *headRef) {
            last = last-&gt;next;
        }

        // Update the head and unlink the node
        last-&gt;next = temp-&gt;next;
        *headRef = temp-&gt;next;
        free(temp);
        return;
    }

    // Find the previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
        if (temp == *headRef) {
            // If we have reached the head again, the position is out of bounds
            printf("Position out of bounds\n");
            return;
        }
    }

    // If position is more than number of nodes or temp is NULL
    if (temp == NULL || temp-&gt;next == *headRef) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next; // Unlink the node from the list
    free(nodeToDelete); // Free the memory of the deleted node
}

// Function to traverse the circular list and print all elements
void traverse(Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    Node* temp = head;
    do {
        printf("%d -&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    } while (temp != head);  // Stop when we reach the head again
    printf("(head)\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    if (head == NULL) return 0;

    Node* temp = head;
    do {
        if (temp-&gt;data == key)
            return 1;
        temp = temp-&gt;next;
    } while (temp != head);
    
    return 0;
}

// Function to get the size of the circular linked list
int size(Node* head) {
    if (head == NULL) return 0;
    
    int size = 1;
    Node* temp = head-&gt;next;
    while (temp != head) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    if (head == NULL) return -1;

    int count = 0;
    Node* temp = head;
    do {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    } while (temp != head);
    
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    int count = 0;
    Node* current = head;
    do {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;
        }
        count++;
        current = current-&gt;next;
    } while (current != head);
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to reverse the circular linked list
void reverse(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == *headRef) {
        return;  // No need to reverse for empty or single node
    }

    Node *prev = NULL, *current = *headRef, *next = NULL;
    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != *headRef);
    
    (*headRef)-&gt;next = prev;  // Make the last node point to the new head
    *headRef = prev;
}

// Function to clear the entire circular linked list and free memory
void clear(Node** headRef) {
    if (*headRef == NULL) return;
    
    Node* current = *headRef;
    Node* next;
    do {
        next = current-&gt;next;
        free(current);
        current = next;
    } while (current != *headRef);

    *headRef = NULL;
}
// Function to find the middle of a circular singly linked list
void middle(Node** mid, Node* head) {
    if (head == NULL || head-&gt;next == head) {
        *mid = head;
        return;
    }

    Node* slow = head;
    Node* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    *mid = slow;
}

// Function to merge two circular linked lists
void merge(Node** headRef, Node* head1, Node* head2) {
    Node* tempHead = NULL, *last = NULL;
    Node* first1 = head1, *first2 = head2;
    
    printf("Starting merge...\n");

    if (head1 == NULL) {
        printf("First list is empty. Returning a new node from the second list.\n");
        Node* newNode = createNode(head2-&gt;data); // Create a new node with the data of the first node of head2
        *headRef = newNode; // Set the new node as the head
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = NULL; // Handle circular structure
        return;
    }
    if (head2 == NULL) {
        printf("Second list is empty. Returning a new node from the first list.\n");
        Node* newNode = createNode(head1-&gt;data); // Create a new node with the data of the first node of head1
        *headRef = newNode; // Set the new node as the head
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = NULL; // Handle circular structure
        return;
    }

    printf("Both lists are non-empty. Merging...\n");

    do {
        Node* newNode;
        if (head1 && (head2 == NULL || head1-&gt;data &lt;= head2-&gt;data)) {
            printf("Adding node from List 1: %d\n", head1-&gt;data);
            newNode = createNode(head1-&gt;data);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                printf("End of List 1 reached.\n");
                head1 = NULL;  // Stop merging this list
            }
        } else {
            printf("Adding node from List 2: %d\n", head2-&gt;data);
            newNode = createNode(head2-&gt;data);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                printf("End of List 2 reached.\n");
                head2 = NULL;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            printf("New head node created: %d\n", tempHead-&gt;data);
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != NULL || head2 != NULL);

    // Make the list circular
    last-&gt;next = tempHead;
    *headRef = tempHead;
    printf("Merge completed. Circular list created with head: %d\n", (*headRef)-&gt;data);
}

// Function to sort a circular singly linked list (Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == *headRef)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = head; // Break circularity for first half
    Node* secondHalf = nextToMid;

    // Find last node of second half
    while (secondHalf-&gt;next != head)
        secondHalf = secondHalf-&gt;next;
    
    secondHalf-&gt;next = nextToMid; // Break circularity for second half

    // Sort both halves
    sort(&head);
    sort(&nextToMid);

    // Merge sorted halves
    merge(headRef, head, nextToMid);
}

// Main function to test the circular linked list operations
int main() {
    Node* list = NULL; // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}
	
    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }

    // 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);

    // 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);

    // 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic circular singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for circular singly linked list
struct Node {
    int data;
    Node* next;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (!head) {
        newNode-&gt;next = newNode;
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != head) temp = temp-&gt;next;
    temp-&gt;next = newNode;
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (!head) {
        newNode-&gt;next = newNode;
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != head) temp = temp-&gt;next;
    temp-&gt;next = newNode;
    newNode-&gt;next = head;
}

// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (!head) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != head) temp = temp-&gt;next;
    Node* toDelete = head;
    temp-&gt;next = head-&gt;next;
    head = head-&gt;next;
    delete toDelete;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        cout &lt;&lt; "The list cannot be empty." &lt;&lt; endl;
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL." &lt;&lt; endl;
        return;
    }

    Node* newNode = new Node(data);

    // If inserting before the head, update head reference
    if (headRef == nextNode) {
        // Find the last node to update its next pointer
        Node* temp = headRef;
        while (temp-&gt;next != headRef) {
            temp = temp-&gt;next;
        }

        temp-&gt;next = newNode; // Update last node's next pointer
        newNode-&gt;next = headRef;
        headRef = newNode; // New node becomes the head
        return;
    }

    // Find the node just before nextNode
    Node* temp = headRef;
    while (temp-&gt;next != headRef && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;next != nextNode) {
        cout &lt;&lt; "The given next node is not found in the list." &lt;&lt; endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);

    // If inserting at position 0 (beginning)
    if (position == 0) {
        if (head == nullptr) {
            newNode-&gt;next = newNode; // First node points to itself
            head = newNode;
        } else {
            // Find the last node
            Node* temp = head;
            while (temp-&gt;next != head) {
                temp = temp-&gt;next;
            }

            // Insert the new node at the beginning
            newNode-&gt;next = head;
            temp-&gt;next = newNode;
            head = newNode;
        }
        return;
    }

    // Traverse to the (position-1)th node
    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp-&gt;next != head; i++) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;next == head && position &gt; 0) {
        cout &lt;&lt; "Position out of bounds.\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the end
void deleteAtEnd(Node*& head) {
    if (!head) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next-&gt;next != head) temp = temp-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = head;
}

// Traverse the list
void traverse(Node* head) {
    if (!head) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    do {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    } while (temp != head);
    cout &lt;&lt; "(head)\n";
}

// Function to delete a node at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    Node* temp = head;

    // Case 1: Deleting the head node
    if (position == 0) {
        if (head-&gt;next == head) {
            delete head; // Only one node in the list
            head = nullptr;
            return;
        }

        // Find the last node to update its next pointer
        Node* last = head;
        while (last-&gt;next != head) {
            last = last-&gt;next;
        }

        last-&gt;next = head-&gt;next;
        head = head-&gt;next;
        delete temp;
        return;
    }

    // Case 2: Deleting a node at position &gt; 0
    Node* prev = nullptr;
    for (int i = 0; i &lt; position; i++) {
        prev = temp;
        temp = temp-&gt;next;

        // If we circle back to the head, position is out of bounds
        if (temp == head) {
            cout &lt;&lt; "Position out of bounds\n";
            return;
        }
    }

    prev-&gt;next = temp-&gt;next;
    delete temp;
}

// Function to check if the list is empty
bool isEmpty(Node* head) {
    return head == nullptr;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return -1;
    }

    Node* temp = head;
    int count = 0;

    do {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    cout &lt;&lt; "Index out of range\n";
    return -1;
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    Node* temp = head;
    int count = 0;

    do {
        if (count == index) {
            temp-&gt;data = newValue;
            return;
        }
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    cout &lt;&lt; "Index out of range\n";
}

// Function to search for an element in a circular linked list
bool search(Node* head, int key) {
    if (head == nullptr) return false;

    Node* temp = head;
    do {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    } while (temp != head);

    return false;
}

// Reverse the list
void reverse(Node*& head) {
    if (!head || head-&gt;next == head) return;
    Node* prev = nullptr, *current = head, *next = nullptr, *tail = head;
    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != head);
    head-&gt;next = prev;
    head = prev;
}

// Get size of the list
int size(Node* head) {
    if (!head) return 0;
    int count = 0;
    Node* temp = head;
    do {
        count++;
        temp = temp-&gt;next;
    } while (temp != head);
    return count;
}

// Clear the list
void clear(Node*& head) {
    if (!head) return; // If the list is empty, return immediately.

    Node* temp = head;
    Node* nextNode;

    // Traverse and delete each node
    while (temp-&gt;next != head) {
        nextNode = temp-&gt;next;
        delete temp;
        temp = nextNode;
    }

    // Delete the last remaining node
    delete temp;

    head = nullptr; // Set head to null after clearing the list
}

// Function to merge two sorted circular linked lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    Node* tempHead = nullptr, *last = nullptr;
    Node* first1 = head1, *first2 = head2;
    
    //std::cout &lt;&lt; "Starting merge...\n";

    if (head1 == nullptr) {
        //std::cout &lt;&lt; "First list is empty. Returning a new node from the second list.\n";
        Node* newNode = new Node(head2-&gt;data); // Create a new node with the data of the first node of head2
        headRef = newNode; // Set the new node as the head
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = nullptr; // Handle circular structure
        return;
    }
    if (head2 == nullptr) {
        //std::cout &lt;&lt; "Second list is empty. Returning a new node from the first list.\n";
        Node* newNode = new Node(head1-&gt;data); // Create a new node with the data of the first node of head1
        headRef = newNode; // Set the new node as the head
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = nullptr; // Handle circular structure
        return;
    }

    //std::cout &lt;&lt; "Both lists are non-empty. Merging...\n";

    do {
        Node* newNode;
        if (head1 && (head2 == nullptr || head1-&gt;data &lt;= head2-&gt;data)) {
            //std::cout &lt;&lt; "Adding node from List 1: " &lt;&lt; head1-&gt;data &lt;&lt; "\n";
            newNode = new Node(head1-&gt;data);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                //std::cout &lt;&lt; "End of List 1 reached.\n";
                head1 = nullptr;  // Stop merging this list
            }
        } else {
            //std::cout &lt;&lt; "Adding node from List 2: " &lt;&lt; head2-&gt;data &lt;&lt; "\n";
            newNode = new Node(head2-&gt;data);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                //std::cout &lt;&lt; "End of List 2 reached.\n";
                head2 = nullptr;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            //std::cout &lt;&lt; "New head node created: " &lt;&lt; tempHead-&gt;data &lt;&lt; "\n";
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != nullptr || head2 != nullptr);

    // Make the list circular
    last-&gt;next = tempHead;
    headRef = tempHead;
    //std::cout &lt;&lt; "Merge completed. Circular list created with head: " &lt;&lt; headRef-&gt;data &lt;&lt; "\n";
}


// Function to find the middle of a circular linked list
void middle(Node*& mid, Node* head) {
    if (head == nullptr || head-&gt;next == head) {  // Check if list is empty or contains one node
        mid = head;
        return;
    }

    Node* slow = head;
    Node* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    mid = slow;  // Assign the slow pointer to mid (middle node)
}

void sort(Node*& headRef) {
    // If the list is empty or contains a single node, no need to sort
    if (headRef == nullptr || headRef-&gt;next == headRef)
        return;

    Node* head = headRef;
    Node* mid = nullptr;

    // Find the middle node
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = head;  // Break circularity for first half
    Node* secondHalf = nextToMid;

    // Find the last node of the second half
    while (secondHalf-&gt;next != head)
        secondHalf = secondHalf-&gt;next;

    secondHalf-&gt;next = nextToMid;  // Break circularity for second half

    // Sort both halves recursively
    sort(head);
    sort(nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


int main() {
    Node* list = nullptr;  // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    std::cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    std::cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(list, 4, 2);

    std::cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    std::cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    std::cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(list);

    std::cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(list);

    std::cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(list, 2);

    std::cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);
	
	// 9. Check if the list is empty
    if (isEmpty(list)) {
        cout &lt;&lt; "The list is empty." &lt;&lt; endl;
    } else {
		cout &lt;&lt; "The list is not empty." &lt;&lt; endl;
	}
	
    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; std::endl;
    }

    // 11. Reverse the list
    reverse(list);

    std::cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // 12. Sort the list
    sort(list);

    std::cout &lt;&lt; "List after sorting: ";
    traverse(list);

    // 13. Get the size of the list
    std::cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; std::endl;

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        std::cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Index " &lt;&lt; index &lt;&lt; " is out of range." &lt;&lt; std::endl;
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    std::cout &lt;&lt; "List after setting value 10 at index 2: ";
    traverse(list);

    // 16. Clear the list
    clear(list);

    std::cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic circular singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class CircularLinkedList {

    // Node structure for a circular singly linked list
    static class Node {
        int data;
        Node next;

        // Constructor
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            newNode.next = newNode; // Make it circular
            return newNode;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.next = head;
        return newNode; // New head
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            newNode.next = newNode;
            return newNode;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.next = head;
        return head; // Head remains the same
    }
    
    // Function to insert a new node after a given previous node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be NULL.");
            return;
        }

        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }

    // Function to insert a new node before a given next node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (head == null) {
            System.out.println("The list cannot be empty.");
            return null;
        }

        if (nextNode == null) {
            System.out.println("The given next node cannot be NULL.");
            return head;
        }

        Node newNode = new Node(data);

        // If inserting before the head, update head reference
        if (head == nextNode) {
            Node temp = head;
            while (temp.next != head) {
                temp = temp.next;
            }

            temp.next = newNode;  // Update last node's next pointer
            newNode.next = head;
            return newNode; // New node becomes the head
        }

        // Find the node just before nextNode
        Node temp = head;
        while (temp.next != head && temp.next != nextNode) {
            temp = temp.next;
        }

        if (temp.next != nextNode) {
            System.out.println("The given next node is not found in the list.");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }
    
    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        if (position == 0) {
            return insertAtBeginning(head, data);
        }

        Node newNode = new Node(data);
        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp.next != head; i++) {
            temp = temp.next;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == head) {
            return null;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }

        temp.next = head.next;
        return head.next;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null || head.next == head) {
            return null;
        }

        Node temp = head;
        while (temp.next.next != head) {
            temp = temp.next;
        }
        temp.next = head;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            return null;
        }

        if (position == 0) {
            return deleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp.next != head; i++) {
            temp = temp.next;
        }

        if (temp.next == head) {
            return head;
        }

        temp.next = temp.next.next;
        return head;
    }

    // Traverse the list
    public static void traverse(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }

        Node temp = head;
        do {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        } while (temp != head);
        System.out.println("(head)");
    }
	
	// Check if the list is empty
	public static boolean isEmpty(Node head) {
		return head == null;
	}
	
    // Function to merge two sorted circular linked lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        Node dummy = new Node(0); // Temporary dummy node
        Node tail = dummy;
        Node first1 = head1, first2 = head2;

        do {
            Node newNode;
            if (head1 != null && (head2 == null || head1.data &lt;= head2.data)) {
                newNode = new Node(head1.data);
                head1 = head1.next;
                if (head1 == first1) head1 = null;
            } else {
                newNode = new Node(head2.data);
                head2 = head2.next;
                if (head2 == first2) head2 = null;
            }

            tail.next = newNode;
            tail = newNode;

        } while (head1 != null || head2 != null);

        // Make the merged list circular
        tail.next = dummy.next;
        return dummy.next;
    }

    // Function to find the middle node of a circular linked list
    public static Node middle(Node head) {
        if (head == null || head.next == head) return head;

        Node slow = head, fast = head;
        while (fast.next != head && fast.next.next != head) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    // Function to sort a circular linked list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == head) return head;

        Node mid = middle(head);
        Node secondHalf = mid.next;
        mid.next = head;  // Break circularity for the first half

        // Find last node of second half and break circularity
        Node temp = secondHalf;
        while (temp.next != head) temp = temp.next;
        temp.next = secondHalf;

        // Recursively sort both halves
        Node firstSorted = sort(head);
        Node secondSorted = sort(secondHalf);

        // Merge both halves
        return merge(firstSorted, secondSorted);
    }
    
    // Function to get an element at a specific index (0-based)
    public static int get(Node head, int index) {
        if (head == null) {
            System.out.println("List is empty");
            return -1;
        }

        Node temp = head;
        int count = 0;

        do {
            if (count == index)
                return temp.data;
            count++;
            temp = temp.next;
        } while (temp != head);

        System.out.println("Index out of range");
        return -1;
    }

    // Function to set an element at a specific index (0-based)
    public static void set(Node head, int index, int newValue) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }

        Node temp = head;
        int count = 0;

        do {
            if (count == index) {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        } while (temp != head);

        System.out.println("Index out of range");
    }

    // Function to search for an element in a circular linked list
    public static boolean search(Node head, int key) {
        if (head == null) return false;

        Node temp = head;
        do {
            if (temp.data == key)
                return true;
            temp = temp.next;
        } while (temp != head);

        return false;
    }

    // Function to reverse a circular linked list
    public static Node reverse(Node head) {
        if (head == null || head.next == head) return head;

        Node prev = null, current = head, next = null;
        Node tail = head;

        do {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        } while (current != head);

        head.next = prev; // Fix circular link
        return prev; // New head
    }
    
    // Get the size of the list
    public static int size(Node head) {
        if (head == null) return 0;

        int count = 0;
        Node temp = head;
        do {
            count++;
            temp = temp.next;
        } while (temp != head);
        return count;
    }

    // Clear the circular linked list
	public static void clear(Node head) {
		if (head == null) {
			System.out.println("List is already empty.");
			return null;
		}

		Node current = head;
		do {
			Node next = current.next; // Save the next node
			current.next = null;      // Break the link to the next node
			current = next;           // Move to the next node
		} while (current != head);    // Loop until we reach the head node again

		return null;  // Return null to indicate the list is empty
	}


    // Main method for testing
    public static void main(String[] args) {
        Node head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // 2. Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // 3. Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		
		// 4. Insert after a specific node
        insertAfterNode(head.next, 8);
        System.out.println("List after inserting 8 after second node: ");
        traverse(head);

        // 5. Insert before a specific node
        head = insertBeforeNode(head, head.next, 12);
        System.out.println("List after inserting 12 before second node: ");
        traverse(head);
		
        // 6. Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // 7. Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // 8. Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);
		
		// 9. Check if the list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}
	
        // 10. Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // 11. Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // 12. Get the size of the list
        System.out.println("Size of the list: " + size(head));
		
		// 13. Get element at a specific index
		int indexToGet = 2;
		int value = get(head, indexToGet);
		if (value != -1) {
			System.out.println("Element at index " + indexToGet + ": " + value);
		}

		// 14. Set value at a specific index
		int indexToSet = 1;
		int newValue = 25;
		System.out.println("Setting value at index " + indexToSet + " to " + newValue);
		set(head, indexToSet, newValue);
		
		System.out.println("Updated list after set operation:");
		traverse(head);
	
		// 15. Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
		traverse(head);
		
        // 16. Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic circular singly linked list implementation in C#:</p>
		
		<pre><code class="language-java hljs">using System;

public class CircularLinkedList
{
    // Node structure for circular singly linked list
    public class Node
    {
        public int Data;
        public Node Next;

        // Constructor to create a new node
        public Node(int data)
        {
            Data = data;
            Next = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            newNode.Next = newNode; // Circular link to itself if list is empty
            return newNode;
        }

        Node temp = head;
        // Traverse to the last node to point it to the new node
        while (temp.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = newNode;
        newNode.Next = head; // Link the new node to head
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            newNode.Next = newNode; // Circular link to itself if list is empty
            return newNode;
        }

        Node temp = head;
        // Traverse to the last node
        while (temp.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = newNode;
        newNode.Next = head; // Link the new node to head
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            return InsertAtBeginning(head, data);
        }

        Node temp = head;
        int count = 0;
        // Traverse to the position where new node should be inserted
        while (temp.Next != head && count &lt; position - 1)
        {
            temp = temp.Next;
            count++;
        }

        if (count != position - 1)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Insert after a given node
    public static void InsertAfterNode(Node prevNode, int data)
    {
        if (prevNode == null)
        {
            Console.WriteLine("The given previous node cannot be null");
            return;
        }

        Node newNode = new Node(data);
        newNode.Next = prevNode.Next;
        prevNode.Next = newNode;
    }

    // Insert before a given node
    public static Node InsertBeforeNode(Node head, Node nextNode, int data)
    {
        if (nextNode == null)
        {
            Console.WriteLine("The given next node cannot be null");
            return head;
        }

        if (head == nextNode)
        {
            return InsertAtBeginning(head, data);
        }

        Node temp = head;
        while (temp.Next != head && temp.Next != nextNode)
        {
            temp = temp.Next;
        }

        if (temp.Next == nextNode)
        {
            Node newNode = new Node(data);
            newNode.Next = nextNode;
            temp.Next = newNode;
        }
        else
        {
            Console.WriteLine("The given next node is not present in the list");
        }

        return head;
    }

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == head) // Only one node in the list
        {
            return null;
        }

        Node temp = head;
        // Traverse to the last node to point it to the second node
        while (temp.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = head.Next;
        return head.Next; // New head is the next node
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == head) // Only one node in the list
        {
            return null;
        }

        Node temp = head;
        while (temp.Next.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = head; // Last node points to the head again
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return DeleteAtBeginning(head);
        }

        Node temp = head;
        int count = 0;
        while (temp.Next != head && count &lt; position - 1)
        {
            temp = temp.Next;
            count++;
        }

        if (count != position - 1)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        temp.Next = temp.Next.Next;
        return head;
    }
	
	// Check if the list is empty
	public static bool IsEmpty(Node head)
	{
		return head == null;
	}
	
    // Traverse the circular list
    public static void Traverse(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty.");
            return;
        }

        Node temp = head;
        do
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        } while (temp != head);
        Console.WriteLine("(head)");
    }
    
    // Function to get an element at a specific index (0-based)
    public static int Get(Node head, int index)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return -1;
        }
    
        Node temp = head;
        int count = 0;
    
        do
        {
            if (count == index)
                return temp.Data;  // Return the data at the specified index
            count++;
            temp = temp.Next;
        } while (temp != head);
    
        Console.WriteLine("Index out of range");
        return -1;  // If index is out of bounds
    }
    
    // Function to set an element at a specific index (0-based)
    public static void Set(Node head, int index, int newValue)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return;
        }
    
        Node temp = head;
        int count = 0;
    
        do
        {
            if (count == index)
            {
                temp.Data = newValue;  // Set the new value at the specified index
                return;
            }
            count++;
            temp = temp.Next;
        } while (temp != head);
    
        Console.WriteLine("Index out of range");  // If index is out of bounds
    }

    // Search for an element in the circular list
    public static bool Search(Node head, int key)
    {
        if (head == null)
        {
            return false;
        }

        Node temp = head;
        do
        {
            if (temp.Data == key)
            {
                return true;
            }
            temp = temp.Next;
        } while (temp != head);

        return false;
    }

    // Reverse the circular linked list
    public static Node Reverse(Node head)
    {
        if (head == null || head.Next == head)
        {
            return head; // No reversal needed for empty or single-node list
        }

        Node prev = null;
        Node current = head;
        Node next = null;

        do
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        } while (current != head);

        head.Next = prev; // Circular link
        return prev; // New head
    }

    // Get the size of the circular list
    public static int Size(Node head)
    {
        if (head == null)
        {
            return 0;
        }

        int count = 0;
        Node temp = head;
        do
        {
            count++;
            temp = temp.Next;
        } while (temp != head);

        return count;
    }
    
    // Function to merge two sorted circular linked lists
    public static Node Merge(Node head1, Node head2)
    {
        if (head1 == null) return head2;
        if (head2 == null) return head1;
    
        Node dummy = new Node(0); // Temporary dummy node
        Node tail = dummy;
        Node first1 = head1, first2 = head2;
    
        do
        {
            Node newNode;
            if (head1 != null && (head2 == null || head1.Data &lt;= head2.Data))
            {
                newNode = new Node(head1.Data);
                head1 = head1.Next;
                if (head1 == first1) head1 = null;
            }
            else
            {
                newNode = new Node(head2.Data);
                head2 = head2.Next;
                if (head2 == first2) head2 = null;
            }
    
            tail.Next = newNode;
            tail = newNode;
    
        } while (head1 != null || head2 != null);
    
        // Make the merged list circular
        tail.Next = dummy.Next;
        return dummy.Next;
    }
    
    // Function to find the middle node of a circular linked list
    public static Node Middle(Node head)
    {
        if (head == null || head.Next == head) return head;
    
        Node slow = head, fast = head;
        while (fast.Next != head && fast.Next.Next != head)
        {
            fast = fast.Next.Next;
            slow = slow.Next;
        }
        return slow;
    }
    
    // Function to sort a circular linked list using merge sort
    public static Node Sort(Node head)
    {
        if (head == null || head.Next == head) return head;
    
        Node mid = Middle(head);
        Node secondHalf = mid.Next;
        mid.Next = head;  // Break circularity for the first half
    
        // Find last node of second half and break circularity
        Node temp = secondHalf;
        while (temp.Next != head) temp = temp.Next;
        temp.Next = secondHalf;
    
        // Recursively sort both halves
        Node firstSorted = Sort(head);
        Node secondSorted = Sort(secondHalf);
    
        // Merge both halves
        return Merge(firstSorted, secondSorted);
    }

    // Clear the circular linked list
	public static Node Clear(Node head)
	{
		if (head == null)
		{
			Console.WriteLine("List is already empty.");
			return null;
		}

		Node current = head;
		do
		{
			Node next = current.Next; // Save the next node
			current.Next = null;      // Break the link to the next node
			current = next;           // Move to the next node
		} while (current != head);    // Loop until we reach the head node again

		return null;  // Return null to indicate the list is empty
	}


    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning:");
        Traverse(head);

        // 2. Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end:");
        Traverse(head);

        // 3. Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2:");
        Traverse(head);

        // 4. Insert after a specific node
        InsertAfterNode(head.Next, 8);
        Console.WriteLine("List after inserting 8 after second node:");
        Traverse(head);

        // 5. Insert before a specific node
        head = InsertBeforeNode(head, head.Next, 12);
        Console.WriteLine("List after inserting 12 before second node:");
        Traverse(head);

        // 6. Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning:");
        Traverse(head);

        // 7. Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end:");
        Traverse(head);

        // 8. Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2:");
        Traverse(head);
		
		// 9. Check if the list is empty
		if (IsEmpty(head))
		{
			Console.WriteLine("The list is empty.");
		}
		else
		{
			Console.WriteLine("The list is not empty.");
		}

        // 10. Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine($"Element {key} found in the list");
        }
        else
        {
            Console.WriteLine($"Element {key} not found in the list");
        }

        // 11. Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing:");
        Traverse(head);

        // 12. Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));
		
		// 13. Get value at a specific index
		int indexToGet = 2;  // 0-based index
		int value = Get(head, indexToGet);
		Console.WriteLine($"Value at index {indexToGet}: {value}");

		// 14. Set a new value at a specific index
		int indexToSet = 2;  // 0-based index
		int newValue = 99;
		Set(head, indexToSet, newValue);

		Console.WriteLine($"List after setting index {indexToSet} to {newValue}:");
		Traverse(head);
	
        // 15. Sort the list
        head = Sort(head);
        Console.WriteLine("Sorted list:");
        Traverse(head);

        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing:");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Circular Singly Linked List Implementation</h3>
		
		<p>Here is the Generic circular singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for circular singly linked list
typedef struct Node {
    StackElement element;
    struct Node* next;     // Pointer to the next node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = newNode; // In circular list, the node points to itself initially
    return newNode;
}

// Function to insert a node at the beginning of the list (in a circular way)
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);

    if (*head == NULL) {
        *head = newNode;
    } else {
        Node* temp = *head;
        // Find the last node (which points to the head)
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;  // Set the last node's next to new node
        newNode-&gt;next = *head; // New node points to head
        *head = newNode;       // Update head to the new node
    }
}

// Function to insert a node at the end of the list (in a circular way)
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);

    if (*head == NULL) {
        *head = newNode;
    } else {
        Node* temp = *head;
        // Find the last node
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;  // Set the last node's next to new node
        newNode-&gt;next = *head; // New node points to head
    }
}

// Function to insert a node after a given previous node
void insertAfterNode(Node* prevNode, StackElement element) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // Insert the new node after prevNode
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    // Check if the head is NULL (list is empty)
    if (*head == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    // Check if the nextNode is NULL
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the nextNode is the head node, handle the insertion at beginning
    if (*head == nextNode) {
        // Insert the new node before the head node
        Node* temp = *head;
        while (temp-&gt;next != *head) { // Find the last node
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    // If temp is NULL, then nextNode is not found in the list
    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position in a circular singly linked list
void insertAtPosition(Node** head, StackElement element, int position) {
    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the list is empty and position is 0, insert as the only node
    if (*head == NULL) {
        if (position == 0) {
            *head = newNode;
            newNode-&gt;next = *head; // Make it circular
        } else {
            printf("Position out of bounds\n");
        }
        return;
    }

    // If position is at the beginning (position 0)
    if (position == 0) {
        Node* temp = *head;
        // Find the last node (that points to the head)
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        // Insert the new node at the beginning
        temp-&gt;next = newNode;
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    // Traverse the list to find the correct position
    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp-&gt;next != *head; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes in the list
    if (temp-&gt;next == *head && position &gt; 0) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    // Insert the new node at the specified position
    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}


// Function to delete the first node
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (*head == (*head)-&gt;next) {
        free(*head);
        *head = NULL;
    } else {
        Node* temp = *head;
        // Find the last node
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = (*head)-&gt;next; // Last node points to the second node
        free(*head);
        *head = temp-&gt;next;
    }
}

// Function to delete the last node
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (*head == (*head)-&gt;next) {
        free(*head);
        *head = NULL;
    } else {
        Node* temp = *head;
        // Traverse to the second-last node
        while (temp-&gt;next-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        free(temp-&gt;next);       // Free the last node
        temp-&gt;next = *head;     // Set the second-last node's next to head
    }
}

// Function to delete a node at a specific position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (position == 0) {
        deleteAtBeginning(head);
        return;
    }

    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == *head) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next;
    free(nodeToDelete);
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = head;
    do {
        printf("%s -&gt; ", temp-&gt;element.toString);
        temp = temp-&gt;next;
    } while (temp != head);
    printf("HEAD\n"); // To signify it's a circular list
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    if (head == NULL) {
        return 0;
    }

    Node* temp = head;
    do {
        if (strcmp(temp-&gt;element.toString, keyElement.toString) == 0) {
            return 1; // Found
        }
        temp = temp-&gt;next;
    } while (temp != head);

    return 0; // Not found
}

// Function to reverse the circular linked list (O(n) time complexity)
void reverse(Node** head) {
    if (*head == NULL || (*head)-&gt;next == *head) {
        return;
    }

    Node *prev = NULL, *current = *head, *next = NULL;
    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != *head);

    (*head)-&gt;next = prev;
    *head = prev;
}

// Function to get the size of the list
int size(Node* head) {
    int size = 0;
    if (head == NULL) return size;

    Node* temp = head;
    do {
        size++;
        temp = temp-&gt;next;
    } while (temp != head);

    return size;
}
// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}
// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;

    // If the list is empty
    if (head == NULL) {
        StackElement emptyElement = {NULL, ""};
        return emptyElement; // Return empty element if the list is empty
    }

    // Traverse the list
    do {
        if (count == index) {
            return temp-&gt;element;  // Found the element at the specified index
        }
        count++;
        temp = temp-&gt;next;
    } while (temp != head);  // Stop when we loop back to the head node

    // If the index is out of range
    StackElement emptyElement = {NULL, ""};
    return emptyElement;
}
// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // If the list is empty
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    // Traverse the list
    do {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;  // Exit after updating
        }
        count++;
        current = current-&gt;next;
    } while (current != head);  // Stop when we loop back to the head node

    printf("Index out of range\n");  // Handle case where index exceeds list length
}
// Function to find the middle of a circular singly linked list
void middle(Node** mid, Node* head) {
    if (head == NULL || head-&gt;next == head) {
        *mid = head;
        return;
    }

    Node* slow = head;
    Node* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    *mid = slow;
}

// Function to merge two circular linked lists
void merge(Node** headRef, Node* head1, Node* head2) {
    Node* tempHead = NULL, *last = NULL;
    Node* first1 = head1, *first2 = head2;
    
    printf("Starting merge...\n");

    if (head1 == NULL) {
        printf("First list is empty. Returning a new node from the second list.\n");
        Node* newNode = createNode(head2-&gt;element); // Create a new node with the data of the first node of head2
        *headRef = newNode; // Set the new node as the head
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = NULL; // Handle circular structure
        return;
    }
    if (head2 == NULL) {
        printf("Second list is empty. Returning a new node from the first list.\n");
        Node* newNode = createNode(head1-&gt;element); // Create a new node with the data of the first node of head1
        *headRef = newNode; // Set the new node as the head
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = NULL; // Handle circular structure
        return;
    }

    printf("Both lists are non-empty. Merging...\n");

    do {
        Node* newNode;
        if (head1 && (head2 == NULL || strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt;= 0)) {
            printf("Adding node from List 1: %s\n", head1-&gt;element.toString);
            newNode = createNode(head1-&gt;element);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                printf("End of List 1 reached.\n");
                head1 = NULL;  // Stop merging this list
            }
        } else {
            printf("Adding node from List 2: %s\n", head2-&gt;element.toString);
            newNode = createNode(head2-&gt;element);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                printf("End of List 2 reached.\n");
                head2 = NULL;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            printf("New head node created: %s\n", tempHead-&gt;element.toString);
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != NULL || head2 != NULL);

    // Make the list circular
    last-&gt;next = tempHead;
    *headRef = tempHead;
    printf("Merge completed. Circular list created with head: %s\n", (*headRef)-&gt;element.toString);
}

// Function to sort a circular singly linked list (Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == *headRef)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = head; // Break circularity for first half
    Node* secondHalf = nextToMid;

    // Find last node of second half
    while (secondHalf-&gt;next != head)
        secondHalf = secondHalf-&gt;next;
    
    secondHalf-&gt;next = nextToMid; // Break circularity for second half

    // Sort both halves
    sort(&head);
    sort(&nextToMid);

    // Merge sorted halves
    merge(headRef, head, nextToMid);
}
// Function to clear the entire linked list and free memory
void clear(Node** head) {
    if (*head == NULL) return;

    Node* current = *head;
    Node* next = NULL;
    do {
        next = current-&gt;next;
        free(current);
        current = next;
    } while (current != *head);

    *head = NULL;
}
struct Person {
    char name[20];
    int age;
};
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements at the beginning**
    insertAtBeginning(&personList, personElement1);
    insertAtBeginning(&personList, personElement2);
	
	// 2. Insert elements at the end
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 3. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 4. **Insert before a node**
    insertBeforeNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 5. **Insert after a node**
    insertAfterNode(personList-&gt;next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 6. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 7. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 8. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 9. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 10. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 11. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 12. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 13. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 14. **Sort the linked list**
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 15. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 16. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic circular singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for circular singly linked list template
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (!head) {
        head = newNode;
        newNode-&gt;next = head;
    } else {
        Node&lt;T&gt;* temp = head;
        while (temp-&gt;next != head)
            temp = temp-&gt;next;
        temp-&gt;next = newNode;
        newNode-&gt;next = head;
        head = newNode;
    }
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (!head) {
        head = newNode;
        newNode-&gt;next = head;
    } else {
        Node&lt;T&gt;* temp = head;
        while (temp-&gt;next != head)
            temp = temp-&gt;next;
        temp-&gt;next = newNode;
        newNode-&gt;next = head;
    }
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }
    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    if (head == nextNode) { // Insert before head
        Node&lt;T&gt;* temp = head;
        while (temp-&gt;next != head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    do {
        if (temp-&gt;next == nextNode) {
            newNode-&gt;next = temp-&gt;next;
            temp-&gt;next = newNode;
            return;
        }
        temp = temp-&gt;next;
    } while (temp != head);
    
    cout &lt;&lt; "The given next node is not found in the list\n";
    delete newNode;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        if (head == nullptr) {
            head = newNode;
            newNode-&gt;next = head; // Circular link
        } else {
            Node&lt;T&gt;* temp = head;
            while (temp-&gt;next != head) {
                temp = temp-&gt;next;
            }
            temp-&gt;next = newNode;
            newNode-&gt;next = head;
            head = newNode;
        }
        return;
    }
    
    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1; i++) {
        temp = temp-&gt;next;
        if (temp == head) {
            cout &lt;&lt; "Position out of bounds\n";
            delete newNode;
            return;
        }
    }
    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (!head) return;
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node&lt;T&gt;* temp = head;
    Node&lt;T&gt;* last = head;
    while (last-&gt;next != head)
        last = last-&gt;next;
    head = head-&gt;next;
    last-&gt;next = head;
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (!head) return;
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next-&gt;next != head)
        temp = temp-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = head;
}

// Delete at a specific position in a Circular Singly Linked List
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    Node&lt;T&gt;* temp = head;
    // If deleting the head node
    if (position == 0) {
        // If the list has only one node
        if (head-&gt;next == head) {
            delete head;
            head = nullptr;
            return;
        }

        // Find the last node to update its next pointer
        Node&lt;T&gt;* last = head;
        while (last-&gt;next != head) {
            last = last-&gt;next;
        }

        last-&gt;next = head-&gt;next;
        Node&lt;T&gt;* toDelete = head;
        head = head-&gt;next;
        delete toDelete;
        return;
    }

    // Traverse to the node before the one to be deleted
    Node&lt;T&gt;* prev = head;
    for (int i = 0; i &lt; position - 1 && prev-&gt;next != head; i++) {
        prev = prev-&gt;next;
    }

    if (prev-&gt;next == head) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    // Delete the node
    Node&lt;T&gt;* toDelete = prev-&gt;next;
    prev-&gt;next = toDelete-&gt;next;
    delete toDelete;
}

// check if the list is empty
template &lt;typename T&gt;
bool isEmpty(Node&lt;T&gt;* head) {
    return head == nullptr;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    if (!head) {
        cout &lt;&lt; "NULL\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    do {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    } while (temp != head);
    cout &lt;&lt; "(head)\n";
}

// Search for an element in a Circular Singly Linked List
template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    if (head == nullptr) return false; // Empty list

    Node&lt;T&gt;* temp = head;
    do {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    } while (temp != head); // Loop until we reach the head again

    return false;
}

// Reverse a Circular Singly Linked List
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    if (head == nullptr || head-&gt;next == head) return; // Empty list or single node

    Node&lt;T&gt;* prev = nullptr;
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* next = nullptr;
    Node&lt;T&gt;* tail = head; // Keep track of the last node

    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != head);

    // Fix head and tail pointers
    head-&gt;next = prev;  // Make original head's next point to new head
    head = prev;        // Update head to new first element
}

// Get the size of a Circular Singly Linked List
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    if (head == nullptr) return 0; // Empty list

    int count = 0;
    Node&lt;T&gt;* temp = head;
    do {
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    return count;
}

// Get an element at a specific index in a Circular Singly Linked List
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    if (head == nullptr) throw out_of_range("Index out of range");

    Node&lt;T&gt;* temp = head;
    int count = 0;

    do {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    throw out_of_range("Index out of range");
}


// Set an element at a specific index in a Circular Singly Linked List
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    if (head == nullptr) throw out_of_range("Index out of range");

    Node&lt;T&gt;* temp = head;
    int count = 0;

    do {
        if (count == index) {
            temp-&gt;data = element;
            return;
        }
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    throw out_of_range("Index out of range");
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    if (!head) return;
    Node&lt;T&gt;* temp = head;
    Node&lt;T&gt;* nextNode;
    do {
        nextNode = temp-&gt;next;
        delete temp;
        temp = nextNode;
    } while (temp != head);
    head = nullptr;
}

// Function to merge two sorted circular linked lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    Node&lt;T&gt;* tempHead = nullptr, *last = nullptr;
    Node&lt;T&gt;* first1 = head1, *first2 = head2;

    //std::cout &lt;&lt; "Starting merge...\n";

    if (head1 == nullptr) {
        //std::cout &lt;&lt; "First list is empty. Returning a new node from the second list.\n";
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(head2-&gt;data);
        headRef = newNode;
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = nullptr;
        return;
    }
    if (head2 == nullptr) {
        //std::cout &lt;&lt; "Second list is empty. Returning a new node from the first list.\n";
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(head1-&gt;data);
        headRef = newNode;
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = nullptr;
        return;
    }

    //std::cout &lt;&lt; "Both lists are non-empty. Merging...\n";

    do {
        Node&lt;T&gt;* newNode;
        if (head1 && (head2 == nullptr || head1-&gt;data &lt;= head2-&gt;data)) {
            //std::cout &lt;&lt; "Adding node from List 1: " &lt;&lt; (head1-&gt;data).toString() &lt;&lt; "\n";
            newNode = new Node&lt;T&gt;(head1-&gt;data);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                head1 = nullptr;
            }
        } else {
            //std::cout &lt;&lt; "Adding node from List 2: " &lt;&lt; (head2-&gt;data).toString() &lt;&lt; "\n";
            newNode = new Node&lt;T&gt;(head2-&gt;data);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                head2 = nullptr;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            //std::cout &lt;&lt; "New head node created: " &lt;&lt; (tempHead-&gt;data).toString() &lt;&lt; "\n";
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != nullptr || head2 != nullptr);

    // Make the list circular
    last-&gt;next = tempHead;
    headRef = tempHead;
    //std::cout &lt;&lt; "Merge completed. Circular list created with head: " &lt;&lt; (headRef-&gt;data).toString() &lt;&lt; "\n";
}
// Function to find the middle of a circular linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;*& mid, Node&lt;T&gt;* head) {
    if (head == nullptr || head-&gt;next == head) {  // Check if list is empty or contains one node
        mid = head;
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    mid = slow;  // Assign the slow pointer to mid (middle node)
}

template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    // If the list is empty or contains a single node, no need to sort
    if (headRef == nullptr || headRef-&gt;next == headRef) {
        //std::cout &lt;&lt; "List is empty or has only one node. No sorting needed.\n";
        return;
    }

    //std::cout &lt;&lt; "Starting sort...\n";

    Node&lt;T&gt;* head = headRef;
    Node&lt;T&gt;* mid = nullptr;

    // Find the middle node
    //std::cout &lt;&lt; "Finding middle node...\n";
    middle(mid, head);
    //std::cout &lt;&lt; "Middle node found: " &lt;&lt; mid-&gt;data.toString() &lt;&lt; "\n";

    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = head;  // Break circularity for first half
    Node&lt;T&gt;* secondHalf = nextToMid;

    // Find the last node of the second half
    Node&lt;T&gt;* last = secondHalf;
    while (last-&gt;next != head)
        last = last-&gt;next;

    last-&gt;next = nextToMid;  // Break circularity for second half

    //std::cout &lt;&lt; "Splitting list into two halves:\n";
    //std::cout &lt;&lt; "First half starts with: " &lt;&lt; head-&gt;data.toString() &lt;&lt; "\n";
    //std::cout &lt;&lt; "Second half starts with: " &lt;&lt; secondHalf-&gt;data.toString() &lt;&lt; "\n";

    // Sort both halves recursively
    //std::cout &lt;&lt; "Sorting first half...\n";
    sort(head);
    //std::cout &lt;&lt; "Sorting second half...\n";
    sort(nextToMid);

    // Merge the sorted halves
    //std::cout &lt;&lt; "Merging sorted halves...\n";
    merge(headRef, head, nextToMid);
    //std::cout &lt;&lt; "Merge completed. Circular list created with head: " &lt;&lt; headRef-&gt;data.toString() &lt;&lt; "\n";
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;=(const Person& other) const {
        if (name == other.name) {
            return age &lt;= other.age;  // If names are the same, sort by age
        }
        return name &lt;= other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};
// Main function for testing
int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // 1. Insert elements at the beginning
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
	
	// 2. Insert elements at the beginning
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // 3. Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // 4. Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    Person george("George", 32);
    insertBeforeNode(head, secondNode, george);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // 5. Insert after a node (insert after the second node)
    Person joyce("Joyce", 27);
    insertAfterNode(secondNode, joyce);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // 6. Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // 7. Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);
	
	// 8. Delete at a specific position
	deleteAtPosition(head, 2);
    cout &lt;&lt; "\nList after deleting node at position 2:\n";
    traverse(head);
	
    // 9. Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // 10. Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;
	
	// 11. Check if list is empty
	if (isEmpty(head)) {
		cout &lt;&lt; "The linked list is empty.\n";
	} else {
		cout &lt;&lt; "The linked list is not empty.\n";
	}

    // 12. Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 13. Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 14. Sort the linked list (by name first, then by age)
    sort(head);
    cout &lt;&lt; "\nList after sorting:" &lt;&lt; endl;
    traverse(head);
	
	// 15. Reverse the list
    reverse(head);

    cout &lt;&lt; "\nReversed List:" &lt;&lt; endl;
    traverse(head);


	// 16. Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
	
    return 0;
}</code></pre>
		
		<p>Here is the Generic circular singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class CircularLinkedList&lt;T&gt; {

    // Node structure for circular singly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; tail, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (tail == null) {
            newNode.next = newNode; // Point to itself
            return newNode;
        }
        newNode.next = tail.next;
        tail.next = newNode;
        return tail;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; tail, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (tail == null) {
            newNode.next = newNode;
            return newNode;
        }
        newNode.next = tail.next;
        tail.next = newNode;
        return newNode; // New tail
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; tail, T data, int position) {
        if (tail == null || position == 0) {
            return insertAtBeginning(tail, data);
        }

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        Node&lt;T&gt; temp = tail.next;
        for (int i = 0; i &lt; position - 1 && temp != tail; i++) {
            temp = temp.next;
        }
        newNode.next = temp.next;
        temp.next = newNode;

        if (temp == tail) {
            return newNode; // New tail
        }
        return tail;
    }

    // Function to insert a new node after a given previous node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; prevNode, T data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be NULL.");
            return;
        }

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }

    // Function to insert a new node before a given next node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; nextNode, T data) {
        if (head == null) {
            System.out.println("The list cannot be empty.");
            return null;
        }

        if (nextNode == null) {
            System.out.println("The given next node cannot be NULL.");
            return head;
        }

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);

        // If inserting before the head, update head reference
        if (head == nextNode) {
            Node&lt;T&gt; temp = head;
            while (temp.next != head) {
                temp = temp.next;
            }

            temp.next = newNode;  // Update last node's next pointer
            newNode.next = head;
            return newNode; // New node becomes the head
        }

        // Find the node just before nextNode
        Node&lt;T&gt; temp = head;
        while (temp.next != head && temp.next != nextNode) {
            temp = temp.next;
        }

        if (temp.next != nextNode) {
            System.out.println("The given next node is not found in the list.");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; tail) {
        if (tail == null) {
            System.out.println("List is empty");
            return null;
        }
        if (tail.next == tail) { // Single node case
            return null;
        }
        tail.next = tail.next.next;
        return tail;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; tail) {
        if (tail == null) {
            System.out.println("List is empty");
            return null;
        }
        if (tail.next == tail) { // Single node case
            return null;
        }

        Node&lt;T&gt; temp = tail.next;
        while (temp.next != tail) {
            temp = temp.next;
        }
        temp.next = tail.next; // Skip tail node
        return temp; // New tail
    }
    
    // Delete at a specific position (Generic)
    public static &lt;T&gt; Node&lt;T&gt; deleteAtPosition(Node&lt;T&gt; tail, int position) {
        if (tail == null) {
            return null;
        }
    
        if (position == 0) {
            return deleteAtBeginning(tail);
        }
    
        Node&lt;T&gt; temp = tail.next;
        for (int i = 0; i &lt; position - 1 && temp.next != tail.next; i++) {
            temp = temp.next;
        }
    
        if (temp.next == tail.next) {
            return tail; // Position out of bounds, return unchanged tail
        }
    
        // If deleting the tail node, update tail reference
        if (temp.next == tail) {
            tail = temp;
        }
    
        temp.next = temp.next.next;
        return tail;
    }
    
    // Function to get an element at a specific index (0-based)
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
    
        Node&lt;T&gt; temp = head;
        int count = 0;
    
        do {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        } while (temp != head);
    
        System.out.println("Index out of range");
        return null;
    }
    
    // Function to set an element at a specific index (0-based)
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }
    
        Node&lt;T&gt; temp = head;
        int count = 0;
    
        do {
            if (count == index) {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        } while (temp != head);
    
        System.out.println("Index out of range");
    }
	
	// check if the list is empty
	public static &lt;T&gt; boolean isEmpty(Node&lt;T&gt; head) {
		return head == null;
	}
	
    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; tail, T key) {
        if (tail == null) return false;

        Node&lt;T&gt; temp = tail.next;
        do {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        } while (temp != tail.next);

        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; tail) {
        if (tail == null) return 0;

        int count = 0;
        Node&lt;T&gt; temp = tail.next;
        do {
            count++;
            temp = temp.next;
        } while (temp != tail.next);
        return count;
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; tail) {
        if (tail == null) {
            System.out.println("NULL");
            return;
        }

        Node&lt;T&gt; temp = tail.next;
        do {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        } while (temp != tail.next);
        System.out.println("(back to head)");
    }
    
	public static &lt;T&gt; Node&lt;T&gt; reverse(Node&lt;T&gt; head) {
		if (head == null || head.next == head)
			return head; // Empty list or single node remains the same

		Node&lt;T&gt; prev = null;
		Node&lt;T&gt; current = head;
		Node&lt;T&gt; next = null;
		Node&lt;T&gt; last = head;

		// Find the last node
		while (last.next != head)
			last = last.next;

		do {
			next = current.next; // Store next node
			current.next = prev; // Reverse pointer
			prev = current;      // Move prev forward
			current = next;      // Move current forward
		} while (current != head);

		// Adjust pointers to maintain circular nature
		head.next = prev;  // Original head now points to the new last node
		last.next = prev;  // Last node points to the new head
		return prev;       // New head of the reversed circular list
	}

    // Function to find the middle node of a circular linked list
	public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
		if (head == null || head.next == head) return head;

		Node&lt;T&gt; slow = head, fast = head;
		while (fast.next != head && fast.next.next != head) {
			fast = fast.next.next;
			slow = slow.next;
		}
		return slow;
	}

	// Function to sort a circular linked list using merge sort (requires Comparable&lt;T&gt;)
	public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
		if (head == null || head.next == head) return head;

		Node&lt;T&gt; mid = middle(head);
		Node&lt;T&gt; secondHalf = mid.next;
		mid.next = head;  // Break circularity for the first half

		// Find last node of second half and break circularity
		Node&lt;T&gt; temp = secondHalf;
		while (temp.next != head) temp = temp.next;
		temp.next = secondHalf;

		// Recursively sort both halves
		Node&lt;T&gt; firstSorted = sort(head);
		Node&lt;T&gt; secondSorted = sort(secondHalf);

		// Merge both halves
		return merge(firstSorted, secondSorted);
	}

	public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; head1, Node&lt;T&gt; head2) {
		if (head1 == null) return head2;
		if (head2 == null) return head1;

		Node&lt;T&gt; tempHead = null, last = null;
		Node&lt;T&gt; first1 = head1, first2 = head2;

		do {
			Node&lt;T&gt; newNode;
			if (head1 != null && (head2 == null || head1.data.compareTo(head2.data) &lt;= 0)) {
				newNode = new Node&lt;&gt;(head1.data);
				head1 = head1.next;
				if (head1 == first1) head1 = null;
			} else {
				newNode = new Node&lt;&gt;(head2.data);
				head2 = head2.next;
				if (head2 == first2) head2 = null;
			}

			if (tempHead == null) {
				tempHead = newNode;
			} else {
				last.next = newNode;
			}
			last = newNode;
		} while (head1 != null || head2 != null);

		// Make the list circular
		last.next = tempHead;
		return tempHead;
	}


	// Clear the list
	public static &lt;T&gt; Node&lt;T&gt; clear(Node&lt;T&gt; head) {
		if (head == null) return null;  // If the list is already empty, return null
    
		Node&lt;T&gt; current = head;
		do {
			Node&lt;T&gt; next = current.next; // Save reference to next node
			current.next = null;            // Break the link to the next node
			current = next;                   // Move to the next node
		} while (current != head);            // Stop when we've looped back to the head
		
		return null;  // Return null to indicate the list is empty
	}

    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }

        @Override
        public int compareTo(Person other) {
            // Compare by name first, then by age
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }

    // Main method for testing
    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
		
		// 2. Insert elements at the end
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // 5. Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // 6. Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // 7. Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);
		
		// 8. Delete at a specific position
		head = deleteAtPosition(head, 2);
		System.out.println("\nList after deleting node at position 2:");
		traverse(head);

        // 9. Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // 10. Get size of the list
        System.out.println("\nSize of the list: " + size(head));
		
		// 11. Check if list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}


        // 12. Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 13. Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 14. Sort the linked list (by name first, then by age)
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
		
		// 15. Reverse the list
		head = reverse(head);

		System.out.println("\nList after reversing:");
		traverse(head);

		// 16. Clear the list
        head = clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
}</code></pre>
		
		<p>Here is the Generic circular singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;

    public Node(T data)
    {
        Data = data;
        Next = null;
    }
}

class Program
{
    // Insert at beginning
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null)
        {
            newNode.Next = newNode; // Point to itself in a circular list
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        while (temp.Next != head) temp = temp.Next; // Find the last node
        temp.Next = newNode;
        newNode.Next = head;
        return newNode;
    }

    // Insert at end
    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null)
        {
            newNode.Next = newNode;
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        while (temp.Next != head) temp = temp.Next; // Find the last node
        temp.Next = newNode;
        newNode.Next = head;
        return head;
    }

    // Insert at position
    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        if (position == 0) return InsertAtBeginning(head, data);
        
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp.Next != head; i++) temp = temp.Next;

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }
    
    // Insert before node
    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null || targetNode == null) return head;
        if (head == targetNode) return InsertAtBeginning(head, data);
    
        Node&lt;T&gt; temp = head;
        do
        {
            if (temp.Next == targetNode)
            {
                Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = targetNode };
                temp.Next = newNode;
                return head;
            }
            temp = temp.Next;
        } while (temp != head);
    
        return head; // Target node not found
    }
    
    // Insert after node
    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
    
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next };
        node.Next = newNode;
    }


    // Delete at beginning
    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        if (head.Next == head) return null; // Only one node

        Node&lt;T&gt; temp = head;
        while (temp.Next != head) temp = temp.Next; // Find last node
        temp.Next = head.Next;
        return head.Next;
    }

    // Delete at end
    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        if (head.Next == head) return null; // Only one node

        Node&lt;T&gt; temp = head;
        while (temp.Next.Next != head) temp = temp.Next; // Find second last node
        temp.Next = head;
        return head;
    }
    
    // Delete at a specific position
    static Node&lt;T&gt; DeleteAtPosition&lt;T&gt;(Node&lt;T&gt; head, int position)
    {
        if (head == null) return null; // Empty list
    
        Node&lt;T&gt; temp = head, prev = null;
    
        // If deleting the head node
        if (position == 0)
        {
            if (head.Next == head) // Only one node in the list
                return null;
    
            // Find the last node to update its `Next` pointer
            while (temp.Next != head)
                temp = temp.Next;
    
            temp.Next = head.Next; // Point last node to the new head
            return head.Next;
        }
    
        // Traverse to the position
        int count = 0;
        do
        {
            prev = temp;
            temp = temp.Next;
            count++;
        } while (temp != head && count &lt; position);
    
        // If position is out of bounds
        if (count != position)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }
    
        prev.Next = temp.Next; // Remove node by updating pointer
        return head;
    }

    // Search for an element in a circular singly linked list
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        if (head == null) return false; // Handle case of empty list
    
        Node&lt;T&gt; temp = head;
        do
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        return false;
    }
    
    // Get size of a circular singly linked list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return 0; // Handle case of empty list
    
        int count = 0;
        Node&lt;T&gt; temp = head;
        do
        {
            count++;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        return count;
    }

    // Check if the circular singly linked list is empty
    static bool IsEmpty&lt;T&gt;(Node&lt;T&gt; head)
    {
        return head == null;
    }

    // Get an element at a specific index in a circular singly linked list
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        if (head == null) throw new Exception("List is empty");
    
        int count = 0;
        Node&lt;T&gt; temp = head;
        do
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        throw new Exception("Index out of range");
    }
    
    // Set (modify) an element at a specific index in a circular singly linked list
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        if (head == null) throw new Exception("List is empty");
    
        int count = 0;
        Node&lt;T&gt; temp = head;
        do
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        throw new Exception("Index out of range");
    }


    // Traverse the circular list
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty.");
            return;
        }

        Node&lt;T&gt; temp = head;
        do
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        } while (temp != head);

        Console.WriteLine("(back to head)");
    }
    
    // Reverse a circular singly linked list
    static Node&lt;T&gt; Reverse&lt;T&gt;(Node&lt;T&gt; head)
	{
		if (head == null || head.Next == head) return head; // Handle empty or single-element list
		
		Node&lt;T&gt; prev = null;
		Node&lt;T&gt; current = head;
		Node&lt;T&gt; next = null;
		
		// Traverse the list and reverse the links
		do
		{
			next = current.Next; // Save the next node
			current.Next = prev; // Reverse the current node's link
			prev = current;      // Move prev to the current node
			current = next;      // Move to the next node
		} while (current != head); // Stop when we've looped back to the head
		
		// After the loop, `prev` is pointing to the new head
		head = prev; // Update the head reference to the new first node
		
		// The last node's `Next` should point to the new head
		current.Next = head; // The previous tail should point to the new head
		
		return head; // Return the new head
	}
    
    public static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; head1, Node&lt;T&gt; head2) where T : IComparable&lt;T&gt;
    {
        if (head1 == null) return head2;
        if (head2 == null) return head1;
    
        Node&lt;T&gt; dummy = new Node&lt;T&gt;(default(T)); // Temporary dummy node
        Node&lt;T&gt; tail = dummy;
        Node&lt;T&gt; first1 = head1, first2 = head2;
    
        do
        {
            Node&lt;T&gt; newNode;
            if (head1 != null && (head2 == null || head1.Data.CompareTo(head2.Data) &lt;= 0))
            {
                newNode = new Node&lt;T&gt;(head1.Data);
                head1 = head1.Next;
                if (head1 == first1) head1 = null;
            }
            else
            {
                newNode = new Node&lt;T&gt;(head2.Data);
                head2 = head2.Next;
                if (head2 == first2) head2 = null;
            }
    
            tail.Next = newNode;
            tail = newNode;
    
        } while (head1 != null || head2 != null);
    
        // Make the merged list circular
        tail.Next = dummy.Next;
        return dummy.Next;
    }

    
    public static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == head) return head;
    
        Node&lt;T&gt; slow = head, fast = head;
        while (fast.Next != head && fast.Next.Next != head)
        {
            fast = fast.Next.Next;
            slow = slow.Next;
        }
        return slow;
    }

    public static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == head) return head;
    
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; secondHalf = mid.Next;
        mid.Next = head;  // Break circularity for the first half
    
        // Find last node of second half and break circularity
        Node&lt;T&gt; temp = secondHalf;
        while (temp.Next != head) temp = temp.Next;
        temp.Next = secondHalf;
    
        // Recursively sort both halves
        Node&lt;T&gt; firstSorted = Sort(head);
        Node&lt;T&gt; secondSorted = Sort(secondHalf);
    
        // Merge both halves
        return Merge(firstSorted, secondSorted);
    }
    
    public static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;  // If the list is already empty, return null
        
        Node&lt;T&gt; current = head;
        do
        {
            Node&lt;T&gt; next = current.Next; // Save reference to next node
            current.Next = null;         // Break the link to the next node
            current = next;              // Move to the next node
        } while (current != head);       // Stop when we've looped back to the head
        
        return null;  // Return null to indicate the list is empty
    }



    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);
        
        // Initialize the linked list
        Node&lt;Person&gt; head = null;
        
        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        
        // 2. Insert elements at the end
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);
        
        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);
        
        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);
        
        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        Person jack = new Person("Jack", 29);
        head = InsertBeforeNode(head, secondNode, jack);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);
        
        // 5. Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);
        
        // 6. Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);
        
        // 7. Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);
        
        // 8. Delete node at position 2
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("\nList after deleting at position 2:");
        Traverse(head);

        // 9. Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));
        
        // 10. Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));
        
        // 11. Check if the list is empty
        if (IsEmpty(head))
        {
            Console.WriteLine("The list is empty.");
        }
        else
        {
            Console.WriteLine("The list is not empty.");
        }
    
        // 12. Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 13. Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 14. Sort the linked list (by name first, then by age)
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // 15. Reverse the list
        head = Reverse(head);
    
        Console.WriteLine("\nList after reversing:");
        Traverse(head);
    
        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);

    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";
}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/circular-singly-linked-list" class="tag">circular singly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/02/04/circular-singly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/02/04/circular-singly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/02/04/circular-singly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2025" /><category term="month-02" /><category term="day-04" /><category term="data structure" /><category term="linked list" /><category term="circular singly linked list" /><summary type="html"><![CDATA[A Circular Singly Linked List is a type of linked list where each node points to the next node, and the last node links back to the first, forming a continuous loop. This structure allows efficient insertion, deletion, and traversal without a null reference at the end. It is commonly used in scenarios requiring continuous iteration over elements. Learn about its implementation, operations, and properties in this detailed guide.]]></summary></entry><entry xml:lang="en"><title type="html">Doubly Linked List Data Structure</title><link href="https://hemimorphite.github.io/zh/2025/02/01/doubly-linked-list-data-structure/" rel="alternate" type="text/html" title="Doubly Linked List Data Structure" /><published>2025-02-01T14:20:00+00:00</published><updated>2025-02-01T14:20:00+00:00</updated><id>https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Doubly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published February 01, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/doublylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Doubly Linked List</h3>
		
        <p>A doubly linked list is a linear data structure consisting of a sequence of elements, called nodes, where each node points to both its previous and next nodes in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations.</p>
		
		<p>Each node in a doubly linked list contains three fields:</p>
		
        <ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence.</li>
			<li><b>Previous Pointer</b>: A reference (or pointer) to the previous node in the sequence.</li>
		</ul>

        <p>The doubly linked list forms a linear collection of elements where each node points to both its successor and its predecessor. The first node, known as the head, has a <code>NULL</code> reference for its previous pointer, indicating the beginning of the list. The last node has a <code>NULL</code> reference for its next pointer, marking the end of the list.</p>
		
		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. If the list is empty, the head points to <code>NULL</code>.</p>
		
		<p>Insertions and deletions of nodes, particularly at the beginning, middle, or end of the list, are more efficient compared to arrays since you do not need to shift elements. However, managing both the previous and next pointers requires extra attention.</p>
		
		<p>The nodes in a doubly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next and previous nodes through pointers, and they can be located anywhere in memory.</p>
		
		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>
		
		<p>Each node in a doubly linked list requires extra memory for the two pointers (next and previous references), which slightly increases memory usage compared to arrays or singly linked lists.</p>
		
		<p>Here's a visual representation of a doubly linked list:</p>
		
<pre><code class="language-bash hljs">
               HEAD
		        ↓
NULL ← [Prev | Data | Next] ⇄ [Prev | Data | Next] ⇄ [Prev | Data | Next] → NULL
</code></pre>
		
		<p>In the above representation:</p>
		
		<ul>
			<li>The <code>Head</code> points to the first node of the list, providing quick access to the start of the list.</li>
			<li>Each node contains <code>Data</code>, a <code>Next</code> pointer to the next node, and a <code>Previous</code> pointer to the previous node.</li>
			<li>The last node in the list has its <code>Next</code> pointer set to <code>NULL</code>, indicating the end of the list. Its <code>Prev</code> pointer points to the previous node.</li>
			<li>The <code>Prev</code> pointer of the first node is <code>NULL</code>, as there is no node before it.</li>
		</ul>
		
		<p>A simple doubly linked list with three nodes could look like this:</p>
		
<pre><code class="language-bash hljs">
               HEAD
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
		
		<p>In the above example:</p>
		
		<ul>
			<li>The head points to the first node containing the data <code>10</code>. The <code>Prev</code> pointer of this node is <code>NULL</code>, as there is no node before it.</li>
			<li>The second node contains the data <code>20</code>. Its <code>Prev</code> pointer points to the first node, and its <code>Next</code> pointer points to the third node.</li>
			<li>The third node contains the data <code>30</code>. Its <code>Prev</code> pointer points to the second node, and its <code>Next</code> pointer is <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common doubly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-plaintext hljs">
											   HEAD
												↓
								NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
								</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
<pre><code class="language-plaintext hljs">
              HEAD
               ↓
NULL ← [Prev | 5 | Next] ⇄ [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a doubly linked list is \(O(1)\) (constant time). If the list is empty, the following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>, as there is no node after it.</li>
							<li>Set the <code>prev</code> pointer of the new node to <code>NULL</code>, as it will become the first node.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						If the list is not empty, the following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list).</li>
							<li>If the list is not empty, set the <code>prev</code> pointer of the current head node to point to the new node.</li>
							<li>Set the <code>prev</code> pointer of the new node to <code>NULL</code>, as it will become the first node.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a doubly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] ⇄ [Prev | 40 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning.  The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node <code>NULL</code>, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer is <code>NULL</code>).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 25 | Next]  ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node after a node in a doubly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the given node.</li>
							<li>Update its <code>prev</code> pointer of the node following the given node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node after a node in a doubly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertBeforeNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately before a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> before the node containing <code>20</code>. After calling <code>insertBeforeNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 25 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node before a node in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the preceding node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>prev</code> pointer of the target node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node before a node in a doubly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a doubly linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 35 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the preceding node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>prev</code> pointer of the target node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a doubly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a new node at a specified position in a linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Set the head pointer to the next node</li>
							<li>Set the <code>prev</code> pointer of the new head node (if it exists) to <code>NULL</code>.</li>
							<li>Deallocate the memory for the old head node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a doubly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] → NULL
</code></pre>							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the second-to-last node.</li>
							<li>Set the <code>next</code> pointer of the second-to-last node to <code>null</code>.</li>
							<li>Deallocate the memory for the old last node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position to delete is 0, it means the head node should be removed. If the specified position is out of bounds, and a message is printed.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to remove a node at position <code>3</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
							<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the node before the target position.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the node after the target node (if it exists).</li>
							<li>Update the <code>prev</code> pointer of the node after the target node (if it exists) to point to the preceding node.</li>
							<li>Deallocate the memory for the removed node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a doubly linked list and perform an action, such as printing the node's value.</li>
					<li><b>Time complexity</b>: The time complexity of traverse function in a linked list is \(O(n)\) (linear time). The function iterates through each node in the linked list exactly once, from the head to the end (<code>NULL</code>). Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of traverse function in a linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>
			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 30 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 10 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of reverse function in a doubly linked list is \(O(n)\) (linear time). The function traverses each node of the linked list exactly once. Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of reverse function in a doubly linked list is \(O(1)\) (constant space).  The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes. This amount of space does not depend on the size of the linked list.</li>
				</ul>
			</li>
			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a doubly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of search function in a linked list is \(O(n)\) (linear time).The search function traverses the linked list node by node. In the worst case, it may need to look at every node in the list to find the key (or determine that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of search function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of extra space to store variables, such as pointers for the current node. The space required does not depend on the size of the list because the function does not use any additional data structures or dynamic memory allocations for the search process.</li>
				</ul>
			</li>
			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a doubly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of size function in a linked list is \(O(n)\) (linear time). The function traverses the entire linked list to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of size function in a doubly linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a doubly linked list at a specified index. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of get function in a doubly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of get function in a doubly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a doubly linked list. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of set function in a doubly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of set function in a doubly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a doubly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of <code>isEmpty</code> function in a doubly linked list is \(O(1)\) (constant time). The <code>isEmpty</code> function checks whether the head pointer of the linked list is <code>NULL</code>. This operation is performed in constant time since it only involves a simple comparison, regardless of the size of the linked list.</li>
					<li><b>Space complexity</b>: The space complexity of <code>isEmpty</code> function in a doubly linked list is \(O(1)\) (constant space). The function uses a fixed amount of space to store the result of the comparison (typically a boolean value), regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted linked lists into a single sorted linked list. </li>
					<li><b>Time complexity</b>: The time complexity of merge function in a doubly linked list is \(O(n + m)\) (linear time). The reason for this complexity is that each node from both lists is visited exactly once. In the worst case, the function will traverse both lists entirely, performing comparisons and linking nodes. Where \(n\) is the number of nodes in the first linked list and \(m\) is the number of nodes in the second linked list.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a doubly linked list is \(O(n + m)\) (linear space) due to the call stack storing recursive calls. In the worst case, the maximum depth of recursion will be equal to the total number of nodes in both lists combined, leading to \(n + m\) recursive calls.</li>
				</ul>
			</li>
			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a doubly linked list, in a specific order (typically ascending or descending).</li>
					<li><b>Time complexity</b>: The time complexity of sort function in a doubly linked list, when using merge sort is \(O(n \log n)\) (linearithmic time) because the algorithm consistently divides the list into halves and requires a linear amount of time \(O(n)\) to merge those halves back together. The logarithmic factor \(\log n\) comes from the number of times the list can be divided in half (depth of recursion).</li>
					<li><b>Space complexity</b>: The space complexity of sort function in a doubly linked list, specifically Merge Sort, is \(O(n)\) (linear space) because it requires additional space for the temporary arrays or linked lists used during the merge process. When merging two halves, the algorithm needs space to hold the merged elements before copying them back to the original array or linked list.</li>
				</ul>
			</li>
			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from the list and free up the memory they occupy, effectively making the list empty.</li>
					<li><b>Time complexity</b>: The time complexity of clear function in a doubly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, freeing its memory. Since it processes all nodes in the list, the time complexity is proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of clear function in a doubly linked list is \(O(1)\) (constant space). The function only requires a fixed amount of extra memory for the iteration, typically for a pointer to traverse the list. No additional memory structures are needed, regardless of the size of the linked list.</li>
				</ul>
			</li>
        </ul>
		
		<h3 class="post-subtitle">Non-Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// defines a structure to represent a node in a doubly linked list
typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef != NULL) {
        (*headRef)-&gt;prev = newNode;
    }
    newNode-&gt;next = *headRef;
    *headRef = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }

    Node* newNode = createNode(data);
    newNode-&gt;next = prevNode-&gt;next;
    newNode-&gt;prev = prevNode;
    if (prevNode-&gt;next != NULL) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(data);
    if (*headRef == nextNode) {
        newNode-&gt;next = *headRef;
        (*headRef)-&gt;prev = newNode;
        *headRef = newNode;
        return;
    }

    newNode-&gt;next = nextNode;
    newNode-&gt;prev = nextNode-&gt;prev;
    if (nextNode-&gt;prev != NULL) {
        nextNode-&gt;prev-&gt;next = newNode;
    }
    nextNode-&gt;prev = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    if (position == 0) {
        newNode-&gt;next = *headRef;
        if (*headRef != NULL) {
            (*headRef)-&gt;prev = newNode;
        }
        *headRef = newNode;
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    newNode-&gt;prev = temp;
    if (temp-&gt;next != NULL) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = *headRef;
    *headRef = (*headRef)-&gt;next;
    if (*headRef != NULL) {
        (*headRef)-&gt;prev = NULL;
    }
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;prev != NULL) {
        temp-&gt;prev-&gt;next = NULL;
    } else {
        *headRef = NULL; // List has only one element
    }
    free(temp);
}

// Function to delete a node at a specific position (0-based index)
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    if (position == 0) {
        *headRef = temp-&gt;next;
        if (*headRef != NULL) {
            (*headRef)-&gt;prev = NULL;
        }
        free(temp);
        return;
    }

    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next;
    if (nodeToDelete-&gt;next != NULL) {
        nodeToDelete-&gt;next-&gt;prev = temp;
    }
    free(nodeToDelete);
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d &lt;-&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp-&gt;data == key)
            return 1; // Key found
        temp = temp-&gt;next;
    }
    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** headRef) {
    Node *temp = NULL;
    Node* current = *headRef;
    
    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    if (temp != NULL) {
        *headRef = temp-&gt;prev;
    }
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    while (current != NULL) {
        if (count == index) {
            current-&gt;data = newValue;
            return;
        }
        count++;
        current = current-&gt;next;
    }

    printf("Index out of range\n");
}

// Function to clear the entire linked list and free memory
void clear(Node** headRef) {
    Node* current = *headRef;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *headRef = NULL;
}

// Function to get the middle of the linked list
void middle(Node** mid, Node* head) {
    if (head == NULL) return;
    
    Node* slow = head;
    Node* fast = head-&gt;next;
    
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    
    *mid = slow; // Update the pointer to the middle node
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    // Log the current state of head1 and head2
    //printf("Merging: head1 data = %d, head2 data = %d\n", 
    //       head1 ? head1-&gt;data : -1, head2 ? head2-&gt;data : -1);

    // Base case when one of the lists is empty
    if (head1 == NULL) {
        // Log when head1 is NULL and remaining head2 is being added
        if (head2 != NULL) {
            printf("head1 is NULL, adding remaining head2 data: %d\n", head2-&gt;data);
            Node* newNode = createNode(head2-&gt;data); // Create a new node
            *headRef = newNode;
            merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        }
        return;
    }
    if (head2 == NULL) {
        // Log when head2 is NULL and remaining head1 is being added
        if (head1 != NULL) {
            //printf("head2 is NULL, adding remaining head1 data: %d\n", head1-&gt;data);
            Node* newNode = createNode(head1-&gt;data); // Create a new node
            *headRef = newNode;
            merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        }
        return;
    }

    // Compare the data of head1 and head2 and merge accordingly
    if (head1-&gt;data &lt;= head2-&gt;data) {
        // Log when adding data from head1
        //printf("Adding head1 data: %d\n", head1-&gt;data);
        Node* newNode = createNode(head1-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    } else {
        // Log when adding data from head2
        //printf("Adding head2 data: %d\n", head2-&gt;data);
        Node* newNode = createNode(head2-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    }

    // Log when merge is completed for this recursion
    //printf("Merge step completed. headRef data = %d\n", (*headRef)-&gt;data);
}


// Function to sort the doubly linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;
	
	// Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != nullptr) {
        nextToMid-&gt;prev = nullptr;  // Set 'prev' of the second half to null
    }
	
    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}

// Main function to test the doubly linked list operations
int main() {
    Node* list = NULL;
	
	// 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);
	
	// 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);
	
	// 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);
	
	// 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);
	
	// 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);
	
	// 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);
	
	// 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);
	
	// 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}
	
	// 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }
	
	// 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);
	
	// 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));
	
	// 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }
	
	// 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);
    
	// 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node* next;
    Node* prev;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr), prev(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    newNode-&gt;next = head;
    if (head != nullptr) {
        head-&gt;prev = newNode;
    }
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == nullptr) {
        std::cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    if (prevNode-&gt;next != nullptr) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
    newNode-&gt;prev = prevNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        std::cout &lt;&lt; "The list cannot be empty" &lt;&lt; std::endl;
        return;
    }

    if (nextNode == nullptr) {
        std::cout &lt;&lt; "The given next node cannot be NULL" &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // If the nextNode is the head node, handle the insertion at the beginning
    if (headRef == nextNode) {
        newNode-&gt;next = headRef;
        headRef-&gt;prev = newNode;
        headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = headRef;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        std::cout &lt;&lt; "The given next node is not found in the list" &lt;&lt; std::endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);
    if (position == 0) {
        newNode-&gt;next = head;
        if (head != nullptr) {
            head-&gt;prev = newNode;
        }
        head = newNode;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}


// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    head = head-&gt;next;
    if (head != nullptr) {
        head-&gt;prev = nullptr;
    }
    delete temp;
}


// Delete at the end
void deleteAtEnd(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    temp-&gt;prev-&gt;next = nullptr;
    delete temp;
}


// Delete at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node* temp = head;
        head = head-&gt;next;
        if (head != nullptr) {
            head-&gt;prev = nullptr;
        }
        delete temp;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    if (nextNode != nullptr) {
        nextNode-&gt;prev = temp;
    }
    temp-&gt;next = nextNode;
}

// Function to reverse a doubly linked list
void reverse(Node*& head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;

    while (current != nullptr) {
        // Swap next and prev for the current node
        next = current-&gt;next;
        current-&gt;next = prev;
        current-&gt;prev = next;

        // Move to the next node in the original list
        prev = current;
        current = next;
    }

    // Update head to the last node (new head after reverse)
    head = prev;
}

// Function to get the size of a doubly linked list
int size(Node* head) {
    int count = 0;
    Node* temp = head;

    while (temp != nullptr) {
        count++;  // Increment count for each node
        temp = temp-&gt;next;  // Move to the next node
    }

    return count;
}

// Function to access an element at a specific index (0-based) in a doubly linked list
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;

    // Traverse the list to find the node at the specified index
    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data;  // Return the data at the index
        count++;
        temp = temp-&gt;next;  // Move to the next node
    }

    return -1;  // Index out of range
}

// Function to set an element at a specific index (0-based) in a doubly linked list
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;  // Move to the next node
    }

    cout &lt;&lt; "Index out of range\n";  // Handle case where index exceeds list length
}

// Search for an element in a doubly linked list
bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;  // Element found
        temp = temp-&gt;next;
    }
    return false;  // Element not found
}

// Traverse the list (forward)
void traverse(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " &lt;-&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Find the middle of the list
void middle(Node*& mid, Node* head) {
    if (head == nullptr) {
        mid = nullptr;
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != nullptr && fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    mid = slow;
}

// Merge two sorted lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    if (head1-&gt;data &lt;= head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    }
}

// Sort the list using merge sort
void sort(Node*& head) {
    if (head == nullptr || head-&gt;next == nullptr)
        return;

    Node* mid = nullptr;
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;
	
	// Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != nullptr) {
        nextToMid->prev = nullptr;  // Set 'prev' of the second half to null
    }
	
    Node* left = head;
    Node* right = nextToMid;

    sort(left);
    sort(right);

    merge(head, left, right);
}

// Clear the list
void clear(Node*& head) {
    Node* current = head;
    while (current != nullptr) {
        Node* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

int main() {
    Node* list = nullptr;  // Initialize an empty doubly linked list

    // Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // Insert element at position 2
    insertAtPosition(list, 4, 2);

    cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // Delete the first node
    deleteAtBeginning(list);

    cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // Delete the last node
    deleteAtEnd(list);

    cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // Delete the node at position 2
    deleteAtPosition(list, 2);

    cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);

    // Search for an element
    int key = 6;
    if (search(list, key)) {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; endl;
    }

    // Reverse the list
    reverse(list);

    cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // Get the size of the list
    cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; endl;

    // Clear the list
    clear(list);

    cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class DoublyLinkedList {

    // Node structure for doubly linked list
    static class Node {
        int data;
        Node next;
        Node prev;

        // Constructor to create a new node
        Node(int data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        if (head != null) {
            head.prev = newNode;
        }
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        Node newNode = new Node(data);
        if (position == 0) {
            if (head != null) {
                head.prev = newNode;
            }
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null) {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }
	
	// Insert after a given node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be null");
            return;
        }
        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
        newNode.prev = prevNode;
        if (newNode.next != null) {
            newNode.next.prev = newNode;
        }
    }

    // Insert before a given node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (nextNode == null) {
            System.out.println("The given next node cannot be null");
            return head;
        }
        Node newNode = new Node(data);
        newNode.prev = nextNode.prev;
        newNode.next = nextNode;
        nextNode.prev = newNode;
        if (newNode.prev != null) {
            newNode.prev.next = newNode;
        } else {
            head = newNode;
        }
        return head;
    }
	
    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        Node newHead = head.next;
        if (newHead != null) {
            newHead.prev = null;
        }
        return newHead;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.prev.next = null;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return deleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        Node toDelete = temp.next;
        temp.next = toDelete.next;
        if (toDelete.next != null) {
            toDelete.next.prev = temp;
        }
        return head;
    }

    // Get element at a specific index
    public static int get(Node head, int index) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
        return -1; // Return -1 if the index is out of range
    }

    // Set element at a specific index
    public static void set(Node head, int index, int newValue) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
    }

    // Traverse the list
    public static void traverse(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Search for an element
    public static boolean search(Node head, int key) {
        Node temp = head;
        while (temp != null) {
            if (temp.data == key) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node reverse(Node head) {
        Node temp = null;
        Node current = head;

        // Swap next and prev pointers for each node
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        // After the loop, temp will be the last node, so update head
        if (temp != null) {
            head = temp.prev;
        }

        return head;
    }

    // Merge two sorted lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.data &lt;= head2.data) {
            head1.next = merge(head1.next, head2);
            if (head1.next != null) {
                head1.next.prev = head1;
            }
            return head1;
        } else {
            head2.next = merge(head1, head2.next);
            if (head2.next != null) {
                head2.next.prev = head2;
            }
            return head2;
        }
    }

    // Find the middle of the list
    public static Node middle(Node head) {
        if (head == null) return null;

        Node slow = head;
        Node fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == null) return head;

        // Find the middle node
        Node mid = middle(head);
        Node nextToMid = mid.next;
        mid.next = null;
		
		// Properly break the list into two halves
		if (nextToMid != null) {
			nextToMid.prev = null;  // Set the 'prev' pointer of the second half to null
		}
	
        // Recursively split and sort both halves
        Node left = sort(head);
        Node right = sort(nextToMid);

        // Merge the sorted halves
        return merge(left, right);
    }

    // Get the size of the list
    public static int size(Node head) {
        int count = 0;
        Node temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node clear(Node head) {
        return null;
    }

    // Main method to test
    public static void main(String[] args) {
        Node head = null;

        // Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		    
		    Node second = new Node(20);
		    insertAfterNode(second, 25);
        System.out.println("List after inserting 25 after 20:");
        traverse(head);
        
        head = insertBeforeNode(head, second, 15);
        System.out.println("List after inserting 15 before 20:");
        traverse(head);
		
        // Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);

        // Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // Get the size of the list
        System.out.println("Size of the list: " + size(head));

        // Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
        traverse(head);

        // Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

public class DoublyLinkedList
{
    // Node structure for doubly linked list
    public class Node
    {
        public int data;
        public Node next;
        public Node prev;

        // Constructor to create a new node
        public Node(int data)
        {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data);
        newNode.next = head;
        if (head != null)
        {
            head.prev = newNode;
        }
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null)
        {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.next = head;
            if (head != null)
            {
                head.prev = newNode;
            }
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null)
        {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }
	
	// Insert a new node after a given node
	public static Node InsertAfterNode(Node head, int target, int data)
	{
		Node temp = head;
		while (temp != null && temp.data != target)
		{
			temp = temp.next;
		}

		if (temp == null)
		{
			Console.WriteLine($"Node with value {target} not found.");
			return head;
		}

		Node newNode = new Node(data);
		newNode.next = temp.next;
		newNode.prev = temp;
		
		if (temp.next != null)
		{
			temp.next.prev = newNode;
		}
		temp.next = newNode;
		
		return head;
	}

	// Insert a new node before a given node
	public static Node InsertBeforeNode(Node head, int target, int data)
	{
		if (head == null)
		{
			Console.WriteLine("List is empty.");
			return null;
		}

		if (head.data == target)
		{
			return InsertAtBeginning(head, data);
		}

		Node temp = head;
		while (temp != null && temp.data != target)
		{
			temp = temp.next;
		}

		if (temp == null)
		{
			Console.WriteLine($"Node with value {target} not found.");
			return head;
		}

		Node newNode = new Node(data);
		newNode.next = temp;
		newNode.prev = temp.prev;

		if (temp.prev != null)
		{
			temp.prev.next = newNode;
		}
		temp.prev = newNode;

		return head;
	}

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        if (head.next != null)
        {
            head.next.prev = null;
        }
        return head.next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.next != null)
        {
            temp = temp.next;
        }
        if (temp.prev != null)
        {
            temp.prev.next = null;
        }
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return DeleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.next;
        }

        if (temp == null || temp.next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        if (temp.next.next != null)
        {
            temp.next.next.prev = temp;
        }
        temp.next = temp.next.next;
        return head;
    }

    // Get element at a specific index
    public static int Get(Node head, int index)
    {
        int count = 0;
        Node temp = head;

        while (temp != null)
        {
            if (count == index)
            {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        Console.WriteLine("Index out of range");
        return -1;
    }

    // Set element at a specific index
    public static void Set(Node head, int index, int newValue)
    {
        int count = 0;
        Node temp = head;

        while (temp != null)
        {
            if (count == index)
            {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        }

        Console.WriteLine("Index out of range");
    }

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, int key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.data == key)
            {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node temp = null;
        Node current = head;

        while (current != null)
        {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        if (temp != null)
        {
            head = temp.prev;
        }
        return head;
    }

    // Find the middle of the list
	public static Node Middle(Node head)
	{
		if (head == null) return null;

		Node slow = head, fast = head;
		
		while (fast.next != null && fast.next.next != null)
		{
			slow = slow.next;
			fast = fast.next.next;
		}

		return slow;
	}

	// Sort the list using merge sort
	public static Node Sort(Node head)
	{
		if (head == null || head.next == null) return head;

		Node mid = Middle(head);
		Node nextToMid = mid.next;

		// Properly break the list into two halves
		mid.next = null;
		if (nextToMid != null) 
		{
			nextToMid.prev = null;
		}

		Node left = Sort(head);
		Node right = Sort(nextToMid);

		return Merge(left, right);
	}

	// Merge two sorted lists
	public static Node Merge(Node head1, Node head2)
	{
		if (head1 == null) return head2;
		if (head2 == null) return head1;

		if (head1.data &lt;= head2.data)
		{
			head1.next = Merge(head1.next, head2);
			if (head1.next != null)
			{
				head1.next.prev = head1;
			}
			return head1;
		}
		else
		{
			head2.next = Merge(head1, head2.next);
			if (head2.next != null)
			{
				head2.next.prev = head2;
			}
			return head2;
		}
	}

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node Clear(Node head)
    {
        return null;
    }

    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning: ");
        Traverse(head);

        // Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end: ");
        Traverse(head);

        // Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2: ");
        Traverse(head);
		
  		head = InsertAfterNode(head, 4, 8);
  		Console.WriteLine("List after inserting 8 after 4:");
  		Traverse(head);
  
  		head = InsertBeforeNode(head, 4, 6);
  		Console.WriteLine("List after inserting 6 before 4:");
  		Traverse(head);

        // Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning: ");
        Traverse(head);

        // Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end: ");
        Traverse(head);

        // Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2: ");
        Traverse(head);

        // Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine("Element " + key + " found in the list");
        }
        else
        {
            Console.WriteLine("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing: ");
        Traverse(head);

        // Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));

        // Sort the list
        head = Sort(head);

        Console.WriteLine("Sorted list:");
        Traverse(head);

        // Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing: ");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-cpp hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for doubly linked list
typedef struct Node {
    StackElement element;     // Stack element data
    struct Node* next;        // Pointer to the next node
    struct Node* prev;        // Pointer to the previous node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    newNode-&gt;next = *head;
    (*head)-&gt;prev = newNode;
    *head = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a node after a given previous node
void insertAfterNode(Node** head, Node* prevNode, StackElement element) {
    if (*head == NULL || prevNode == NULL) {
        printf("The list cannot be empty or the previous node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(element);
    newNode-&gt;next = prevNode-&gt;next;
    if (prevNode-&gt;next != NULL) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
    newNode-&gt;prev = prevNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    if (*head == NULL || nextNode == NULL) {
        printf("The list cannot be empty or the next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(element);
    newNode-&gt;prev = nextNode-&gt;prev;
    if (nextNode-&gt;prev != NULL) {
        nextNode-&gt;prev-&gt;next = newNode;
    }
    nextNode-&gt;prev = newNode;
    newNode-&gt;next = nextNode;

    // If nextNode is the head node
    if (newNode-&gt;prev == NULL) {
        *head = newNode;
    }
}

// Function to insert a node at a specific position
void insertAtPosition(Node** head, StackElement element, int position) {
    if (position == 0) {
        insertAtBeginning(head, element);
        return;
    }

    Node* newNode = createNode(element);
    Node* temp = *head;
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != NULL) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *head;
    *head = (*head)-&gt;next;
    if (*head != NULL) {
        (*head)-&gt;prev = NULL;
    }
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;prev != NULL) {
        temp-&gt;prev-&gt;next = NULL;
    } else {
        *head = NULL; // Only one element in the list
    }
    free(temp);
}

// Function to delete a node at a given position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    if (position == 0) {
        *head = temp-&gt;next;
        if (*head != NULL) {
            (*head)-&gt;prev = NULL;
        }
        free(temp);
        return;
    }

    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    if (nextNode != NULL) {
        nextNode-&gt;prev = temp;
    }
    free(temp-&gt;next);
    temp-&gt;next = nextNode;
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%s &lt;-&gt; ", temp-&gt;element.toString);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to reverse the linked list
void reverse(Node** head) {
    Node* temp = NULL;
    Node* current = *head;
    
    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }
    
    if (temp != NULL) {
        *head = temp-&gt;prev;
    }
}


// Function to clear the entire linked list and free memory
void clear(Node** head) {
    Node* current = *head;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *head = NULL;
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    Node* temp = head;

    while (temp != NULL) {
        // Call toString to get the string representation of the data in the current node
        char* currentStr = temp-&gt;element.toString;
        char* keyStr = keyElement.toString;

        // Compare the string representations of the current node's data and the key element's data
        if (strcmp(currentStr, keyStr) == 0) {
            return 1; // Key found
        }

        temp = temp-&gt;next;
    }

    return 0; // Key not found
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;element;
        count++;
        temp = temp-&gt;next;
    }
    StackElement emptyElement = {NULL, ""};
    return emptyElement; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head2 = head2-&gt;next;
        }
        return;
    }
    if (head2 == NULL) {
        while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head1 = head1-&gt;next;
        }
        return;
    }

    if (strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt; 0) {
        Node* newNode = createNode(head1-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    } else {
        Node* newNode = createNode(head2-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    }
}

// Function to get the middle of the linked list
void middle(Node* head, Node** middle) {
    if (head == NULL) {
        *middle = NULL; // Set middle node to NULL if list is empty
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    *middle = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(head, &mid);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;

    // Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != NULL) {
        nextToMid-&gt;prev = NULL;  // Set 'prev' of the second half to null
    }

    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


struct Car {
    char model[20];
    int year;
};

struct Person {
    char name[20];
    int age;
};

// Main function to test the doubly linked list operations
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements into the list**
    insertAtBeginning(&personList, personElement1);
    insertAtEnd(&personList, personElement2);
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 2. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 3. **Insert before a node**
    insertBeforeNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 4. **Insert after a node**
    insertAfterNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 5. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 6. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 7. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 8. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 9. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 10. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 11. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 12. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 13. **Sort the linked list**
    printf("\nList before sorting:\n");
    traverse(personList);
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 14. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 15. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for doubly linked list
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;
    Node* prev; // Add prev pointer

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr), prev(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    newNode-&gt;next = head;
    if (head != nullptr) {
        head-&gt;prev = newNode;
    }
    head = newNode;
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    newNode-&gt;prev = prevNode;

    if (prevNode-&gt;next != nullptr) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    
    if (head == nextNode) {
        newNode-&gt;next = head;
        head-&gt;prev = newNode;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "The given next node is not found in the list\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        newNode-&gt;next = head;
        if (head != nullptr) {
            head-&gt;prev = newNode;
        }
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    head = head-&gt;next;
    if (head != nullptr) {
        head-&gt;prev = nullptr;
    }
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    temp-&gt;prev-&gt;next = nullptr;
    delete temp;
}

// Delete at a specific position
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node&lt;T&gt;* temp = head;
        head = head-&gt;next;
        if (head != nullptr) {
            head-&gt;prev = nullptr;
        }
        delete temp;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node&lt;T&gt;* nextNode = temp-&gt;next-&gt;next;
    if (nextNode != nullptr) {
        nextNode-&gt;prev = temp;
    }
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " &lt;-&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Reverse the list
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* temp = nullptr;

    // Reverse the next and prev pointers of all nodes
    while (current != nullptr) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    // Reset the head to the last node
    if (temp != nullptr) {
        head = temp-&gt;prev;
    }
}

// Get the size of the list
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    int count = 0;
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Function to access an element at a specific index (0-based)
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    int count = 0;
    Node&lt;T&gt;* temp = head;

    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data; // Return the data at the index
        count++;
        temp = temp-&gt;next;
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to set an element at a specific index (0-based)
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    Node&lt;T&gt;* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = element; // Update the node's value
            return;                  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;     // Move to the next node
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    Node&lt;T&gt;* temp = head;
    
    // Traverse the list in the forward direction
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;  // Element found
        temp = temp-&gt;next;
    }

    // If not found, return false
    return false;
}

// Function to merge two lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    // Merge the two lists based on data comparison (using &lt; operator)
    if (head1-&gt;data &lt; head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
        // Update the prev pointer of the next node in the merged list
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
        // Update the prev pointer of the next node in the merged list
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    }
}

// Function to find the middle node of the linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;* head, Node&lt;T&gt;*& mid) {
    if (head == nullptr) {
        mid = nullptr; // Set middle node to nullptr if the list is empty
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head-&gt;next;

    while (fast != nullptr) {
        fast = fast-&gt;next;
        if (fast != nullptr) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    mid = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    if (headRef == nullptr || headRef-&gt;next == nullptr)
        return;

    Node&lt;T&gt;* mid = nullptr;
    middle(headRef, mid);
    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;
    
    // Properly handle the 'prev' pointers for the second half of the list
    if (nextToMid != nullptr) {
        nextToMid-&gt;prev = nullptr;  // Set 'prev' of the second half to null
    }
    
    // Sort the two halves
    sort(headRef);
    sort(nextToMid);

    // Merge the sorted halves
    Node&lt;T&gt;* mergedHead = nullptr;
    merge(mergedHead, headRef, nextToMid);
    headRef = mergedHead; // Update the original head reference
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    while (current != nullptr) {
        Node&lt;T&gt;* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;(const Person& other) const {
        if (name == other.name) {
            return age &lt; other.age;  // If names are the same, sort by age
        }
        return name &lt; other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};

int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // Insert elements into the list
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    insertBeforeNode(head, secondNode, eve);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // Insert after a node (insert after the second node)
    insertAfterNode(secondNode, eve);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);

    // Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;

    // Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // Sort the linked list (by name first, then by age)
    cout &lt;&lt; "\nList before sorting:\n";
    traverse(head);
    sort(head);
    cout &lt;&lt; "\nList after sorting:\n";
    traverse(head);
    
    // Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
    
    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class LinkedList&lt;T&gt; {

    // Node structure for doubly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;
        Node&lt;T&gt; prev;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head != null) {
            head.prev = newNode;
        }
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head == null) {
            return newNode;
        }
        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; head, T data, int position) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (position == 0) {
            newNode.next = head;
            if (head != null) {
                head.prev = newNode;
            }
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null) {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert before a specific node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data) {
        if (head == null) return null;

        if (head == targetNode) {
            return insertAtBeginning(head, data);
        }

        Node&lt;T&gt; temp = head;
        while (temp != null && temp.next != targetNode) {
            temp = temp.next;
        }

        if (temp != null) {
            Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
            newNode.next = temp.next;
            if (temp.next != null) {
                temp.next.prev = newNode;
            }
            temp.next = newNode;
            newNode.prev = temp;
        }
        return head;
    }

    // Insert after a specific node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; node, T data) {
        if (node == null) return;

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = node.next;
        if (node.next != null) {
            node.next.prev = newNode;
        }
        node.next = newNode;
        newNode.prev = node;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        if (head.next != null) {
            head.next.prev = null;
        }
        return head.next;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.prev.next = null;
        return head;
    }

    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; head, T key) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; head) {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Get element at a specific index
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Set element at a specific index
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            System.out.print(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Sort the list
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
        if (head == null || head.next == null) return head;

        Node&lt;T&gt; mid = middle(head);
        Node&lt;T&gt; nextToMid = mid.next;
        mid.next = null;
        
        // Properly handle the 'prev' pointers for a doubly linked list
        if (nextToMid != null) {
            nextToMid.prev = null;  // Set 'prev' of the second half to null
        }
    
        Node&lt;T&gt; left = sort(head);
        Node&lt;T&gt; right = sort(nextToMid);

        return merge(left, right);
    }

    // Merge two sorted lists
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; left, Node&lt;T&gt; right) {
        if (left == null) return right;
        if (right == null) return left;

        if (left.data.compareTo(right.data) &lt;= 0) {
            left.next = merge(left.next, right);
            if (left.next != null) {
                left.next.prev = left;
            }
            return left;
        } else {
            right.next = merge(left, right.next);
            if (right.next != null) {
                right.next.prev = right;
            }
            return right;
        }
    }

    // Find the middle of the list
    public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
        if (head == null) return null;

        Node&lt;T&gt; slow = head;
        Node&lt;T&gt; fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Clear the list by removing all nodes
    public static &lt;T&gt; void clear(Node&lt;T&gt; head) {
        Node&lt;T&gt; current = head;
        while (current != null) {
            Node&lt;T&gt; next = current.next;
            current.next = null;  // Disconnect the current node
            current.prev = null;  // Disconnect the previous node
            current = next;       // Move to the next node
        }
    }
    
    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }

        @Override
        public int compareTo(Person other) {
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }

    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // Insert elements into the list
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);

        // Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // Get size of the list
        System.out.println("\nSize of the list: " + size(head));

        // Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // Sort the linked list (by name first, then by age)
        System.out.println("\nList before sorting:");
        traverse(head);
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
        
        // Clear the list
        clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;
    public Node&lt;T&gt; Prev;

    public Node(T data)
    {
        Data = data;
        Next = null;
        Prev = null;
    }
}

class Program
{
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = head };
        if (head != null) head.Prev = newNode;
        return newNode;
    }

    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null) return newNode;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Next = newNode;
        newNode.Prev = temp;
        return head;
    }

    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (position == 0) { newNode.Next = head; if (head != null) head.Prev = newNode; return newNode; }
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) temp = temp.Next;
        if (temp == null) { Console.WriteLine("Position out of bounds"); return head; }
        newNode.Next = temp.Next;
        newNode.Prev = temp;
        if (temp.Next != null) temp.Next.Prev = newNode;
        temp.Next = newNode;
        return head;
    }

    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null) return null;
        if (head == targetNode) return InsertAtBeginning(head, data);
        Node&lt;T&gt; temp = head;
        while (temp != null && temp.Next != targetNode) temp = temp.Next;
        if (temp != null)
        {
            Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = temp.Next, Prev = temp };
            if (temp.Next != null) temp.Next.Prev = newNode;
            temp.Next = newNode;
        }
        return head;
    }

    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next, Prev = node };
        if (node.Next != null) node.Next.Prev = newNode;
        node.Next = newNode;
    }

    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        head = head.Next;
        if (head != null) head.Prev = null;
        return head;
    }

    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null || head.Next == null) return null;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Prev.Next = null;
        return head;
    }

    // Search for an element
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        }
        return false;
    }

    // Get size of the list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Traverse the list and print elements
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " &lt;-&gt; ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Get an element at specific index
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Set (modify) an element at specific index
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }
    
    // Sort the linked list (Merge Sort)
    static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == null) return head;

        // Split the list into two halves
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; nextToMid = mid.Next;
        mid.Next = null;
        if (nextToMid != null) nextToMid.Prev = null;

        // Recursively sort both halves
        Node&lt;T&gt; left = Sort(head);
        Node&lt;T&gt; right = Sort(nextToMid);

        // Merge the sorted halves
        return Merge(left, right);
    }

    // Merge two sorted lists
    static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; left, Node&lt;T&gt; right) where T : IComparable&lt;T&gt;
    {
        if (left == null) return right;
        if (right == null) return left;

        if (left.Data.CompareTo(right.Data) &lt;= 0)
        {
            left.Next = Merge(left.Next, right);
            if (left.Next != null) left.Next.Prev = left;
            return left;
        }
        else
        {
            right.Next = Merge(left, right.Next);
            if (right.Next != null) right.Next.Prev = right;
            return right;
        }
    }

    // Find the middle node of the list
    static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        Node&lt;T&gt; slow = head, fast = head.Next;

        while (fast != null && fast.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }
    
    // Clear the linked list
    static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        head = null;
        return head;
    }
    
    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // Insert elements into the list
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);

        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);

        // Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);

        // Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        head = InsertBeforeNode(head, secondNode, eve);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);

        // Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);

        // Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);

        // Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);

        // Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));

        // Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

        // Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

        // Sort the linked list (by name first, then by age)
        Console.WriteLine("\nList before sorting:");
        Traverse(head);
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);
    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";

}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/doubly-linked-list" class="tag">doubly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/02/01/doubly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/02/01/doubly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/02/01/doubly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2025" /><category term="month-02" /><category term="day-01" /><category term="data structure" /><category term="linked list" /><category term="doubly linked list" /><summary type="html"><![CDATA[A Doubly Linked List is a dynamic data structure where each node contains data and two pointers, one pointing to the next node and another to the previous node. This bidirectional linking enables efficient insertion, deletion, and traversal in both directions, making it ideal for applications like undo or redo functionality, navigation systems, and memory management. Unlike singly linked lists, doubly linked lists allow easier manipulation of elements at both ends but require extra memory for storing an additional pointer. Learn how doubly linked lists work, their advantages, and implementations in this comprehensive guide.]]></summary></entry><entry xml:lang="en"><title type="html">Solving Recurrences - Master Theorem</title><link href="https://hemimorphite.github.io/zh/2025/01/14/master-theorem/" rel="alternate" type="text/html" title="Solving Recurrences - Master Theorem" /><published>2025-01-14T10:20:00+00:00</published><updated>2025-01-14T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2025/01/14/master-theorem</id><content type="html" xml:base="https://hemimorphite.github.io/2025/01/14/master-theorem/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Solving Recurrences - Master Theorem</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published January 14, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/mastertheorem.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h4 class="post-subtitle">Divide and Conquer Recurrence Relations</h4>
		
		<p>Suppose that a recursive algorithm divides a problem of size \(n\) into a subproblems. Assume each subproblem is of size \(\frac{n}{b}\). Suppose \(f(n)\) extra operations are needed in the conquer step. Then \(T(n)\) represents the number of operations to solve a problem of size \(n\) satisfies the following recurrence relation:</p>
		
		<div class="equation-container">
		\[ T(n) = aT(\frac{n}{b}) + f(n), \]
        </div>
		
		<p>where:</p>
		
		<ul>
			<li>\(T(n)\) represents the total time complexity for solving a problem of size \(n\).</li>
			<li>\(a\) represents number of subproblems the problem is divided into.</li>
			<li>\(\frac{n}{b}\) represents the size of each subproblem.</li>
			<li>\(f(n)\) represents the cost of dividing the problem into subproblems and combining their solutions. This is the work done outside of the recursive calls.</li>
		</ul>
		
		<p>The recursion \(T(n) = aT(\frac{n}{b}) + f(n)\) stops:</p>
		
		<ul>
			<li>When \(T(n)\) is applied to the base case (usually \(n=1\)). The recursion halts at this point because the problem size can no longer be divided further.</li>
			<li>At the depth of the recursion tree, which corresponds to the number of times the problem size \(n\) can be divided by \(b\) until reaching the base case.</li>
		</ul>
		
		<h4 class="post-subtitle">The Asymptotic Growth of Geometric Series</h4>
		
		<div class="lemma">
			<p>Let \(r\) be a positive constant. Then,</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{n} r^{i} = 
			\begin{cases} 
			\Theta(r^{n}), & \text{if } r \gt 1 \\
			\Theta(n), & \text{if } r = 1 \\
			\Theta(1), & \text{if } r \lt 1 
			\end{cases}, \]
			</div>
			
			<p>That is, if geometric progression is increasing, then the series grows as its last (and largest) term. If it is constant, then it grows as the number of terms. Finally, if it is decreasing, it is bounded by a constant.</p>
		</div>
		
		<div class="proof">
			<p>The sum of the first \(n+1\) terms of a geometric sequence is given by the formula:</p>
			
			<div class="equation-container">
			\[ S(n) = \frac{r^{n+1} - 1}{r - 1} \]
			</div>
			
			<p>where the first term is \(1\), and the common ratio is \(r\).</p>
			
			<p>Finding the lower bound or upper bound of a function involves identifying the dominant term because the dominant term determines the function's growth rate as the input size increases significantly.</p>
			
			<p><b>Case \(r \gt 1\):</b></p>
			
			<p>Each term in the geometric series grows exponentially, starting from \(r^{0}\) (i.e., \(1\)) and ending with \(r^{n}\). As the series progresses, the terms increase rapidly, with the last term dominating the others. As a result, the sum is always greater \(r^{n}\) for \(n \gt 0\). This implies that the sum is bounded below by \(r^{n}\).</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \gt r^{n} \]
			</div>
			
			<p>As \(n\) becomes large, the term \(r^{n+1}\) in the numerator of the geometric series formula dominates the constant \(1\), and the sum of the geometric series can be approximately expressed as \(\frac{r^{n+1}}{r - 1}\).</p>
			
			<p>Thus, the upper bound of the geometric series sum is:</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \lt \frac{r}{r - 1}r^{n} \]
			</div>
			
			<p>We have found both the lower bound and the upper bound for the sum of the geometric series. Thus, we have:</p>
			
			<div class="equation-container">
			\[ r^{n} \lt \frac{r^{n+1} - 1}{r - 1} \lt \frac{r}{r - 1}r^{n} \]
			</div>
			
			<p>Therefore, the asymptotic behavior of \(S(n)\) is:</p>
			
			<div class="equation-container">
			\[ S(n) = \Theta(r^{n}) \]
			</div>
			
			<p><b>Case \(r = 1\):</b></p>
			
			<p>For \(r=1\), the sum of the series is simply the number of terms. The sum grows linearly with \(n\), and we can express the sum as:</p>
			
			<div class="equation-container">
			\[ S(n) = n + 1. \]
			</div>
			
			<p>Therefore, the asymptotic behavior of \(S(n)\) is:</p>
			
			<div class="equation-container">
			\[ S(n) = \Theta(n) \]
			</div>
			
			
			<p><b>Case \(r \lt 1\):</b></p>
			
			<p>Each term in the geometric series decays exponentially, starting from \(r^{0}\) (i.e., \(1\)) and ending with \(r^{n}\). As the series progresses, the terms decrease rapidly, with the first term dominating the others. As a result, the sum is always greater \(1\) for \(n \gt 0\). This implies that the sum is bounded above by \(1\).</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \gt 1 \]
			</div>
			
			<p>As \(n\) becomes large, the term \(r^{n+1}\) in the numerator of the geometric series formula approaches \(0\), and the sum of the geometric series can be approximately expressed as \(\frac{1}{1-r}\).</p>
			
			<p>Thus, the upper bound of the geometric series sum is:</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \lt \frac{1}{1-r} \]
			</div>
			
			<p>We have found both the lower bound and the upper bound for the sum of the geometric series. Thus, we have:</p>
			
			<div class="equation-container">
			\[ 1 \lt \frac{r^{n+1} - 1}{r - 1} \lt \frac{1}{1-r} \]
			</div>
			
			<p>Therefore, the asymptotic behavior of \(S(n)\) is:</p>
			
			<div class="equation-container">
			\[ S(n) = \Theta(1) \]
			</div>
		</div>
		
		<h4 class="post-subtitle">Simplified Version of Master Theorem</h4>
		
		<p>The simplified version of master theorem is a formula for analyzing the asymptotic behavior of divide-and-conquer recurrences of the form:</p>
		
		<div class="equation-container">
		\[ T(n) = aT(\frac{n}{b}) + cn^{k}, \]
		</div>
		
		<p>where \(a \geq 1\) and \(b \geq 2\) are integer constants, \(c \geq 0\), and \(k \geq 0\) are real constants. \(a\), \(b\), \(c\) and \(d\) do not depend on \(n\). The first term, \(a \cdot T(\frac{n}{b})\), represents the time required for the a recursive calls, each to an input of size \(\frac{n}{b}\); and the second term, \(c \cdot n^{k}\), represents the time required to divide up the input into a pieces of size \(\frac{n}{b}\) each and to combine the results of the recursive calls into the result of the main call.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT(\frac{n}{b}) + cn^{k}, & \text{if } n \gt 1
			\end{cases}, \]
			</div>
			
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(n^{k}), & \text{if } a \lt b^{k} \\
			\Theta(n^{k} \log_{b}(n)), & \text{if } a = b^{k} \\
			\Theta(n^{\log_{b}(a)}), & \text{if } a \gt b^{k}
			\end{cases}. \]
			</div>
			
			<p>Analogus results hold for the \(O\) and \(\Omega\) notations.</p>
		</div>
		
		<div class="proof">
			<p>Consider the tree of recursive calls made by the algorithm:</p>
			
			<ul>
				<li>At level \(0\) (the root), we have one call for input of size \(n\). The time needed by this call, exclusive of the time needed by the calls it makes (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(cn^{k}\) — the second term in the definition of the recurrence.</li>
				<li>At level \(1\) we have the calls made by the call at level \(0\): there are a such calls (one for each subproblem), each working on an input of size \(\frac{n}{b}\). The time needed by each of these calls, exclusive of the time needed by the calls it makes, is \(c\left(\frac{n}{b}\right)^{k}\), so the total time needed by these a calls is \(ac\left(\frac{n}{b}\right)^{k}\).</li>
				<li>At level \(2\) we have the calls made by the calls at level \(1\): there are \(a^{2}\) such calls, each working on an input of size \(\frac{n}{b^{2}}\). Reasoning as before, the total time needed by these \(a^{2}\) calls is \(a^{2}c\left(\frac{n}{b^{2}}\right)^{k}\).</li>
				<li>In general, at level \(i\), we have \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time needed for these calls is \(a^{i}c\left(\frac{n}{b^{i}}\right)^{k}\).</li>
				<li>This continues for every integer \(i = 0, 1, 2, \dots, \log_{b}(n)\). For \(i = \log_{b}(n)\), the input size is \(1\), and we have reached the base case of the recursion. At the base case, the problem is small enough that no further division is needed, and the solution can be solve directly.</li>
			</ul>
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			T(n) &= cn^{k} + aT(\frac{n}{b}) \\
			&= cn^{k} + a(c\left(\frac{n}{b}\right)^{k} + aT(\frac{n}{b^2})) = cn^{k} + ca\left(\frac{n}{b}\right)^{k} + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= cn^{k} + ca\left(\frac{n}{b}\right)^{k} + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} + \dots + a^{\log_{b}(n)}T(1) \\
			&= cn^{k} + ca\left(\frac{n}{b}\right)^{k} + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} + \dots + n^{\log_{b}(a)}T(1) \\
			&= \sum_{i=0}^{\log_{b}(n)-1} ca^{i}\left(\frac{n}{b^{i}}\right)^{k} + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i}. \]
			</div>
			
			<p>The series is a geometric series with ratio \(r=\frac{a}{b^{k}}\). Its growth rate depends on whether \(a\) is smaller, equal, or larger than \(b^{k}\). Consider these three cases.</p>
			
			<p><b>Case 1: \(a \gt b^{k}\)</b>. Given the condition \(a \gt b^{k}\), which implies that the ratio \(r=\frac{a}{b^{k}} \gt 1\).</p>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} r^{i}\) is a geometric series with the common ratio \(r=\frac{a}{b^{k}} \gt 1\) which grows exponentially, and can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
            \[
			\begin{aligned}  
			r^{\log_{b}(n)-1} &\leq& \sum_{i=0}^{\log_{b}(n)-1} r^{i} &\lt& \frac{r^{\log_{b}(n)}}{r-1} \\
			\left(\frac{a}{b^{k}}\right)^{\log_{b}(n)-1} &\leq& \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt& \frac{\left(\frac{a}{b^{k}}\right)^{\log_{b}(n)}}{\frac{a}{b^{k}}-1} \\
			\frac{a^{\log_{b}(n)-1}}{\left(b^{\log_{b}(n)-1}\right)^{k}} &\leq& \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt& \frac{\frac{a^{\log_{b}(n)}}{\left(b^{\log_{b}(n)}\right)^{k}}}{\frac{a}{b^{k}}-1} \\
			\frac{n^{\log_{b}(a)}}{n^{k}}\frac{b^{k}}{a} &\leq& \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt& \frac{n^{\log_{b}(a)}}{n^{k}}\frac{1}{\frac{a}{b^{k}}-1}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}  
			cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\leq& g(n) &\leq& cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \\
			cn^{k}\frac{n^{\log_{b}(a)}}{n^{k}}\frac{b^{k}}{a} &\leq& g(n) &\lt& cn^{k}\frac{n^{\log_{b}(a)}}{n^{k}}\frac{1}{\frac{a}{b^{k}}-1} \\
			c\frac{b^{k}}{a}n^{\log_{b}(a)} &\leq& g(n) &\lt& c\frac{1}{\frac{a}{b^{k}}-1}n^{\log_{b}(a)}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both below and above by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}  
			T(n) &= O\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 2: \(a = b^{k}\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=1\).</p>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} 1\) is an arithmetic series where every term in the series is constant. The sum is simply the constant value multiplied by the number of terms.</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{\log_{b}(n)-1} 1 = \log_{b}(n). \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned} 
			cn^{k}\sum_{i=0}^{\log_{b}(n)-1} 1 &\leq& g(n) &\leq& cn^{k}\sum_{i=0}^{\log_{b}(n)-1} 1 \\
			cn^{k}\log_{b}(n) &\leq& g(n) &\leq& cn^{k}\log_{b}(n). 
			\end{aligned}
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both below and above by constant multiples of \(n^{k}\log_{b}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\log_{b}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= O\left(n^{k}\log_{b}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\log_{b}(n)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\log_{b}(n)\right). \]
			</div>
			
			<p><b>Case 3: \(a \lt b^{k}\)</b>. Given the condition \(a \lt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \lt 1\).</p>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} r^{i}\) is a geometric series with the common ratio \(r=\frac{a}{b^{k}} \lt 1\) which grows exponentially, and can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			1 &\leq \sum_{i=0}^{\log_{b}(n)-1} r^{i} &\lt \frac{1}{1-r} \\
			1 &\leq \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt \frac{1}{1-\frac{a}{b^{k}}}. 
			\end{aligned}
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{k} &\leq& g(n) &\leq& cn^{k}\frac{1}{1-\frac{a}{b^{k}}} \\
			cn^{k} &\leq& g(n) &\leq& c\frac{1}{1-\frac{a}{b^{k}}}n^{k}. 
			\end{aligned}
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both below and above by constant multiples of \(n^{k}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= O\left(n^{k}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\right). \]
			</div>
		</div>

		<h4 class="post-subtitle">Simplified Version of Master Theorem with Log Factors</h4>
		
		<p>A recurrence such as</p>
		
		<div class="equation-container">
		\[ T(n) = 2T(\frac{n}{2}) + n \log_{2}(n) \]
		</div>
		
		<p>does not exactly fit the form of the master theorem above, since the additive term \(n \log_{2}(n)\) does not look like \(n^{k}\) for some constant \(k\). Such a recurrence can be handled by a more general form of the theorem, as follows.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ 
			T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT(\frac{n}{b}) + cn^{k} \log_{b}^{p}(n), & \text{if } n \gt 1.
			\end{cases}
			\]
			</div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta(n^{\log_{b}(a)}), & \text{if } \log_{b}(a) \gt k \\
			\Theta(n^{k} \log_{b}^{p+1}(n)), & \text{if } \log_{b}(a) = k \text{ and } p \gt -1 \\
			\Theta(n^{k} \log_{b}(\log_{b}(n))), & \text{if } \log_{b}(a) = k \text{ and } p = -1 \\
			\Theta(n^{k}), & \text{if } \log_{b}(a) = k \text{ and } p \lt -1 \\
			\Theta(n^{k} \log_{b}^{p}(n)), & \text{if } \log_{b}(a) \lt k \text{ and } p \gt 0 \\
			\Theta(n^{k}), & \text{if } \log_{b}(a) \lt k \text{ and } p \leq 0.
			\end{cases} \]
            </div>
			
			<p>Analogus results hold for the \(O\) and \(\Omega\) notations.</p>
		</div>
		
		<div class="proof">
			<p>Consider the tree of recursive calls made by the recurrence:</p>
			
			<ul>
				<li>At level \(0\) (the root), there is one call with an input size of \(n\).  The time required for this call, excluding the time needed by the recursive calls it spawns (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(cn^{k} \log_{b}^{p}(n)\).</li>
				<li>At level \(1\), The single call at level 0 spawns \(a\) recursive calls, each working on a subproblem of size \(\frac{n}{b}\). Each of these calls requires \(c\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right)\) time, excluding their own recursive calls. The total time required at this level is therefore \(ac\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right)\).</li>
				<li>At level \(2\),  The \(a\) calls from level \(1\) each spawn \(a\) new calls, resulting in \(a^{2}\) calls at this level. Each of these calls works on an input of size \(\frac{n}{b^{2}}\).  The total time required at this level is \(a^{2}c\left(\frac{n}{b^{2}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{2}}\right)\).</li>
				<li>In general, at level \(i\), there are \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time required for all calls at this level is \(a^{i}c\left(\frac{n}{b^{i}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{i}}\right)\).</li>
				<li>This process continues until \(i = log_{b}(n)\), where the input size reduces to \(1\). At this base case, the problem is small enough to be solved directly without further recursive calls.</li>
			</ul>
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= cn^{k} \log_{b}^{p}(n) + aT(\frac{n}{b}) \\
			&= cn^{k} \log_{b}^{p}(n) + a(c\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + aT(\frac{n}{b^2})) = cn^{k} \log_{b}^{p}(n) + ca\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= cn^{k} \log_{b}^{p}(n) + ca\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{2}}\right) + \dots + a^{\log_{b}(n)}\Theta(1) \\
			&= cn^{k} \log_{b}^{p}(n) + ca\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{2}}\right) + \dots + n^{\log_{b}(a)}\Theta(1) \\
			&= \sum_{i=0}^{\log_{b}(n)-1} ca^{i}\left(\frac{n}{b^{i}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \log_{b}^{p}\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p} + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p}. \]
			</div>
			
			<p>The series \(\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(j=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−j\). When \(i=0\), \(j=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(j=1\). Rewriting the summation in terms of \(j\), we have:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p} &= \sum_{j=1}^{\log_{b}(n)} \left(\frac{a}{b^{k}}\right)^{\log_{b}(n)-j} j^{p} \\
			&= \sum_{j=1}^{\log_{b}(n)} \frac{a^{\log_{b}(n)}}{\left(b^{\log_{b}(n)}\right)^{k}}\left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			&= \sum_{j=1}^{\log_{b}(n)} \frac{n^{\log_{b}(a)}}{n^{k}}\left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			&= \frac{n^{\log_{b}(a)}}{n^{k}}\sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= cn^{k}\frac{n^{\log_{b}(a)}}{n^{k}}\sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			&= cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p}. 
			\end{aligned}
			\]
			</div>
			
			<p>The series is classified as a polynomial-geometric series because the terms involve both a geometric factor \(\left(\frac{b^{k}}{a}\right)^{j}\) and a polynomial factor \(j^{p}\). Its growth rate depends on whether \(a\) is smaller, equal, or larger than \(b^{k}\). Consider these cases.</p>
		
			<p><b>Case 1: \(a \gt b^{k}\)</b>. Given the condition \(a \gt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \lt 1\). </p>
			
			<p>Since \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) is a partial sum of \(\sum_{j=1}^{\infty}r^{j} j^{p}\) which converges to a constant , it follows that</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \lt \sum_{j=1}^{\infty}r^{j} j^{p}. \]
			</div>
			
			<p>To prove that the series \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) for \(r \lt 1\) converges to a constant, we will use techniques from calculus, especially the concept of generating functions and differentiation.</p>
			
			<p>We begin with the basic geometric series:</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} r^{j} = \frac{r}{1-r}. \]
			</div>
			
			<p>The series converges to a constant for \(|x| \lt 1\).</p>
			
			<p>To find \(\sum_{j=1}^{\infty} jr^{j}\), we differentiate \(\sum_{j=1}^{\infty} r^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
            \[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{\infty} r^{j}\right) &= \frac{d}{dr}\left(\frac{r}{1-r}\right) \\
			\sum_{j=1}^{\infty} jr^{j-1} &= \frac{1}{(1-r)^{2}}. 
			\end{aligned}
			\]
            </div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} jr^{j} = \frac{r}{(1-r)^{2}}. \]
			</div>
			
			<p>This confirms that for \(p=1\), the series \(\sum_{j=1}^{\infty} jr^{j}\) converges to a constant, and it does not depend on \(n\).</p>
			
			<p>To find \(\sum_{j=1}^{\infty} j^{2}r^{j}\), we differentiate \(\sum_{j=1}^{\infty} jr^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{\infty} jr^{j}\right) &= \frac{d}{dr}\left(\frac{r}{(r-1)^{2}}\right) \\
			\sum_{j=1}^{\infty} j^{2}r^{j-1} &= \frac{r+1}{(1-r)^{3}}.
			\end{aligned} 
			\]
			</div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} j^{2}r^{j} = \frac{r(r+1)}{(1-r)^{3}}. \]
			</div>
			
			<p>This confirms that for \(p=2\), the series \(\sum_{j=1}^{\infty} j^{2}r^{j}\) converges to a constant, and it does not depend on \(n\).</p>
			
			<p>For a general \(p\), we can continue this differentiation process \(p\) times.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} j^{p}r^{j} = \frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right). \]
			</div>
			
			<p>Therefore, based on the previous conclusion, the series \(\sum_{j=1}^{\infty} j^{2}r^{j}\) converges to a constant, and it does not depend on \(n\).</p>
			
			<p>Since each term in the series \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) is smaller than or equal to the first term,  it can serve as a good lower bound for the series.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \geq r. \]
			</div>
			
			<p>Thus, \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ r \leq \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \lt \sum_{j=1}^{\infty} j^{p}r^{j} = \frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right). \]
			</div>
			
			<p>Subtituting into \(g(n)\), where \(r=\frac{b^{k}}{a}\), yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			cn^{\log_{b}(a)}r &\leq& g(n) &\leq& cn^{\log_{b}(a)} \frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right) \\
			crn^{\log_{b}(a)} &\leq& g(n) &\leq& c\frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right)n^{\log_{b}(a)}. 
			\end{aligned} 
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned} 
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 2: \(a = b^{k}\) and \(p \gt -1\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a}=1\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p}. \]
			</div>
			
			<p>\(\sum_{j=1}^{\log_{b}(n)} j^{p}\) is a sum of powers of integers, and can be bounded both below and above using integral approximation:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\int_{j=0}^{\log_{b}(n)} j^{p} \, dj &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \int_{j=1}^{\log_{b}(n)+1} j^{p} \, dj \\
			\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}.
			\end{aligned} 
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} \\
			cn^{\log_{b}(a)} \frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}. 
			\end{aligned} 
			\]
            </div>
			
			<p>To factor out \(\log_{b}^{p+1}(n)\) from \(\left(\log_{b}(n)+1\right)^{p+1}\), we use the binomial expansion.</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\left(\log_{b}(n)+1\right)^{p+1} &= \sum_{k=0}^{p+1}\binom{p+1}{k} \log_{b}^{p+1-k}(n) \\
			&= \log_{b}^{p+1}(n) + (p+1)\log_{b}^{p}(n) + \frac{(p+1)p}{2}\log_{b}^{p-1}(n) + \cdots + 1 \\
			&= \log_{b}^{p+1}(n) \left(1 + (p+1)\frac{1}{\log_{b}(n)} + \frac{(p+1)p}{2}\frac{1}{\log_{b}^{2}(n)} + \cdots + \frac{1}{\log_{b}^{p+1}(n)}\right) \\
			&= \log_{b}^{p+1}(n)\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}. 
			\end{aligned} 
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& cn^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1}\sum_{k=0}^{p+1}\binom{p+1}{k}\frac{1}{\log_{b}^{k}(n)} \\
			c\frac{1}{p+1}n^{\log_{b}(a)}\log_{b}^{p+1}(n) &\leq& g(n) &\leq& c\frac{1}{p+1}\left(\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}\right)n^{\log_{b}(a)}\log_{b}^{p+1}(n). 
			\end{aligned} 
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right).
			\end{aligned} 
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			
			<p><b>Case 3: \(a = b^{k}\) and \(p = -1\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a}=1\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j}. \]
			</div>
			
			<p>The expression \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\), representing a partial sum of the harmonic series.</p>
			
			<p>The harmonic series, represented by \(H_{n}=\sum_{k=1}^{n} \frac{1}{j}\), can be bounded both below and above as follows:</p> 
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\log_{2}(n+1) &\leq H_{n} \leq \log_{2}(n) + 1 \\
			\log_{2}(n) + \log_{2}\left(1+\frac{1}{n}\right) &\leq H_{n} \leq \log_{2}(n) + 1.
			\end{aligned} 
			\]
            </div>
			
			<p>where \(H_{n}\) is the \(n\)-th harmonic number.</p>
			
			<p>As a result, the partial sum of \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\) satisfies the inequality:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) \leq \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \leq \log_{2}(\log_{b}(n)) + 1. 
			\end{aligned} 
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \\
			cn^{\log_{b}(a)} \left(\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right)\right) &\leq& g(n) &\leq& cn^{\log_{b}(a)} \left(\log_{2}(\log_{b}(n)) + 1\right) \\
			cn^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + cn^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) &\leq& g(n) &\leq& cn^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + cn^{\log_{b}(a)} \\
			cn^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{2}(n)} + cn^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) &\leq& g(n) &\leq& cn^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{2}(n)} + cn^{\log_{b}(a)} \\
			c\frac{1}{\log_{2}(n)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + cn^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) &\leq& g(n) &\leq& c\frac{1}{\log_{2}(n)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + cn^{\log_{b}(a)}.
			\end{aligned} 
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). 
			\end{aligned} 
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p><b>Case 4: \(a = b^{k}\) and \(p \lt -1\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a}=1\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p}. \]
			</div>
			
			<p>Let \(p=-s\), which simplifies the \(g(n)\) to</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j^{s}}. \]
			</div>
			
			<p>The series \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j^{s}}\) is a partial sum of the p-series.</p>
			
			<p>For \(s \gt 1\), the series \(\sum_{k=1}^{n} \frac{1}{k^{s}}\) converges and can be bounded above and below using integral approximation:</p> 
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\int_{1}^{\infty} \frac{1}{x^{s}} \, dx &\leq& \sum_{k=1}^{n} \frac{1}{k^{s}} &\leq& 1 + \int_{1}^{\infty} \frac{1}{x^{s}} \, dx \\
			\frac{1}{s-1} &\leq& \sum_{k=1}^{n} \frac{1}{k^{s}} &\leq& 1 + \frac{1}{s-1}.
			\end{aligned} 
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} \\
			cn^{\log_{b}(a)}\frac{1}{s-1} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \left(1 + \frac{1}{s-1}\right) \\
			c\frac{1}{s-1}n^{\log_{b}(a)} &\leq& g(n) &\leq& c\left(1 + \frac{1}{s-1}\right)n^{\log_{b}(a)}.
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right).
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 5: \(a \lt b^{k}\) and \(p \gt 0\)</b>. Given the condition \(a \lt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \gt 1\).</p>
			
			<p>To find the sum \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) for \(r \gt 1\) and large \(n\), we will use techniques from calculus, especially the concept of generating functions and differentiation.</p>
			
			<p>We begin with the basic geometric series:</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} r^{j} = \frac{r\left(r^{t}-1\right)}{r-1}. \]
			</div>
			
			<p>For large \(t\), the sum of the geometric series can be approximated as follows</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} r^{j} = \frac{r\left(r^{t}-1\right)}{r-1} \lt \frac{r}{r-1}r^{t}. \]
			</div>
			
			<p>To find \(\sum_{j=1}^{t} jr^{j}\), we differentiate \(\sum_{j=1}^{t} r^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{t} r^{j}\right) &\lt \frac{d}{dr}\left(\frac{r}{r-1}r^{t}\right) \\
			\sum_{j=1}^{t} jr^{j-1} &\lt \left(\frac{1}{r-1}-\frac{1}{t(r-1)^{2}}\right)tr^{t}. 
			\end{aligned}
			\]
			</div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} jr^{j} \lt \left(\frac{r}{r-1}-\frac{r}{t(r-1)^{2}}\right)tr^{t}. \]
			</div>
			
			<p>To find \(\sum_{j=1}^{t} j^{2}r^{j}\), we differentiate \(\sum_{j=1}^{t} jr^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{t} jr^{j}\right) &\lt \frac{d}{dr}\left(\left(\frac{r}{r-1}-\frac{r}{t(r-1)^{2}}\right)tr^{t}\right) \\
			\sum_{j=1}^{t} j^{2}r^{j-1} &\lt \left(\frac{1}{r-1}-\frac{2}{t(r-1)^{2}}+\frac{r+1}{t^{2}(r-1)^{3}}\right)t^{2}r^{t}. 
			\end{aligned}
			\]
			</div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} j^{2}r^{j} \lt \left(\frac{r}{r-1}-\frac{2r}{t(r-1)^{2}}+\frac{r(r+1)}t^{2}{(r-1)^{3}}\right)t^{2}r^{t}. \]
			</div>
			
			<p>To find \(\sum_{j=1}^{t} j^{3}r^{j}\), we differentiate \(\sum_{j=1}^{t} jr^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{t} j^{2}r^{j}\right) &\lt \frac{d}{dr}\left(\left(\frac{r}{r-1}-\frac{2r}{t(r-1)^{2}}+\frac{r(r+1)}t^{2}{(r-1)^{3}}\right)t^{2}r^{t}\right) \\
			\sum_{j=1}^{t} j^{2}r^{j-1} &\lt \left(\frac{1}{r-1}-\frac{3}{t(r-1)^{2}}+\frac{3r(r+1)}{t^{2}(r-1)^{3}}-\frac{r^{2}+4r+1}{t^{3}(r-1)^{4}}\right)t^{3}r^{t}. 
			\end{aligned}
			\]
            </div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{j=1}^{t} j^{2}r^{j} &\lt \left(\frac{r}{r-1}-\frac{3r}{t(r-1)^{2}}+\frac{3r^{2}(r+1)}{t^{2}(r-1)^{3}}-\frac{r(r^{2}+4r+1)}{t^{3}(r-1)^{4}}\right)t^{3}r^{t}. 
			\end{aligned}
			\]
			</div>
			
			<p>For a general \(p\), we can continue this differentiation process \(p\) times.</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{j=1}^{t} j^{p}r^{j} &\lt \frac{d^{p}}{dr^{p}}\left(\frac{r}{r-1}r^{k}\right)
			&= t^{p}r^{t}L(r), 
			\end{aligned}
			\]
            </div>
			
			<p>where \(L(r)\) is a rational function.</p>
			
			<p>The function \(L(r)\) has the form</p>
			
			<div class="equation-container">
			\[ L(r) = \frac{N(r)}{t^{p}(r-1)^{p+1}}. \]
			</div>
			
			<p>where N(r) is a polynomial function.</p>
			
			<p>Therefore, let \(t=\log_{b}(n)\), which gives the upper bound:</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} j^{p}r^{j} \lt t^{p}r^{\log_{b}(n)}L(r). \]
			</div>
			
			<p>Since each term in the sum \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) is smaller than or equal to the last term, it can serve as a good lower bound for the series.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \geq r^{\log_{b}(n)} \log_{b}^{p}(n). \]
			</div>
			
			<p>Thus, \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ r^{\log_{b}(n)} \log_{b}^{p}(n) \leq \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \lt \log_{b}^{p}(n)r^{\log_{b}(n)}L(r). \]
			</div>
			
			<p>Subtituting into \(g(n)\), where \(r=\frac{b^{k}}{a}\), yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			cn^{\log_{b}(a)} \left(\frac{b^{k}}{a}\right)^{\log_{b}(n)} \log_{b}^{p}(n) &\leq& g(n) &\lt& cn^{\log_{b}(a)} \log_{b}^{p}(n)\left(\frac{b^{k}}{a}\right)^{\log_{b}(n)}L(r) \\
			cn^{\log_{b}(a)} \frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}} \log_{b}^{p}(n) &\leq& g(n) &\lt& cn^{\log_{b}(a)} \log_{b}^{p}(n)\frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}}L\left(\frac{b^{k}}{a}\right) \\
			cn^{\log_{b}(a)} \frac{n^{k}}{n^{\log_{b}(a)}} \log_{b}^{p}(n) &\lt& g(n) &\leq& cn^{\log_{b}(a)} \frac{n^{k}}{n^{\log_{b}(a)}}\log_{b}^{p}(n)L\left(\frac{b^{k}}{a}\right) \\
			cn^{k}\log_{b}^{p}(n) &\leq& g(n) &\lt& cL\left(\frac{b^{k}}{a}\right)n^{k}\log_{b}^{p}(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{k}\log_{b}^{p}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\log_{b}^{p}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{k}\log_{b}^{p}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\log_{b}^{p}(n)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\log_{b}^{p}(n)\right). \]
			</div>
			
			<p><b>Case 6: \(a \lt b^{k}\) and \(p \lt 0\)</b>. Given the condition \(a \lt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \gt 1\).</p>
			
			<p>Let \(s=-p\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}}. \]
			</div>
			
			<p>Since \(\frac{r^{j}}{j^{s}} \leq r^{j}\), the series can be bounded above by a geometric series.</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}} &\leq \sum_{j=1}^{\log_{b}(n)} r^{j}
			&\lt \frac{r^{\log_{b}(n)+1}}{r-1}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since each term in the series \(\sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}}\) is smaller than or equal to the last term,  it can serve as a good lower bound for the sum.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}} \geq \frac{r^{\log_{b}(n)}}{\log_{b}^{s}(n)}. \]
			</div>
			
			<p>Thus, \(\sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}}\) can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ \frac{r^{\log_{b}(n)}}{\log_{b}^{s}(n)} \leq \sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}} \lt \frac{r^{\log_{b}(n)+1}}{r-1}. \]
			</div>
			
			<p>Subtituting into \(g(n)\), where \(r=\frac{b^{k}}{a}\), yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j}\frac{1}{j^{s}} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j}\frac{1}{j^{s}} \\
			cn^{\log_{b}(a)} \left(\frac{b^{k}}{a}\right)^{\log_{b}(n)}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \frac{\frac{b^{k}}{a}}{\frac{b^{k}}{a}-1}\left(\frac{b^{k}}{a}\right)^{\log_{b}(n)} \\
			cn^{\log_{b}(a)} \frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \frac{\frac{b^{k}}{a}}{\frac{b^{k}}{a}-1}\frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}} \\
			cn^{\log_{b}(a)} \frac{n^{k}}{n^{\log_{b}(a)}}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \frac{\frac{b^{k}}{a}}{\frac{b^{k}}{a}-1}\frac{n^{k}}{n^{\log_{b}(a)}} \\
			cn^{k}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& c\frac{b^{k}}{b^{k}-a}n^{k}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{k}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{k}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\right). \]
			</div>
		</div>

		<h4 class="post-subtitle">General Version of Master Theorem</h4>
		
		<p>The general version of master theorem is a formula for analyzing the time complexity of divide-and-conquer recurrences of the form:</p>
		
		<div class="equation-container">
		\[ T(n) = aT(\frac{n}{b}) + f(n), \]
		</div>
		
		<p>where \(a \geq 1\) and \(b \geq 2\) with \(f\) asymptotically positive (Asymptotically positive mean that the function is positive for all sufficiently large \(n\)).</p>
		
		<p>This recurrence describes an algorithm that divides a problem of size \(n\) into a subproblems, each of size \(\frac{n}{b}\), and solves them recursively. Note that \(\frac{n}{b}\) might not be an integer, but replacing \(T\lceil(\frac{n}{b}\rceil)\) with \(T\lceil(\frac{n}{b}\rceil)\) or \(T\lceil(\lfloor\frac{n}{b}\rfloor\rceil)\) does not affect the asymptotic behavior of the recurrence. So we will just ignore floors and ceilings.</p>
		
		<p>The master theorem compares the function \(n^{\log_{b}(a)}\) to the function \(f(n)\). Intuitively, if \(n^{\log_{b}(a)}\) is larger (by a polynomial factor), then the solution is \(T(n) = \Theta(n^{\log_{b}(a)})\). If \(f(n)\) is larger (by a polynomial factor), then the solution is \(T(n) = \Theta(f(n))\). If they are the same size, then we multiply by a logarithmic factor.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\frac{n}{b}\right) + f(n), & \text{if } n \gt 1
			\end{cases}, \]
			</div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\frac{n}{b}\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>Consider the tree of recursive calls made by the algorithm:</p>
			<ul>
				<li>At level \(0\) (the root), there is one call with an input size of \(n\).  The time required for this call, excluding the time needed by the recursive calls it spawns (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(f(n)\).</li>
				<li>At level \(1\), The single call at level 0 spawns \(a\) recursive calls, each working on a subproblem of size \(\frac{n}{b}\). Each of these calls requires \(f\left(\frac{n}{b}\right)\) time, excluding their own recursive calls. The total time required at this level is therefore \(af\left(\frac{n}{b}\right)\).</li>
				<li>At level \(2\),  The \(a\) calls from level \(1\) each spawn \(a\) new calls, resulting in \(a^{2}\) calls at this level. Each of these calls works on an input of size \(\frac{n}{b^{2}}\).  The total time required at this level is \(a^{2}f\left(\frac{n}{b^{2}}\right)\).</li>
				<li>In general, at level \(i\), there are \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time required for all calls at this level is \(a^{i}f\left(\frac{n}{b^{i}}\right)\).</li>
				<li>This process continues until \(i = \lfloor\log_{b}(n)\rfloor\), where the input size reduces to \(1\). At this base case, the problem is small enough to be solved directly without further recursive calls.</li>
			</ul>
			
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= f(n) + aT(\frac{n}{b}) \\
			&= f(n) + a(f\left(\frac{n}{b}\right) + aT(\frac{n}{b^2})) = f(n) + af\left(\frac{n}{b}\right) + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + a^{\log_{b}(n)}T(1)  \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + n^{\log_{b}(a)}\Theta(1)  \\
			&= \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right). \]
			</div>
			
			<p><b>Case 1: \(f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right)\)</b>. Since we have \(f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = O\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)-\epsilon}\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}O\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)-\epsilon}\right). \]
			</div>
			
			<p>Using the meaning of the \(O\)-notation, there exist constants \(c \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\leq \sum_{i=0}^{\log_{b}(n)-1} a^{i}c\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)-\epsilon} \\
			&= cn^{\log_{b}(a)-\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{\log_{b}(a)-\epsilon}}\right)^{i} \\
			&= cn^{\log_{b}(a)-\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{ab^{\epsilon}}{b^{\log_{b}(a)}}\right)^{i} \\
			&= cn^{\log_{b}(a)-\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(b^{\epsilon}\right)^{i}. 
			\end{aligned}
			\]
            </div>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} \left(b^{\epsilon}\right)^{i}\) is a geometric series with the common ratio \(b^{\epsilon}\) which grows exponentially, and can be bounded above as follows:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{i=0}^{\log_{b}(n)-1} \left(b^{\epsilon}\right)^{i} &\leq \frac{\left(b^{\epsilon}\right)^{\log_{b}(n)}}{b^{\epsilon}-1} \\
			&= \frac{n^{\epsilon}}{b^{\epsilon}-1}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &\leq cn^{\log_{b}(a)-\epsilon}\frac{n^{\epsilon}}{b^{\epsilon}-1} \\
			&= c\frac{1}{b^{\epsilon}-1}n^{\log_{b}(a)}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded above by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = O\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= O\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 2: \(f(n) = \Theta\left(n^{\log_{b}(a)}\right)\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)}\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)}\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} 1 &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} 1 \\
			c_{1}n^{\log_{b}(a)}\log_{b}(n) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\log_{b}(n).
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right). \]
			</div>
			
			
			<p><b>Case 3: \(f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right)\)</b>. Since we have \(f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Omega\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)+\epsilon}\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Omega\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)+\epsilon}\right). \]
			</div>
			
			<p>Using the meaning of the \(\Omega\)-notation, there exist constants \(c \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\geq \sum_{i=0}^{\log_{b}(n)-1} a^{i}c\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)+\epsilon} \\
			&= cn^{\log_{b}(a)+\epsilon} \sum_{i=0}^{\log_{b}(n)-1} a^{i}\left(\frac{1}{b^{\log_{b}(a)+\epsilon}}\right)^{i} \\
			&= cn^{\log_{b}(a)+\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{1}{b^{\epsilon}}\right)^{i}. 
			\end{aligned}
			\]
            </div>
			
			<p>\(\sum_{i=0}^{\lfloor\log_{b}(n)\rfloor-1} \left(\frac{1}{b^{\epsilon}}\right)^{i}\) is a geometric series with the common ratio \(\frac{1}{b^{\epsilon}}\) which decays exponentially, and can be bounded below as follows:</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{\lfloor\log_{b}(n)\rfloor-1} \left(\frac{1}{b^{\epsilon}}\right)^{i} \geq 1. \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\geq cn^{\log_{b}(a)+\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{1}{b^{\epsilon}}\right)^{i} \\
			&= cn^{\log_{b}(a)+\epsilon}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded below by constant multiples of \(f(n)=n^{\log_{b}(a)+\epsilon}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Omega\left(f(n)\right). \]
			</div>
			
			<p>Since \(af\left(\frac{n}{b}\right) \leq cf(n)\), it follows that \(f\left(\frac{n}{b}\right) \leq \frac{c}{a}f(n)\).</p>
			
			<p>Now, iterate the recurrence</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			f\left(\frac{n}{b^{2}}\right) &\leq \frac{c}{a}f\left(\frac{n}{b}\right) \\
			&\leq \frac{c}{a}\cdot\frac{c}{a}f(n) \\
			&= \left(\frac{c}{a}\right)^{2}f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Iterate the recurrence once more</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			f\left(\frac{n}{b^{3}}\right) &\leq \frac{c}{a}f\left(\frac{n}{b^{2}}\right) \\
			&\leq \frac{c}{a}\cdot\left(\frac{c}{a}\right)^{2}f(n) \\
			&= \left(\frac{c}{a}\right)^{3}f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>By continuing this process, after \(i\) iterations, we have:</p>
			
			<div class="equation-container">
			\[ f\left(\frac{n}{b^{i}}\right) \leq \left(\frac{c}{a}\right)^{i}f(n). \]
			</div>
			
			<p>Thus, we have:</p>
			
			<div class="equation-container">
			\[ a^{i}f\left(\frac{n}{b^{i}}\right) \leq c^{i}f(n). \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right) \\
			&\leq \sum_{i=0}^{\log_{b}(n)-1} c^{i}f(n) \\
			&= f(n)\sum_{i=0}^{\log_{b}(n)-1} c^{i}. 
			\end{aligned}
			\]
            </div>
			
			<p>\(\sum_{i=0}^{\lfloor\log_{b}(n)\rfloor-1} c^{i}\) is a geometric series with the common ratio \(b^{\epsilon}\) which decays exponentially because \(c \lt 1\), and can be bounded above as follows:</p>
			
			<div class="equation-container">
			\[ f(n)\sum_{i=0}^{\log_{b}(n)-1} c^{i} \leq f(n)\frac{1}{1-c}. \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\leq f(n)\frac{1}{1-c} \\
			&= \frac{1}{1-c}f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above by constant multiples of \(f(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = O\left(f(n)\right). \]
			</div>
			
			<p>We have \(g(n) = \Omega\left(f(n)\right)\) and \(g(n) = O\left(f(n)\right)\), which implies that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(f(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(f(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(f(n)\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(f(n)\right). \]
			</div>
		</div>

		<p>In the Master Theorem, as given above, there is a gap between cases 1 and 2, and a gap between cases 2 and 3.</p>
		
		<p>The recurrence</p>
		
		<div class="equation-container">
		\[ T(n) = 2T(\frac{n}{2}) + n\log_{2}(n), \]
		</div>
		
		<p>and</p>
		
		<div class="equation-container">
		\[ T(n) = 2T(\frac{n}{2}) + \frac{n}{\log_{2}(n)} \]
		</div>
		
		<p>does not exactly fit the form of the master theorem above.</p>
		
		<p> The Master Theorem works well when \(f(n)\) is a simple polynomial function, like \(n^{d}\), but in this case, \(f(n)=n\log_{2}(n)\) involves both a polynomial part and a logarithmic factor, which is more complicated.</p>
		
		<p>To handle recurrences like this, we need to use an extension of case 2 of the Master Theorem, known as the Generalized Master Theorem or Extended Master Theorem, which can handle additional logarithmic factors.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\frac{n}{b}\right) + f(n), & \text{if } n \gt 1
			\end{cases}. \]
			</div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)} \log_{b}^{k+1}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right) \text{ and } k \gt -1 \\
			\Theta(n^{\log_{b}(a)} \log_{b}(\log_{b}(n))), & \text{if } f(n) = \Theta(n^{\log_{b}(a)} \log_{b}^{k}(n)) \text{ and } k = -1 \\
			\Theta(n^{\log_{b}(a)}), & \text{if } f(n) = \Theta(n^{\log_{b}(a)} \log_{b}^{k}(n)) \text{ and } k \lt -1
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>Consider the tree of recursive calls made by the algorithm:</p>
			<ul>
				<li>At level \(0\) (the root), there is one call with an input size of \(n\).  The time required for this call, excluding the time needed by the recursive calls it spawns (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(f(n)\).</li>
				<li>At level \(1\), The single call at level 0 spawns \(a\) recursive calls, each working on a subproblem of size \(\frac{n}{b}\). Each of these calls requires \(f\left(\frac{n}{b}\right)\) time, excluding their own recursive calls. The total time required at this level is therefore \(af\left(\frac{n}{b}\right)\).</li>
				<li>At level \(2\),  The \(a\) calls from level \(1\) each spawn \(a\) new calls, resulting in \(a^{2}\) calls at this level. Each of these calls works on an input of size \(\frac{n}{b^{2}}\).  The total time required at this level is \(a^{2}f\left(\frac{n}{b^{2}}\right)\).</li>
				<li>In general, at level \(i\), there are \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time required for all calls at this level is \(a^{i}f\left(\frac{n}{b^{i}}\right)\).</li>
				<li>This process continues until \(i = \lfloor\log_{b}(n)\rfloor\), where the input size reduces to \(1\). At this base case, the problem is small enough to be solved directly without further recursive calls.</li>
			</ul>
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= f(n) + aT(\frac{n}{b}) \\
			&= f(n) + a(f\left(\frac{n}{b}\right) + aT(\frac{n}{b^2})) = f(n) + af\left(\frac{n}{b}\right) + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + a^{\log_{b}(n)}T(1) \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + n^{\log_{b}(a)}\Theta(1)  \\
			&= \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right). \]
			</div>
			
			<p><b>Case 2a: \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\) and \(k \gt -1\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} \left(\log_{b}(n)-i\right)^{k} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} \left(\log_{b}(n)-i\right)^{k} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} \left(\log_{b}(n)-i\right)^{k} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} \left(\log_{b}(n)-i\right)^{k} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k}.
			\end{aligned}
			\]
            </div>
			
			<p>The expression \(\sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(j=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−j\). When \(i=0\), \(j=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(j=1\). Rewriting the summation in terms of \(j\), we have:</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k} = \sum_{j=1}^{\log_{b}(n)} j^{p}. \]
			</div>
			
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p} \leq g(n) \leq c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p}.
			\]
            </div>
			
			<p>\(\sum_{j=1}^{\log_{b}(n)} j^{p}\) is a sum of powers of integers, and can be bounded both below and above using integral approximation:</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\int_{j=0}^{\log_{b}(n)} j^{p} \, dj &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \int_{j=1}^{\log_{b}(n)+1} j^{p} \, dj \\
			\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}.
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p} \\
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}. 
			\end{aligned}
			\]
            </div>
			
			<p>To factor out \(\log_{b}^{p+1}(n)\) from \(\left(\log_{b}(n)+1\right)^{p+1}\), we use the binomial expansion.</p>
			
			<div class="equation-container">
        	\[ 
			\begin{aligned}
			\left(\log_{b}(n)+1\right)^{p+1} &= \sum_{k=0}^{p+1}\binom{p+1}{k} \log_{b}^{p+1-k}(n) \\
			&= \log_{b}^{p+1}(n) + (p+1)\log_{b}^{p}(n) + \frac{(p+1)p}{2}\log_{b}^{p-1}(n) + \cdots + 1 \\
			&= \log_{b}^{p+1}(n) \left(1 + (p+1)\frac{1}{\log_{b}(n)} + \frac{(p+1)p}{2}\frac{1}{\log_{b}^{2}(n)} + \cdots + \frac{1}{\log_{b}^{p+1}(n)}\right) \\
			&= \log_{b}^{p+1}(n)\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1} \\
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\log_{b}^{p+1}(n)\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)} \\
			c_{1}\frac{1}{p+1}n^{\log_{b}(a)}\log_{b}^{p+1}(n) &\leq& g(n) &\leq& c_{2}\left(\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}\right)n^{\log_{b}(a)}\log_{b}^{p+1}(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			<p><b>Case 2b: \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\) and \(k=-1\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right). \]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \frac{1}{\log_{b}(n)-i} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \frac{1}{\log_{b}(n)-i} \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}(n)-i} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}(n)-i} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i}.
			\end{aligned}
			\]
            </div>
			
			<p>The series \(\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(j=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−j\). When \(i=0\), \(j=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(j=1\). Rewriting the summation in terms of \(j\), we have:</p>
			
			<div class="equation-container">
            \[
			\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i} = \sum_{j=1}^{\log_{b}(n)} \frac{1}{j}.
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \leq g(n) \leq c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}.
			\]
            </div>
			
			<p>The series \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\) is a partial sum of the harmonic series.</p>
			
			<p>The harmonic series, represented by \(H_{n}=\sum_{j=1}^{n} \frac{1}{j}\), can be bounded as follows:</p> 
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\log_{2}(n+1) &\leq& H_{n} &\leq& \log_{2}(n) + 1 \\
			\log_{2}(n) + \log_{2}\left(1+\frac{1}{n}\right) &\leq& H_{n} &\leq& \log_{2}(n) + 1.
			\end{aligned}
			\]
            </div>
			
			<p>where \(H_{n}\) is the \(n\)-th harmonic number.</p>
			
			<p>As a result, the partial sum of \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\) satisfies the inequality:</p>
			
			<div class="equation-container">
			\[
			\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) \leq \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \leq \log_{2}(\log_{b}(n)) + 1. 
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \\ 
			c_{1}n^{\log_{b}(a)}\left(\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right)\right) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\left(\log_{2}(\log_{b}(n)) + 1\right) \\
			c_{1}n^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + c_{1}n^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(\log_{b}(n))}\right) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + c_{2}n^{\log_{b}(a)} \\
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{b}(2)} + c_{1}n^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{2}(\log_{b}(n))}\right) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{b}(2)} + c_{2}n^{\log_{b}(a)} \\
			c_{1}\frac{1}{\log_{b}(2)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + c_{1}n^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{2}(\log_{b}(n))}\right) &\leq& g(n) &\leq& c_{2}\frac{1}{\log_{b}(2)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + c_{2}n^{\log_{b}(a)}.
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p><b>Case 2c: \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\) and \(k \lt -1\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) &\leq g(n) &\leq \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right).
			\end{aligned}
			\]
            </div>
			
			<p>Let \(k=-r\), which simplifies the \(g(n)\) to</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \log_{b}^{-r}\left(\frac{n}{b^{i}}\right) &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \log_{b}^{-r}\left(\frac{n}{b^{i}}\right) \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}^{r}\left(\frac{n}{b^{i}}\right)} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}^{r}\left(\frac{n}{b^{i}}\right)} \\
			c_{1}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} &\leq& g(n) &\leq&  c_{2}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} \\
			c_{1}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} &\leq& g(n) &\leq&  c_{2}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}}.
			\end{aligned}
			\]
            </div>
			
			<p>The expression \(\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(k=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−k\). When \(i=0\), \(k=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(k=1\). Rewriting the summation in terms of \(k\), we have:</p>
			
			<div class="equation-container">
            \[
			\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} = \sum_{k=1}^{\log_{b}(n)} \frac{1}{k^{r}}.
			\]
            </div>
			
			<p>The series \(\sum_{k=1}^{\log_{b}(n)} \frac{1}{k^{r}}\) is a partial sum of the p-series.</p>
			
			<p>For \(r \gt 1\), the p-series, represented by \(\sum_{k=1}^{n} \frac{1}{k^{r}}\), converges and can be bounded above and below using integral approximation:</p> 
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\int_{k=1}^{\infty} \frac{1}{k^r} \, dk &\leq& \sum_{k=1}^{n} \frac{1}{k^{r}} &\leq& 1 + \int_{k=1}^{\infty} \frac{1}{k^{r}} \, dk \\
			\frac{1}{r-1} &\leq& \sum_{k=1}^{n} \frac{1}{k^{r}} &\leq& 1 + \frac{1}{r-1}.
			\end{aligned}
			\]
            </div>
			
			<p>As a result, the partial sum of \(\sum_{k=1}^{\log_{b}(n)} \frac{1}{k^{r}}\) satisfies the inequality:</p>
			
			<div class="equation-container">
            \[ \frac{1}{r-1} \leq \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} \leq 1 + \frac{1}{r-1}. \]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)} \frac{1}{r-1} &\leq& g(n) &\leq&  c_{2}n^{\log_{b}(a)} \left(1 + \frac{1}{r-1}\right) \\
			c_{1}\frac{1}{r-1} n^{\log_{b}(a)} &\leq& g(n) &\leq& c_{2}\left(1 + \frac{1}{r-1}\right)n^{\log_{b}(a)}.
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
		</div>

		<p>In the preceding analysis we assumed that the input size \(n\) is a positive integer that is a power of \(b \gt 1\), and therefore that \(b\) is also an integer. It turns out that, essentially, the Master Theorem holds even if \(n\) is not necessarily a power of \(b\) and \(b \gt 1\) is a real number, not necessarily an integer. If \(n\) is not a power of \(b\), however, the previous recurrence expression is not a legitimate recurrence: sooner or later as we keep dividing the input size by \(b\) we will end up with a non-natural number and then the recurrence is not defined.</p>
		
		<p>In general, a divide-and-conquer algorithm breaks a problem of size \(n\) into a subproblems, \(a_{1}\) of which have size \(\lceil \frac{n}{b} \rceil\) and \(a_{2}\) have size \(\lfloor \frac{n}{b} \rfloor\), for some non-negative integers \(a_{1}\) and \(a_{2}\) such that \(a_{1} + a_{2} = a\). Thus, the following recurrence describes the running time of such an algorithm, when \(n\) is not necessarily a power of \(b\), and \(b \gt 1\) is not necessarily an integer.</p>
		
		<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			a_{1}T\left(\lceil \frac{n}{b} \rceil\right) + a_{2}T\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \gt 1,
			\end{cases} \]
        </div>
		
		<p>where \(a_{1}\), \(a_{2}\) are non-negative integers such that \(a_{1} + a_{2} = a\).</p>
		
		<p>or</p>
		
		<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } 1 \leq n \leq \frac{b}{b-1} \\
			aT\left(\lceil \frac{n}{b} \rceil\right) + f(n), & \text{if } n \geq \frac{b}{b-1},
			\end{cases} \]
        </div>
		
		<p>or</p>
		
		<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } 1 \leq n \leq \frac{b}{b-1} \\
			aT\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \geq \frac{b}{b-1}.
			\end{cases} \]
        </div>
			
		<p>We need to extend our analysis to allow situations in which floors and ceilings appear in the master recurrence.</p>
		
		<div class="theorem">
			<p>Let \(a_{1} + a_{2} = a \geq 1\) and \(b \gt 1\) be real constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			a_{1}T\left(\lceil \frac{n}{b} \rceil\right) + a_{2}T\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \gt 1.
			\end{cases} \]
            </div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>The monotonicity property allows us to apply techniques like induction to prove bounds for \(T(n)\).</p>
			
			<div class="equation-container">
			\[ T(a) \leq T(b) \text{ for any } a \leq b \]
			</div>
			
			<p>The running time \(T(a)\) represents the worst-case running time for a problem of size \(a\) and \(T(b)\) represents the worst-case running time for a problem of size \(b\).</p>
			
			<p>Every input of size \(a\) can be seen as a part (or subset) of the inputs of size \(b\), because if \(a \leq b\), any instance of the problem that can be solved for \(a\)-sized inputs can also be considered a part of the problem for \(b\)-sized inputs.</p>
			
			<p>For example, if a problem involves sorting an array, the set of possible arrays of size \(a\) is a subset of the set of possible arrays of size \(b\) when \(a \lt b\).</p>
			
			<p>Therefore, the worst-case running time for the smaller problem (size \(a\)) is essentially a subset of the worst-case running time for the larger problem (size \(b\)). In other words, the worst-case scenario for a problem of size \(a\) will not exceed the worst-case scenario for a problem of size \(b\).</p>
			
			<p>Since \(\lfloor\frac{n}{b}\rfloor \leq \lceil\frac{n}{b}\rceil \lt \frac{n}{b} + 1\), we replace \(\lfloor\frac{n}{b}\rfloor\) with \(\lceil\frac{n}{b}\rceil\) in the recurrence relation because \(\lceil\frac{n}{b}\rceil\) is larger, ensuring an upper bound on the running time. Furthermore, the size of \(\lceil\frac{n}{b}\rceil\) can be bounded by \(\frac{n}{b} + 1\). This simplification helps establish a tighter upper bound for analyzing the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) \leq (a_{1} + a_{2})T(\lceil\frac{n}{b}\rceil) + f(n) \lt (a_{1} + a_{2})T(\frac{n}{b} + 1) + f(n). \]
			</div>
			
			<p>To simplify the recurrence and analyze it more effectively, we apply the change-of-function trick by defining a new function:</p>
			
			<div class="equation-container">
			\[ S(n) = T(n+l). \]
			</div>
			
			<p>This simplifies the recurrence:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			S(n) &= T(n+l) \\
			&\leq (a_{1} + a_{2})T(\frac{n+b}{b} + 1) + f(n) \\
			&= (a_{1} + a_{2})T(\frac{n}{b} + 2) + f(n) \\
			&= (a_{1} + a_{2})S(\frac{n}{b}) + f(n) \\
			&= aS(\frac{n}{b}) + f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Summarizing the above inequalities we have</p>
			
			<div class="equation-container">
			\[ S(n) \leq aS(\frac{n}{b}) + f(n). \]
			</div>
			
			<p>Applying this inequality repeatedly, and using the geometric series formulas as in the proof of previous theorem we get that</p>
			
			<div class="equation-container">
            \[ S(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n.
			\end{cases} \]
            </div>
			
			<p>By definition of \(S\), \( T(n) = S(n-l) \). Therefore </p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(\left(n-l\right)^{\log_{b}(a)-\epsilon}\right) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(\left(n-l\right)^{\log_{b}(a)} \log_{b}\left(n-l\right)\right) = \Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n-l)) = \Theta(f(n)), & \text{if } f(n) = \Omega\left(\left(n-l\right)^{\log_{b}(a)+\epsilon}\right) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be real constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\lceil \frac{n}{b} \rceil\right) + f(n), & \text{if } n \gt 1
			\end{cases}.
			\]
            </div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n.
			\end{cases} \]
            </div>
		</div>

		<div class="proof">
			<p>The monotonicity property allows us to apply techniques like induction to prove bounds for \(T(n)\).</p>
			
			<div class="equation-container">
			\[ T(a) \leq T(b) \text{ for any } a \leq b \]
			</div>
			
			<p>Since \(\lceil\frac{n}{b}\rceil \lt \frac{n}{b} + 1\), the size of \(\lceil\frac{n}{b}\rceil\) can be bounded by \(\frac{n}{b} + 1\). This simplification helps establish a tighter upper bound for analyzing the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) \leq aT(\lceil\frac{n}{b}\rceil) + f(n) \lt aT(\frac{n}{b} + 1) + f(n). \]
			</div>
			
			<p>To simplify the recurrence and analyze it more effectively, we apply the change-of-function trick by defining a new function:</p>
			
			<div class="equation-container">
			\[ S(n) = T(n+l). \]
			</div>
			
			<p>This simplifies the recurrence:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			S(n) &= T(n+l) \\
			&\leq aT(\frac{n+b}{b} + 1) + f(n) \\
			&= aT(\frac{n}{b} + 2) + f(n) \\
			&= aS(\frac{n}{b}) + f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Summarizing the above inequalities we have</p>
			
			<div class="equation-container">
            \[ S(n) \leq aS(\frac{n}{b}) + f(n). \]
            </div>
			
			<p>Applying this inequality repeatedly, and using the geometric series formulas as in the proof of previous theorem we get that</p>
			
			<div class="equation-container">
            \[ S(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
			
			<p>By definition of \(S\), \( T(n) = S(n-l) \). Therefore </p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(\left(n-l\right)^{\log_{b}(a)-\epsilon}\right) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(\left(n-l\right)^{\log_{b}(a)} \log_{b}\left(n-l\right)\right) = \Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n-l)) = \Theta(f(n)), & \text{if } f(n) = \Omega\left(\left(n-l\right)^{\log_{b}(a)+\epsilon}\right) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>
		
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be real constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \gt 1
			\end{cases}.
			\]
            </div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lfloor \frac{n}{b} \rfloor\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>The monotonicity property allows us to apply techniques like induction to prove bounds for \(T(n)\).</p>
			
			<div class="equation-container">
			\[ T(a) \leq T(b) \text{ for any } a \leq b \]
			</div>
			
			<p>Since \(\lfloor\frac{n}{b}\rfloor \leq \lceil\frac{n}{b}\rceil \lt \frac{n}{b} + 1\), we replace \(\lfloor\frac{n}{b}\rfloor\) with \(\lceil\frac{n}{b}\rceil\) in the recurrence relation because \(\lceil\frac{n}{b}\rceil\) is larger, ensuring an upper bound on the running time. Furthermore, the size of \(\lceil\frac{n}{b}\rceil\) can be bounded by \(\frac{n}{b} + 1\). This simplification helps establish a tighter upper bound for analyzing the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) \leq aT(\lceil\frac{n}{b}\rceil) + f(n) \lt aT(\frac{n}{b} + 1) + f(n). \]
			</div>
			
			<p>To simplify the recurrence and analyze it more effectively, we apply the change-of-function trick by defining a new function:</p>
			
			<div class="equation-container">
			\[ S(n) = T(n+l). \]
			</div>
			
			<p>This simplifies the recurrence:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			S(n) &= T(n+l) \\
			&\leq aT(\frac{n+b}{b} + 1) + f(n) \\
			&= aT(\frac{n}{b} + 2) + f(n) \\
			&= aS(\frac{n}{b}) + f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Summarizing the above inequalities we have</p>
			
			<div class="equation-container">
			\[ S(n) \leq aS(\frac{n}{b}) + f(n). \]
			</div>
			
			<p>Applying this inequality repeatedly, and using the geometric series formulas as in the proof of previous theorem we get that</p>
			
			<div class="equation-container">
            \[ S(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
			
			<p>By definition of \(S\), \( T(n) = S(n-l) \). Therefore </p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(\left(n-l\right)^{\log_{b}(a)-\epsilon}\right) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(\left(n-l\right)^{\log_{b}(a)} \log_{b}\left(n-l\right)\right) = \Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n-l)) = \Theta(f(n)), & \text{if } f(n) = \Omega\left(\left(n-l\right)^{\log_{b}(a)+\epsilon}\right) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<h4 class="post-subtitle">Limitations of Master Theorem</h4>
		
		<p>For master theorem to work:</p>
		
		<ul>
			<li>The Master Theorem only applies to recurrence relations of the form \(T(n) = aT(\frac{n}{b}) + f(n)\). It cannot be used for other forms of recurrence relations.</li>
			<li>The parameters \(a\) and \(b\) must be positive and greater than one. The theorem is not applicable if \(a \leq 0\) or \(b \leq 1\).</li>
			<li>The function \(f(n)\) must be asymptotically positive. If \(f(n)\) is not positive for large \(n\), the theorem cannot be applied.</li>
			<li>The Master Theorem is less effective for non-polynomial \(f(n)\). If \(f(n)\) does not fit into a polynomial form, the theorem might not provide a straightforward solution.</li>
			<li>The theorem assumes that the problem size is reduced by a constant factor \(b\). It cannot handle cases where the subdivision factor \(b\) varies with \(n\).</li>
		</ul>
		
		<h4 class="post-subtitle">Examples</h4>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{2}) + n^{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n^{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(3)}=n^{1.585}\). Since \(f(n)=n^{2}\) is asymptotically larger than \(n^{log_{b}(a)}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=3\), \(b=2\), and \(f(n)=n^{2}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				3\left(\frac{n}{2}\right)^{2} &\leq cn^{2}  \\
				\frac{3n^{2}}{4} &\leq cn^{2}  \\
				\frac{3}{4} &\leq c  \\
				c &\geq \frac{3}{4}
				\end{aligned}
				\]
                </div>
				
				<p>Therefore, the inequality holds for any \(c\) such that \(\frac{3}{4} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 4T(\frac{n}{2}) + n^{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=4\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n^{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(4)}=n^{2}\). Since \(f(n)=n^{2}\) is asymptotically equal to \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 2 of the General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}\log_{b}(n)). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = T(\frac{n}{2}) + 2^{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=1\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=2^{n}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(1)}=1\). Since \(f(n)=2^{n}\) is asymptotically faster than \(n^{log_{b}(a)}=1\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=1\), \(b=2\), and \(f(n)=2^{n}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				2^{\frac{n}{2}} &\leq c2^{n}  \\
				2^{-\frac{n}{2}} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>As \(n\) becomes large, \(2^{-\frac{n}{2}}\) approaches \(0\). Therefore, the inequality holds for any \(c\) such that \(0 \lt c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(2^{n}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2^{n}T(\frac{n}{2}) + n^{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>The Master Theorem cannot be applied directly to this recurrence because:</p>
				
				<ul>
					<li>\(a=2^{n}\) is not a constant.</li>
					<li>\(f(n)=n^{n}\) grows super-exponentially, which is much faster than any polynomial or standard exponential growth.</li>
				</ul>
            </div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 16T(\frac{n}{4}) + n \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=16\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(16)}=n^{4}\). Since \(f(n)=n\) is asymptotically smaller than \(n^{log_{b}(a)}=n^{4}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{4}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2T(\frac{n}{2}) + n \log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=2\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(2)}=n\). Since \(f(n)=n\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n\) due to the additional logarithmic factor, we conclude that this is Case 2a of the Extended General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log^{2}(n)). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2T(\frac{n}{2}) + \frac{n}{\log(n)} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=2\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\frac{n}{\log(n)}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(2)}=n\). Since \(f(n)=\frac{n}{\log(n)}\) is asymptotically slower than \(n^{log_{b}(a)}=n\) due to the additional logarithmic factor, we conclude that this is Case 2b of the Extended General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log(\log(n))). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2T(\frac{n}{4}) + n^{0.58} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=2\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n^{0.58}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{4}(2)}=n^{0.5}\). Since \(f(n)=n^{0.58}\) is asymptotically faster than \(n^{log_{b}(a)}=n^{0.5}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=2\), \(b=4\), and \(f(n)=n^{0.58}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				2\left(\frac{n}{4}\right)^{0.58} &\leq cn^{0.58}  \\
				\frac{2}{4^{0.58}} &\leq c \\
				\frac{1}{2^{0.16}} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>Therefore, the inequality holds for any \(c\) such that \(\frac{1}{2^{0.16}} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{0.58}). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 0.5T(\frac{n}{2}) + \frac{1}{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>The Master Theorem cannot be applied to this recurrence because \(a \lt 1\).</p>
            </div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 16T(\frac{n}{4}) + n! \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=16\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n!\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{4}(16)}=n^{2}\). Since \(f(n)=n!\) is asymptotically faster than \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=16\), \(b=4\), and \(f(n)=n!\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				16\left(\frac{n}{4}\right)! &\leq cn!  \\
				16\frac{\left(\frac{n}{4}\right)!}{n!} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>The factor \(16\left(\frac{n}{4}\right)!\) grows slower than \(n!\) for large \(n\). Therefore, the inequality holds for any \(c\) such that \(0 \lt c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n!). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = \sqrt{2}T(\frac{n}{2}) + \log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=\sqrt{2}\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(\sqrt{2})}=n^{\frac{1}{2}}\). Since \(f(n)=\log(n)\) is asymptotically slower than \(n^{log_{b}(a)}=n^{\frac{1}{2}}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{\frac{1}{2}}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{2}) + n \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(3)}=n^{1.585}\). Since \(f(n)=n\) is asymptotically smaller than \(n^{log_{b}(a)}=n^{1.585}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{1.585}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{3}) + \sqrt{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=\sqrt{n}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(3)}=n\). Since \(f(n)=\sqrt{n}\) is asymptotically slower than \(n^{log_{b}(a)}=n\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{4}) + n\log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{4}(3)}=n^{0.973}\). Since \(f(n)=n\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n^{0.973}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=3\), \(b=4\), and \(f(n)=n\log(n)\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				3\frac{n}{4}\log\left(\frac{n}{4}\right) &\leq cn\log(n)  \\
				\frac{3}{4}(\log(n)-\log(4)) &\leq c\log(n) \\
				\frac{3}{4}-\frac{3\log(4)}{4\log(n)} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>As \(n\) becomes large, \(\frac{3\log(4)}{4\log(n)}\) approaches \(0\). Therefore, the inequality holds for any \(c\) such that \(\frac{3}{4} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log(n)). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{3}) + \frac{n}{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=\frac{n}{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(3)}=n\). Since \(f(n)=\frac{n}{2}\) is asymptotically equal to \(n^{log_{b}(a)}=n\), we conclude that this is Case 2 of the General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log(n)). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 6T(\frac{n}{3}) + n^{2}\log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=6\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=n^{2}\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(6)}=n^{1.631}\). Since \(f(n)=n^{2}\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n^{1.631}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=6\), \(b=3\), and \(f(n)=n^{2}\log(n)\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				6\left(\frac{n}{3}\right)^{2}\log\left(\frac{n}{3}\right) &\leq cn^{2}\log(n)  \\
				6\left(\frac{1}{3}\right)^{2}(\log(n)-\log(3)) &\leq c\log(n) \\
				\frac{2}{3}(\log(n)-\log(3)) &\leq c\log(n) \\
				\frac{2}{3}-\frac{2\log(3)}{3\log(n)} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>As \(n\) becomes large, \(\frac{2\log(3)}{3\log(n)}\) approaches \(0\). Therefore, the inequality holds for any \(\frac{2}{3} \leq c \lt 1\). Since such a \(c\) exists, the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}\log(n)). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 4T(\frac{n}{2}) + \frac{n}{\log(n)} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=4\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\frac{n}{\log(n)}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(4)}=n^{2}\). Since \(f(n)=\frac{n}{\log(n)}\) is asymptotically slower than \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 64T(\frac{n}{8}) - n^{2}\log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>The Master Theorem cannot be applied to this recurrence because \(f(n)\) is not positive.</p>
            </div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 7T(\frac{n}{3}) + n^{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=7\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=n^{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(7)}=n^{1.7712}\). Since \(f(n)=n^{2}\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n^{1.7712}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=7\), \(b=3\), and \(f(n)=n^{2}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				7\left(\frac{n}{3}\right)^{2} &\leq cn^{2}  \\
				\frac{7}{9} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>Therefore, the inequality holds for any \(c\) such that \(\frac{2}{3} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 4T(\frac{n}{4}) + \log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=4\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(4)}=n^{2}\). Since \(f(n)=\log(n)\) is asymptotically slower than \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = T(\frac{n}{2}) + n(2-\sin(n)) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=1\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n(2-\sin(n))\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(1)}=1\). Since \(f(n)=n(2-\sin(n))\) is asymptotically faster than \(n^{log_{b}(a)}=1\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=1\), \(b=2\), and \(f(n)=n(2-sin(n))\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{n}{2}(2-\sin\left(\frac{n}{2}\right)) &\leq cn(2-\sin(n)) \\
				\frac{1}{2}(2-\sin\left(\frac{n}{2}\right)) &\leq c(2-\sin(n)).
				\end{aligned}
				\]
                </div>
				
				<p>Consider \(n = \pi k\), where \(k \geq 0\) and arbitrarily large. The value of \(\sin(n)\) will always be \(0\) and the value of \(\sin(\frac{n}{2})\) alternates depending on \(k \mod 4\).<p>
				
				<p>If \(k \equiv 0 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = 0\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq 2c \\
				c \geq \frac{1}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 1 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = 1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-1) &\leq 2c \\
				c \geq \frac{1}{4}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 2 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = 0\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq 2c \\
				c \geq \frac{1}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 3 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = -1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2+1) &\leq 2c \\
				c \geq \frac{3}{4}.
				\end{aligned}
				\]
                </div>
				
				<p>Thus, for all values of \(k\), the largest lower bound on \(c\) is \(c \geq \frac{3}{4}\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n(2-\sin(n))). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = T(\frac{n}{2}) + n(2-\cos(n)) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=1\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n(2-\cos(n))\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(1)}=1\). Since \(f(n)=n(2-\cos(n))\) is asymptotically faster than \(n^{log_{b}(a)}=1\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=1\), \(b=2\), and \(f(n)=n(2-\cos(n))\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{n}{2}(2-\cos\left(\frac{n}{2}\right)) &\leq cn(2-\cos(n)) \\
				\frac{1}{2}(2-\cos\left(\frac{n}{2}\right)) &\leq c(2-\cos(n)).
				\end{aligned}
				\]
                </div>
				
				<p>Consider \(n = \pi k\), where \(k \geq 0\) and arbitrarily large. The value of \(\cos(n)\) is \((-1)^{k}\) and the value of \(\cos(\frac{n}{2})\) alternates depending on \(k \mod 4\).<p>
				
				<p>If \(k \equiv 0 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = 1\) and \(\cos(n) = 1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-1) &\leq c(2-1) \\
				c \geq \frac{1}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 1 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = 0\) and \(\cos(n) = -1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq c(2+1) \\
				c \geq \frac{1}{3}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 2 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = -1\) and \(\cos(n) = 1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2+1) &\leq c(2-1) \\
				c \geq \frac{3}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 3 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = 0\) and \(\cos(n) = -1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq c(2+1) \\
				c \geq \frac{1}{3}.
				\end{aligned}
				\]
                </div>
				
				<p>Thus, for all values of \(k\), the largest lower bound on \(c\) is \(c \geq \frac{3}{2}\) and it violates the condition that \(c \lt 1\).</p>
				
				<p>Since the regularity condition is not satisfied, this implies that the recurrence does not fit into Case 3 of the General Master Theorem.</p>
            </div>
        </div>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/recurrence" class="tag">recurrence</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/simplified-master-theorem" class="tag">simplified master theorem</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/general-master-theorem" class="tag">general master theorem</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/master-theorem-extension" class="tag">master theorem extension</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/master-theorem-with-logarithmic-factor" class="tag">master theorem with logarithmic factor</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/recursive-algorithm" class="tag">recursive algorithm</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/asymptotic-analysis" class="tag">asymptotic analysis</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2025/01/14/master-theorem/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2025/01/14/master-theorem/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2025/01/14/master-theorem/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2025" /><category term="month-01" /><category term="day-14" /><category term="math" /><category term="recurrence" /><category term="simplified master theorem" /><category term="general master theorem" /><category term="master theorem extension" /><category term="master theorem with logarithmic factor" /><category term="recursive algorithm" /><category term="asymptotic analysis" /><summary type="html"><![CDATA[Learn how to solve recurrence relations using the Master Theorem and its application to recurrences with logarithmic factors. This comprehensive guide covers the step-by-step process of analyzing recursive algorithms to determine their time complexity. We explore how to apply the Master Theorem to different forms of recurrences. The article provides in-depth explanations of the key concepts of the Master Theorem, including Case 1, Case 2, Case 2 extension, and Case 3, and walks you through the conditions required for each case. With practical examples, including detailed solutions, this resource will help you master asymptotic analysis and efficiently determine the runtime of recursive functions.]]></summary></entry><entry xml:lang="en"><title type="html">Deriving Binet’s Formula</title><link href="https://hemimorphite.github.io/zh/2024/12/09/deriving-binets-formula/" rel="alternate" type="text/html" title="Deriving Binet’s Formula" /><published>2024-12-09T08:20:00+00:00</published><updated>2024-12-09T08:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/12/09/deriving-binets-formula</id><content type="html" xml:base="https://hemimorphite.github.io/2024/12/09/deriving-binets-formula/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Deriving Binet's Formula</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published December 09, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/binetformula.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		
        <p>The Fibonacci sequence, one of the most renowned number sequences in mathematics, is named after Leonardo of Pisa, a prominent mathematician of the European Middle Ages. Born in 1170 into the Bonacci family, Leonardo later became known as Fibonacci — a name derived from the Latin phrase Filius Bonacci, meaning "son of Bonacci."</p>

        <p>In his book Liber Abaci (1202), he introduced the now-famous Fibonacci sequence:</p>
		
		<div class="equation-container">
        \[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... \]
        </div>
		
		<p>This sequence arose from an arithmetic problem about counting rabbit pairs, where each term represents the total number of rabbit pairs in a given month. The pattern is that each term is the sum of the two preceding terms. This means the Fibonacci sequence can be defined recursively as follows:</p>
		
		<div class="equation-container">
        \[ F_{0} = 1, F_{1} = 1, F_{n} = F_{n-1} + F_{n-2} \text{ for } n \geq 2 \]
        </div>
		
		<p>It turns out that the Fibonacci sequence also has a closed-form expression, known as Binet's formula. It is given by:</p>
		
		<div class="equation-container">
        \[ F_{n} = \frac{\phi^{n} - \psi^{n}}{\sqrt{5}}, \]
        </div>
		
		<p>where:</p>
		
		<div class="equation-container">
        \[ \phi = \frac{1 + \sqrt{5}}{2}, \quad \psi = \frac{1 - \sqrt{5}}{2}. \]
        </div>
		
		<p>Here, \(\phi\) and \(\psi\) are the roots of the characteristic equation associated with the Fibonacci recurrence relation. Binet's formula provides an exact value for \(F_{n}\) without requiring recursive computation, beautifully connecting the Fibonacci sequence to algebra and the golden ratio.</p>
		
		<p>For any sequence of numbers, there exists an associated generating function that encodes the sequence into a formal power series. Given a sequence \(\{a_n\}_{n=0}^{\infty}\), the generating function \(G(x)\) is defined as:</p>
		
		<div class="equation-container">
        \[ G(x) = \sum_{n=0}^{\infty} a_n x^{n}  \]
        </div>
		
		<p>If we change the sequence by adding \(k\) zeros to the left \(\{0, 0, ..., 0, a_{0}, a_{1}, a_{2}, ... \}\), then the new generating function is \(x^{k}G(x) = a_{0} x^{k} + a_{1} x^{k+1} + a_{2} x^{k+2} + ...\).</p>
		
		<p>Recall that the Fibonacci sequence are defined by the recurrence relation</p>
		
		<div class="equation-container">
        \[ F_{0} = 1, F_{1} = 1, F_{n} = F_{n-1} + F_{n-2} \text{ for } n \geq 2 \]
        </div>
		
		<p>We begin by defining the generating function for the Fibonacci sequence as the formal power series whose coefficients are the Fibonacci sequence themselves,</p>
		
		<div class="equation-container">
        \[ F(x) = \sum_{n=0}^{\infty} F_{n} x^{n} \]
        </div>
		
		<p>When dealing with a recurrence relation like the Fibonacci sequence, where the recurrence starts with two defined initial terms (\(F_{0}\) and \(F_{1}\)), shifting the generating function twice to the right is necessary to properly represent the recurrence algebraically.</p>
		
		<p>We multiply the generating function for the Fibonacci sequence with \(x\) and \(x^{2}\) to shift the terms:</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		F(x)  &= \phantom{ \;\; } F_{0} + F_{1} x + F_{2} x^{2} + F_{3} x^{3} + F_{4} x^{4} + F_{5} x^{5} + F_{6} x^{6} + \dots \\
		xF(x) &= \phantom{F_{0} x +} F_{0} x + F_{1} x^{2} + F_{2} x^{3} + F_{3} x^{4} + F_{4} x^{5} + F_{5} x^{6} + \dots \\
		x^{2}F(x) &= \phantom{F_{0} x + F_{1} x +} F_{0} x^{2} + F_{1} x^{3} + F_{2} x^{4} + F_{3} x^{5} + F_{4} x^{6} + \dots
		\end{aligned}
		\]
        </div>

		<p>When we multiply \(F(x)\) by \(x\), it shifts all terms of the sequence to the right by one position:</p>
		
		<div class="equation-container">
        \[ xF(x) = x\sum_{n=0}^{\infty} F_{n} x^{n} = \sum_{n=0}^{\infty} F_{n} x^{n+1} = \sum_{n=1}^{\infty} F_{n-1} x^{n} \]
        </div>
		
		<p>When we multiply \(F(x)\) by \(x^{2}\), it shifts all terms of the sequence to the right by two positions:</p>
		
		<div class="equation-container">
        \[ x^{2}F(x) = x^{2}\sum_{n=0}^{\infty} F_{n} x^{n} = \sum_{n=0}^{\infty} F_{n} x^{n+2} = \sum_{n=2}^{\infty} F_{n-2} x^{n} \]
        </div>
		
		<p>The initial terms \(F_{0}\) and \(F_{1}\) need to be added explicitly because they are not part of the recurrence relation and subsitute the recurrence relation for \(F_{n}\) into the coefficients of the sum.</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		F(x) &= F_{0} + F_{1} x^{1} + \sum_{n=2}^{\infty} F_{n} x^{n} \\
		&= F_{0} + F_{1} x + \sum_{n=2}^{\infty} \left(F_{n-1} + F_{n-2}\right) x^{n} \\
		&= F_{0} + F_{1} x + \sum_{n=2}^{\infty} F_{n-1} x^{n} + \sum_{n=2}^{\infty} F_{n-2} x^{n} \\
		&= F_{0} + F_{1} x + x\sum_{n=2}^{\infty} F_{n-1} x^{n-1} + x^{2}\sum_{n=2}^{\infty} F_{n-2} x^{n-2} \\
		&= F_{0} + F_{1} x + x\left(\sum_{n=0}^{\infty} F_{n} x^{n} - F_{0}\right) + x^{2}\sum_{n=0}^{\infty} F_{n} x^{n} \\
		&= F_{0} + F_{1} x + x(F(x) - F_{0}) + x^{2} F(x) \\
		&= F_{0} + F_{1} x + x F(x) - F_{0} x + x^{2} F(x)
		\end{aligned}
		\]
        </div>
		
		<p>From the initial conditions \(F_{0} = 0\) and \(F_{1} = 1\), the equation simplifies to:</p>
		
		<div class="equation-container">
        \[ F(x) = x + x F(x) + x^{2} F(x) \]
        </div>
		
		<p>Sovling for the generating function, we get:</p>
		
		<div class="equation-container">
        \[ F(x) = \frac{x}{1 - x - x^{2}} \]
        </div>
		
		<p>Now that we have found a closed form for the generating function, all that remains is to express this function as a power series. After doing so, we may match its coefficients term-by-term with the corresponding Fibonacci numbers. The roots of the polynomial \(1 − x − x^{2}\) are \(-\phi\) and \(-\psi\), where</p>
		
		<div class="equation-container">
        \[ \phi = \frac{1 + \sqrt{5}}{2} \]
        </div>
		
		<p>and</p>
		
		<div class="equation-container">
        \[ \psi = \frac{1 - \sqrt{5}}{2}, \]
        </div>
		
		<p>so the polynomial factors as \(1-x-x^{2}=-(x+\phi)(x+\psi)\).</p>
		
		<p>In order to express the generating function as a power series, we will use the partial fraction decomposition to express it in the form</p>
		
		<div class="equation-container">
        \[ F(x) = -\frac{x}{(x+\phi)(x+\psi)} = \frac{A}{x+\phi} + \frac{B}{x+\psi}, \]
        </div>
		
		<p>which is equivalent to</p>
		
		<div class="equation-container">
        \[ -x = A(x+\psi) + B(x+\phi). \]
        </div>
		
		<p>Letting \(x=-\phi\):</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		-x &= A(x+\psi) + B(x+\phi) \\
		-(-\phi) &= A(-\phi+\psi) + B(-\phi+\phi) \\
		\phi &= A(-\phi+\psi) \\
		A &= \frac{\phi}{\psi-\phi}
		\end{aligned}
		\]
        </div>
		
		<p>Using the fact that \(\psi-\phi=-\sqrt{5}\), we get:</p>
		
		<div class="equation-container">
        \[ A = -\frac{\phi}{\sqrt{5}}. \]
        </div>
		
		<p>Letting \(x=-\psi\):</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		-x &= A(x+\psi) + B(x+\phi) \\
		-(-\psi) &= A(-\psi+\psi) + B(-\psi+\phi) \\
		\psi &= B(-\psi+\phi) \\
		B &= \frac{\psi}{\phi-\psi}
		\end{aligned}
		\]
        </div>
		
		<p>Using the fact that \(\phi-\psi=\sqrt{5}\), we get:</p>
		
		<div class="equation-container">
        \[ B = \frac{\psi}{\sqrt{5}}. \]
        </div>
		
		<p>Now substitute these values of \(A\) and \(B\) into the partial fraction decomposition and we get:</p>
		
		<div class="equation-container">
        \[ F(x) = \frac{1}{\sqrt{5}}\left(\frac{\psi}{x+\psi} - \frac{\phi}{x+\phi}\right). \]
        </div>
		
		<p>Recall that the sum of a geometric series is given by</p>
		
		<div class="equation-container">
        \[ \frac{1}{1-x} = \sum_{n=0}^{\infty} x^{n}, \]
        </div>
		
		<p>assuming \(|x| \lt 1\) for convergence.</p>
		
		<p>The roots \(\phi\) and \(\psi\) are conjugates of each other, and they satisfy the product of the roots relationships:</p>
		
		<div class="equation-container">
        \[ \phi \cdot \psi = -1. \]
        </div>
		
		<p>Using the fact that \(\phi=-\frac{1}{\psi}\), we can rewrite the first term of the generating function as</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		\frac{\psi}{x+\psi} &= \frac{1}{1+\frac{x}{\psi}} \\
		&= \frac{1}{1-\phi x} \\
		&= \sum_{n=0}^{\infty} \phi^{n} x^{n}.
		\end{aligned}
		\]
        </div>
		
		<p>Similarly,</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		\frac{\phi}{x+\phi} &= \frac{1}{1+\frac{x}{\phi}} \\
		&= \frac{1}{1-\psi x} \\
		&= \sum_{n=0}^{\infty} \psi^{n} x^{n}.
		\end{aligned}
		\]
        </div>
		
		<p>so</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		F(x) &= \frac{1}{\sqrt{5}}\left(\frac{\psi}{x+\psi} - \frac{\phi}{x+\phi}\right) \\
		&= \frac{1}{\sqrt{5}}\left(\sum_{n=0}^{\infty} \phi^{n} x^{n} - \sum_{n=0}^{\infty} \psi^{n} x^{n}\right) \\
		&= \sum_{n=0}^{\infty} \frac{1}{\sqrt{5}} (\phi^{n} - \psi^{n}) x^{n}.
		\end{aligned}
		\]
        </div>
		
		<p>Since the definition of \(F(x)\) was</p>
		
		<div class="equation-container">
        \[ F(x) = \sum_{n=0}^{\infty} F_{n} x^{n}, \]
        </div>
		
		<p>we match the coefficients on corresponding powers of \(x\) in these two expressions for \(F(x)\) to finally arrive at the desired closed form for the n-th Fibonacci number,</p>
		
		<div class="equation-container">
        \[ F_{n} = \frac{1}{\sqrt{5}} (\phi^{n} - \psi^{n}). \]
        </div>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/fibonacci" class="tag">fibonacci</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/recurrence-relation" class="tag">recurrence relation</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/generating-function" class="tag">generating function</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/binet-formula" class="tag">binet formula</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2024/12/09/deriving-binets-formula/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2024/12/09/deriving-binets-formula/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2024/12/09/deriving-binets-formula/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-12" /><category term="day-09" /><category term="math" /><category term="fibonacci" /><category term="recurrence relation" /><category term="generating function" /><category term="binet formula" /><summary type="html"><![CDATA[Explore the fascinating derivation of Binet's Formula, a closed-form expression for Fibonacci numbers, using mathematical tools like recurrence relations, generating functions, and properties of the golden ratio.]]></summary></entry><entry xml:lang="en"><title type="html">Recurrence Relations</title><link href="https://hemimorphite.github.io/zh/2024/10/14/recurrence-relations/" rel="alternate" type="text/html" title="Recurrence Relations" /><published>2024-10-14T10:20:00+00:00</published><updated>2024-10-14T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/10/14/recurrence-relations</id><content type="html" xml:base="https://hemimorphite.github.io/2024/10/14/recurrence-relations/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Recurrence Relations</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published October 14, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/recurrencerelation.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3>Recurrence Relation Definition</h3>
		
        <p>Recurrences, or recurrence relations, are equations that define sequences of values using recursion and initial values. Recurrences can be linear or non-linear, homogeneous or non-homogeneous, and first order or higher order.</p>

        <p>For example,</p>
		
		\[ 3, 6, 9, 12, 15, ...\]
		
		<p>For this sequence, the rule is add three.</p>
		
		<p>Each number in a sequence is called a term and is identified by its position within the sequence. We write them as follows:</p>
		
		<ul>
			<li>The first term \(T(1) = 3\)</li>
			<li>The second term \(T(2) = 6\)</li>
			<li>The third term \(T(3) = 9\)</li>
			<li>The fourth term \(T(4) = 12\)</li>
			<li>The nth term \(T(n)\)</li>
		</ul>
		
		<p>To generate this sequence we can use the nnth term formula for the sequence. For this sequence, the \(n\)th term would be \(T(n) = 3n\).</p>
		
		<p>When \(n = 1\), \(T(1) = 3(1) = 3\).</p>
		
		<p>When \(n = 2\), \(T(2) = 3(2) = 6\), and so on.</p>
		
		<p>Another way of generating this sequence would be to use the recurrence relation, where each term is generated using the previous value. These recurrence relations are algorithms and can generate any term in the sequence.</p>
		
		<p>When \(n = 1\), \(T(1) = 3\).</p>
		
		<p>When \(n = 2\), \(T(2) = 3 + 3 = 6\).</p>
		
		<p>When \(n = 3\), \(T(3) = 6 + 3 = 9\), and so on.</p>
		
		<p>Hence, the recurrence equation can be written as the formula:</p>
		
		\[ T(n+1) = T(n) + 3 \]
		
		<p>The initial value, \(T(1)\), would need to be provided. The initial value could also be \(T(0)\).</p>
		
		<p>A recurrence relation for a sequence \(T(1), T(2), ..., T(n)\) is a formula that calculates each term \(T(k)\) in terms of \(T(k-1), T(k-2), ..., T(k-i)\) for some integer \(i\). The initial conditions for a recurrence relation specify values for \(T(1), T(2), ..., T(k-1)\).</p>
		
		<h3>Classifying Recurrence Relations</h3>
		
		<p>Recurrence relations are often classified based on how the terms are combined, the nature of their coefficients, and the number and nature of the previous terms involved. Below is a breakdown of the key classifications for recurrence relations:</p>
		
		<h4>1. By the Number of Previous Terms Used</h4>
		
		<h5>1.1. First-Order Recurrence Relations</h5>
		
		<p>In first-order recurrence relations, only the immediately previous term is used to compute the next term. These relations are the simplest type and are often easy to solve.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n-1) \]
		
		<p>In this example, the next term is twice the previous term.</p>
		
		<h6>Example 2: First-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n-1) + n \]
		
		<p>In this example, the next term depends on the previous term plus an additional term \(n\).</p>
		
		<h5>1.2. Second-Order Recurrence Relations</h5>
		
		<p>In second-order recurrence relations, the next term depends on the two previous terms. These relations are more complex than first-order ones, and the solution method is different (e.g., using the characteristic equation).</p>
		
		<h6>Example 1: Second-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n-1) + 3T(n-2) \]
		
		<p>In this example, the next term is calculated based on a linear combination of the two previous terms.</p>
		
		<h6>Example 2: Second-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n−1) + T(n−2) + 1 \]
		
		<p>In this example, the next term is calculated based on a linear combination of the two previous terms plus an additional term (a constant value).</p>
		
		<h5>1.3. Higher-Order Recurrence Relations</h5>
		
		<p>In higher-order recurrence relations, the next term depends on three or more previous terms. These relations are even more complex and often require advanced techniques (such as matrix methods or generating functions) for solving.</p>
		
		<h6>Example 1: Higher-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n-1) + T(n-2) + T(n-3) \]
		
		<p>In this example, the next term is calculated based on a linear combination of the three previous terms.</p>
		
		<h6>Example 2: Higher-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n-1) + 3T(n−2) + T(n−3) + n^{2} \]
		
		<p>In this example, the next term depends on a combination of the previous three terms and a quadratic function of \(n\).</p>
		
		<h4>2. By the Nature of the Coefficients</h4>
		
		<h5>2.1. Constant-Coefficient Recurrence Relations</h5>
		
		<p>In Constant-Coefficient Recurrence Relations, the coefficients multiplying the previous terms are constant (i.e., they do not depend on nn). This is the most common type of recurrence relation and is often easier to solve.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) \]
		
		<p>In this example, the next term depends on a linear combination of the previous term with constant coefficients.</p>
		
		<h6>Example 2: Second-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n−1) + 3T(n−2) + 1 \]
		
		<p>In this example, the next term depends on a linear combination of the previous terms with constant coefficients, and an additional unit (such as a constant value) is added at each step.</p>
		
		<h5>2.2. Variable-Coefficient Recurrence Relations</h5>
		
		<p>In Variable-Coefficient Recurrence Relations, the coefficients multiplying the previous terms are functions of \(n\) (i.e., they change as \(n\) increases). These are generally more complex than constant-coefficient recurrences.</p>
		
		<h6>Example 1: First-Order Variable-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = nT(n-1) \]
		
		<p>In this example, the next term depends on the previous term with variable coefficient.</p>
		
		<h6>Example 2: Second-Order Variable-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = (n-1)T(n−1) + nT(n−2) + 1 \]
		
		<p>In this example, the next term depends on the previous terms with variable coefficients, and an additional unit (such as a constant value) is added at each step.</p>
		
		<h4>3. By the Combination of Terms</h4>
		
		<h5>3.1. Linear Recurrence Relations</h5>
		
		<p>In linear recurrence relations, a sequence is defined using linear combinations of its previous terms.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) + 2T(n-2) \]
		
		<p>In this example, the next term depends on a linear combination of the two previous terms with constant coefficients.</p>
		
		<h5>3.1. Nonlinear Recurrence Relations</h5>
		
		<p>In nonlinear recurrence relations, a sequence is defined based on one or more previous terms, using a nonlinear operations (e.g., squaring, multiplying, taking powers, etc.).</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Nonlinear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n-1)^{2} + n \]
		
		<p>In this example, the next term depends on the non-linear previous term which is squared and a additional term.</p>
		
		<h4>4. By the Presence of additional terms</h4>
		
		<h5>4.1. Homogeneous Recurrence Relations</h5>
		
		<p>In homogeneous recurrence relations, a sequence is defined based on its previous terms, and it relies solely on the values of those terms without any additional independent term.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) + 2T(n-2) \]
		
		<p>In this example, the next term depends on a linear combination of the two previous terms with constant coefficients and there are no additional independent terms.</p>
		
		<h5>4.2. Non-Homogeneous Recurrence Relations</h5>
		
		<p>In non-homogeneous recurrence relations, a sequence is defined based on its previous terms, and it includes additional independent terms.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) + 2T(n-2) + n \]
		
		<p>In this example, the next term depends on a linear combination of the two previous terms with constant coefficients plus the additional independent term.</p>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/recurrence-relation" class="tag">recurrence relation</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/recursion" class="tag">recursion</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2024/10/14/recurrence-relations/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2024/10/14/recurrence-relations/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2024/10/14/recurrence-relations/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-10" /><category term="day-14" /><category term="math" /><category term="recurrence relation" /><category term="recursion" /><summary type="html"><![CDATA[Explore the fundamentals of recurrence relations, a key concept in mathematics and algorithm design. This guide introduces different types of recurrence relations, including linear, divide-and-conquer, and homogeneous recurrences.]]></summary></entry><entry xml:lang="en"><title type="html">Singly Linked List Data Structure</title><link href="https://hemimorphite.github.io/zh/2024/10/14/singly-linked-list-data-structure/" rel="alternate" type="text/html" title="Singly Linked List Data Structure" /><published>2024-10-14T10:20:00+00:00</published><updated>2024-10-14T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Singly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published October 14, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/singlylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Singly Linked List</h3>
		
        <p>A singly linked list is a linear data structure consisting of a sequence of elements, called nodes, where each node points to the next node in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations. Each node contains two fields:</p>

        <ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence.</li>
		</ul>

        <p>The singly linked list forms a linear collection of elements where each node points to its successor, and the last node points to <code>NULL</code>, indicating the end of the list. It is a dynamic data structure, meaning it can grow or shrink in size during runtime, as nodes can be added or removed without requiring memory to be reallocated.</p>
		
		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. If the list is empty, the head points to <code>NULL</code>.</p>
		
		<p>Unlike arrays that have a fixed size, a singly linked list dynamically allocates memory for each node when it is created. This means the size of the list can grow or shrink as nodes are added or removed at runtime.</p>
		
		<p>Insertions and deletions of nodes, particularly at the beginning or middle of the list, are more efficient compared to arrays since you do not need to shift elements.</p>
		
		<p>Singly linked lists can only be traversed in one direction, from the head to the tail. There is no way to traverse backward from the tail to the head, which can be a limitation in some use cases.</p>
		
		<p>The nodes in a singly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next through pointers, and they can be located anywhere in memory.</p>
		
		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>
		
		<p>Each node in a singly linked list requires extra memory for the pointer (next reference), which slightly increases memory usage compared to arrays.</p>
		
		<p>The last node in a singly linked list is called the tail. Its next pointer is set to <code>NULL</code>, indicating that it is the end of the list.</p>
		
		<p>Here's a visual representation of a singly linked list:</p>
		
		<pre><code class="language-bash hljs">Head -&gt; [Data | Next] -&gt; [Data | Next] -&gt; [Data | NULL]</code></pre>
		
		<p>In the above representation:</p>
		
		<ul>
			<li>The <code>Head</code> points to the first node of the list.</li>
			<li>Each node contains <code>Data</code> and a <code>Next</code> pointer to the next node.</li>
			<li>The last node in the list has its <code>Next</code> pointer set to <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>A simple singly linked list with three nodes could look like this:</p>
		
		<pre><code class="language-bash hljs">Head -> [10 | Next] -> [20 | Next] -> [30 | NULL]</code></pre>
		
		<p>In the above example:</p>
		
		<ul>
			<li>The head points to the first node containing the data <code>10</code>.</li>
			<li>The second node contains the data <code>20</code> and points to the third node.</li>
			<li>The third node contains the data <code>30</code> and points to <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common singly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [5 | Next] -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>If the list is not empty, set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list). If the list is empty, set the <code>next</code> pointer of the new node to point to <code>NULL</code>.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; [40 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning. The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node <code>NULL</code>, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer is <code>NULL</code>).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [25 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertBeforeNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node before a given node in a singly linked list. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> before the node containing <code>20</code>. After calling <code>insertBeforeNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [25 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node before a node in a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Update the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node before a node in a singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [35 | NULL] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Update the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a new node at a specified position in a linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the beginning of a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Set the head pointer to the next node</li>
							<li>Deallocate the memory for the old head node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the second-to-last node.</li>
							<li>Update the <code>next</code> pointer of the second-to-last node to <code>null</code>.</li>
							<li>Deallocate the memory for the old last node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position to delete is 0, it means the head node should be removed. If the specified position is out of bounds, and a message is printed.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to remove a node at position <code>3</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the node before the target position.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the node after the target node.</li>
							<li>Deallocate the memory for the removed node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a singly linked list and perform an action, such as printing the node's value.</li>
					<li><b>Time complexity</b>: The time complexity of traverse function in a linked list is \(O(n)\) (linear time). The function iterates through each node in the linked list exactly once, from the head to the end (<code>NULL</code>). Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of traverse function in a linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>
			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [30 | Next] -&gt; [20 | Next] -&gt; [10 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of reverse function in a linked list is \(O(n)\) (linear time). The function traverses each node of the linked list exactly once. Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of reverse function in a linked list is \(O(1)\) (constant space).  The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes. This amount of space does not depend on the size of the linked list.</li>
				</ul>
			</li>
			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a singly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of search function in a singly linked list is \(O(n)\) (linear time).The search function traverses the linked list node by node. In the worst case, it may need to look at every node in the list to find the key (or determine that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of search function in a singly linked list is \(O(1)\) (constant space). The function uses a constant amount of extra space to store variables, such as pointers for the current node. The space required does not depend on the size of the list because the function does not use any additional data structures or dynamic memory allocations for the search process.</li>
				</ul>
			</li>
			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a singly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of size function in a singly linked list is \(O(n)\) (linear time). The function traverses the entire linked list to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of size function in a singly linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a singly linked list at a specified index. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of get function in a singly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of get function in a singly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a singly linked list. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of set function in a singly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of set function in a singly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a singly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of isEmpty function in a singly linked list is \(O(1)\) (constant time). The <code>isEmpty</code> function checks whether the head pointer of the linked list is <code>NULL</code>. This operation is performed in constant time since it only involves a simple comparison, regardless of the size of the linked list.</li>
					<li><b>Space complexity</b>: The space complexity of isEmpty function in a singly linked list is \(O(1)\) (constant space). The function uses a fixed amount of space to store the result of the comparison (typically a boolean value), regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted linked lists into a single sorted linked list. </li>
					<li><b>Time complexity</b>: The time complexity of merge function in a singly linked list is \(O(n + m)\) (linear time). The reason for this complexity is that each node from both lists is visited exactly once. In the worst case, the function will traverse both lists entirely, performing comparisons and linking nodes. Where \(n\) is the number of nodes in the first linked list and \(m\) is the number of nodes in the second linked list.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a singly linked list is \(O(n + m)\) (linear space) due to the call stack storing recursive calls. In the worst case, the maximum depth of recursion will be equal to the total number of nodes in both lists combined, leading to \(n + m\) recursive calls.</li>
				</ul>
			</li>
			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a singly linked list, in a specific order (typically ascending or descending).</li>
					<li><b>Time complexity</b>: The time complexity of sort function in a singly linked list, when using merge sort is \(O(n \log n)\) (linearithmic time) because the algorithm consistently divides the list into halves and requires a linear amount of time \(O(n)\) to merge those halves back together. The logarithmic factor \(\log n\) comes from the number of times the list can be divided in half (depth of recursion).</li>
					<li><b>Space complexity</b>: The space complexity of sort function in a singly linked list, specifically Merge Sort, is \(O(n)\) (linear space) because it requires additional space for the temporary arrays or linked lists used during the merge process. When merging two halves, the algorithm needs space to hold the merged elements before copying them back to the original array or linked list.</li>
				</ul>
			</li>
			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from the list and free up the memory they occupy, effectively making the list empty.</li>
					<li><b>Time complexity</b>: The time complexity of clear function in a singly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, freeing its memory. Since it processes all nodes in the list, the time complexity is proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of clear function in a singly linked list is \(O(1)\) (constant space). The function only requires a fixed amount of extra memory for the iteration, typically for a pointer to traverse the list. No additional memory structures are needed, regardless of the size of the linked list.</li>
				</ul>
			</li>
        </ul>
		
		<h3 class="post-subtitle">Non-Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// defines a structure to represent a node in a singly linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    newNode-&gt;next = *headRef;
    *headRef = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }
	
	Node* newNode = createNode(data);
	
    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }
    
	if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }
	
	Node* newNode = createNode(data);
	
    // If the nextNode is the head node, handle the insertion at beginning
    if (*headRef == nextNode) {
        newNode-&gt;next = *headRef;
        *headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = *headRef;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    // If position is at the beginning
    if (position == 0) {
        newNode-&gt;next = *headRef;
        *headRef = newNode;
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes
    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = *headRef;
    *headRef = (*headRef)-&gt;next;
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    
    // If there's only one node in the list
    if (temp-&gt;next == NULL) {
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the second last node
    while (temp-&gt;next-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    // Free the last node
    free(temp-&gt;next);
    temp-&gt;next = NULL;
}

// Function to delete a node at a specific position (0-based index)
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    // If head needs to be removed
    if (position == 0) {
        *headRef = temp-&gt;next; // Change head
        free(temp); // Free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    // If position is more than number of nodes
    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nextNode = temp-&gt;next-&gt;next;
    free(temp-&gt;next); // Free memory
    temp-&gt;next = nextNode; // Unlink the deleted node from the list
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d -&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp-&gt;data == key)
            return 1; // Key found
        temp = temp-&gt;next;
    }
    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** headRef) {
    Node *prev = NULL, *current = *headRef, *next = NULL;
    while (current != NULL) {
        next = current-&gt;next; // Store next
        current-&gt;next = prev; // Reverse current node's pointer
        prev = current;       // Move pointers one position ahead
        current = next;
    }
    *headRef = prev;
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
		//while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;data); // Create a new node
            *headRef = newNode;
            //headRef = &((*headRef)-&gt;next);
            //head2 = head2-&gt;next;
			merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        //}
        return;
    }
    if (head2 == NULL) {
        //while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;data); // Create a new node
            *headRef = newNode;
            //headRef = &((*headRef)-&gt;next);
            //head1 = head1-&gt;next;
			merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        //}
        return;
    }

    if (head1-&gt;data &lt;= head2-&gt;data) {
        Node* newNode = createNode(head1-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
    } else {
        Node* newNode = createNode(head2-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
    }
}
// Function to get the middle of the linked list
void middle(Node** mid, Node* head) {
    if (head == NULL) return;
    
    Node* slow = head;
    Node* fast = head-&gt;next;
    
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    
    *mid = slow; // Update the pointer to the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;
  
    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}

// Function to clear the entire linked list and free memory
void clear(Node** headRef) {
    Node* current = *headRef;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *headRef = NULL;
}

// Main function to test the linked list operations
int main() {
    Node* list = NULL; // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}


    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }

    // 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);

    // 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);

    // 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == nullptr) {
        std::cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        std::cout &lt;&lt; "The list cannot be empty" &lt;&lt; std::endl;
        return;
    }

    if (nextNode == nullptr) {
        std::cout &lt;&lt; "The given next node cannot be NULL" &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // If the nextNode is the head node, handle the insertion at the beginning
    if (headRef == nextNode) {
        newNode-&gt;next = headRef;
        headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = headRef;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        std::cout &lt;&lt; "The given next node is not found in the list" &lt;&lt; std::endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);
    if (position == 0) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}


// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    head = head-&gt;next;
    delete temp;
}


// Delete at the end
void deleteAtEnd(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node* temp = head;
    while (temp-&gt;next-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    delete temp-&gt;next;
    temp-&gt;next = nullptr;
}


// Delete at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node* temp = head;
        head = head-&gt;next;
        delete temp;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    cout &lt;&lt; "Index out of range\n"; // Handle case where index exceeds list length
}

// Function to check if the list is empty
bool isEmpty(Node* head) {
    return head == nullptr;
}

// Traverse the list
void traverse(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}


// Search for an element
bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    }
    return false;
}


// Reverse the list
void reverse(Node*& head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;

    while (current != nullptr) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    head = prev;
}


// Get the size of the list
int size(Node* head) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Merge two sorted lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        if (head2 != nullptr) {
            //std::cout &lt;&lt; "head1 is null, adding node from head2 with data: " &lt;&lt; head2-&gt;data &lt;&lt; std::endl;
            headRef = new Node(head2-&gt;data);
            merge(headRef-&gt;next, head1, head2-&gt;next); // Continue merging head2
        }
        return;
    }
    if (head2 == nullptr) {
        if (head1 != nullptr) {
            //std::cout &lt;&lt; "head2 is null, adding node from head1 with data: " &lt;&lt; head1-&gt;data &lt;&lt; std::endl;
            headRef = new Node(head1-&gt;data);
            merge(headRef-&gt;next, head1-&gt;next, head2); // Continue merging head1
        }
        return;
    }

    // Merge the two lists
    if (head1-&gt;data &lt;= head2-&gt;data) {
        //std::cout &lt;&lt; "Choosing node from head1 with data: " &lt;&lt; head1-&gt;data &lt;&lt; std::endl;
        headRef = new Node(head1-&gt;data);
        merge(headRef-&gt;next, head1-&gt;next, head2); // Move head1 forward
    } else {
        //std::cout &lt;&lt; "Choosing node from head2 with data: " &lt;&lt; head2-&gt;data &lt;&lt; std::endl;
        headRef = new Node(head2-&gt;data);
        merge(headRef-&gt;next, head1, head2-&gt;next); // Move head2 forward
    }
}


// Find the middle of the list
void middle(Node*& mid, Node* head) {
    if (head == nullptr) {
        mid = nullptr;
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != nullptr && fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    mid = slow;
}


// Sort the list using merge sort
void sort(Node*& head) {
    if (head == nullptr || head-&gt;next == nullptr)
        return;

    Node* mid = nullptr;
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;

    Node* left = head;
    Node* right = nextToMid;

    sort(left);
    sort(right);

    merge(head, left, right);
}

// Clear the list
void clear(Node*& head) {
    Node* current = head;
    while (current != nullptr) {
        Node* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

int main() {
    Node* list = nullptr;  // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    std::cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    std::cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(list, 4, 2);

    std::cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    std::cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    std::cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(list);

    std::cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(list);

    std::cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(list, 2);

    std::cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);
	
	// 9. Check if the list is empty
    if (isEmpty(list)) {
        cout &lt;&lt; "The list is empty." &lt;&lt; endl;
    } else {
		cout &lt;&lt; "The list is not empty." &lt;&lt; endl;
	}
	
    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; std::endl;
    }

    // 11. Reverse the list
    reverse(list);

    std::cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // 12. Sort the list
    sort(list);

    std::cout &lt;&lt; "List after sorting: ";
    traverse(list);

    // 13. Get the size of the list
    std::cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; std::endl;

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        std::cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Index " &lt;&lt; index &lt;&lt; " is out of range." &lt;&lt; std::endl;
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    std::cout &lt;&lt; "List after setting value 10 at index 2: ";
    traverse(list);

    // 16. Clear the list
    clear(list);

    std::cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class LinkedList {

    // Node structure for singly linked list
    static class Node {
        int data;
        Node next;

        // Constructor to create a new node
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        Node newNode = new Node(data);
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }
	
	// Insert after a given node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be NULL.");
            return;
        }

        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }

    // Insert before a given node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (head == null) {
            System.out.println("The list cannot be empty");
            return head;
        }

        if (nextNode == null) {
            System.out.println("The given next node cannot be NULL");
            return head;
        }

        Node newNode = new Node(data);

        if (head == nextNode) {
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        while (temp != null && temp.next != nextNode) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("The given next node is not found in the list");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }
	
    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        return head.next;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node temp = head;
        while (temp.next.next != null) {
            temp = temp.next;
        }
        temp.next = null;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return head.next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        temp.next = temp.next.next;
        return head;
    }
	
	// Get element at a specific index
    public static int get(Node head, int index) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
        return -1; // Return -1 if the index is out of range
    }

    // Set element at a specific index
    public static void set(Node head, int index, int newValue) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
    }

    // Traverse the list
    public static void traverse(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " -> ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }
	
	// Check if the list is empty
	public static boolean isEmpty(Node head) {
		return head == null;
	}

    // Search for an element
    public static boolean search(Node head, int key) {
        Node temp = head;
        while (temp != null) {
            if (temp.data == key) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node reverse(Node head) {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }
	
	// Merge two sorted lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.data &lt;= head2.data) {
            head1.next = merge(head1.next, head2);
            return head1;
        } else {
            head2.next = merge(head1, head2.next);
            return head2;
        }
    }

    // Find the middle of the list
    public static Node middle(Node head) {
        if (head == null) return null;

        Node slow = head;
        Node fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == null) return head;

        // Find the middle node
        Node mid = middle(head);
        Node nextToMid = mid.next;
        mid.next = null;

        // Recursively split and sort both halves
        Node left = sort(head);
        Node right = sort(nextToMid);

        // Merge the sorted halves
        return merge(left, right);
    }
	
    // Get the size of the list
    public static int size(Node head) {
        int count = 0;
        Node temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the entire list
	public static Node clear(Node head) {
		Node current = head;
		while (current != null) {
			Node nextNode = current.next;  // Save reference to the next node
			current.next = null;           // Break the link to the next node
			current = nextNode;            // Move to the next node
		}
		return null;  // Set head to null to indicate the list is empty
	}


    // Main method to test
    public static void main(String[] args) {
        Node head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // 2. Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // 3. Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		
		// 4. Insert after a specific node
        insertAfterNode(head.next, 8);
        System.out.println("List after inserting 8 after second node: ");
        traverse(head);

        // 5. Insert before a specific node
        head = insertBeforeNode(head, head.next, 12);
        System.out.println("List after inserting 12 before second node: ");
        traverse(head);
		
        // 6. Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // 7. Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // 8. Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);
		
		// 9. Check if the list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}
	
        // 10. Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // 11. Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // 12. Get the size of the list
        System.out.println("Size of the list: " + size(head));
		
		// 13. Get element at a specific index
		int indexToGet = 2;
		int value = get(head, indexToGet);
		if (value != -1) {
			System.out.println("Element at index " + indexToGet + ": " + value);
		}

		// 14. Set value at a specific index
		int indexToSet = 1;
		int newValue = 25;
		System.out.println("Setting value at index " + indexToSet + " to " + newValue);
		set(head, indexToSet, newValue);
		
		System.out.println("Updated list after set operation:");
		traverse(head);
	
		// 15. Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
		traverse(head);
		
        // 16. Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-java hljs">using System;

public class LinkedList
{
    // Node structure for singly linked list
    public class Node
    {
        public int Data;
        public Node Next;

        // Constructor to create a new node
        public Node(int data)
        {
            Data = data;
            Next = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data)
        {
            Next = head
        };
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.Next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }
	
	// Insert after a given node
    public static void InsertAfterNode(Node prevNode, int data)
    {
        if (prevNode == null)
        {
            Console.WriteLine("The given previous node cannot be null");
            return;
        }
        Node newNode = new Node(data);
        newNode.Next = prevNode.Next;
        prevNode.Next = newNode;
    }

    // Insert before a given node
    public static Node InsertBeforeNode(Node head, Node nextNode, int data)
    {
        if (nextNode == null)
        {
            Console.WriteLine("The given next node cannot be null");
            return head;
        }
        if (head == nextNode)
        {
            return InsertAtBeginning(head, data);
        }
        Node temp = head;
        while (temp != null && temp.Next != nextNode)
        {
            temp = temp.Next;
        }
        if (temp == null)
        {
            Console.WriteLine("The given next node is not present in the list");
            return head;
        }
        Node newNode = new Node(data);
        newNode.Next = nextNode;
        temp.Next = newNode;
        return head;
    }


    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        return head.Next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.Next.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = null;
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return head.Next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null || temp.Next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        temp.Next = temp.Next.Next;
        return head;
    }
	
	// Function to access an element at a specific index (0-based)
	public static int Get(Node head, int index)
	{
		int count = 0;
		Node temp = head;
		while (temp != null)
		{
			if (count == index)
				return temp.Data;
			count++;
			temp = temp.Next;
		}
		Console.WriteLine("Index out of range");
		return -1; // Index out of range
	}

	// Function to set an element at a specific index (0-based)
	public static void Set(Node head, int index, int newValue)
	{
		Node current = head;
		int count = 0;

		// Traverse the list until the specified index
		while (current != null)
		{
			if (count == index)
			{
				current.Data = newValue; // Update the node's value
				return;                 // Exit the function after the update
			}
			count++;
			current = current.Next;     // Move to the next node
		}

		Console.WriteLine("Index out of range"); // Handle case where index exceeds list length
	}
	
	// Check if the list is empty
	public static bool IsEmpty(Node head)
	{
		return head == null;
	}

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " -> ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, int key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.Data == key)
            {
                return true;
            }
            temp = temp.Next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null)
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }
	
	 // Merge two sorted lists
    public static Node Merge(Node head1, Node head2)
    {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.Data &lt;= head2.Data)
        {
            head1.Next = Merge(head1.Next, head2);
            return head1;
        }
        else
        {
            head2.Next = Merge(head1, head2.Next);
            return head2;
        }
    }

    // Find the middle of the list
    public static Node Middle(Node head)
    {
        if (head == null) return null;

        Node slow = head;
        Node fast = head;

        while (fast.Next != null && fast.Next.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node Sort(Node head)
    {
        if (head == null || head.Next == null)
            return head;

        // Find the middle of the list
        Node middle = Middle(head);
        Node nextToMiddle = middle.Next;

        // Split the list into two halves
        middle.Next = null;

        // Recursively sort the two halves
        Node left = Sort(head);
        Node right = Sort(nextToMiddle);

        // Merge the sorted halves
        return Merge(left, right);
    }
	
    // Clear the entire list
	public static Node Clear(Node head)
	{
		Node current = head;
		while (current != null)
		{
			Node nextNode = current.Next;  // Save reference to the next node
			current.Next = null;           // Break the link to the next node
			current = nextNode;            // Move to the next node
		}
		return null;  // Return null to indicate the list is empty
	}


    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning:");
        Traverse(head);

        // 2. Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end:");
        Traverse(head);

        // 3. Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2:");
        Traverse(head);

        // 4. Insert after a specific node
        InsertAfterNode(head.Next, 8);
        Console.WriteLine("List after inserting 8 after second node:");
        Traverse(head);

        // 5. Insert before a specific node
        head = InsertBeforeNode(head, head.Next, 12);
        Console.WriteLine("List after inserting 12 before second node:");
        Traverse(head);

        // 6. Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning:");
        Traverse(head);

        // 7. Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end:");
        Traverse(head);

        // 8. Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2:");
        Traverse(head);
		
		// 9. Check if the list is empty
		if (IsEmpty(head))
		{
			Console.WriteLine("The list is empty.");
		}
		else
		{
			Console.WriteLine("The list is not empty.");
		}

        // 10. Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine($"Element {key} found in the list");
        }
        else
        {
            Console.WriteLine($"Element {key} not found in the list");
        }

        // 11. Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing:");
        Traverse(head);

        // 12. Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));
		
		// 13. Get value at a specific index
		int indexToGet = 2;  // 0-based index
		int value = Get(head, indexToGet);
		Console.WriteLine($"Value at index {indexToGet}: {value}");

		// 14. Set a new value at a specific index
		int indexToSet = 2;  // 0-based index
		int newValue = 99;
		Set(head, indexToSet, newValue);

		Console.WriteLine($"List after setting index {indexToSet} to {newValue}:");
		Traverse(head);
	
        // 15. Sort the list
        head = Sort(head);
        Console.WriteLine("Sorted list:");
        Traverse(head);

        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing:");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for singly linked list
typedef struct Node {
    StackElement element;
    struct Node* next;     // Pointer to the next node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    newNode-&gt;next = *head;
    *head = newNode;
}

// Function to insert a node at the end of the list (generic)
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a node after a given previous node
void insertAfterNode(Node* prevNode, StackElement element) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // Insert the new node after prevNode
    newNode->next = prevNode->next;
    prevNode->next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    // Check if the head is NULL (list is empty)
    if (*head == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    // Check if the nextNode is NULL
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the nextNode is the head node, handle the insertion at beginning
    if (*head == nextNode) {
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    // If temp is NULL, then nextNode is not found in the list
    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position
void insertAtPosition(Node** head, StackElement element, int position) {
    Node* newNode = createNode(element);
    
    // If position is at the beginning
    if (position == 0) {
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes
    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *head;           // Temporary pointer to the head node
    *head = (*head)-&gt;next;        // Move the head to the next node
    
    free(temp);                   // Free the node
}

/// Function to delete a node at the end of the list
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    // If there's only one node in the list
    if (temp-&gt;next == NULL) {
        free(temp);                 // Free the node
        *head = NULL;
        return;
    }

    // Traverse to the second last node
    while (temp-&gt;next-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    free(temp-&gt;next);                 // Free the last node
    temp-&gt;next = NULL;                // Set the second last node's next to NULL
}

// Function to delete a node at a given position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    // If head needs to be removed
    if (position == 0) {
        *head = temp-&gt;next; // Change head
        free(temp); // Free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    // If position is more than number of nodes
    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nextNode = temp-&gt;next-&gt;next;

    free(temp-&gt;next);                 // Free the node
    temp-&gt;next = nextNode;            // Unlink the deleted node from the list
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        char* str = temp-&gt;element.toString;
        printf("%s -&gt; ", str);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    Node* temp = head;

    while (temp != NULL) {
        // Call toString to get the string representation of the data in the current node
        char* currentStr = temp-&gt;element.toString;
        char* keyStr = keyElement.toString;

        // Compare the string representations of the current node's data and the key element's data
        if (strcmp(currentStr, keyStr) == 0) {
            return 1; // Key found
        }
		
        temp = temp-&gt;next;
    }

    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** head) {
    Node *prev = NULL, *current = *head, *next = NULL;
    while (current != NULL) {
        next = current-&gt;next; // Store next
        current-&gt;next = prev; // Reverse current node's pointer
        prev = current;       // Move pointers one position ahead
        current = next;
    }
    *head = prev;
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;element;
        count++;
        temp = temp-&gt;next;
    }
    StackElement emptyElement = {NULL, ""};
    return emptyElement; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head2 = head2-&gt;next;
        }
        return;
    }
    if (head2 == NULL) {
        while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head1 = head1-&gt;next;
        }
        return;
    }

    if (strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt; 0) {
        Node* newNode = createNode(head1-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
    } else {
        Node* newNode = createNode(head2-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
    }
}

// Function to get the middle of the linked list
void middle(Node* head, Node** middle) {
    if (head == NULL) {
        *middle = NULL; // Set middle node to NULL if list is empty
        return;
    }

    Node* slow = head;
    Node* fast = head->next;

    while (fast != NULL) {
        fast = fast->next;
        if (fast != NULL) {
            slow = slow->next;
            fast = fast->next;
        }
    }

    *middle = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
	middle(head, &mid);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;

    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


// Function to clear the entire linked list and free memory
void clear(Node** head) {
    Node* current = *head;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *head = NULL;
}

struct Person {
    char name[20];
    int age;
};

// Main function to test the linked list operations
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements at the beginning**
    insertAtBeginning(&personList, personElement1);
    insertAtBeginning(&personList, personElement2);
	
	// 2. **Insert elements at the beginning**
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 3. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 4. **Insert before a node**
    insertBeforeNode(&personList, personList->next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 5. **Insert after a node**
    insertAfterNode(personList->next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 6. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 7. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 8. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 9. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 10. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 11. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 12. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 13. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 14. **Sort the linked list**
    printf("\nList before sorting:\n");
    traverse(personList);
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 15. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 16. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for singly linked list template
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    
    if (head == nextNode) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "The given next node is not found in the list\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    head = head-&gt;next;
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    delete temp-&gt;next;
    temp-&gt;next = nullptr;
}

// Delete at a specific position
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node&lt;T&gt;* temp = head;
        head = head-&gt;next;
        delete temp;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node&lt;T&gt;* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " -&gt; ";  // Using toString()
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Search for an element
template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    }
    return false;
}

// Reverse the list
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* prev = nullptr;
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* next = nullptr;

    while (current != nullptr) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    head = prev;
}

// Get the size of the list
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    int count = 0;
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Function to access an element at a specific index (0-based)
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    int count = 0;
    Node&lt;T&gt;* temp = head;

    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data; // Return the data at the index
        count++;
        temp = temp-&gt;next;
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to set an element at a specific index (0-based)
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    Node&lt;T&gt;* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = element; // Update the node's value
            return;                  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;     // Move to the next node
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to check if the list is empty
template &lt;typename T&gt;
bool isEmpty(Node&lt;T&gt;* head) {
    return head == nullptr;
}

// Function to merge two lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    // Merge the two lists based on data comparison (using &lt; operator)
    if (head1-&gt;data &lt; head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
    }
}

// Function to find the middle node of the linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;* head, Node&lt;T&gt;*& mid) {
    if (head == nullptr) {
        mid = nullptr; // Set middle node to nullptr if the list is empty
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head-&gt;next;

    while (fast != nullptr) {
        fast = fast-&gt;next;
        if (fast != nullptr) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    mid = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    if (headRef == nullptr || headRef-&gt;next == nullptr)
        return;

    Node&lt;T&gt;* mid = nullptr;
    middle(headRef, mid);
    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;

    // Sort the two halves
    sort(headRef);
    sort(nextToMid);

    // Merge the sorted halves
    Node&lt;T&gt;* mergedHead = nullptr;
    merge(mergedHead, headRef, nextToMid);
    headRef = mergedHead; // Update the original head reference
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    while (current != nullptr) {
        Node&lt;T&gt;* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;(const Person& other) const {
        if (name == other.name) {
            return age &lt; other.age;  // If names are the same, sort by age
        }
        return name &lt; other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};

// Testing the Person class with merge
int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // 1. Insert elements at the beginning
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
	
	// 2. Insert elements at the beginning
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // 3. Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // 4. Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    Person george("George", 32);
    insertBeforeNode(head, secondNode, george);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // 5. Insert after a node (insert after the second node)
    Person joyce("Joyce", 27);
    insertAfterNode(secondNode, joyce);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // 6. Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // 7. Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);
	
	// 8. Delete at a specific position
	deleteAtPosition(head, 2);
    cout &lt;&lt; "\nList after deleting node at position 2:\n";
    traverse(head);
	
    // 9. Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // 10. Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;
	
	// 11. Check if list is empty
	if (isEmpty(head)) {
		cout &lt;&lt; "The linked list is empty.\n";
	} else {
		cout &lt;&lt; "The linked list is not empty.\n";
	}

    // 12. Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 13. Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 14. Sort the linked list (by name first, then by age)
    sort(head);
    cout &lt;&lt; "\nList after sorting:" &lt;&lt; endl;
    traverse(head);
	
	// 15. Reverse the list
    reverse(head);

    cout &lt;&lt; "\nReversed List:" &lt;&lt; endl;
    traverse(head);


	// 16. Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
	
    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class LinkedList&lt;T&gt; {

    // Node structure for singly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head == null) {
            return newNode;
        }
        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; head, T data, int position) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Insert before a specific node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data) {
        if (head == null) return null;

        if (head == targetNode) {
            return insertAtBeginning(head, data);
        }

        Node&lt;T&gt; temp = head;
        while (temp != null && temp.next != targetNode) {
            temp = temp.next;
        }

        if (temp != null) {
            Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
            newNode.next = temp.next;
            temp.next = newNode;
        }
        return head;
    }

    // Insert after a specific node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; node, T data) {
        if (node == null) return;

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = node.next;
        node.next = newNode;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        return head.next;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node&lt;T&gt; temp = head;
        while (temp.next.next != null) {
            temp = temp.next;
        }
        temp.next = null;
        return head;
    }
	
	// Delete at a specific position
	public static &lt;T&gt; Node&lt;T&gt; deleteAtPosition(Node&lt;T&gt; head, int position) {
		if (head == null) {
			System.out.println("List is empty");
			return null;
		}

		if (position == 0) {
			return head.next;
		}

		Node&lt;T&gt; temp = head;
		for (int i = 0; i &lt; position - 1 && temp.next != null; i++) {
			temp = temp.next;
		}

		if (temp.next == null) {
			System.out.println("Position out of bounds");
			return head;
		}

		temp.next = temp.next.next;
		return head;
	}
	
	// check if the list is empty
	public static &lt;T&gt; boolean isEmpty(Node&lt;T&gt; head) {
		return head == null;
	}

    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; head, T key) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; head) {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Get element at a specific index
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Set element at a specific index
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }
	
	// reverse the list
	public static &lt;T&gt; Node&lt;T&gt; reverse(Node&lt;T&gt; head) {
		Node&lt;T&gt; prev = null;
		Node&lt;T&gt; current = head;
		Node&lt;T&gt; next = null;

		while (current != null) {
			next = current.next;  // Store next node
			current.next = prev;  // Reverse current node's pointer
			prev = current;       // Move prev forward
			current = next;       // Move current forward
		}

		return prev;  // New head of the reversed list
	}

    // Sort the list (by name first, then by age)
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
        if (head == null || head.next == null) return head;

        Node&lt;T&gt; mid = middle(head);
        Node&lt;T&gt; nextToMid = mid.next;
        mid.next = null;

        Node&lt;T&gt; left = sort(head);
        Node&lt;T&gt; right = sort(nextToMid);

        return merge(left, right);
    }

    // Merge two sorted lists
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; left, Node&lt;T&gt; right) {
        if (left == null) return right;
        if (right == null) return left;

        if (left.data.compareTo(right.data) &lt;= 0) {
            left.next = merge(left.next, right);
            return left;
        } else {
            right.next = merge(left, right.next);
            return right;
        }
    }

    // Find the middle of the list
    public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
        if (head == null) return null;

        Node&lt;T&gt; slow = head;
        Node&lt;T&gt; fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
    
	public static &lt;T&gt; Node&lt;T&gt; clear(Node&lt;T&gt; head) {
        Node&lt;T&gt; current = head;
        while (current != null) {  // Traverse the list until we reach the end
            Node&lt;T&gt; next = current.next;  // Save reference to the next node
            current.next = null;          // Break the link to the next node
            current = next;               // Move to the next node
        }
        return null;  // Set the head to null to indicate the list is empty
    }
	
    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;
    
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }
    
        @Override
        public int compareTo(Person other) {
            // Compare by name first, then by age
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }
    
    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
		
		// 2. Insert elements at the end
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // 5. Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // 6. Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // 7. Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);
		
		// 8. Delete at a specific position
		head = deleteAtPosition(head, 2);
		System.out.println("\nList after deleting node at position 2:");
		traverse(head);

        // 9. Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // 10. Get size of the list
        System.out.println("\nSize of the list: " + size(head));
		
		// 11. Check if list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}


        // 12. Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 13. Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 14. Sort the linked list (by name first, then by age)
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
		
		// 15. Reverse the list
		head = reverse(head);

		System.out.println("\nList after reversing:");
		traverse(head);

		// 16. Clear the list
        head = clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
    
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;

    public Node(T data)
    {
        Data = data;
        Next = null;
    }
}

class Program
{
    // Insert at beginning
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = head };
        return newNode;
    }

    // Insert at end
    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null) return newNode;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Insert at position
    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (position == 0) { newNode.Next = head; return newNode; }
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) temp = temp.Next;
        if (temp == null) { Console.WriteLine("Position out of bounds"); return head; }
        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Insert before node
    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null) return null;
        if (head == targetNode) return InsertAtBeginning(head, data);
        Node&lt;T&gt; temp = head;
        while (temp != null && temp.Next != targetNode) temp = temp.Next;
        if (temp != null)
        {
            Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = temp.Next };
            temp.Next = newNode;
        }
        return head;
    }

    // Insert after node
    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next };
        node.Next = newNode;
    }

    // Delete at beginning
    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        return head.Next;
    }

    // Delete at end
    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        if (head.Next == null) return null;
        Node&lt;T&gt; temp = head;
        while (temp.Next.Next != null) temp = temp.Next;
        temp.Next = null;
        return head;
    }
    
    // Delete at a specific position
    static Node&lt;T&gt; DeleteAtPosition&lt;T&gt;(Node&lt;T&gt; head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
    
        if (position == 0) // Deleting the first node
        {
            return head.Next;
        }
    
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }
    
        if (temp == null || temp.Next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }
    
        temp.Next = temp.Next.Next; // Remove the node at the given position
        return head;
    }


    // Search for an element
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        }
        return false;
    }

    // Get size of the list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Traverse the list and print elements
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Get an element at specific index
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Set (modify) an element at specific index
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Sort the linked list (Merge Sort)
    static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == null) return head;

        // Split the list into two halves
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; nextToMid = mid.Next;
        mid.Next = null;

        // Recursively sort both halves
        Node&lt;T&gt; left = Sort(head);
        Node&lt;T&gt; right = Sort(nextToMid);

        // Merge the sorted halves
        return Merge(left, right);
    }
    
    static bool IsEmpty&lt;T&gt;(Node&lt;T&gt; head) {
        return head == null;
    }

    // Reverse the linked list
    static Node&lt;T&gt; Reverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; prev = null;
        Node&lt;T&gt; current = head;
        Node&lt;T&gt; next = null;
        
        while (current != null)
        {
            next = current.Next;  // Store next node
            current.Next = prev;  // Reverse the current node's pointer
            prev = current;       // Move prev and current one step forward
            current = next;
        }
        
        head = prev;  // Set the new head to the last node
        return head;
    }

    // Merge two sorted lists
    static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; left, Node&lt;T&gt; right) where T : IComparable&lt;T&gt;
    {
        if (left == null) return right;
        if (right == null) return left;

        if (left.Data.CompareTo(right.Data) &lt;= 0)
        {
            left.Next = Merge(left.Next, right);
            return left;
        }
        else
        {
            right.Next = Merge(left, right.Next);
            return right;
        }
    }

    // Find the middle node of the list
    static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        Node&lt;T&gt; slow = head, fast = head.Next;

        while (fast != null && fast.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }
	
	  // Clear the linked list
    public static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;  // If the list is already empty, return null
        
        Node&lt;T&gt; current = head;
        while (current != null)  // Traverse the list until we reach the end
        {
            Node&lt;T&gt; next = current.Next;  // Save reference to next node
            current.Next = null;          // Break the link to the next node
            current = next;               // Move to the next node
        }
        
        return null;  // Return null to indicate the list is empty
    }

	
    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);
        
        // Initialize the linked list
        Node&lt;Person&gt; head = null;
        
        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        
        // 2. Insert elements at the end
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);
        
        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);
        
        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);
        
        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        Person jack = new Person("Jack", 29);
        head = InsertBeforeNode(head, secondNode, jack);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);
        
        // 5. Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);
        
        // 6. Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);
        
        // 7. Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);
        
        // 8. Delete node at position 2
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("\nList after deleting at position 2:");
        Traverse(head);

        // 9. Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));
        
        // 10. Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));
        
        // 11. Check if the list is empty
        if (IsEmpty(head))
        {
            Console.WriteLine("The list is empty.");
        }
        else
        {
            Console.WriteLine("The list is not empty.");
        }
    
        // 12. Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 13. Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 14. Sort the linked list (by name first, then by age)
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // 15. Reverse the list
        head = Reverse(head);
    
        Console.WriteLine("\nList after reversing:");
        Traverse(head);
    
        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);
    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";
}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/zh/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/zh/tag/singly-linked-list" class="tag">singly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/zh/2024/10/14/singly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/zh/2024/10/14/singly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/zh/2024/10/14/singly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-10" /><category term="day-14" /><category term="data structure" /><category term="linked list" /><category term="singly linked list" /><summary type="html"><![CDATA[Discover the essential concepts of singly linked list data structures in this detailed tutorial designed for both beginners and experienced learners. This guide offers a thorough exploration of the implementation process, complete with illustrative examples that demonstrate key operations such as node creation, insertion, deletion, sorting, searching, and traversal.]]></summary></entry></feed>