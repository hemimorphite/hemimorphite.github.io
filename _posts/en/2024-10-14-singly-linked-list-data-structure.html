---
layout: post
lang: en
locale: en
title: "Singly Linked List Data Structure"
thumb: "singlylinked.jpg"
eyebrow: "Tutorial"
description: "Discover the essential concepts of singly linked list data structures in this detailed tutorial designed for both beginners and experienced learners. This guide offers a thorough exploration of the implementation process, complete with illustrative examples that demonstrate key operations such as node creation, insertion, deletion, sorting, searching, and traversal."
date: 2024-10-14 17:20:00 +0700
author: Samuel Yang
categories: ["Tutorial", "year-2024", "month-10", "day-14"]
tags: ["data structure", "linked list", "singly linked list"]
---

<div class="blog-post">
    {% include post-header.html %}

    <article class="post-content">
		<h3 class="post-subtitle">Singly Linked List</h3>
		
        <p>A singly linked list is a linear data structure consisting of a sequence of elements, called nodes, where each node points to the next node in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations. Each node contains two fields:</p>

        <ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence.</li>
		</ul>

        <p>The singly linked list forms a linear collection of elements where each node points to its successor, and the last node points to <code>NULL</code>, indicating the end of the list. It is a dynamic data structure, meaning it can grow or shrink in size during runtime, as nodes can be added or removed without requiring memory to be reallocated.</p>
		
		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. If the list is empty, the head points to <code>NULL</code>.</p>
		
		<p>Unlike arrays that have a fixed size, a singly linked list dynamically allocates memory for each node when it is created. This means the size of the list can grow or shrink as nodes are added or removed at runtime.</p>
		
		<p>Insertions and deletions of nodes, particularly at the beginning or middle of the list, are more efficient compared to arrays since you do not need to shift elements.</p>
		
		<p>Singly linked lists can only be traversed in one direction, from the head to the tail. There is no way to traverse backward from the tail to the head, which can be a limitation in some use cases.</p>
		
		<p>The nodes in a singly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next through pointers, and they can be located anywhere in memory.</p>
		
		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>
		
		<p>Each node in a singly linked list requires extra memory for the pointer (next reference), which slightly increases memory usage compared to arrays.</p>
		
		<p>The last node in a singly linked list is called the tail. Its next pointer is set to <code>NULL</code>, indicating that it is the end of the list.</p>
		
		<p>Here's a visual representation of a singly linked list:</p>
		
		<pre><code class="language-bash hljs">Head -> [Data | Next] -> [Data | Next] -> [Data | Next] -> NULL</code></pre>
		
		<p>In the above representation:</p>
		
		<ul>
			<li>The <code>Head</code> points to the first node of the list.</li>
			<li>Each node contains <code>Data</code> and a <code>Next</code> pointer to the next node.</li>
			<li>The last node in the list points to <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>A simple singly linked list with three nodes could look like this:</p>
		
		<pre><code class="language-bash hljs">Head -> [10 | Next] -> [20 | Next] -> [30 | NULL]</code></pre>
		
		<p>In the above example:</p>
		
		<ul>
			<li>The head points to the first node containing the data <code>10</code>.</li>
			<li>The second node contains the data <code>20</code> and points to the third node.</li>
			<li>The third node contains the data <code>30</code> and points to <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common singly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a singly linked list is \(O(1)\) (constant time). This is because creating a new node takes constant time and updating a few pointers (the next pointer of the new node, and the head pointer) also takes constant time. Thus, regardless of the number of nodes already in the list, inserting a new node at the beginning always takes the same amount of time.</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a singly linked list is \(O(1)\) (constant space). The only additional space used during the operation is the memory required to create the new node, which is constant (one node). No additional data structures or space that scales with the number of nodes in the list are required. Therefore, the space complexity is constant, since the operation does not depend on the size of the list.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a doubly linked list is \(O(n)\) (linear time).<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning. This takes constant time.</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. Traversing the list takes linear time, where \(n\) is the number of nodes in the list. After reaching the last node, creating a new node and updating the pointers (the last node's next) takes constant time.</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a singly linked list is \(O(1)\) (constant space). The function only needs a constant amount of extra memory to store the pointer to the new node. This is independent of the size of the list. Allocating space for the new node takes \(O(1)\) (constant space), as only a single node's memory is allocated.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 25 -&gt; 30 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node after a node in a singly linked list is \(O(1)\) (constant time). This operation has to traverse the list to find the node after which the new node will be inserted. In the worst case, it might have to traverse the entire list to find this node, which takes \(O(n)\), where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The function only needs a constant amount of extra memory for a few local variables. This is independent of the size of the list. Allocating space for the new node takes \(O(1)\) (constant space), as only a single node's memory is allocated.</li>
				</ul>
			</li>
            <li><code>insertBeforeNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately before a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> before the node containing <code>20</code>. After calling <code>insertBeforeNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10  -&gt; 25 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node before a node in a singly linked list is \(O(n)\) (linear time). This operation has to traverse the list to find the node before which the new node will be inserted. In the worst case, it might have to traverse the entire list to find this node, which takes \(O(n)\), where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node before a node in a singly linked list is \(O(1)\) (constant time). The function only needs a constant amount of extra memory for a few local variables. Allocating space for the new node takes \(O(1)\) (constant space), as only a single node's memory is allocated.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. In this case, the new node's next pointer is assigned to point to the current head, and the head is updated to be the new node. For positions other than the head, the function must traverse the list until it reaches the node before the desired position. This traversal ensures that we place the new node between the current node and the next node at the target position. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 35 -&gt; 30 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a new node at a specified position in a linked list is \(O(n)\) (linear time). This operation has to traverse the list to locate the position which the new node will be inserted. In the worst case, it might have to traverse the entire list to locate the position, which takes \(O(n)\), where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of inserting a new node at a specified position in a linked list is \(O(1)\) (constant space). The function only needs a constant amount of extra memory for a few local variables. Allocating space for the new node takes \(O(1)\) (constant space), as only a single node's memory is allocated.</li>
				</ul>
			</li>
            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a singly linked list. If the list is empty, it prints a message "List is empty, nothing to delete" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of removing a node at the beginning of a singly linked list is \(O(1)\) (constant time). This operation is independent of the size of the linked list. Therefore, regardless of whether the list has \(1\) node, \(100\) nodes, or is empty, the time it takes to remove a new node at the beginning is always constant.</li>
					<li><b>Space complexity</b>: The space complexity of removing a node at the beginning of a singly linked list is \(O(1)\) (constant space). The function only requires a fixed amount of extra memory to store references to the head node and potentially the node to be deleted. It doesn't depend on the size of the list.</li>
				</ul>
			</li>
            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a singly linked list.  If the list is empty, and there are no nodes to delete. In this case, the function will typically print a message indicating that the list is empty and return without making any changes.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of removing a node at the end of a singly linked list is \(O(n)\) (linear time). This operation has to traverse the entire list to reach the last node (since each node only points to the next one), which takes \(O(n)\), where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of removing a node at the end of a singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position to delete is 0, it means the head node should be removed. The function updates the head pointer to point to the next node and frees the memory of the old head node. For positions other than the head, the function must traverse the list until it reaches the node before the desired position.  If the specified position is out of bounds, and a message is printed.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>You want to remove a node at position <code>3</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of removing a node at a specified position in a linked list is \(O(n)\) (linear time). This operation has to traverse the list to locate the position which the node will be removed. In the worst case, it might have to traverse the entire list to locate the position, which takes \(O(n)\), where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of removing a node at a specified position in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a singly linked list and perform an action, such as printing the node's value.</li>
					<li><b>Time complexity</b>: The time complexity of traverse function in a linked list is \(O(n)\) (linear time). The function iterates through each node in the linked list exactly once, from the head to the end (NULL). Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of traverse function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; 30 -&gt; 20 -&gt; 10 -&gt; NULL</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of reverse function in a linked list is \(O(n)\) (linear time). The function traverses each node of the linked list exactly once. Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of reverse function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a singly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of search function in a linked list is \(O(n)\) (linear time).The search function traverses the linked list node by node. In the worst case, it may need to look at every node in the list to find the key (or determine that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of search function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a singly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of size function in a linked list is \(O(n)\) (linear time). The function traverses the entire linked list to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of size function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a singly linked list at a specified index. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of get function in a linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of get function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a singly linked list. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of set function in a linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of set function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a singly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of isEmpty function in a linked list is \(O(1)\) (constant time). The <code>isEmpty</code> function checks whether the head pointer of the linked list is <code>NULL</code>. This operation is performed in constant time since it only involves a simple comparison, regardless of the size of the linked list.</li>
					<li><b>Space complexity</b>: The space complexity of isEmpty function in a linked list is \(O(1)\) (constant space). It only utilizes a fixed amount of space to store the return value.</li>
				</ul>
			</li>
			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted linked lists into a single sorted linked list. </li>
					<li><b>Time complexity</b>: The time complexity of merge function in a linked list is \(O(n + m)\) (linear time). The reason for this complexity is that each node from both lists is visited exactly once. In the worst case, the function will traverse both lists entirely, performing comparisons and linking nodes. Where \(n\) is the number of nodes in the first linked list and \(m\) is the number of nodes in the second linked list.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a linked list is \(O(n + m)\) (linear space). In the worst case, the maximum depth of recursion will be equal to the total number of nodes in both lists combined, leading to \(n + m\) recursive calls.</li>
				</ul>
			</li>
			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a singly linked list, in a specific order (typically ascending or descending).</li>
					<li><b>Time complexity</b>: The time complexity of merge function in a linked list is \(O(n \log n)\) (linearithmic time) because the algorithm consistently divides the list into halves and requires a linear amount of time \(O(n)\) to merge those halves back together. The logarithmic factor \(\log n\) comes from the number of times the list can be divided in half (depth of recursion).</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a linked list is \(O(n)\) (linear space) because it requires additional space for the temporary arrays or linked lists used during the merge process. When merging two halves, the algorithm needs space to hold the merged elements before copying them back to the original array or linked list.</li>
				</ul>
			</li>
			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from the list and free up the memory they occupy, effectively making the list empty.</li>
					<li><b>Time complexity</b>: The time complexity of merge function in a linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, freeing its memory. Since it processes all nodes in the list, the time complexity is proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a linked list is \(O(1)\) (constant space). The function uses only a small, fixed amount of extra memory, regardless of the size of the linked list.</li>
				</ul>
			</li>
        </ul>
		
		<h3 class="post-subtitle">Non-Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// defines a structure to represent a node in a singly linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    newNode-&gt;next = *headRef;
    *headRef = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }
	
	Node* newNode = createNode(data);
	
    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }
    
	if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }
	
	Node* newNode = createNode(data);
	
    // If the nextNode is the head node, handle the insertion at beginning
    if (*headRef == nextNode) {
        newNode-&gt;next = *headRef;
        *headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = *headRef;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    // If position is at the beginning
    if (position == 0) {
        newNode-&gt;next = *headRef;
        *headRef = newNode;
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes
    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = *headRef;
    *headRef = (*headRef)-&gt;next;
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    
    // If there's only one node in the list
    if (temp-&gt;next == NULL) {
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the second last node
    while (temp-&gt;next-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    // Free the last node
    free(temp-&gt;next);
    temp-&gt;next = NULL;
}

// Function to delete a node at a specific position (0-based index)
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    // If head needs to be removed
    if (position == 0) {
        *headRef = temp-&gt;next; // Change head
        free(temp); // Free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    // If position is more than number of nodes
    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nextNode = temp-&gt;next-&gt;next;
    free(temp-&gt;next); // Free memory
    temp-&gt;next = nextNode; // Unlink the deleted node from the list
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d -&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp-&gt;data == key)
            return 1; // Key found
        temp = temp-&gt;next;
    }
    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** headRef) {
    Node *prev = NULL, *current = *headRef, *next = NULL;
    while (current != NULL) {
        next = current-&gt;next; // Store next
        current-&gt;next = prev; // Reverse current node's pointer
        prev = current;       // Move pointers one position ahead
        current = next;
    }
    *headRef = prev;
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        *headRef = head2;
        return;
    }
    if (head2 == NULL) {
        *headRef = head1;
        return;
    }

    if (head1-&gt;data &lt;= head2-&gt;data) {
        *headRef = head1;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
    } else {
        *headRef = head2;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
    }
}

// Function to get the middle of the linked list
void middle(Node** mid, Node* head) {
    if (head == NULL) return;
    
    Node* slow = head;
    Node* fast = head-&gt;next;
    
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    
    *mid = slow; // Update the pointer to the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;
  
    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}

// Function to clear the entire linked list and free memory
void clear(Node** headRef) {
    Node* current = *headRef;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *headRef = NULL;
}

// Main function to test the linked list operations
int main() {
    Node* head = NULL;
    
    // Insert at beginning
    insertAtBeginning(&head, 10);
    insertAtBeginning(&head, 20);
    insertAtBeginning(&head, 30);
    printf("After inserting at the beginning: ");
    traverse(head);  // Output: 30 -&gt; 20 -&gt; 10 -&gt; NULL

    // Insert at end
    insertAtEnd(&head, 40);
    printf("After inserting at the end: ");
    traverse(head);  // Output: 30 -&gt; 20 -&gt; 10 -&gt; 40 -&gt; NULL

    // Insert at position
    insertAtPosition(&head, 25, 2);  // Insert 25 at position 2
    printf("After inserting at position 2: ");
    traverse(head);  // Output: 30 -&gt; 20 -&gt; 25 -&gt; 10 -&gt; 40 -&gt; NULL

    // Delete at position
    deleteAtPosition(&head, 2);  // Delete node at position 2
    printf("After deleting at position 2: ");
    traverse(head);  // Output: 30 -&gt; 20 -&gt; 10 -&gt; 40 -&gt; NULL

    // Reverse the list
    reverse(&head);
    printf("After reversing the list: ");
    traverse(head);  // Output: 40 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL

    // Search for a value
    int found = search(head, 20);
    printf("Is 20 in the list? %s\n", found ? "Yes" : "No");  // Output: Yes

    // Get size of the list
    printf("Size of the list: %d\n", size(head));  // Output: 4

    // Sort the list
    sort(&head);
    printf("After sorting the list: ");
    traverse(head);  // Output: 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; NULL

    // Clear the list
    clear(&head);
    printf("After clearing the list: ");
    traverse(head);  // Output: NULL

    return 0;
}</code></pre>

		<p>Here is the Non-Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);
    if (position == 0) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}


// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    head = head-&gt;next;
    delete temp;
}


// Delete at the end
void deleteAtEnd(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node* temp = head;
    while (temp-&gt;next-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    delete temp-&gt;next;
    temp-&gt;next = nullptr;
}


// Delete at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node* temp = head;
        head = head-&gt;next;
        delete temp;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}


// Traverse the list
void traverse(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}


// Search for an element
bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    }
    return false;
}


// Reverse the list
void reverse(Node*& head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;

    while (current != nullptr) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    head = prev;
}


// Get the size of the list
int size(Node* head) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Merge two sorted lists
void merge(Node*& mergedHead, Node* head1, Node* head2) {
    if (head1 == nullptr && head2 == nullptr) {
        mergedHead = nullptr;
        return;
    }

    if (head1 == nullptr) {
        mergedHead = new Node(head2-&gt;data);
        merge(mergedHead-&gt;next, head1, head2-&gt;next);
    } else if (head2 == nullptr) {
        mergedHead = new Node(head1-&gt;data);
        merge(mergedHead-&gt;next, head1-&gt;next, head2);
    } else if (head1-&gt;data &lt;= head2-&gt;data) {
        mergedHead = new Node(head1-&gt;data);
        merge(mergedHead-&gt;next, head1-&gt;next, head2);
    } else {
        mergedHead = new Node(head2-&gt;data);
        merge(mergedHead-&gt;next, head1, head2-&gt;next);
    }
}

// Find the middle of the list
void middle(Node*& mid, Node* head) {
    if (head == nullptr) {
        mid = nullptr;
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != nullptr && fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    mid = slow;
}


// Sort the list using merge sort
void sort(Node*& head) {
    if (head == nullptr || head-&gt;next == nullptr)
        return;

    Node* mid = nullptr;
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;

    Node* left = head;
    Node* right = nextToMid;

    sort(left);
    sort(right);

    merge(head, left, right);
}


// Clear the list
void clear(Node*& head) {
    Node* current = head;
    while (current != nullptr) {
        Node* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}


int main() {
    Node* head = nullptr;

    // Insert elements at the beginning
    insertAtBeginning(head, 5);
    insertAtBeginning(head, 10);
    insertAtBeginning(head, 3);

    cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(head);

    // Insert element at the end
    insertAtEnd(head, 7);
    insertAtEnd(head, 2);

    cout &lt;&lt; "List after inserting at the end: ";
    traverse(head);

    // Insert at a specific position
    insertAtPosition(head, 4, 2);
    cout &lt;&lt; "List after inserting at position 2: ";
    traverse(head);

    // Delete at the beginning
    deleteAtBeginning(head);
    cout &lt;&lt; "List after deleting at the beginning: ";
    traverse(head);

    // Delete at the end
    deleteAtEnd(head);
    cout &lt;&lt; "List after deleting at the end: ";
    traverse(head);

    // Delete at a specific position
    deleteAtPosition(head, 2);
    cout &lt;&lt; "List after deleting at position 2: ";
    traverse(head);

    // Search for an element
    int key = 7;
    if (search(head, key)) {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list\n";
    } else {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list\n";
    }

    // Reverse the list
    reverse(head);
    cout &lt;&lt; "List after reversing: ";
    traverse(head);

    // Sort the list
    sort(head);
    cout &lt;&lt; "Sorted list: ";
    traverse(head);

    // Get the size of the list
    cout &lt;&lt; "Size of the list: " &lt;&lt; size(head) &lt;&lt; endl;

    // Clear the list
    clear(head);
    cout &lt;&lt; "List after clearing: ";
    traverse(head);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class LinkedList {

    // Node structure for singly linked list
    static class Node {
        int data;
        Node next;

        // Constructor to create a new node
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        Node newNode = new Node(data);
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        return head.next;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node temp = head;
        while (temp.next.next != null) {
            temp = temp.next;
        }
        temp.next = null;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return head.next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        temp.next = temp.next.next;
        return head;
    }

    // Traverse the list
    public static void traverse(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " -> ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Search for an element
    public static boolean search(Node head, int key) {
        Node temp = head;
        while (temp != null) {
            if (temp.data == key) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node reverse(Node head) {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Get the size of the list
    public static int size(Node head) {
        int count = 0;
        Node temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node clear(Node head) {
        return null;
    }

    // Main method to test
    public static void main(String[] args) {
        Node head = null;

        // Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);

        // Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);

        // Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // Get the size of the list
        System.out.println("Size of the list: " + size(head));

        // Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-java hljs">using System;

public class LinkedList
{
    // Node structure for singly linked list
    public class Node
    {
        public int Data;
        public Node Next;

        // Constructor to create a new node
        public Node(int data)
        {
            Data = data;
            Next = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data)
        {
            Next = head
        };
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.Next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        return head.Next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.Next.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = null;
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return head.Next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null || temp.Next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        temp.Next = temp.Next.Next;
        return head;
    }

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " -> ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, int key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.Data == key)
            {
                return true;
            }
            temp = temp.Next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null)
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Clear the list
    public static Node Clear(Node head)
    {
        return null;
    }

    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning:");
        Traverse(head);

        // Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end:");
        Traverse(head);

        // Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2:");
        Traverse(head);

        // Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning:");
        Traverse(head);

        // Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end:");
        Traverse(head);

        // Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2:");
        Traverse(head);

        // Search for an element
        int key = 7;
        Console.WriteLine(Search(head, key)
            ? $"Element {key} found in the list"
            : $"Element {key} not found in the list");

        // Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing:");
        Traverse(head);

        // Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));

        // Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing:");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-cpp hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for singly linked list
typedef struct Node {
    StackElement element;
    struct Node* next;     // Pointer to the next node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    newNode-&gt;next = *head;
    *head = newNode;
}

// Function to insert a node at the end of the list (generic)
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a node after a given previous node
void insertAfterNode(Node** head, Node* prevNode, StackElement element) {
    // Check if the head is NULL (list is empty)
    if (*head == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // Check if prevNode is the head node
    if (*head == prevNode) {
        // Insert the new node after the head
        newNode-&gt;next = (*head)-&gt;next;
        (*head)-&gt;next = newNode;
        return;
    }

    // Traverse the list to find prevNode if it's not the head
    Node* temp = *head;
    while (temp != NULL && temp != prevNode) {
        temp = temp-&gt;next;
    }

    // If prevNode is not found in the list, return an error
    if (temp == NULL) {
        printf("The given previous node is not found in the list\n");
        free(newNode);
        return;
    }

    // Insert the new node after prevNode
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    // Check if the head is NULL (list is empty)
    if (*head == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    // Check if the nextNode is NULL
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the nextNode is the head node, handle the insertion at beginning
    if (*head == nextNode) {
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    // If temp is NULL, then nextNode is not found in the list
    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position
void insertAtPosition(Node** head, StackElement element, int position) {
    Node* newNode = createNode(element);
    
    // If position is at the beginning
    if (position == 0) {
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes
    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *head;           // Temporary pointer to the head node
    *head = (*head)-&gt;next;        // Move the head to the next node
    
    free(temp);                   // Free the node
}

/// Function to delete a node at the end of the list
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    // If there's only one node in the list
    if (temp-&gt;next == NULL) {
        free(temp);                 // Free the node
        *head = NULL;
        return;
    }

    // Traverse to the second last node
    while (temp-&gt;next-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    free(temp-&gt;next);                 // Free the last node
    temp-&gt;next = NULL;                // Set the second last node's next to NULL
}

// Function to delete a node at a given position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    // If head needs to be removed
    if (position == 0) {
        *head = temp-&gt;next; // Change head
        free(temp); // Free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    // If position is more than number of nodes
    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nextNode = temp-&gt;next-&gt;next;

    free(temp-&gt;next);                 // Free the node
    temp-&gt;next = nextNode;            // Unlink the deleted node from the list
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        char* str = temp-&gt;element.toString;
        printf("%s -&gt; ", str);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    Node* temp = head;

    while (temp != NULL) {
        // Call toString to get the string representation of the data in the current node
        char* currentStr = temp-&gt;element.toString;
        char* keyStr = keyElement.toString;

        // Compare the string representations of the current node's data and the key element's data
        if (strcmp(currentStr, keyStr) == 0) {
            return 1; // Key found
        }
		
        temp = temp-&gt;next;
    }

    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** head) {
    Node *prev = NULL, *current = *head, *next = NULL;
    while (current != NULL) {
        next = current-&gt;next; // Store next
        current-&gt;next = prev; // Reverse current node's pointer
        prev = current;       // Move pointers one position ahead
        current = next;
    }
    *head = prev;
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;element;
        count++;
        temp = temp-&gt;next;
    }
    StackElement emptyElement = {NULL, ""};
    return emptyElement; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head2 = head2-&gt;next;
        }
        return;
    }
    if (head2 == NULL) {
        while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head1 = head1-&gt;next;
        }
        return;
    }

    if (strcasecmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt; 0) {
        Node* newNode = createNode(head1-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
    } else {
        Node* newNode = createNode(head2-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
    }
}


// Function to get the middle of the linked list
Node* middle(Node* head) {
    if (head == NULL) return head;
    Node* slow = head;
    Node* fast = head-&gt;next;
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    return slow;
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = middle(head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;

    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


// Function to clear the entire linked list and free memory
void clear(Node** head) {
    Node* current = *head;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *head = NULL;
}
struct Car {
    char model[20];
    int year;
};

struct Person {
    char name[20];
    int age;
};
// Main function to test the linked list operations
int main() {
    // Create Cars
    struct Car tesla = {"Tesla", 2020};
    struct Car toyota = {"Toyota", 2019};
    struct Car honda = {"Honda", 2020};
    
    // Create StackElement for cars
    StackElement carElement1, carElement2, carElement3;
    carElement1.data = &tesla;
    carElement1.toString = "Car{model:\"Tesla\", year:2020}";
    
    carElement2.data = &toyota;
    carElement2.toString = "Car{model:\"Toyota\", year:2019}";
    
    carElement3.data = &honda;
    carElement3.toString = "Car{model:\"Honda\", year:2020}";
    
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};
    
    // Create StackElement for people
    StackElement personElement1, personElement2, personElement3, personElement4;
    personElement1.data = &alice;
    personElement1.toString = "Person{name:\"Alice\", age:30}";
    
    personElement2.data = &john;
    personElement2.toString = "Person{name:\"John\", age:19}";
    
    personElement3.data = &albert;
    personElement3.toString = "Person{name:\"Albert\", age:28}";
    
    personElement4.data = &robert;
    personElement4.toString = "Person{name:\"Robert\", age:20}";

    // Initialize linked lists for cars and people
    Node* carList = NULL;
    Node* personList = NULL;

    // Insert cars into the car linked list
    insertAtEnd(&carList, carElement1);
    insertAtEnd(&carList, carElement2);
    insertAtEnd(&carList, carElement3);

    // Insert people into the person linked list
    insertAtEnd(&personList, personElement1);
    insertAtEnd(&personList, personElement2);
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);

    // Print the original car list
    printf("Original Car List:\n");
    traverse(carList);

    // Print the original person list
    printf("\nOriginal Person List:\n");
    traverse(personList);
    
    // Sort the list
    sort(&personList);
    sort(&carList);
    
    printf("\nSorted Person List:\n");
    traverse(personList);
    
    printf("\nSorted Car List:\n");
    traverse(carList);
    
    Node* mergedList = NULL;
    // Merge the two lists and sort the combined list
    merge(&mergedList, personList, carList);

    // Print the merged and sorted list
    printf("\nMerged and Sorted List:\n");
    traverse(mergedList);

    // Clean up and free the memory
    clear(&carList);
    clear(&personList);
    clear(&mergedList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for singly linked list template
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    head = head-&gt;next;
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    delete temp-&gt;next;
    temp-&gt;next = nullptr;
}

// Delete at a specific position
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node&lt;T&gt;* temp = head;
        head = head-&gt;next;
        delete temp;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node&lt;T&gt;* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Search for an element
template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    }
    return false;
}

// Reverse the list
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* prev = nullptr;
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* next = nullptr;

    while (current != nullptr) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    head = prev;
}

// Get the size of the list
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    int count = 0;
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    while (current != nullptr) {
        Node&lt;T&gt;* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

int main() {
    Node&lt;int&gt;* head = nullptr;

    // Insert elements at the beginning
    insertAtBeginning(head, 5);
    insertAtBeginning(head, 10);
    insertAtBeginning(head, 3);

    cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(head);

    // Insert element at the end
    insertAtEnd(head, 7);
    insertAtEnd(head, 2);

    cout &lt;&lt; "List after inserting at the end: ";
    traverse(head);

    // Insert at a specific position
    insertAtPosition(head, 4, 2);
    cout &lt;&lt; "List after inserting at position 2: ";
    traverse(head);

    // Delete at the beginning
    deleteAtBeginning(head);
    cout &lt;&lt; "List after deleting at the beginning: ";
    traverse(head);

    // Delete at the end
    deleteAtEnd(head);
    cout &lt;&lt; "List after deleting at the end: ";
    traverse(head);

    // Delete at a specific position
    deleteAtPosition(head, 2);
    cout &lt;&lt; "List after deleting at position 2: ";
    traverse(head);

    // Search for an element
    int key = 7;
    if (search(head, key)) {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list\n";
    } else {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list\n";
    }

    // Reverse the list
    reverse(head);
    cout &lt;&lt; "List after reversing: ";
    traverse(head);

    // Get the size of the list
    cout &lt;&lt; "Size of the list: " &lt;&lt; size(head) &lt;&lt; endl;

    // Clear the list
    clear(head);
    cout &lt;&lt; "List after clearing: ";
    traverse(head);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class LinkedList&lt;T&gt; {

    // Node structure for singly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head == null) {
            return newNode;
        }
        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; head, T data, int position) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        return head.next;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node&lt;T&gt; temp = head;
        while (temp.next.next != null) {
            temp = temp.next;
        }
        temp.next = null;
        return head;
    }

    // Delete at a specific position
    public static &lt;T&gt; Node&lt;T&gt; deleteAtPosition(Node&lt;T&gt; head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return head.next;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        temp.next = temp.next.next;
        return head;
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; head, T key) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static &lt;T&gt; Node&lt;T&gt; reverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; prev = null;
        Node&lt;T&gt; current = head;
        Node&lt;T&gt; next = null;

        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; head) {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static &lt;T&gt; Node&lt;T&gt; clear(Node&lt;T&gt; head) {
        return null;
    }

    // Main method to test
    public static void main(String[] args) {
        Node&lt;Integer&gt; head = null;

        // Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);

        // Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);

        // Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // Get the size of the list
        System.out.println("Size of the list: " + size(head));

        // Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

public class LinkedList&lt;T&gt;
{
    // Node structure for singly linked list
    public class Node
    {
        public T Data;
        public Node Next;

        // Constructor to create a new node
        public Node(T data)
        {
            Data = data;
            Next = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, T data)
    {
        Node newNode = new Node(data)
        {
            Next = head
        };
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, T data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, T data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.Next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        return head.Next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.Next.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = null;
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return head.Next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null || temp.Next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        temp.Next = temp.Next.Next;
        return head;
    }

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, T key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.Data.Equals(key))
            {
                return true;
            }
            temp = temp.Next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null)
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Clear the list
    public static Node Clear(Node head)
    {
        return null;
    }

    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning:");
        Traverse(head);

        // Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end:");
        Traverse(head);

        // Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2:");
        Traverse(head);

        // Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning:");
        Traverse(head);

        // Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end:");
        Traverse(head);

        // Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2:");
        Traverse(head);

        // Search for an element
        T key = (T)(object)7; // Example for an integer type
        Console.WriteLine(Search(head, key)
            ? $"Element {key} found in the list"
            : $"Element {key} not found in the list");

        // Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing:");
        Traverse(head);

        // Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));

        // Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing:");
        Traverse(head);
    }
}</code></pre>
    </article>

    {% include post-tags.html %}

    {% include post-share.html %}
</div>