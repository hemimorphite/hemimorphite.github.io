---
layout: post
lang: en
locale: en
title: "Gentoo Linux Installation Guide with Screenshots (amd64 Architecture, Glibc library, gcc Compiler, openRC Service Manager, GRUB Bootloader)"
thumb: "gentoo-01.jpg"
eyebrow: "Best Practice"
description: "This step-by-step installation guide with screenshots will walk you through the process of installing Gentoo Linux on an AMD64 system using the Glibc library, GCC compiler, OpenRC init system, and GRUB Bootloader."
date: 2023-05-31 11:44:59 +0700
author: Samuel Yang
categories: ["Best Practices", "year-2023", "month-05", "day-31"]
tags: ["gentoo", "linux", "amd64", "glibc", "gcc", "openrc", "grub2", "uefi"]
---

<div class="blog-post">
    {% include post-header.html %}

    <article class="post-content">
        <h4 class="post-subtitle">Gentoo Linux installation media</h4>

        <p>This tutorial is intended to work on AMD64-compatible processors, Glibc C library, GCC C Compiler, and OpenRC service manager. Get the minimal Installation CD file at <a href="https://www.gentoo.org/downloads/">https://www.gentoo.org/downloads/</a>. Pick the one that belongs to AMD64 architecture.</p>

        <figure class="post-figure">
            <img src="/assets/images/image-01.jpg" alt="Gentoo minimal Installation CD">
        </figure>

        <h4 class="post-subtitle">Setting up a Virtual Machine with Virtualbox</h4>
        
        <p>Open Virtualbox, and click on "New". Enter a name for your VM, choose a location where you want to save the VM, choose an ISO image and navigate to the gentoo minimal Installation CD file that you have downloaded earlier. Change the type to "Linux", and set the version to the distro you're using.</p>

        <figure class="post-figure">
            <img src="/assets/images/image-02.jpg" alt="Virtualbox">
        </figure>

        <p>Set the amount of memory in megabytes to be allocated to the VM, set the number of virtual CPU, and check the box "Enable EFI (Special OSes only)".</p>

        <figure class="post-figure">
            <img src="/assets/images/image-03.jpg" alt="Virtualbox">
        </figure>

        <p>Set the size of the virtual hard disk in megabytes to be allocated to the VM.</p>
        
        <figure class="post-figure">
            <img src="/assets/images/image-04.jpg" alt="Virtualbox">
        </figure>

        <p>Once done, click button "Finish".</p>

        <p>Next click on "Settings", choose menu "Storage", and remove SATA controller.</p>

        <p>Then you add a NVMe controller to connect virtual hard disks.</p>

        <figure class="post-figure">
            <img src="/assets/images/image-05.jpg" alt="Virtualbox">
        </figure>

        <p>Finally, click on "Start".</p>

        <h4 class="post-subtitle">Creating GPT Disk Partitions</h4>

        <p>To begin, SCSI and Serial ATA drives are both labeled under device handles such as: <code>/dev/sda</code>, <code>/dev/sdb</code>, <code>/dev/sdc</code>, etc. On more modern machines, PCI Express based NVMe solid state disks have device handles such as <code>/dev/nvme0n1</code>, <code>/dev/nvme0n2</code>, etc.</p>

        <table class="table table-bordered border-primary">
            <thead>
                <th>Type of device</th>
                <th>Default device handle</th>
                <th>Description</th>
            </thead>
            <tbody>
            <tr>
                <td>SATA, SAS, SCSI, or USB flash</td>
                <td>
                    <code>/dev/sda</code><br>
                    <code>/dev/sdb</code><br>
                    <code>/dev/sdc</code><br>
                    etc
                </td>
                <td>These types of devices can be connected via the SATA bus, SCSI, USB bus as block storage. As example, the first partition on the first SATA device is called <code>/dev/sda1</code>.</td>
            </tr>
            <tr>
                <td>NVM Express (NVMe)</td>
                <td>
                    <code>/dev/nvme0n1</code><br>
                    <code>/dev/nvme0n2</code><br>
                    <code>/dev/nvme0n3</code><br>
                    etc
                </td>
                <td>NVMe drives are connected to the PCI Express bus. The first partition on the first NVMe device is called <code>/dev/nvme0n1p1</code>.</td>
            </tr>
            </tbody>
        </table>

        <p>The following partitioning scheme will be used as a simple example layout:</p>

        <table class="table table-bordered border-primary">
            <thead>
                <th>Partition</th>
                <th>Filesystem</th>
                <th>Size</th>
                <th>Description</th>
            </thead>
            <tbody>
            <tr>
                <td><code>/dev/nvme0n1p1</code></td>
                <td>fat32 (UEFI)</td>
                <td>128M</td>
                <td>EFI system partition</td>
            </tr>
            <tr>
                <td><code>/dev/nvme0n1p2</code></td>
                <td>ext4</td>
                <td>256M</td>
                <td>Boot partition</td>
            </tr>
            <tr>
                <td><code>/dev/nvme0n1p3</code></td>
                <td>(swap)</td>
                <td>RAM size * 2</td>
                <td>Swap partition</td>
            </tr>
            <tr>
                <td><code>/dev/nvme0n1p4</code></td>
                <td>ext4</td>
                <td>Rest of the disk</td>
                <td>Root partition</td>
            </tr>
            </tbody>
        </table>

        <p>Fire up <code>fdisk</code> against the disk:</p>

        <pre class="command">fdisk /dev/nvme0n1</pre>

        <p>When using UEFI, type <code>g</code> to create a new GPT disklabel on the disk; this will remove all existing partitions.</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-01.png" alt="fdisk 1">
        </figure>

        <p>First create a small EFI system partition, which will also be mounted as <code>/boot/efi</code>. Type <code>n</code> to create a new partition, followed by <code>1</code> to create the first partition, <code>/dev/nvme0n1p1</code>. When prompted for the first sector, make sure it starts from 2048 (which may be needed for the boot loader) and hit <code>Enter</code>. When prompted for the last sector, type <code>+128M</code> to create a partition 128 Mbyte in size:</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-02.png" alt="fdisk 2">
        </figure>

        <p>Mark the partition as EFI system partition. Type <code>t</code> to set the partition type, and then type in <code>1</code> to set the partition type to "EFI System".</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-03.png" alt="fdisk 3">
        </figure>

        <p>After that create a boot partition, which will also be mounted as <code>/boot</code>. Type <code>n</code> to create a new partition, followed by <code>2</code> to create the second partition, <code>/dev/nvme0n1p2</code>. When prompted for the first sector, hit <code>Enter</code>. When prompted for the last sector, type <code>+256M</code> to create a partition 256 Mbyte in size:</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-04.png" alt="fdisk 4">
        </figure>

        <p>Next, to create the swap partition, type <code>n</code> to create a new partition, then type <code>3</code> to create the third partition, <code>/dev/nvme0n1p3</code>. When prompted for the first sector, hit <code>Enter</code>. When prompted for the last sector, type <code>+16G</code> (or any other size needed for the swap space) to create a partition 16GB in size.</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-05.png" alt="fdisk 5">
        </figure>        

        <p>After all this is done, type <code>t</code> to set the partition type, <code>3</code> to select the partition just created and then type in <code>19</code> to set the partition type to "Linux Swap".</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-06.png" alt="fdisk 6">
        </figure>

        <p>Finally, to create the root partition, type <code>n</code> to create a new partition. Then type <code>3</code> to create the third partition, <code>/dev/nvme0n1p4</code>. When prompted for the first sector, hit <code>Enter</code>. When prompted for the last sector, hit <code>Enter</code> to create a partition that takes up the rest of the remaining space on the disk.</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-07.png" alt="fdisk 7">
        </figure>        

        <p>After completing these steps, typing <code>p</code> should display a partition table that looks similar to this:</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-08.png" alt="fdisk 8">
        </figure>

        <p>To save the partition layout and exit <code>fdisk</code>, type <code>w</code>.</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-12.png" alt="fdisk 9">
        </figure>

        <h4 class="post-subtitle">Creating File Systems</h4>

        <p>Create FAT32 filesystem on the EFI system partition (<code>/dev/nvme0n1p1</code>).</p>

        <pre class="command">mkfs.vfat -F 32 /dev/nvme0n1p1</pre>

        <p>Create <code>ext4</code> filesystem on the boot partition (<code>/dev/nvme0n1p2</code>).</p>

        <pre class="command">mkfs.ext4 /dev/nvme0n1p2</pre>

        <p>Create swap area on the swap partition.</p>

        <pre class="command">mkswap /dev/nvme0n1p3</pre>

        <p>Activate the swap partition:</p>

        <pre class="command">swapon /dev/nvme0n1p3</pre>

        <p>Create <code>ext4</code> filesystem on the root partition (<code>/dev/nvme0n1p4</code>).</p>

        <pre class="command">mkfs.ext4 /dev/nvme0n1p4</pre>

        <h4 class="post-subtitle">Mounting File Systems</h4>

        <p>Create a mount point for the root partition.</p>

        <pre class="command">mkdir --parents /mnt/gentoo</pre>

        <p>Then we mount the root partition on <code>/mnt/gentoo</code>.</p>

        <pre class="command">mount /dev/nvme0n1p4 /mnt/gentoo</pre>

        <p>Go to the Gentoo mount point where the root file system is mounted.</p>

        <pre class="command">cd /mnt/gentoo</pre>

        <p>Download the stage tarball that is intended for AMD64-compatible processors and using Glibc as C library, GCC as C Compiler, and OpenRC as service manager. Use the <code>wget</code> utility to proceed:</p>

        <pre class="command">wget https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds/20230521T160357Z/stage3-amd64-openrc-20230521T160357Z.tar.xz</pre>

        <p>Now unpack the downloaded stage onto the system. Use the <code>tar</code> utility to proceed:</p>

        <pre class="command">tar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner</pre>

        <p>The <code>x</code> stands for extract, the <code>p</code> for preserve permissions and the <code>f</code> to denote that we want to extract a file (not standard input). <code>--xattrs-include='*.*'</code> is to include preservation of the the extended attributes in all namespaces stored in the archive. Finally, <code>--numeric-owner</code> is used to ensure that the user and group IDs of the files being extracted from the tarball will remain the same as Gentoo's release engineering team intended.</p>

        <p>The stage tarball file is a tarball containing a populated directory structure from Linux Filesystem. The tarball contains no kernel, only binaries and libraries essential to bootstrapping.</p> 

        <p>Next we mount the boot partition on <code>/mnt/gentoo/boot</code>.</p>

        <pre class="command">mount /dev/nvme0n1p2 /mnt/gentoo/boot</pre>

        <p>Create a mount point for the efi system partition.</p>

        <pre class="command">mkdir /mnt/gentoo/boot/efi</pre>

        <p>After that we mount the efi system partition on <code>/mnt/gentoo/boot/efi</code>.</p>

        <pre class="command">mount /dev/nvme0n1p1 /mnt/gentoo/boot/efi</pre>

        <p>The organization of the Linux Filesystem is defined by the Filesystem Hierarchy Standard. This standard enables Software and users to predict the location of installed files and directories. We will just indicates to what use are the first level directories are intended for:</p>

        <ul>
            <li><code>/</code> is the <i>root</i>. It is the highest level of the filesystem. At the very beginning of the filesystem setting up, this directory — as some other sub directories — is purely virtual (residing in RAM), then the partition that contains the final root of the filesystem is mounted there read-only. Thus the kernel is able to find the tools necessary to the initialization of disks and the mounting of the other partitions. After this job is done, the partition is remounted read write.</li>
            <li><code>/home</code> is the place where the files of the users will be placed. Generally, but it is not mandatory, a separate partition is mounted there.</li>
            <li><code>/etc</code> is the place for installed application configuration files e.g. <code>/etc/fstab</code>, <code>/etc/hosts</code>, etc.</li>
            <li><code>/lib</code> is the place for shared libraries and the kernel modules.</li>
            <li><code>/media</code> is a mounting point for removable devices such as CDs, DVDs, USB stick or drives, etc.</li>
            <li><code>/bin</code> is a place for essential command binaries such as <i>cat</i>, <i>ls</i>, <i>mount</i>, etc.</li>
            <li><code>/boot</code> is a place for static files of the boot loader.</li>
            <li><code>/dev</code> is for the device files.</li>
            <li><code>/mnt</code> is a place where to mount filesystems temporarily.</li>
            <li><code>/opt</code> is for additional programs.</li>
            <li><code>/run</code> is for data related to running processes.</li>
            <li><code>/sbin</code> is for essential commands.</li>
            <li><code>/srv</code> is for the data of services supported by the system e.g. the files of a web server.</li>
            <li><code>/tmp</code> is for temporary files.</li>
            <li><code>/usr</code> is a secondary hierarchy.</li>
            <li><code>/var</code> is for variable data.</li>
            <li><code>/root</code> is for the files belonging to the super user (<i>root</i>).</li>
        </ul>

        <p>Portage is the official package manager and distribution system for Gentoo. Portage reads in the <code>make.conf</code> file when it runs, which will change runtime behavior depending on the values saved in the file. <code>make.conf</code> can be considered the primary configuration file for Portage.</p>

        <p>Update the <code>/mnt/gentoo/etc/portage/make.conf</code> file.</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-09.png" alt="Configuration make.conf">
        </figure>

        <p>The CFLAGS and CXXFLAGS variables define the optimization flags for GCC C and C++ compilers respectively.</p>

        <p>A first setting is the <code>-march=</code> or <code>-mtune=</code> flag, which specifies the name of the target architecture. A commonly used value is <code>native</code> as that tells the compiler to select the target architecture of the current system</p>       

        <p>A second one is the <code>-O</code> flag (that is a capital O, not a zero), which specifies the gcc optimization class flag. Possible classes are s (for size-optimized), 0 (zero - for no optimizations), 1, 2 or even 3 for more speed-optimization flags (every class has the same flags as the one before, plus some extras). <code>-O2</code> is the recommended default. <code>-O3</code> is known to cause problems when used system-wide</p>

        <p>Another popular optimization flag is <code>-pipe</code> (use pipes rather than temporary files for communication between the various stages of compilation). It has no impact on the generated code, but uses more memory. On systems with low memory, gcc might get killed. In that case, do not use this flag.</p>

        <p>Next step is to configure the Gentoo ebuild repository via the <code>/etc/portage/repos.conf/gentoo.conf</code> file. This file contains the sync information needed to update the package repository (the collection of ebuilds and related files containing all the information Portage needs to download and install software packages).</p>

        <p>Configuring the repository can be done in a few simple steps. First, if it does not exist, create the <code>repos.conf</code> directory:</p>

        <pre class="command">mkdir --parents /mnt/gentoo/etc/portage/repos.conf</pre>

        <p>Next, copy the Gentoo repository configuration file provided by Portage to the (newly created) <code>repos.conf</code> directory:</p>

        <pre class="command">cp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf</pre>

        <p>Next thing to be done is copying over the DNS information in <code>/etc/resolv.conf</code> to the new environment. <code>/etc/resolv.conf</code> contains the name servers (DNS servers) for name resolution. Priorities to nameservers are given in the order the system finds an entry in the file.</p>

        <pre class="command">cp --dereference /etc/resolv.conf /mnt/gentoo/etc/</pre>

        <p>The <code>--dereference</code> option ensures that, if <code>/etc/resolv.conf</code> is a symbolic link, that the link's target file is copied instead of the symbolic link itself.</p>

        <p>The Linux root will be changed towards the new location. The filesystems that need to be made available in the new environment are:</p>

        <ul>
            <li><code>/proc/</code> is a pseudo-filesystem. It looks like regular files, but is generated on-the-fly by the Linux kernel</li>
            <li><code>/sys/</code> is a pseudo-filesystem, like <code>/proc/</code> which it was once meant to replace, and is more structured than <code>/proc/</code></li>
            <li><code>/dev/</code> is a regular file system which contains all device. It is partially managed by the Linux device manager (usually <code>udev</code>)</li>
            <li><code>/run/</code> is a temporary file system used for files generated at runtime, such as PID files or locks</li>
        </ul>

        <p>The <code>/proc/</code> location will be mounted on <code>/mnt/gentoo/proc/</code> whereas the others are bind-mounted. For instance, <code>/mnt/gentoo/sys/</code> will actually be <code>/sys/</code> (it is just a second entry point to the same filesystem) whereas <code>/mnt/gentoo/proc/</code> is a new mount of the filesystem.</p>

        <pre><code class="language-bash hljs">mount --types proc /proc /mnt/gentoo/proc</code></pre>
        <pre><code class="language-bash hljs">mount --rbind /sys /mnt/gentoo/sys</code></pre>
        <pre><code class="language-bash hljs">mount --make-rslave /mnt/gentoo/sys</code></pre>
        <pre><code class="language-bash hljs">mount --rbind /dev /mnt/gentoo/dev</code></pre>
        <pre><code class="language-bash hljs">mount --make-rslave /mnt/gentoo/dev</code></pre>
        <pre><code class="language-bash hljs">mount --bind /run /mnt/gentoo/run</code></pre>
        <pre><code class="language-bash hljs">mount --make-slave /mnt/gentoo/run</code></pre>

        <p>Now that all partitions are initialized and the base environment installed, it is time to enter the new installation environment by chrooting into it. This means that the session will change its root from the current installation environment (installation CD) to the installation system (namely the initialized partitions).</p>

        <p>First, we change root location from <code>/</code> (on the installation medium) to <code>/mnt/gentoo/</code> (on the partitions) using <code>chroot</code>.</p>

        <pre><code class="language-bash hljs">chroot /mnt/gentoo /bin/bash</code></pre>

        <p>Then, reload <code>/etc/profile</code> in memory using the <code>source</code> command.</p>

        <pre class="command">source /etc/profile</pre>

        <p>Change primary prompt to help us remember that this session is inside a chroot environment.</p>

        <pre class="command">export PS1="(chroot) ${PS1}"</pre>

        <h4 class="post-subtitle">Configuring Portage</h4>

        <p>Next step is to install a snapshot of the Gentoo ebuild repository. This snapshot contains a collection of files that informs Portage about available software titles (for installation), which profiles the system administrator can select, package or profile specific news items, etc.</p>

        <pre class="command">emerge-webrsync</pre>

        <p>During this operation, emerge-webrsync might complain about a missing <code>/var/db/repos/gentoo/</code> location. This is to be expected and nothing to worry about - the tool will create the location.</p>    
        
        <p>Some architectures (including AMD64/X86, ARM, PPC) have a <code>USE_EXPAND</code> variable called <code>CPU_FLAGS_ARCH</code> (replace ARCH with the relevant system architecture as appropriate).</p>

        <p>Install package <code>app-portage/cpuid2cpuflags</code>:</p>
        
        <pre class="command">emerge --ask app-portage/cpuid2cpuflags</pre>  
        
        <p>Then copy the output into <code>package.use</code>:</p>

        <pre class="command">echo "*/* $(cpuid2cpuflags)" > /etc/portage/package.use/00cpu-flags</pre>     

        <h4 class="post-subtitle">Setting Timezone</h4> 

        <p>Select the timezone for the system. Look for the available timezones in <code>/usr/share/zoneinfo/</code>:</p>

        <pre class="command">ls /usr/share/zoneinfo</pre>

        <p>Suppose the timezone of choice is <code>Asia/Jakarta</code>.</p>

        <p>We write the timezone name into the <code>/etc/timezone</code> file.</p>

        <pre class="command">echo "Asia/Jakarta" > /etc/timezone</pre>

        <p>Next, reconfigure the <code>sys-libs/timezone-data</code> package, which will update the <code>/etc/localtime</code>, based on the /etc/timezone entry. The <code>/etc/localtime</code> file is used by the system C library to know the timezone the system is in.</p>

        <pre class="command">emerge --config sys-libs/timezone-data</pre>  
        
        <h4 class="post-subtitle">Setting Locale</h4>

        <p>Locales specify not only the language that the user should use to interact with the system, but also the rules for sorting strings, displaying dates and times, etc. Locales are case sensitive and must be represented exactly as described. A full listing of available locales can be found in the <code>/usr/share/i18n/SUPPORTED</code> file.</p>

        <p>Supported system locales must be defined in the <code>/etc/locale.gen</code> file.</p>

        <pre class="command">nano -w /etc/locale.gen</pre>

        <p>The next step is to run the <code>locale-gen</code> command. This command generates all locales specified in the <code>/etc/locale.gen</code> file.</p>

        <p>To display information about the current locales</p>

        <pre class="command">locale -a</pre>

        <h4 class="post-subtitle">Kernel configuration</h4>
        
        <p>Before configuring kernel, it is important to be know that some hardware devices require additional firmware to be installed on the system before they will operate correctly. This is often the case for wireless network interfaces commonly found in both desktop and laptop computers. Modern video chips from vendors like AMD, Nvidia, and Intel, often also require external firmware files to be fully functional. Most firmware for modern hardware devices can be found within the <code>sys-kernel/linux-firmware</code> package.</p>

        <p>Some packages will only be allowed to be installed by accepting its license. Update <code>/etc/portage/make.conf</code> and add the following variable:</p>

        <pre class="command">ACCEPT_LICENSE="-* @FREE @BINARY-REDISTRIBUTABLE"</pre>

        <p>Then we install the <code>sys-kernel/linux-firmware</code> package.</p>

        <pre class="command">emerge --ask sys-kernel/linux-firmware</pre>

        <p>There are two approach to configure and compile the kernel:</p>
        <ul>
            <li>Full automation approach: the linux kernel are fully automated in configuring, building, and installing. It is possible provide a custom kernel configuration file if customization is necessary.</li>
            <li>Full manual approach: the kernel is manually configured, built, and installed using the eselect kernel and a slew of <code>make</code> commands.</li>
        </ul> 

        <h5 class="post-subtitle">Full automation approach</h5>

        <p>Distribution Kernels are ebuilds that cover the complete process of unpacking, configuring, compiling, and installing the kernel.</p>

        <p>Before installing the distribution kernels, first we install <code>installkernel</code> package:</p>

        <pre class="command">emerge --ask sys-kernel/installkernel-gentoo</pre>

        <p>Then we install the distribution kernels:</p> 

        <pre class="command">emerge --ask sys-kernel/gentoo-kernel-bin</pre>

        <h5 class="post-subtitle">Full manual approach</h5>

        <p>First, install the <code>sys-kernel/gentoo-sources</code> package.</p>

        <pre class="command">emerge --ask sys-kernel/gentoo-sources</pre>

        <p>Setting the symlink with the <code>eselect</code> tool:</p>

        <pre class="command">eselect kernel list</pre>

        <pre class="command">eselect kernel set 1</pre>

        <p>A symbolic link called <code>linux</code> is created.</p>

        <pre class="command">ls -l /usr/src/linux</pre>

        <figure class="post-figure">
            <img src="/assets/images/carbon-13.png" alt="Kernel symlink">
        </figure>

        <p>Now go to the kernel source directory and execute <code>make menuconfig</code>. This will fire up menu-driven configuration screen.</p>

        <pre class="command">cd /usr/src/linux</pre>

        <pre class="command">make menuconfig</pre>

        <p>Enabling Gentoo-specific options and enabling openRC support:</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-14.png" alt="Kernel configuration">
        </figure>        

        <p>Enabling devtmpfs support (<code>CONFIG_DEVTMPFS</code>):</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-15.png" alt="Kernel configuration">
        </figure>

        <p>Enabling SCSI disk support (<code>CONFIG_SCSI</code>, <code>CONFIG_BLK_DEV_SD</code>):</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-16.png" alt="Kernel configuration">
        </figure>

        <p>Enabling basic SATA and PATA support (<code>CONFIG_ATA_ACPI</code>, <code>CONFIG_SATA_PMP</code>, <code>CONFIG_SATA_AHCI</code>, <code>CONFIG_ATA_BMDMA</code>, <code>CONFIG_ATA_SFF</code>, <code>CONFIG_ATA_PIIX</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-17.png" alt="Kernel configuration">
        </figure>

        <p>Enabling basic NVMe support (<code>CONFIG_DEVTMPFS</code>, <code>CONFIG_NVME_MULTIPATH</code>, <code>CONFIG_NVME_MULTIPATH</code>, <code>CONFIG_NVME_HWMON</code>, <code>CONFIG_NVME_FC</code>, <code>CONFIG_NVME_TCP</code>, <code>CONFIG_NVME_TARGET</code>, <code>CONFIG_NVME_TARGET_PASSTHRU</code>, <code>CONFIG_NVME_TARGET_LOOP</code>, <code>CONFIG_NVME_TARGET_FC</code>, <code>CONFIG_NVME_TARGET_FCLOOP</code>, <code>CONFIG_NVME_TARGET_TCP</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-18.png" alt="Kernel configuration">
        </figure>

        <p>Enabling file system support (<code>CONFIG_EXT2_FS</code>, <code>CONFIG_EXT3_FS</code>, <code>CONFIG_EXT4_FS</code>, <code>CONFIG_BTRFS_FS</code>, <code>CONFIG_MSDOS_FS</code>, <code>CONFIG_VFAT_FS</code>, <code>CONFIG_PROC_FS</code>, and <code>CONFIG_TMPFS</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-19.png" alt="Kernel configuration">
        </figure>

        <p>Activating SMP support (<code>CONFIG_SMP</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-20.png" alt="Kernel configuration">
        </figure>

        <p>Enabling USB and human input device support (<code>CONFIG_HID_GENERIC</code>, <code>CONFIG_USB_HID</code>, <code>CONFIG_USB_SUPPORT</code>, <code>CONFIG_USB_XHCI_HCD</code>, <code>CONFIG_USB_EHCI_HCD</code>, <code>CONFIG_USB_OHCI_HCD</code>, (<code>CONFIG_HID_GENERIC</code>, <code>CONFIG_USB_HID</code>, <code>CONFIG_USB_SUPPORT</code>, <code>CONFIG_USB_XHCI_HCD</code>, <code>CONFIG_USB_EHCI_HCD</code>, <code>CONFIG_USB_OHCI_HCD</code>, <code>CONFIG_USB4</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-21.png" alt="Kernel configuration">
        </figure>

        <p>Enabling IA32 Emulation (<code>CONFIG_IA32_EMULATION</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-22.png" alt="Kernel configuration">
        </figure>

        <p>Enabling support for GPT (<code>CONFIG_PARTITION_ADVANCED</code> and <code>CONFIG_EFI_PARTITION</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-23.png" alt="Kernel configuration">
        </figure>

        <p>Enabling support for UEFI (<code>CONFIG_EFI</code>, <code>CONFIG_EFI_STUB</code>, <code>CONFIG_EFI_MIXED</code>, <code>CONFIG_EFI_VARS</code>, and <code>CONFIG_FB_EFI</code>)</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-24.png" alt="Kernel configuration">
        </figure>

        <p>With the configuration now done, it is time to compile and install the kernel. Exit the configuration and start the compilation process:</p>

        <pre class="command">make && make modules_install</pre>

        <p>When the kernel has finished compiling, copy the kernel image to <code>/boot/</code>. This is handled by the <code>make install</code> command:

        <pre class="command">make install</pre>

        <p>To build an initramfs, install <code>sys-kernel/dracut</code> package:</p>

        <pre class="command">emerge --ask sys-kernel/dracut</pre>
        
        <p>Before we generate an initramfs, we must know the version of the chosen kernel sources. To check the version of the chosen kernel sources, enter:</p>

        <pre class="command">eselect kernel list</pre>

        <p>This command must return the output similar to:</p>

        <pre class="command">Available kernel symlink targets:<br>  [1]   linux-6.1.28-gentoo *</pre>

        <p>Then have it generate an initramfs:</p>
        
        <pre class="command">dracut --kver=6.1.28-gentoo</pre>

        <p>The initramfs will be stored in <code>/boot/</code>.</p>

        <h4 class="post-subtitle">Creating the fstab file</h4>
        
        <p>Under Linux, all partitions used by the system must be listed in <code>/etc/fstab</code>. This file contains the mount points of those partitions, how they should be mounted and with what special options.</p>

        <p>The <code>/etc/fstab</code> file uses a table-like syntax. Every line consists of six fields, separated by whitespace (space(s), tabs, or a mixture of the two). Each field has its own meaning:</p>

        <ul>
            <li>The first field shows the block special device or remote filesystem to be mounted. Several kinds of device identifiers are available for block special device nodes, including paths to device files, filesystem labels and UUIDs, and partition labels and UUIDs.</li>
            <li>The second field shows the mount point at which the partition should be mounted.</li>
            <li>The third field shows the type of filesystem used by the partition.</li>
            <li>The fourth field shows the mount options used by <code>mount</code> when it wants to mount the partition. As every filesystem has its own mount options, so system admins are encouraged to read the mount man page (<code>man mount</code>) for a full listing. Multiple mount options are comma-separated.</li>
            <li>The fifth field is used by dump to determine if the partition needs to be dumped or not. This can generally be left as <code>0</code> (zero).</li>
            <li>The sixth field is used by <code>fsck</code> to determine the order in which filesystems should be checked if the system wasn't shut down properly. The root filesystem should have <code>1</code> while the rest should have <code>2</code> (or <code>0</code> if a filesystem check is not necessary).</li>
        </ul>

        <p>Add these rules in the <code>/etc/fstab</code> file.</p>

        <pre class="command">/dev/nvme0n1p2   /boot            ext4    defaults,noatime     0 2<br>/dev/nvme0n1p1   /boot/efi        vfat    defaults,noatime     0 2<br>/dev/nvme0n1p3   none             swap    sw                   0 0<br>/dev/nvme0n1p4   /                ext4    noatime              0 1<br>/dev/cdrom       /mnt/cdrom       auto    noauto,user          0 0</pre>
        

        <figure class="post-figure">
            <img src="/assets/images/carbon-10.png" alt="fstab">
        </figure>

        <h4 class="post-subtitle">Setting the hostname</h4>

        <pre class="command">echo codingempire > /etc/hostname</pre>

        <h4 class="post-subtitle">Configuring the network</h4>

        <p>First install <code>net-misc/netifrc</code>:</p>

        <pre class="command">emerge --ask --noreplace net-misc/netifrc</pre>

        <p><code>net-misc/netifrc</code> package needs <code>net-misc/dhcpcd</code> to obtain an IP address.</p>
        
        <pre class="command">emerge --ask --noreplace net-misc/dhcpcd</pre>
                
        <p>Then we list all available physical network interfaces:</p>

        <pre class="command">find /sys/class/net -type l -not -lname '*virtual*' -printf '%f\n'</pre>

        <p>The <code>-type l</code> option tells to look for symbolic links.</p>
        
        <p>The <code>-lname '*virtual*'</code> option tells to ignore the path that contains the virtual string.</p>

        <p>The <code>-printf '%f\n'</code> option tells to print only the basename of the path.</p>

        <p>The output of the command must show that at least one physical network interface is found:</p>

        <pre class="command">enp0s3</pre>

        <p>Then we create <code>/etc/conf.d/net</code> file.</p>

        <pre class="command">touch /etc/conf.d/net</pre>

        <p>Next we set DHCP on that physical network interface. Add these rules in the <code>/etc/conf.d/net</code> file.</p>

        <pre class="command">config_enp0s3="dhcp"</pre>

        <p>Now that the interface name is determined and configuration is done in <code>/etc/conf.d/net</code>, the service script must be created by creating a symlink to <code>/etc/init.de/net.lo</code>:</p>

        <pre class="command">ln -s /etc/init.d/net.lo /etc/init.d/net.enp0s3</pre>

        <p>Finally, enable it at boot:</p>

        <pre class="command">rc-update add net.enp0s3 default</pre>

        <h4 class="post-subtitle">Setting hosts file</h4>
        
        <p><code>/etc/hosts</code> helps in resolving host names to IP addresses for hosts that aren't resolved by the nameserver.</p>

        <h4 class="post-subtitle">Setting root user profile</h4>

        <p>Create a root user profile:</p>

        <pre class="command">touch ~/.profile</pre>

        <p>Then add the <code>PS1</code> variable in the <code>.profile</code> file:</p>        

        <pre class="command">PS1='\u@\h:\w\$ '</pre>

        <h4 class="post-subtitle">Setting root password</h4>

        <p>Set the root password using the <code>passwd</code> command.</p>

        <pre class="command">passwd</pre>

        <h4 class="post-subtitle">Init and boot configuration</h4>

        <p>When using OpenRC with Gentoo, it uses <code>/etc/rc.conf</code> to configure the services, startup, and shutdown of a system.</p>

        <pre class="command">nano /etc/rc.conf</pre>

        <p>Next, open <code>/etc/conf.d/keymaps</code> to handle keyboard configuration. Edit it to configure and select the right keyboard.</p>

        <pre class="command">nano /etc/conf.d/keymaps</pre>

        <p>Finally, edit <code>/etc/conf.d/hwclock</code> to set the clock options. If the hardware clock is not using UTC, then it is necessary to set <code>clock="local"</code> in the file.</p>      
        
        <pre class="command">nano /etc/conf.d/hwclock</pre>

        <h4 class="post-subtitle">System logger</h4>    
        
        <p>Install and activate <code>app-admin/sysklogd</code> as the system's syslog utility:</p>

        <pre class="command">emerge --ask app-admin/sysklogd</pre>

        <pre class="command">rc-update add sysklogd default</pre>     
        
        <h4 class="post-subtitle">Cron daemon</h4>

        <p>A cron daemon executes commands on scheduled intervals. Internals could be daily, weekly, or monthly, once every Tuesday, once every other week, etc.</p>

        <p>All cron daemons support high levels of granularity for scheduled tasks, and generally include the ability to send an email or other form of notification if a scheduled task does not complete as expected.</p>  

        <p>Install and activate <code>sys-process/cronie</code>:</p>

        <pre class="command">emerge --ask sys-process/cronie</pre>

        <pre class="command">rc-update add cronie default</pre>

        <h4 class="post-subtitle">File indexing</h4>
        
        <p>In order to index the file system to provide faster file location capabilities, install <code>sys-apps/mlocate</code>.</p>

        <pre class="command">emerge --ask sys-apps/mlocate</pre>
        
        <h4 class="post-subtitle">Remote shell access</h4>

        <p>Change SSH Configuration file (<code>/etc/ssh/sshd_config</code>), uncomment the <code>Port</code> option to enable SSH client connects to SSH server on port 22.</p>

        <pre class="command">Port 22</pre>

        <p>Uncomment the <code>PermitRootLogin</code> option and set the value to <code>yes</code> to enable root login.</p>

        <pre class="command">PermitRootLogin yes</pre>

        <p>To add the <code>sshd</code> init script to the default runlevel on OpenRC:</p>

        <pre class="command">rc-update add sshd default</pre>

        <h4 class="post-subtitle">Time synchronization</h4>

        <p>Install and activate <code>net-misc/chrony</code>:</p>

        <pre class="command">emerge --ask net-misc/chrony</pre>

        <pre class="command">rc-update add chronyd default</pre>
        
        <h4 class="post-subtitle">Configuring the GRUB bootloader</h4>
        
        <p>The boot loader is responsible for firing up the Linux kernel upon boot - without it, the system would not know how to proceed when the power button has been pressed.</p>

        <p>A note for UEFI users: running the above command will output the enabled <code>GRUB_PLATFORMS</code> values before emerging. When using UEFI capable systems, users will need to ensure <code>GRUB_PLATFORMS="efi-64"</code> is enabled. If that is not the case for the setup, <code>GRUB_PLATFORMS="efi-64"</code> will need to be added to the <code>/etc/portage/make.conf</code> file before emerging GRUB so that the package will be built with EFI functionality:</p>

        <pre class="command">echo 'GRUB_PLATFORMS="efi-64"' >> /etc/portage/make.conf</pre>

        <pre class="command">emerge --ask sys-boot/grub</pre>  

        <p>Next, install the GRUB EFI file (<code>grubx64.efi</code>) to the <code>/boot/efi/</code> directory via the <code>grub-install</code> command. Run <code>grub-install</code> command:</p>

        <pre class="command">grub-install --target=x86_64-efi --efi-directory=/boot/efi</pre>

        <p>Next, generate the GRUB configuration based on the user configuration specified in the <code>/etc/default/grub</code> file and <code>/etc/grub.d scripts</code>. Run the <code>grub-mkconfig</code> command:</p>

        <pre class="command">grub-mkconfig -o /boot/grub/grub.cfg</pre>
        
        <p>The output of the command must mention that at least one Linux image is found, as those are needed to boot the system. If an initramfs is used, the correct initrd image should be detected as well.</p>

        <figure class="post-figure">
            <img src="/assets/images/carbon-11.png" alt="grub-mkconfig">
        </figure>

        <h4 class="post-subtitle">Rebooting the system</h4>
        
        <p>Exit the chrooted environment and unmount all mounted partitions.</p>

        <pre class="command">exit</pre>

        <pre class="command">cd</pre>

        <pre class="command">umount -l /mnt/gentoo/dev{/shm,/pts,}</pre>

        <pre class="command">umount -R /mnt/gentoo</pre>

        <pre class="command">reboot</pre>
    </article>

  {% include post-tags.html %}

  {% include post-share.html %}
</div>