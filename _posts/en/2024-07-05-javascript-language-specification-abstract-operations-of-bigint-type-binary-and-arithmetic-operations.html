---
layout: post
lang: en
locale: en
title: "Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations"
thumb: "javascript.jpg"
eyebrow: "Complete Reference"
description: "Learn about the abstract operations of the BigInt type in JavaScript, focusing on binary and arithmetic operations. This article provides examples, algorithms, and explanations to help you understand these concepts better."
date: 2024-07-05 18:21:00 +0700
author: Samuel Yang
categories: ["Complete Reference", "year-2024", "month-07", "day-05"]
tags: ["javascript", "abstract operation"]
---

<div class="blog-post">
    {% include post-header.html %}

    <article class="post-content">
        <p>An abstract operation is a conceptual operation that is not an actual operation in the language but is used to aid in the specification and understanding of a programming concept or system.</p>

        <p>The following abstract operations are defined over the BigInt type:</p>

        <table>
            <tbody>
                <tr>
                    <th>Operation</th>
                    <th>Example</th>
                    <th>Invoked by</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::unaryMinus</code>
                    </td>
                    <td>
                        <code>-x</code>
                    </td>
                    <td>
                        Unary <code>-</code> Operator
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseNOT</code>
                    </td>
                    <td>
                        <code>~x</code>
                    </td>
                    <td>
                        Bitwise NOT Operator (<code>~</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::exponentiate</code>
                    </td>
                    <td>
                        <code>x&nbsp;**&nbsp;y</code>
                    </td>
                    <td>
                        Exponentiation Operator (<code>**</code>)
                        and <code>Math.pow(base, exponent)</code>
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::multiply</code>
                    </td>
                    <td>
                        <code>x&nbsp;*&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::divide</code>
                    </td>
                    <td>
                        <code>x&nbsp;/&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                
                <tr>
                    <td>
                        <code>BigInt::remainder</code>
                    </td>
                    <td>
                        <code>x&nbsp;%&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::add</code>
                    </td>
                    <td>
                        <code>x ++</code>
                        <br>
                        <code>++ x</code>
                        <br>
                        <code>x&nbsp;+&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Increment Operator, Prefix Increment Operator, and The Addition Operator (<code>+</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                
                <tr>
                    <td>
                        <code>BigInt::subtract</code>
                    </td>
                    <td>
                        <code>x --</code>
                        <br>
                        <code>-- x</code>
                        <br>
                        <code>x&nbsp;-&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Decrement Operator, Prefix Decrement Operator, and The Subtraction Operator (<code>-</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::leftShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&lt;&nbsp;y</code>
                    </td>
                    <td>
                        The Left Shift Operator(<code>&lt;&lt;</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::signedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Signed Right Shift Operator(<code>&gt;&gt;</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td>  a throw completion  </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::lessThan</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&lt;=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;=&nbsp;y</code>
                    </td>
                    <td>
                        Relational Operators, via <code>IsLessThan (x, y, LeftFirst)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::equal</code>
                    </td>
                    <td>
                        <code>x&nbsp;==&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;===&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!==&nbsp;y</code>
                    </td>
                    <td>
                        Equality Operators, via <code>IsStrictlyEqual (x, y)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::sameValue</code>
                    </td>
                    <td>
                        <code>Object.is(x, y)</code>
                    </td>
                    <td> 
                        Object internal methods, via <code>SameValue (x, y)</code>, to test exact value equality 
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::sameValueZero</code>
                    </td>
                    <td>
                        <code>[x].includes(y)</code>
                    </td>
                    <td> 
                        Array, Map, and Set methods, via <code>SameValueZero (x, y)</code>, to test value equality, ignoring the difference between +0 and -0
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseAND</code>
                    </td>
                    <td>
                        <code>x&nbsp;&amp;&nbsp;y</code>
                    </td>
                    <td rowspan="3">
                        Binary Bitwise Operators
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseXOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;^&nbsp;y</code>
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;|&nbsp;y</code>
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::toString</code>
                    </td>
                    <td>
                        <code>String(x)</code>
                    </td>
                    <td> Many expressions and built-in functions, via <code>ToString (argument)</code> 
                    </td>
                    <td> String </td>
                </tr>
            </tbody>
        </table>

        <h6>BigInt::unaryMinus (x)</h6>

        <p>The abstract operation <code>BigInt::unaryMinus</code> takes argument <code>x</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is 0, return 0.</li>
            <li>Return the BigInt value that represents the negation of <code>x</code>.</li>
        </ol>

        <pre><code class="language-bash hljs">BigInt.unaryMinus = function (x) {
    if(x === 0n) {
        return BigInt(x);
    }
    return -BigInt(x);
}
BigInt.unaryMinus(100n);</code></pre>
        
        <h6>BigInt::bitwiseNOT (x)</h6>

        <p>The abstract operation <code>BigInt::bitwiseNOT</code> takes argument <code>x</code> (a BigInt) and returns a BigInt. It returns the one's complement of x. It performs the following steps when called:</p>

        <ol>
            <li>Return -x - 1.</li>
            <li>Return the BigInt value that represents the negation of <code>x</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.bitwiseNOT = function (x) {
    return -BigInt(x) - 1;
}
BigInt.bitwiseNOT(100n);</code></pre>

        <h6>BigInt::exponentiate (base, exponent)</h6>

        <p>The abstract operation <code>BigInt::exponentiate</code> takes arguments <code>base</code> (a BigInt) and <code>exponent</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>exponent</code> < 0, throw a <code>RangeError</code> exception.</li>
            <li>If <code>base</code> is 0 and <code>exponent</code> is 0, return 1.</li>
            <li>Return the BigInt value that represents <code>base</code> raised to the power <code>exponent</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.exponentiate = function (base, exponent) {
    if(BigInt(exponent) < 0n) {
        // If exponent < 0, throw a RangeError exception
        throw new RangeError("The exponent must be greater than 0.");
    }
    if(BigInt(base) === 0n && BigInt(exponent) === 0n) {
        // If base is 0 and exponent is 0, return 1
        return BigInt(1);
    }

    // Return the BigInt value that represents base raised to the power exponent
    return BigInt(base) ** BigInt(exponent);
}
BigInt.exponentiate(100n, 100n);</code></pre>

        <h6>BigInt::multiply  (x, y)</h6>

        <p>The abstract operation <code>BigInt::multiply</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the product of <code>x</code> and <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.multiply = function (x, y) {
    // Return the BigInt value that represents the product of x and y
    return BigInt(x) * BigInt(y);
}
BigInt.multiply(100n, 100n);</code></pre>

        <h6>BigInt::divide (x, y)</h6>

        <p>The abstract operation <code>BigInt::divide</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>y</code> is 0, throw a <code>RangeError</code> exception.</li>
            <li>Let <code>quotient</code> be <code>x</code> / <code>y</code>.</li>
            <li>Return <code>truncate(quotient)</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.divide = function (x, y) {
    // If y is 0, throw a RangeError exception.
    if(BigInt(y) === 0n) {
        throw new RangeError("The divisor must be greater than 0.");
    }

    // Let quotient be x / y
    let quotient = BigInt(x) / BigInt(y);

    // Return truncate(quotient)
    return BigInt(quotient);
}
BigInt.divide(100n, 2n);</code></pre>

        <h6>BigInt::remainder (n, d)</h6>

        <p>The abstract operation <code>BigInt::remainder</code> takes arguments <code>n</code> (a BigInt) and <code>d</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>d</code> is 0, throw a <code>RangeError</code> exception.</li>
            <li>If <code>n</code> is 0, return 0.</li>
            <li>Let <code>quotient</code> be <code>n</code> / <code>d</code>.</li>
            <li>Let <code>q</code> be <code>truncate(quotient)</code>.</li>
            <li>Return <code>n</code> - (<code>d</code> × <code>q</code>).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.remainder = function (n, d) {
    // If d is 0, throw a RangeError exception
    if(BigInt(d) === 0n) {
        throw new RangeError("The divisor must be greater than 0.");
    }

    // If n is 0, return 0
    if(BigInt(n) === 0n) {
        return BigInt(0);
    }

    // Let quotient be n / d
    let quotient = BigInt(n) / BigInt(d);

    // Let q be truncate(quotient)
    let q = quotient;

    // Return n - (d × q)
    return BigInt(n) - (BigInt(d) * BigInt(q));
}
BigInt.remainder(13n, 3n);</code></pre>

        <h6>BigInt::add (x, y)</h6>

        <p>The abstract operation <code>BigInt::add</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the sum of <code>x</code> and <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.add = function (x, y) {
    // Return the BigInt value that represents the sum of x and y
    return BigInt(x) + BigInt(y);
}
BigInt.add(13n, 3n);</code></pre>

        <h6>BigInt::subtract (x, y)</h6>

        <p>The abstract operation <code>BigInt::subtract</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the difference <code>x</code> minus <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.subtract = function (x, y) {
    // Return the BigInt value that represents the difference x minus y
    return BigInt(x) - BigInt(y);
}
BigInt.add(13n, 3n);</code></pre>

        <h6>BigInt::leftShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::leftShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>If <code>y</code> < 0, then<br>
                <ol>
                    <li>Return the BigInt value that represents $$x / 2^-y$$, rounding down to the nearest integer, including for negative numbers.</li>
                </ol>
            </li>
            <li>Return the BigInt value that represents $$x × 2^y$$.</li>
        </ol>
        
        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.leftShift = function (x, y) {
    if(y < 0) {
        // If y < 0, then return the BigInt value that represents x / 2^-y, rounding down to the nearest integer, including for negative numbers.
        return BigInt(x) / BigInt(2) ** BigInt(-y);
    }

    // Return the BigInt value that represents x × 2^y.
    return BigInt(x) * BigInt(2) ** BigInt(y);
}
BigInt.leftShift(13n, -3n);</code></pre>

        <h6>BigInt::signedRightShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::signedRightShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return <code>BigInt::leftShift(x, -y)</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.leftShift = function (x, y) {
    if(y < 0) {
        // If y < 0, then return the BigInt value that represents x / 2^-y, rounding down to the nearest integer, including for negative numbers.
        return BigInt(x) / BigInt(2) ** BigInt(-y);
    }

    // Return the BigInt value that represents x × 2^y.
    return BigInt(x) * BigInt(2) ** BigInt(y);
};
BigInt.signedRightShift = function (x, y) {
    // Return BigInt::leftShift(x, -y).
    return BigInt.leftShift(x, -y);
};
BigInt.signedRightShift(13n, -3n);</code></pre>


        <h6>BigInt::unsignedRightShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::unsignedRightShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>Throw a <code>TypeError</code> exception.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.unsignedRightShift = function (x, y) {
    throw new TypeError("Invalid operator") 
};
BigInt.unsignedRightShift(13n, -3n);</code></pre>

        <h6>BigInt::lessThan (x, y)</h6>

        <p>The abstract operation <code>BigInt::lessThan</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> < <code>y</code>, return <code>true</code>; otherwise return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.lessThan = function (x, y) {
    if(BigInt(x) < BigInt(y)) {
        // If x < y, return true; 
        return true;
    }else {
        // otherwise return false
        return false;
    }
};
BigInt.lessThan(13n, -13n);</code></pre>

        <h6>BigInt::equal (x, y)</h6>

        <p>The abstract operation <code>BigInt::equal</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> = <code>y</code>, return <code>true</code>; otherwise return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.lessThan = function (x, y) {
    if(BigInt(x) === BigInt(y)) {
        // If x = y, return true; 
        return true;
    }else {
        // otherwise return false
        return false;
    }
};
BigInt.lessThan(13n, -13n);</code></pre>

        <h6>BinaryAnd (x, y)</h6>

        <p>The abstract operation <code>BinaryAnd</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 and y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryAnd(x, y) {
    if(x === BigInt(1) && y === BigInt(1)) {
        // If x = 1 and y = 1, return 1;
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
BinaryAnd(1n, 0n);</code></pre>

        <h6>BinaryOr (x, y)</h6>

        <p>The abstract operation <code>BinaryOr</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 or y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryOr(x, y) {
    if(x === BigInt(1) || y === BigInt(1)) {
        // If x = 1 or y = 1, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
BinaryOr(1n, 0n);</code></pre>

        <h6>BinaryXor (x, y)</h6>

        <p>The abstract operation <code>BinaryXor</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 and y = 0, return 1.</li>
            <li>Else if x = 0 and y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryXor(x, y) {
    if(x === BigInt(1) && y === BigInt(0)) {
        // If x = 1 and y = 0, return 1 
        return BigInt(1);
    } else if(x === BigInt(0) && y === BigInt(1)) {
        // Else if x = 0 and y = 1, return 1
        return BigInt(1);
    } else {
        // Else, return 0
        return BigInt(0);
    }
};
BinaryXor(1n, 0n);</code></pre>


        <h6>BigIntBitwiseOp (op, x, y)</h6>

        <p>The abstract operation <code>BigIntBitwiseOp</code> takes arguments <code>op</code> (<code>&</code>, <code>^</code>, or <code>|</code>), <code>x</code> (a BigInt), and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Set <code>x</code> to <code>x</code>.</li>
            <li>Set <code>y</code> to <code>y</code>.</li>
            <li>Let <code>result</code> be 0.</li>
            <li>Let <code>shift</code> be 0.</li>
            <li>Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1),<br>
                <ol>
                    <li>Let <code>xDigit</code> be <code>x</code> modulo 2.</li>
                    <li>Let <code>yDigit</code> be <code>y</code> modulo 2.</li>
                    <li>If <code>op</code> is <code>&</code>, set <code>result</code> to $$result + 2^shift × BinaryAnd(xDigit, yDigit)$$.</li>
                    <li>Else if <code>op</code> is <code>|</code>, set <code>result</code> to $$result + 2^shift × BinaryOr(xDigit, yDigit)$$.</li>
                    <li>Else<br>
                        <ol>
                            <li>Assert: <code>op</code> is <code>^</code>.</li>
                            <li>Set <code>result</code> to $$result + 2^shift × BinaryXor(xDigit, yDigit)$$.</li>
                        </ol>
                    </li>
                    <li>Set <code>shift</code> to <code>shift</code> + 1.</li>
                    <li>Set <code>x</code> to $$(x - xDigit) / 2$$.</li>
                    <li>Set <code>y</code> to $$(y - yDigit) / 2$$.</li>
                </ol>
            </li>
            <li>If <code>op</code> is <code>&</code>, let <code>tmp</code> be <code>BinaryAnd(x modulo 2, y modulo 2)</code>.</li>
            <li>Else if <code>op</code> is <code>|</code>, let <code>tmp</code> be <code>BinaryOr(x modulo 2, y modulo 2)</code>.</li>
            <li>Else,<br>
                <ol>
                    <li>Assert: <code>op</code> is <code>^</code>.</li>
                    <li>Let <code>tmp</code> be <code>BinaryXor(x modulo 2, y modulo 2)</code>.</li>
                </ol>
            </li>
            <li>If <code>tmp</code> ≠ 0, then<br>
                <ol>
                    <li>Set <code>result</code> to $$result - 2^shift$$.</li>
                    <li>NOTE: This extends the sign.</li>
                </ol>
            </li>
            <li>Return the BigInt value for <code>result</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};</code></pre>

        <h6>BigInt::bitwiseAND (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseAND</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(&, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryAnd(x, y) {
    if(x === BigInt(1) && y === BigInt(1)) {
        // If x = y, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseAND = function (x, y) {
    return BigIntBitwiseOp('&', x, y);
}
BigInt.bitwiseAND(102n, 875n);</code></pre>

        <h6>BigInt::bitwiseXOR (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseXOR</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(^, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryXor(x, y) {
    if(x === BigInt(1) && y === BigInt(0)) {
        // If x = 1 and y = 0, return 1 
        return BigInt(1);
    } else if(x === BigInt(0) && y === BigInt(1)) {
        // Else if x = 0 and y = 1, return 1
        return BigInt(1);
    } else {
        // Else, return 0
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseXOR = function (x, y) {
    return BigIntBitwiseOp('^', x, y);
}
BigInt.bitwiseXOR(102n, 875n);</code></pre>

        <h6>BigInt::bitwiseOR (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseOR</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(|, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryOr(x, y) {
    if(x === BigInt(1) || y === BigInt(1)) {
        // If x = 1 or y = 1, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseOR = function (x, y) {
    return BigIntBitwiseOp('|', x, y);
}
BigInt.bitwiseOR(102n, 875n);</code></pre>

        <h6>BigInt::toString (x, radix)</h6>

        <p>The abstract operation <code>BigInt::toString</code> takes arguments <code>x</code> (a BigInt) and <code>radix</code> (an integer in the inclusive interval from 2 to 36) and returns a String. It represents <code>x</code> as a String using a positional numeral system with radix <code>radix</code>. The digits used in the representation of a BigInt using radix <code>r</code> are taken from the first <code>r</code> code units of <b>"0123456789abcdefghijklmnopqrstuvwxyz"</b> in order. The representation of BigInts other than 0 never includes leading zeroes. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> < 0, return the string-concatenation of <code>"-"</code> and <code>BigInt::toString(-x, radix)</code>.</li>
            <li>Return the String value consisting of the representation of <code>x</code> using radix <code>radix</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.toString = function (x, radix) {
    if(x < BigInt(0)) {
        return "-" + BigInt.toString(-x, radix);
    }

    let result = "";
    let number = BigInt(x);

    while(number > BigInt(0n)) {    
        let remainder = number % BigInt(radix);
            
        if (remainder === BigInt(10n)) {
            result = "A" + result;
        } else if (remainder === BigInt(11n)) {
            result = "B" + result;
        } else if (remainder === BigInt(12n)) {
            result = "C" + result;
        } else if (remainder === BigInt(13n)) {
            result = "D" + result;
        } else if (remainder === BigInt(14n)) {
            result = "E" + result;
        } else if (remainder === BigInt(15n)) {
            result = "F" + result;
        } else if (remainder === BigInt(16n)) {
            result = "G" + result;
        } else if (remainder === BigInt(17n)) {
            result = "H" + result;
        } else if (remainder === BigInt(18n)) {
            result = "I" + result;
        } else if (remainder === BigInt(19n)) {
            result = "J" + result;
        } else if (remainder === BigInt(20n)) {
            result = "K" + result;
        } else if (remainder === BigInt(21n)) {
            result = "L" + result;
        } else if (remainder === BigInt(22n)) {
            result = "M" + result;
        } else if (remainder === BigInt(23n)) {
            result = "N" + result;
        } else if (remainder === BigInt(24n)) {
            result = "O" + result;
        } else if (remainder === BigInt(25n)) {
            result = "P" + result;
        } else if (remainder === BigInt(26n)) {
            result = "Q" + result;
        } else if (remainder === BigInt(27n)) {
            result = "R" + result;
        } else if (remainder === BigInt(28n)) {
            result = "S" + result;
        } else if (remainder === BigInt(29n)) {
            result = "T" + result;
        } else if (remainder === BigInt(30n)) {
            result = "U" + result;
        } else if (remainder === BigInt(31n)) {
            result = "V" + result;
        } else if (remainder === BigInt(32n)) {
            result = "W" + result;
        } else if (remainder === BigInt(33n)) {
            result = "X" + result;
        } else if (remainder === BigInt(34n)) {
            result = "Y" + result;
        } else if (remainder === BigInt(35n)) {
            result = "Z" + result;
        } else {
            result = remainder + result;
        }    
        
        number = number / radix;
    }
    return result;
}
BigInt.toString(123456789012345678901234567890n, 16n);</code></pre>
        
    </article>

    {% include post-tags.html %}

    {% include post-share.html %}
</div>