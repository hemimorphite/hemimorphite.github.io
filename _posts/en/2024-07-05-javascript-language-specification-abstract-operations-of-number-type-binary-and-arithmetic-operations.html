---
layout: post
lang: en
locale: en
title: "Javascript Language Specification: Abstract Operations of Number Type Binary and Arithmetic Operations"
thumb: "javascript.jpg"
eyebrow: "Complete Reference"
description: "Learn about the abstract operations of the Number type in JavaScript, focusing on binary and arithmetic operations. This article provides examples, algorithms, and explanations to help you understand these concepts better."
date: 2024-07-05 18:00:00 +0700
author: Samuel Yang
categories: ["Complete Reference", "year-2024", "month-07", "day-05"]
tags: ["javascript", "abstract operation"]
---

<div class="blog-post">
    {% include post-header.html %}

    <article class="post-content">
        <p>An abstract operation is a conceptual operation that is not an actual operation in the language but is used to aid in the specification and understanding of a programming concept or system.</p>

        <p>The following abstract operations are defined over the Number object:</p>

        <table>
            <tbody>
                <tr>
                    <th>Operation</th>
                    <th>Example</th>
                    <th>Invoked by</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>
                        <code>Number::unaryMinus</code>
                    </td>
                    <td>
                        <code>-x</code>
                    </td>
                    <td>
                        Unary <code>-</code> Operator
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseNOT</code>
                    </td>
                    <td>
                        <code>~x</code>
                    </td>
                    <td>
                        Bitwise NOT Operator (<code>~</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::exponentiate</code>
                    </td>
                    <td>
                        <code>x&nbsp;**&nbsp;y</code>
                    </td>
                    <td>
                        Exponentiation Operator (<code>**</code>)
                        and <code>Math.pow(base, exponent)</code>
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::multiply</code>
                    </td>
                    <td>
                        <code>x&nbsp;*&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::divide</code>
                    </td>
                    <td>
                        <code>x&nbsp;/&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> Number </td>
                </tr>
                
                <tr>
                    <td>
                        <code>Number::remainder</code>
                    </td>
                    <td>
                        <code>x&nbsp;%&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::add</code>
                    </td>
                    <td>
                        <code>x ++</code>
                        <br>
                        <code>++ x</code>
                        <br>
                        <code>x&nbsp;+&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Increment Operator, Prefix Increment Operator, and The Addition Operator (<code>+</code>)
                    </td>
                    <td> Number </td>
                </tr>
                
                <tr>
                    <td>
                        <code>Number::subtract</code>
                    </td>
                    <td>
                        <code>x --</code>
                        <br>
                        <code>-- x</code>
                        <br>
                        <code>x&nbsp;-&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Decrement Operator, Prefix Decrement Operator, and The Subtraction Operator (<code>-</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::leftShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&lt;&nbsp;y</code>
                    </td>
                    <td>
                        The Left Shift Operator(<code>&lt;&lt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::signedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Signed Right Shift Operator(<code>&gt;&gt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::lessThan</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&lt;=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;=&nbsp;y</code>
                    </td>
                    <td>
                        Relational Operators, via <code>IsLessThan (x, y, LeftFirst)</code>
                    </td>
                    <td> Boolean or <code>undefined</code> (for unordered inputs) </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::equal</code>
                    </td>
                    <td>
                        <code>x&nbsp;==&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;===&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!==&nbsp;y</code>
                    </td>
                    <td>
                        Equality Operators, via <code>IsStrictlyEqual (x, y)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::sameValue</code>
                    </td>
                    <td>
                        <code>Object.is(x, y)</code>
                    </td>
                    <td> 
                        Object internal methods, via <code>SameValue (x, y)</code>, to test exact value equality 
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::sameValueZero</code>
                    </td>
                    <td>
                        <code>[x].includes(y)</code>
                    </td>
                    <td> 
                        Array, Map, and Set methods, via <code>SameValueZero (x, y)</code>, to test value equality, ignoring the difference between +0 and -0
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseAND</code>
                    </td>
                    <td>
                        <code>x&nbsp;&amp;&nbsp;y</code>
                    </td>
                    <td>
                        Binary Bitwise Operators
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseXOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;^&nbsp;y</code>
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;|&nbsp;y</code>
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::toString</code>
                    </td>
                    <td>
                        <code>String(x)</code>
                    </td>
                    <td> Many expressions and built-in functions, via <code>ToString (argument)</code> 
                    </td>
                    <td> String </td>
                </tr>
            </tbody>
        </table>

        <h5 class="post-subtitle">Number::unaryMinus(x)</h5>

        <p>The abstract operation <code>Number::unaryMinus</code> takes argument <code>x</code> (a Number) and returns a <code>Number</code>. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>Return the result of negating <code>x</code>; that is, compute a <code>Number</code> with the same magnitude but opposite sign.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.unaryMinus = function(x) {
            if (Number.isNaN(x)) {
                // if x is NaN, return NaN
                return Number.NaN;
            } else {
                // return the result of negating
                return Number(-x);
            }
        };
        Number.unaryMinus(Number(100));</code></pre>

        <h5 class="post-subtitle">Number::bitwiseNOT(x)</h5>

        <p>The abstract operation <code>Number::bitwiseNOT</code> takes argument <code>x</code> (a Number) and returns a Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>oldValue</code> be <code>!ToInt32(x)</code></li>
            <li>Return the result of applying bitwise complement to <code>oldValue</code>. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.</li>
        </ol>

        <p>The <code>!ToInt32(x)</code> just means that we are certain that this call to <code>ToInt32</code> will never return an exception</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.bitwiseNOT = function(x) {
    // return the result of applying bitwise complement to x
    return Number(~x);
};
Number.bitwiseNOT(Number(100));</code></pre>

        <h5 class="post-subtitle">Number::exponentiate (base, exponent)</h5>

        <p>The abstract operation <code>Number::exponentiate</code> takes arguments <code>base</code> (a Number) and <code>exponent</code> (a Number) and returns a Number. It returns an implementation-approximated value representing the result of raising base to the exponent power. It performs the following steps when called:</p>

        <ol>
            <li>If <code>exponent</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>exponent</code> is either +0 or -0, return <code>1</code>.</li>
            <li>If <code>base</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>base</code> is +∞, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, return +∞. Otherwise, return +0</li>
                </ol>
            </li>
            <li>If <code>base</code> is -∞, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, then<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -∞. Otherwise, return +∞.</li>
                        </ol>
                    </li>
                    <li>Else<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -0. Otherwise, return +0.</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>If <code>base</code> is +0, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, return +0. Otherwise, return +∞.</li>
                </ol>
            </li>
            <li>If <code>base</code> is -0, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, return +0. Otherwise, return +∞.<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -0. Otherwise, return +0.</li>
                        </ol>
                    </li>
                    <li>Else,<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -∞. Otherwise, return +∞.</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>
                Assert: <code>base</code> is finite and is neither +0 nor -0.
            </li>
            <li>If <code>exponent</code> is +∞, then<br>
                <ol>
                    <li>If <code>abs(base)</code> > 1, return +∞.</li>
                    <li>If <code>abs(base)</code> = 1, return <code>NaN</code>.</li>
                    <li>If <code>abs(base)</code> < 1, return +0.</li>
                </ol>
            </li>
            <li>If <code>exponent</code> is -∞, then<br>
                <ol>
                    <li>If <code>abs(base)</code> > 1, return +0.</li>
                    <li>If <code>abs(base)</code> = 1, return <code>NaN</code>.</li>
                    <li>If <code>abs(base)</code> < 1, return +∞.</li>
                </ol>
            </li>
            <li>Assert: <code>exponent</code> is finite and is neither +0 nor -0.</li>
            <li>If <code>base</code> < -0 and <code>exponent</code> is not an integral Number, return <code>NaN</code>.</li>
            <li>Return an implementation-approximated Number value representing the result of raising <code>base</code> to the <code>exponent</code> power.</li>
        </ol>

        <pre><code class="language-bash hljs">Number.exponentiate = function(base, exponent) {
    if(Number.isNaN(exponent)) {
        // if exponent is NaN, return NaN
        return Number.NaN;
    }
    if(Number(exponent) === 0) {
        // if exponent is either +0 or -0, return 1
        return 1;
    }
    if(Number.isNaN(base)) {
        // if base is NaN, return NaN
        return Number.NaN;
    }
    if(Number(base) === +Infinity) {
        // if base is +∞
        if(Number(exponent) > 0) {
            // if exponent > +0, return +∞
            return +Infinity;
        } else {
            // otherwise, return +0
            return Number(0);
        }
    }
    if(Number(base) === -Infinity) {
        // if base is -∞, then
        if(Number(exponent) > 0) {
            // if exponent > +0, then
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -∞
                return -Infinity;
            }
            else {
                // otherwise, return +∞
                return +Infinity;
            }
        } else {
            // else
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -0
                return Number(-0);
            }
            else {
                // otherwise, return +0.
                return Number(0);
            }
        }
    }
    if(Number(base) === Infinity) {
        // f base is +∞, then
        if(Number(exponent) > 0) {
            // If exponent > +0, return +∞
            return Infinity;
        }
        else {
            // Otherwise, return +0
            return Number(0);
        }
    }
    if(Number(base) === -Infinity) {
        // if base is -∞, then
        if(exponent > 0) {
            // if exponent > +0 then
            if(exponent % 2 === 1) {
                // if exponent is an odd integral Number, return -∞
                return -Infinity;
            }
            else {
                // otherwise, return +∞
                return Infinity;
            }
        }
        else {
            // else
            if(exponent % 2 === 1) {
                // if exponent is an odd integral Number, return -0
                return Number(-0);
            }
            else {
                // otherwise, return +0
                return Number(0);
            }
        }
    }
    if(1/Number(base) === Infinity) {
        // if base is +0, then
        if(Number(exponent) > 0) {
            // if exponent > +0, return +0
            return Number(0);
        }
        else {
            // otherwise, return +∞
            return Infinity;
        }
    }
    if(1/Number(base) === -Infinity) {
        // if base is -0, then
        if(Number(exponent) > 0) {
            // if exponent > +0 then
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -0
                return Number(-0);
            }
            else {
                // Otherwise, return +0
                return Number(0);
            }
        }
        else {
            // else
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -∞
                return -Infinity;
            }
            else {
                // otherwise, return +∞
                return Infinity;
            }
        }
    }
    // base is finite and is neither +0 nor -0
    if(exponent === Infinity) {
        // if exponent is +∞, then
        if(Math.abs(base) > 1) {
            // if abs(base) > 1, return +∞
            return Infinity;
        }
        if(Math.abs(base) === 1) {
            // if abs(base) = 1, return NaN
            return Number.NaN;
        }
        if(Math.abs(base) <  1) {
            // If abs(base) < 1, return +0
            return Number(0);
        }
    }

    if(exponent === -Infinity) {
        // if exponent is -∞, then
        if(Math.abs(base) > 1) {
            // if abs(base) > 1, return +0
            return Number(0);
        }
        if(Math.abs(base) === 1) {
            // if abs(base) = 1, return NaN.
            return Number.NaN;
        }
        if(Math.abs(base) <  1) {
            // if abs(base) < 1, return +∞
            return Infinity;
        }
    }

    // exponent is finite and is neither +0 nor -0
    if(base < 0 && Math.isNaN(exponent)) {
        // if base < -0 and exponent is not an integral Number, return NaN.
        return Number.NaN;
    }
    // return an implementation-approximated Number value representing the result of raising base to the exponent power.
    return Number(base) ** Number(exponent);
};
Number.exponentiate(Number(2), Number(1.2));</code></pre>

        <h5 class="post-subtitle">Number::multiply (x, y)</h5>

        <p>The abstract operation <code>Number::multiply</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs multiplication according to the rules of IEEE 754-2019 binary double-precision arithmetic, producing the product of <code>x</code> and <code>y</code>. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> or <code>y</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>x</code> is either +∞ or -∞, then<br>
                <ol>
                    <li>If <code>y</code> is either +0 or -0, return <code>NaN</code>.</li>
                    <li>If <code>y</code> > +0, return <code>x</code>.</li>
                    <li>Return <code>-x</code>.</li>
                </ol>
            </li>
            <li>If <code>y</code> is either +∞ or -∞, then<br>
                <ol>
                    <li>If <code>x</code> is either +0 or -0, return <code>NaN</code>.</li>
                    <li>If <code>x</code> > +0, return <code>y</code>.</li>
                    <li>Return <code>-y</code>.</li>
                </ol>
            </li>
            <li>If x is -0, then<br>
                <ol>
                    <li>If <code>y</code> is -0 or <code>y</code> < -0, return +0.</li>
                    <li>Else, return -0.</li>
                </ol>
            </li>
            <li>If y is -0, then<br>
                <ol>
                    <li>If <code>x</code> < -0, return +0.</li>
                    <li>Else, return -0.</li>
                </ol>
            </li>
            <li>Return <code>x</code> × <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.multiply = function(x, y) {
    if(Number.isNaN(x) || Number.isNaN(y)) {
        // if x is NaN or y is NaN, return NaN
        return Number.NaN;
    }
    if(Number(x) === +Infinity || Number(x) === -Infinity) {
        // if x is either +∞ or -∞, then
        if(1/Number(y) === +Infinity || 1/Number(y) === -Infinity) {
            // If y is either +0 or -0, return NaN
            return Number.NaN;
        }

        if(Number(y) > 0) {
            // If y > +0, return x
            return Number(x);
        }
        // Return -x
        return Number(-x);
    }
    if(Number(y) === +Infinity || Number(y) === -Infinity) {
        // if y is either +∞ or -∞, then
        if(Number(x) === 0) {
            // if x is either +0 or -0, return NaN.
            return Number.NaN;
        }
        if(Number(x) > 0) {
            // if x > +0, return y.
            return Number(y);
        }
        // Return -y
        return Number(-y);
    }
    if(1/Number(x) === -Infinity) {
        // If x is -0, then
        if(1/Number(y) === -Infinity || y < 0) {
            // If y is -0 or y < -0, return +0
            return Number(0);
        } else {
            // Else, return -0
            return Number(-0);
        }
    }
    if(1/Number(-y) === -Infinity) {
        // If y is -0, then
        if(x < 0) {
            // If x < -0, return +0
            return Number(0);
        }
        else {
            // Else, return -0
            return Number(-0);
        }
    }
    // Return x × y
    return Number(x) * Number(y);
};
Number.multiply(Number(1.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::divide (x, y)</h5>

        <p>The abstract operation <code>Number::divide</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs division according to the rules of IEEE 754-2019 binary double-precision arithmetic, producing the quotient of <code>x</code> and <code>y</code> where <code>x</code> is the dividend and <code>y</code> is the divisor. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> or <code>y</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>x</code> is either +∞ or -∞, then<br>
                <ol>
                    <li>If <code>y</code> is either +∞ or -∞, return <code>NaN</code>.</li>
                    <li>If <code>y</code> is +0 or <code>y</code> > +0, return <code>x</code>.</li>
                    <li>Return <code>-x</code>.</li>
                </ol>
            </li>
            <li>If <code>y</code> is +∞, then<br>
                <ol>
                    <li>If <code>x</code> is +0 or <code>x</code> > +0, return +0. Otherwise, return -0.</li>
                </ol>
            </li>
            <li>If <code>y</code> is -∞, then<br>
                <ol>
                    <i>If <code>x</code> is +0 or <code>x</code> > +0, return -0. Otherwise, return +0.</i>
                </ol>
            </li>
            <li>If <code>x</code> is either +0 or -0, then<br>
                <ol>
                    <li>If <code>y</code> is either +0 or -0, return <code>NaN</code>.</li>
                    <li>If <code>y</code> > +0, return <code>x</code>.</li>
                    <li>Return <code>-x</code>.</li>
                </ol>
            </li>
            <li>If <code>y</code> is +0, then<br>
                <ol>
                    <li>If <code>x</code> > +0, return +∞. Otherwise, return -∞.</li>
                </ol>
            </li>
            <li>If <code>y</code> is -0, then<br>
                <li>If <code>x</code> > +0, return -∞. Otherwise, return +∞.</li>
            </li>
            <li>
                Return x / y.
            </li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.divide = function(x, y) {
    if(Number.isNaN(x) || Number.isNaN(y)) {
        // if x is NaN or y is NaN, return NaN
        return Number.NaN;
    }
    if(Number(x) === +Infinity || Number(x) === -Infinity) {
        // if x is either +∞ or -∞, then
        if(Number(y) === +Infinity || Number(y) === -Infinity) {
            // If y is either +∞ or -∞, return NaN
            return Number.NaN;
        }
        if(1/Number(y) === Infinity ||  Number(y) > 0) {
            // If y is +0 or y > +0, return x
            return Number(x);
        }
        // Return -x
        return Number(-x);
    }
    if(Number(y) === +Infinity) {
        // If y is +∞, then
        if(1/Number(x) === Infinity || Number(x) > 0) {
            // If x is +0 or x > +0, return +0
            return Number(0);
        }
        else {
            // Otherwise, return -0
            return Number(-0);
        }
    }
    if(Number(y) === -Infinity) {
        // If y is -∞, then
        if(1/Number(x) === Infinity || x > 0) {
            // If x is +0 or x > +0, return -0
            return Number(-0);
        } else {
            // Otherwise, return +0
            return Number(+0);
        }
    }
    if(Number(x) === 0) {
        // If x is either +0 or -0, then
        if(Number(y) === 0) {
            // If y is either +0 or -0, return NaN.
            return Number.NaN;
        }
        if(Number(y) > 0) {
            // If y > +0, return x
            return Number(x);
        }
        // Return -x
        return Number(-x);
    }
    if(1/Number(y) === Infinity) {
        // If y is +0, then
        if(Number(x) > 0) {
            // If x > +0, return +∞
            return Infinity;
        }
        else {
            // Otherwise, return -∞
            return -Infinity;
        }
    }
    if(1/Number(y) === -Infinity) {
        // If y is -0, then
        if(x > 0) {
            // If x > +0, return -∞
            return -Infinity;
        }
        else {
            // Otherwise, return +∞
            return Infinity;
        }
    }

    // Return x / y
    return Number(x) / Number(y);
};
Number.divide(Number(1.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::remainder (n, d)</h5>

        <p>The abstract operation <code>Number::remainder</code> takes arguments <code>n</code> (a Number) and <code>d</code> (a Number) and returns a Number. It yields the remainder from an implied division of its operands where <code>n</code> is the dividend and <code>d</code> is the divisor. It performs the following steps when called:</p>

        <ol>
            <li>If <code>n</code> is <code>NaN</code> or <code>d</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>n</code> is either +∞ or -∞, return <code>NaN</code>.</li>
            <li>If <code>d</code> is either +∞ or -∞, return <code>n</code>.</li>
            <li>If <code>d</code> is either +0 or -0, return <code>NaN</code>.</li>
            <li>If <code>n</code> is either +0 or -0, return <code>n</code>.</li>
            <li>Assert: <code>n</code> and <code>d</code> are finite and non-zero.</li>
            <li>Let <code>quotient</code> be <code>n / d</code>.</li>
            <li>Let <code>q</code> be <code>truncate(quotient)</code>.</li>
            <li>Let <code>r</code> be <code>n - (d × q)</code>.</li>
            <li>If <code>r</code> = 0 and <code>n</code> < -0, return -0.</li>
            <li>Return <code>r</code>.</li>
        </ol>

        <p>The mathematical function truncate(x) removes the fractional part of x by rounding towards zero, producing -floor(-x) if x < 0 and otherwise producing floor(x).</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.remainder = function(n, d) {
    if(Number.isNaN(n) || Number.isNaN(d)) {
        // If n is NaN or d is NaN, return NaN
        return Number.NaN;
    }
    if(Number(n) === +Infinity || Number(n) === -Infinity) {
        // If n is either +∞𝔽 or -∞𝔽, return NaN
        return Number.NaN;
    }
    if(Number(d) === +Infinity || Number(d) === -Infinity) {
        // If d is either +∞ or -∞, return n
        return Number(d);
    }
    if(Number(d) === 0) {
        // If d is either +0 or -0, return NaN
        return Number.NaN;
    }
    if(Number(n) === 0) {
        // If n is either +0 or -0, return n
        return Number(n);
    }

    // let quotient be n / d
    let quotient = n / d;
    
    // let q be truncate(quotient)
    let q = Math.floor(quotient);

    // let r be n - (d × q)
    let r = n - (d * q);

    if(r === 0 && n < 0) {
        // if r = 0 and n < -0, return -0
        return Number(-0);
    }
    
    // Return r
    return Number(r);
};
Number.remainder(Number(1.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::add (x, y)</h5>

        <p>The abstract operation <code>Number::add</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs addition according to the rules of IEEE 754-2019 binary double-precision arithmetic, producing the sum of its arguments. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> or <code>y</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>x</code> is +∞ and <code>y</code> is -∞, return <code>NaN</code>.</li>
            <li>If <code>x</code> is -∞ and <code>y</code> is +∞, return <code>NaN</code>.</li>
            <li>If <code>x</code> is either +∞ or -∞, return <code>x</code>.</li>
            <li>If <code>y</code> is either +∞ or -∞, return <code>y</code>.</li>
            <li>Assert: <code>x</code> and <code>y</code> are both finite.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is -0, return -0.</li>
            <li>Return <code>x</code> + <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.add = function(x, y) {
    if(Number.isNaN(x) || Number.isNaN(y)) {
        // If x is NaN or y is NaN, return NaN
        return Number.NaN;
    }
    if(Number(x) === +Infinity && Number(y) === -Infinity) {
        // If x is +∞ and y is -∞, return NaN
        return Number.NaN;
    }
    if(Number(x) === -Infinity && Number(y) === Infinity) {
        // If x is -∞ and y is +∞, return NaN.
        return Number.NaN;
    }
    if(Number(x) === Infinity || Number(x) === -Infinity) {
        // If x is either +∞ or -∞, return x
        return Number(x);
    }
    if(Number(y) === Infinity || Number(y) === -Infinity) {
        // If y is either +∞ or -∞, return y
        return Number(y);
    }
    // x and y are both finite
    if(1/Number(x) === -Infinity && 1/Number(y) === -Infinity) {
        // If x is -0 and y is -0, return -0
        return Number(-0);
    }
    
    // Return x + y
    return Number(x) + Number(y);
};
Number.add(Number(73.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::subtract (x, y)</h5>

        <p>The abstract operation Number::subtract takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs subtraction, producing the difference of its operands; <code>x</code> is the minuend and <code>y</code> is the subtrahend. It performs the following steps when called:</p>

        <ol>
            <li>Return <code>Number::add(x, Number::unaryMinus(y))</code></li>
        </ol>

        <h5 class="post-subtitle">Number::leftShift (x, y)</h5>

        <p>The abstract operation <code>Number::leftShift</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToInt32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToUint32(y)</code>.</li>
            <li>Let <code>shiftCount</code> be <code>rnum modulo 32</code>.</li>
            <li>Return the result of left shifting <code>lnum</code> by <code>shiftCount</code> bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.</li>
        </ol>

        <p>The <code>!ToInt32(x)</code> just means that we are certain that this call to <code>ToInt32</code> will never return an exception.</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.leftShift = function (x, y) {
    // lnum is the value of x converted to 32 bit integer
    // rnum is the value of y converted to 32 bit unsigned integer
    let lnum = x;
    let rnum = y;

    // Let shiftCount be rnum modulo 32
    let shiftCount = rnum % 32;

    // Return the result of left shifting lnum by shiftCount bits
    return lnum << shiftCount;
};
Number.leftShift(20, 5);</code></pre>

        <h5 class="post-subtitle">Number::signedRightShift (x, y)</h5>

        <p>The abstract operation <code>Number::signedRightShift</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToInt32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToUint32(y)</code>.</li>
            <li>Let <code>shiftCount</code> be <code>rnum modulo 32</code>.</li>
            <li>Return the result of performing a sign-extending right shift of <code>lnum</code> by <code>shiftCount</code> bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.</li>
        </ol>

        <p>When the most significant bit (MSB) is propagated, it means that the value of the MSB is copied and shifted into the vacant positions during a right shift operation. As a result, the sign of the original number is preserved, and the MSB, which indicates the sign of the number, is replicated and moved to the right. This process is also referred to as an arithmetic shift.</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.signedRightShift = function (x, y) {
    // lnum is the value of x converted to 32 bit integer
    // rnum is the value of y converted to 32 bit unsigned integer
    let lnum = x;
    let rnum = y;

    // Let shiftCount be rnum modulo 32
    let shiftCount = rnum % 32;

    // Return the result of performing a sign-extending right shift of lnum by shiftCount bits
    return lnum >> shiftCount;
};
Number.signedRightShift(320, 5);</code></pre>

        <h5 class="post-subtitle">Number::unsignedRightShift (x, y)</h5>

        <p>The abstract operation <code>Number::unsignedRightShift</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToUint32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToUint32(y)</code>.</li>
            <li>Let <code>shiftCount</code> be <code>rnum modulo 32</code>.</li>
            <li>Return the result of performing a zero-filling right shift of <code>lnum</code> by <code>shiftCount</code> bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.unsignedRightShift = function (x, y) {
    // lnum is the value of x converted to 32 bit unsigned integer
    // rnum is the value of y converted to 32 bit unsigned integer
    let lnum = x;
    let rnum = y;

    // Let shiftCount be rnum modulo 32
    let shiftCount = rnum % 32;

    // Return the result of performing a sign-extending right shift of lnum by shiftCount bits
    return lnum >>> shiftCount;
};
Number.unsignedRightShift(320, 5);</code></pre>

        <h5 class="post-subtitle">Number::lessThan (x, y)</h5>

        <p>The abstract operation <code>Number::lessThan</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean or undefined. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>undefined</code>.</li>
            <li>If <code>y</code> is <code>NaN</code>, return <code>undefined</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>false</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>false</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>false</code>.</li>
            <li>If <code>x</code> is +∞, return <code>false</code>.</li>
            <li>If <code>y</code> is +∞, return <code>true</code>.</li>
            <li>If <code>y</code> is -∞, return <code>false</code>.</li>
            <li>If <code>x</code> is -∞, return <code>true</code>.</li>
            <li>Assert: <code>x</code> and <code>y</code> are finite and non-zero.</li>
            <li>If <code>x</code> < <code>y</code>, return <code>true</code>. Otherwise, return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.lessThan = function (x, y) {
    if(Number.isNaN(x)) {
        // If x is NaN, return undefined
        return undefined;
    }
    if(Number.isNaN(y)) {
        // If y is NaN, return undefined
        return undefined;
    }
    if(x === y) {
        // If x is y, return false
        return false;
    }
    if(1/Number(x) === Infinity && 1/Number(y) === -Infinity) {
        // If x is +0 and y is -0, return false
        return false;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) === Infinity) {
        // If x is -0 and y is +0, return false
        return false;
    }
    if(x === Infinity) {
        // If x is +∞, return false
        return false;
    }
    if(y === Infinity) {
        // If y is +∞, return true
        return true;
    }
    if(y === -Infinity) {
        // If y is -∞, return false
        return false;
    }
    if(x === -Infinity) {
        // If x is -∞, return true.
        return true;
    }
    // x and y are finite and non-zero
    
    // If x < y, return true
    if(Number(x) < Number(y)) {
        return true;
    }
    else {
        return false;
    }
};
Number.lessThan(30, 50);</code></pre>

        <h5 class="post-subtitle">Number::equal(x, y)</h5>

        <p>The abstract operation <code>Number::equal</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>false</code>.</li>
            <li>If <code>y</code> is <code>NaN</code>, return <code>false</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>true</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>true</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>true</code>.</li>
            <li>Return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.equal = function (x, y) {
    if(Number.isNaN(x)) {
        // If x is NaN, return false
        return false;
    }
    if(Number.isNaN(y)) {
        // If y is NaN, return false.
        return false;
    }
    if(x === y) {
        // If x is y, return true
        return true;
    }
    if(1/Number(x) === Infinity && 1/Number(y) === -Infinity) {
        // If x is +0 and y is -0, return true.
        return true;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) === Infinity) {
        // If x is -0 and y is +0, return true
        return true;
    }
    
    // Return false
    return false;
};
Number.equal(30, 30);</code></pre>

        <h5 class="post-subtitle">Number::sameValue(x, y)</h5>

        <p>The abstract operation <code>Number::sameValue</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> and <code>y</code> is <code>NaN</code>, return <code>true</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>false</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>false</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>true</code>.</li>
            <li>Return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.sameValue = function (x, y) {
    if(Number.isNaN(x) && Number.isNaN(y)) {
        // If x is NaN and y is NaN, return true
        return true;
    }
    if(1/Number(x) === Infinity && 1/Number(y) ==== -Infinity) {
        // If x is +0 and y is -0, return false
        return false;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) ==== Infinity) {
        // If x is -0 and y is +0, return false
        return false;
    }
    if(Number(x) === Number(y)) {
        // If x is y, return true
        return true;
    }
    
    // Return false
    return false;
};
Number.sameValue(0, -0);</code></pre>

        <h5 class="post-subtitle">Number::sameValueZero(x, y)</h5>

        <p>The abstract operation <code>Number::sameValueZero</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> and <code>y</code> is <code>NaN</code>, return <code>true</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>true</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>true</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>true</code>.</li>
            <li>Return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.sameValueZero = function (x, y) {
    if(Number.isNaN(x) && Number.isNaN(y)) {
        // If x is NaN and y is NaN, return true.
        return true;
    }
    if(1/Number(x) === Infinity && 1/Number(y) ==== -Infinity) {
        // If x is +0 and y is -0, return true.
        return true;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) ==== Infinity) {
        // If x is -0 and y is +0, return true.
        return true;
    }
    if(Number(x) === Number(y)) {
        // If x is y, return true
        return true;
    }
    
    // Return false
    return false;
};
Number.sameValueZero(0, -0);</code></pre>

        <h5 class="post-subtitle">NumberBitwiseOp (op, x, y)</h5>

        <p>The abstract operation <code>NumberBitwiseOp</code> takes arguments <code>op</code> (<code>&</code>, <code>^</code>, or <code>|</code>), <code>x</code> (a Number), and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToInt32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToInt32(y)</code>.</li>
            <li>Let <code>lbits</code> be the 32-bit two's complement bit string representing <code>lnum</code>.</li>
            <li>Let <code>rbits</code> be the 32-bit two's complement bit string representing <code>rnum</code>.</li>
            <li>If <code>op</code> is <code>&</code>, let <code>result</code> be the result of applying the bitwise AND operation to <code>lbits</code> and <code>rbits</code>.</li>
            <li>Else if <code>op</code> is <code>^</code>, let <code>result</code> be the result of applying the bitwise exclusive OR (XOR) operation to <code>lbits</code> and <code>rbits</code>.</li>
            <li>Else, <code>op</code> is <code>|</code>. Let <code>result</code> be the result of applying the bitwise inclusive OR operation to <code>lbits</code> and <code>rbits</code>.</li>
            <li>Return the Number value for the integer represented by the 32-bit two's complement bit string <code>result</code>.</li>
        </ol>

        <p>The <code>!ToInt32(x)</code> just means that we are certain that this call to <code>ToInt32</code> will never return an exception</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
    // Let lnum be ! ToInt32(x)
    let lnum = Number(x);

    // Let rnum be ! ToInt32(y)
    let rnum = Number(y);

    // Let lbits be the 32-bit two's complement bit string representing lnum
    let lbits = lnum;

    // Let rbits be the 32-bit two's complement bit string representing rnum
    let rbits = rnum;
    
    let result;

    if(op == '&') {
        // If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
        result = lbits & rbits;
    }
    else if(op == '&') {
        // Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
        result = lbits ^ rbits;
    }
    else {
        // Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
        result = lbits | rbits;
    }

    // Return the Number value for the integer represented by the 32-bit two's complement bit string result
    return result;
};</code></pre>

        <h5 class="post-subtitle">Number::bitwiseAND (x, y)</h5>

        <p>The abstract operation <code>Number::bitwiseAND</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Return NumberBitwiseOp(&, x, y)</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
    // Let lnum be ! ToInt32(x)
    let lnum = Number(x);

    // Let rnum be ! ToInt32(y)
    let rnum = Number(y);

    // Let lbits be the 32-bit two's complement bit string representing lnum
    let lbits = lnum;

    // Let rbits be the 32-bit two's complement bit string representing rnum
    let rbits = rnum;
    
    let result;

    if(op == '&') {
        // If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
        result = lbits & rbits;
    }
    else if(op == '&') {
        // Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
        result = lbits ^ rbits;
    }
    else {
        // Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
        result = lbits | rbits;
    }

    // Return the Number value for the integer represented by the 32-bit two's complement bit string result
    return result;
};
Number.bitwiseAND = function(x, y) {
    return NumberBitwiseOp('&', x, y);
}
Number.bitwiseAND(20, 30);</code></pre>

        <h5 class="post-subtitle">Number::bitwiseXOR (x, y)</h5>

        <p>The abstract operation <code>Number::bitwiseXOR</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Return NumberBitwiseOp(^, x, y)</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
// Let lnum be ! ToInt32(x)
let lnum = Number(x);

// Let rnum be ! ToInt32(y)
let rnum = Number(y);

// Let lbits be the 32-bit two's complement bit string representing lnum
let lbits = lnum;

// Let rbits be the 32-bit two's complement bit string representing rnum
let rbits = rnum;

let result;

if(op == '&') {
// If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
result = lbits & rbits;
}
else if(op == '&') {
// Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
result = lbits ^ rbits;
}
else {
// Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
result = lbits | rbits;
}

// Return the Number value for the integer represented by the 32-bit two's complement bit string result
return result;
};
Number.bitwiseXOR = function(x, y) {
    return NumberBitwiseOp('^', x, y);
}
Number.bitwiseXOR (20, 30);</code></pre>

        <h5 class="post-subtitle">Number::bitwiseOR (x, y)</h5>

        <p>The abstract operation <code>Number::bitwiseOR</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Return NumberBitwiseOp(|, x, y)</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
    // Let lnum be ! ToInt32(x)
    let lnum = Number(x);

    // Let rnum be ! ToInt32(y)
    let rnum = Number(y);

    // Let lbits be the 32-bit two's complement bit string representing lnum
    let lbits = lnum;

    // Let rbits be the 32-bit two's complement bit string representing rnum
    let rbits = rnum;

    let result;

    if(op == '&') {
    // If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
    result = lbits & rbits;
    }
    else if(op == '&') {
    // Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
    result = lbits ^ rbits;
    }
    else {
    // Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
    result = lbits | rbits;
    }

    // Return the Number value for the integer represented by the 32-bit two's complement bit string result
    return result;
};
Number.bitwiseOR = function(x, y) {
    return NumberBitwiseOp('|', x, y);
}
Number.bitwiseOR (20, 30);</code></pre>

        <h5 class="post-subtitle">Number::toString (x, radix)</h5>

        <p>The abstract operation <code>Number::toString</code> takes arguments <code>x</code> (a Number) and <code>radix</code> (an integer in the inclusive interval from 2 to 36) and returns a String. It represents <code>x</code> as a String using a positional numeral system with radix <code>radix</code>. The digits used in the representation of a number using radix <code>r</code> are taken from the first <code>r</code> code units of <b>0123456789abcdefghijklmnopqrstuvwxyz</b> in order. The representation of numbers with magnitude greater than or equal to 1 never includes leading zeroes. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>"NaN"</code>.</li>
            <li>If <code>x</code> is either +0 or -0, return <code>"0"</code>.</li>
            <li>If <code>x</code> < -0, return the string-concatenation of <code>"-"</code> and <code>Number::toString(-x, radix)</code>.</li>
            <li>If <code>x</code> is +∞, return <code>"Infinity"</code>.</li>
            <li>Let <code>n</code>, <code>k</code>, and <code>s</code> be integers such that $$k ≥ 1$$, $$radix^{k - 1} ≤ s < radix^k$$, $$s × radix^{n - k}$$ is $$x$$, and $$k$$ is as small as possible. Note that <code>k</code> is the number of digits in the representation of <code>s</code> using radix <code>radix</code>, that <code>s</code> is not divisible by <code>radix</code>, and that the least significant digit of <code>s</code> is not necessarily uniquely determined by these criteria.<br><br>
            In simple words, <code>x</code> is an integer, <code>n</code> is the position of the leading digit of <code>x</code>, with n=0 being the first fraction (0.X), n=1 being the least significant integer position (X.0), n=2 being the "tens" position (X0.0) etc. <code>s</code> is the integer representation that results from stripping all trailing zeroes of <code>x</code>, and <code>k</code> is the number of digits in <code>s</code>.<br><br>

            Example 1:<br>
            <code>x</code> = 100000000000000000000, would yield <code>s</code> = 1, <code>k</code> = 1, <code>n</code> = 21. Therefore the <code>x</code> passes point 6a and will return "100000000000000000000"<br><br>
            Example 2:<br>
            <code>x</code> = 10000000000000000000000, would yield <code>s</code> = 1, <code>k</code> = 1, <code>n</code> = 23. Therefore the <code>x</code> passes point 11a and will return "1e+22"<br><br>
            Example 3:<br>
            <code>x</code> = 0.000003001, would yield <code>s</code> = 3001, <code>k</code> = 4, <code>n</code> = -5. Therefore the <code>x</code> passes point 6c and will return "0.000003001"<br><br>
            Example 4:<br>
            <code>x</code> = 0.0000003001, would yield <code>s</code> = 3001, <code>k</code> = 4, <code>n</code> = -6. Therefore the <code>x</code> passes point 12 and will return "3.001e-7"<br><br>
            Example 5:<br>
            <code>x</code> = 100000000.00000003001, would yield <code>s</code> = 10000000000000003001, <code>k</code> = 20, <code>n</code> = 9. Therefore the <code>x</code> passes point 6b and will return "100000000.00000003" since the floating-point numbers in JavaScript can only keep 16 decimal places of precision; beyond that, the value will be changed.<br><br>
            Example 6:<br>
            <code>x</code> = 1000000000.00000003001, would yield <code>s</code> = 100000000000000003001, <code>k</code> = 21, <code>n</code> = 10. Therefore the <code>x</code> passes point 6b and will return "100000000". It actually returned "100000000.0000000" since the floating-point numbers in JavaScript can only keep 16 decimal places of precision and since Javascript automatically removes the trailing zeros of a floating point number, it returned "100000000".<br><br>
            </li>
            <li>If radix ≠ 10 or n is in the inclusive interval from -5 to 21, then<br>
                <ol>
                    <li>If n ≥ k, then<br>
                        <ol>
                            <li>Return the string-concatenation of:<br>
                                <ol>
                                    <li>the code units of the k digits of the representation of s using radix radix</li>
                                    <li>n - k occurrences of the code unit 0x0030 (DIGIT ZERO)</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>Else if n > 0, then<br>
                        <ol>
                            <li>Return the string-concatenation of:<br>
                                <ol>
                                    <li>
                                        the code units of the most significant n digits of the representation of s using radix radix
                                    </li>
                                    <li>the code unit 0x002E (FULL STOP)</li>
                                    <li>the code units of the remaining k - n digits of the representation of s using radix radix</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>Else,<br>
                        <ol>
                            <li>Assert: n ≤ 0.</li>
                            <li>Return the string-concatenation of:<br>
                                <ol>
                                    <li>the code unit 0x0030 (DIGIT ZERO)</li>
                                    <li>the code unit 0x002E (FULL STOP)</li>
                                    <li>-n occurrences of the code unit 0x0030 (DIGIT ZERO)</li>
                                    <li>the code units of the k digits of the representation of s using radix radix</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>NOTE: In this case, the input will be represented using scientific E notation, such as 1.2e+3.</li>
            <li>Assert: radix is 10.</li>
            <li>If n < 0, then<br>
                <ol>
                    <li>Let exponentSign be the code unit 0x002D (HYPHEN-MINUS).</li>
                </ol>
            </li>
            <li>Else,<br>
                <ol>
                    <li>Let exponentSign be the code unit 0x002B (PLUS SIGN).</li>
                </ol>
            </li>
            <li>If k = 1, then<br>
                <ol>
                    <li>Return the string-concatenation of:<br>
                        <ol>
                            <li>the code unit of the single digit of s</li>
                            <li>the code unit 0x0065 (LATIN SMALL LETTER E)</li>
                            <li>exponentSign</li>
                            <li>the code units of the decimal representation of abs(n - 1)</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>Return the string-concatenation of:<br>
                <ol>
                    <li>the code unit of the most significant digit of the decimal representation of s</li>
                    <li>the code unit 0x002E (FULL STOP)</li>
                    <li>the code units of the remaining k - 1 digits of the decimal representation of s</li>
                    <li>the code unit 0x0065 (LATIN SMALL LETTER E)</li>
                    <li>exponentSign</li>
                    <li>the code units of the decimal representation of abs(n - 1)</li>
                </ol>
            </li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.toString = function (x, radix) {
    if(Number.isNaN(x)) {
        // If x is NaN, return "NaN"
        return "NaN";
    }

    if(x === 0) {
        // If x is either +0 or -0, return "0"
        return "0";
    }
    
    if(x < 0) {
        // If x < -0, return the string-concatenation of "-" and Number::toString(-x, radix)
        return "-" + Number.toString(-x, radix);
    }

    if(x === Infinity) {
        // If x is +∞, return "Infinity".
        return "Infinity";
    }

    let n = 0;
    let k = 0;
    let narray = [];
    let karray = [];
    let whole;
    let fraction;
    
    if(Math.floor(x) === Math.ceil(x)) {
        whole = x + "";
    } else {
        let str = x.toString().split(".");
        whole = str[0];
        fraction = str[1];
    }
    
    let temp = x;
    let numofzero = 0;
    let iszero = true;
    
    while(Math.floor(temp) > 0) {
        n = n + 1;
        narray.push(whole[whole.length - n]);
        
        k = k + 1;
        karray.push(whole[whole.length - n]);
        
        //console.log(whole[whole.length-n])
        if(Math.floor(x) === Math.ceil(x) && whole[whole.length - n] === "0" && iszero) {
            k = k - 1;
            
            karray.pop();
            
            numofzero = numofzero + 1;
        } else {
            iszero = false;
        }
        
        temp = temp / 10;
    }
    
    temp = x;
    iszero = true;
    let i = 0;
    while(Math.ceil(temp) !== Math.floor(temp)) {
        temp = temp * 10;
        
        if(n <= 0 && Math.floor(temp) === 0 && iszero) {
            n = n - 1;
            narray.push(fraction[i]);
        } else {
            k = k + 1;
            iszero = false;
            karray.unshift(fraction[i]);
        }
        i = i + 1;
    }
    
    function numbertobase(number, rad) {
        let wnum;
        let fnum;
        if(Math.floor(number) === Math.ceil(number)) {
            wnum = number;
        } else {
            let str = number.split(".");
            wnum = str[0];
            fnum = str[1];
        }
    
        let numberofdigits = Math.round(Math.log10(Math.pow(2,53)) / Math.log10(rad)) + 1;
        let result = "";
        let zeropads = "";

        while(wnum > 0) {
            let remainder = wnum - Math.floor(wnum / rad) * rad + "";
            
            if (remainder === "10") {
                result = "A" + result;
            } else if (remainder === "11") {
                result = "B" + result;
            } else if (remainder === "12") {
                result = "C" + result;
            } else if (remainder === "13") {
                result = "D" + result;
            } else if (remainder === "14") {
                result = "E" + result;
            } else if (remainder === "15") {
                result = "F" + result;
            } else if (remainder === "16") {
                result = "G" + result;
            } else if (remainder === "17") {
                result = "H" + result;
            } else if (remainder === "18") {
                result = "I" + result;
            } else if (remainder === "19") {
                result = "J" + result;
            } else if (remainder === "20") {
                result = "K" + result;
            } else if (remainder === "21") {
                result = "L" + result;
            } else if (remainder === "22") {
                result = "M" + result;
            } else if (remainder === "23") {
                result = "N" + result;
            } else if (remainder === "24") {
                result = "O" + result;
            } else if (remainder === "25") {
                result = "P" + result;
            } else if (remainder === "26") {
                result = "Q" + result;
            } else if (remainder === "27") {
                result = "R" + result;
            } else if (remainder === "28") {
                result = "S" + result;
            } else if (remainder === "29") {
                result = "T" + result;
            } else if (remainder === "30") {
                result = "U" + result;
            } else if (remainder === "31") {
                result = "V" + result;
            } else if (remainder === "32") {
                result = "W" + result;
            } else if (remainder === "33") {
                result = "X" + result;
            } else if (remainder === "34") {
                result = "Y" + result;
            } else if (remainder === "35") {
                result = "Z" + result;
            } else {
                result = remainder + result;
            }
            numberofdigits = numberofdigits - 1;
            
            wnum = Math.floor(wnum / rad);
        }
        
        if(Math.ceil(number) !== Math.floor(number)) {
            const factor = Math.pow(10, fnum.length)
            fnum = "1." + fnum;
            
            if(fnum > 0) {
                if(result === "") {
                    result = "0.";
                } else {
                    result = result + ".";
                }
            }
            
            while(fnum > 0) {
                fnum = (Math.round(fnum * rad * factor) / factor) + "";
                str = fnum.split(".");
                let num = str[0] - rad + "";
                fnum = "1." + str[1];
                
                if (num > 0) {
                    result = result + zeropads;
                    zeropads = "";
                }
                
                if (num === "10") {
                    result = result + "A";
                } else if (num === "11") {
                    result = result + "B";
                } else if (num === "12") {
                    result = result + "C";
                } else if (num === "13") {
                    result = result + "D";
                } else if (num === "14") {
                    result = result + "E";
                } else if (num === "15") {
                    result = result + "F";
                } else if (num === "16") {
                    result = result + "G";
                } else if (num === "17") {
                    result = result + "H";
                } else if (num === "18") {
                    result = result + "I";
                } else if (num === "19") {
                    result = result + "J";
                } else if (num === "20") {
                    result = result + "K";
                } else if (num === "21") {
                    result = result + "L";
                } else if (num === "22") {
                    result = result + "M";
                } else if (num === "23") {
                    result = result + "N";
                } else if (num === "24") {
                    result = result + "O";
                } else if (num === "25") {
                    result = result + "P";
                } else if (num === "26") {
                    result = result + "Q";
                } else if (num === "27") {
                    result = result + "R";
                } else if (num === "28") {
                    result = result + "S";
                } else if (num === "29") {
                    result = result + "T";
                } else if (num === "30") {
                    result = result + "U";
                } else if (num === "31") {
                    result = result + "V";
                } else if (num === "32") {
                    result = result + "W";
                } else if (num === "33") {
                    result = result + "X";
                } else if (num === "34") {
                    result = result + "Y";
                } else if (num === "35") {
                    result = result + "Z";
                } else if (num === "0") {
                    zeropads = zeropads + "0";
                } else {
                    result = result + num;
                }
                
                numberofdigits = numberofdigits - 1;
                
                if(numberofdigits === 0) {
                    break;
                }
                
            }
        } 
        
        return result;
    }
    //let s = x / 10 ** (n-k);

    if(radix !== 10 || (n >= -5 && n <= 21)) {
        // If radix ≠ 10 or n is in the inclusive interval from -5 to 21, then

        if(n >= k) {
            // If n ≥ k, then
            // Return the string-concatenation of: 
            // the code units of the k digits of the representation of s using radix radix
            // n - k occurrences of the code unit 0x0030 (DIGIT ZERO)
            
            return numbertobase(karray.reverse().join("") + narray.slice(0, n - k).reverse().join(""), radix);
        } else if(n > 0) {
            // Else if n > 0, then
            // Return the string-concatenation of:
            // the code units of the most significant n digits of the representation of s using radix radix
            // the code unit 0x002E (FULL STOP)
            // the code units of the remaining k - n digits of the representation of s using radix radix
            
            return numbertobase(narray.reverse().join("") + "." +  karray.slice(0, k - n).reverse().join(""), radix);
        } else {
            // Else n ≤ 0
            // Return the string-concatenation of:
            // the code unit 0x0030 (DIGIT ZERO)
            // the code unit 0x002E (FULL STOP)
            // -n occurrences of the code unit 0x0030 (DIGIT ZERO)
            // the code units of the k digits of the representation of s using radix radix
            
            return numbertobase("0" + "." + narray.reverse().join("") + karray.reverse().join(""), radix);
        }
    }

    let exponentSign;
    // radix is 10
    if(n < 0) {
        // If n < 0, then
        // Let exponentSign be the code unit 0x002D (HYPHEN-MINUS)
        exponentSign = "-";
    } else {
        // Else
        // Let exponentSign be the code unit 0x002B (PLUS SIGN)
        exponentSign = "+";
    }

    if(k === 1) {
        // If k = 1, then
        // the code unit of the single digit of s
        // the code unit 0x0065 (LATIN SMALL LETTER E)
        // exponentSign
        // the code units of the decimal representation of abs(n - 1)
        return karray.reverse().join("") + "e" + exponentSign + Math.abs(n - 1);
    }
    
    // Return the string-concatenation of:
    // the code unit of the most significant digit of the decimal representation of s
    // the code unit 0x002E (FULL STOP)
    // the code units of the remaining k - 1 digits of the decimal representation of s
    // the code unit 0x0065 (LATIN SMALL LETTER E)
    // exponentSign
    // the code units of the decimal representation of abs(n - 1)

    return karray[karray.length - 1] + "." + karray.slice(0, karray.length - 1).reverse().join("") + "e" + exponentSign + Math.abs(n - 1);
};
Number.toString(100000000000000000000, 10);
// "100000000000000000000"
Number.toString(100000000000000000000, 16);
// "56BC75E2D63100000"
Number.toString(0.000003001, 10);
// "0.000003001"
Number.toString(0.000003001, 16);
// "0.0000325932651B"
Number.toString(100000000.00000003001, 10);
// "100000000.00000003"
Number.toString(100000000.00000003001, 16);
// "5f5e100.0000008"</code></pre>
        
    </article>

    {% include post-tags.html %}

    {% include post-share.html %}
</div>