<!DOCTYPE html>
<html lang="en">
	<head>
		
		
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	    <meta name="description" content="A Doubly Linked List is a dynamic data structure where each node contains data and two pointers, one pointing to the next node and another to the previous node. This bidirectional linking enables efficient insertion, deletion, and traversal in both directions, making it ideal for applications like undo or redo functionality, navigation systems, and memory management. Unlike singly linked lists, doubly linked lists allow easier manipulation of elements at both ends but require extra memory for storing an additional pointer. Learn how doubly linked lists work, their advantages, and implementations in this comprehensive guide.">
	    <meta name="author" content="Samuel Yang">
	    <link rel="canonical" href="https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/">
	    <link rel="icon" type="image/x-icon" href="https://hemimorphite.github.io/favicon.ico">
	    <meta property="fb:app_id" content="771418017802270">
		<meta property="og:title" content="Doubly Linked List Data Structure">
		<meta property="og:type" content="article">
		<meta property="og:site_name" content="Hemimorphite">
		<meta property="og:url" content="https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/">
		<meta property="og:description" content="A Doubly Linked List is a dynamic data structure where each node contains data and two pointers, one pointing to the next node and another to the previous node. This bidirectional linking enables efficient insertion, deletion, and traversal in both directions, making it ideal for applications like undo or redo functionality, navigation systems, and memory management. Unlike singly linked lists, doubly linked lists allow easier manipulation of elements at both ends but require extra memory for storing an additional pointer. Learn how doubly linked lists work, their advantages, and implementations in this comprehensive guide.">
		<meta property="og:image" content="https://hemimorphite.github.io/assets/images/doublylinked.jpg">

		<meta name="twitter:card" content="summary">
		<meta name="twitter:title" content="Doubly Linked List Data Structure">
		<meta name="twitter:description" content="A Doubly Linked List is a dynamic data structure where each node contains data and two pointers, one pointing to the next node and another to the previous node. This bidirectional linking enables efficient insertion, deletion, and traversal in both directions, making it ideal for applications like undo or redo functionality, navigation systems, and memory management. Unlike singly linked lists, doubly linked lists allow easier manipulation of elements at both ends but require extra memory for storing an additional pointer. Learn how doubly linked lists work, their advantages, and implementations in this comprehensive guide.">
		<meta name="twitter:creator" content="Samuel Yang">
		<meta name="twitter:image:src" content="https://hemimorphite.github.io/assets/images/doublylinked.jpg">
	
	    <link href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i&display=swap" rel="stylesheet">

	    <title>Doubly Linked List Data Structure</title>

	    <!-- Bootstrap core CSS -->
	    <link rel="stylesheet" href="https://hemimorphite.github.io/assets/vendor/bootstrap/css/bootstrap.css">

	    <!-- Additional CSS Files -->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
		<link rel="stylesheet" href="https://hemimorphite.github.io/assets/vendor/highlight.js/css/default.min.css">
	    <link rel="stylesheet" href="https://hemimorphite.github.io/assets/vendor/highlight.js/css/themes/monokai-sublime.css">
	    <link rel="stylesheet" href="https://hemimorphite.github.io/assets/css/fontawesome.css">
		<link rel="stylesheet" href="https://hemimorphite.github.io/assets/vendor/latex-css/custom.css">
	    <link rel="stylesheet" href="https://hemimorphite.github.io/assets/css/hemimorphite.css">
  	</head>

  	<body>
  		<!-- ***** Preloader Start ***** -->
	    <!--<div id="preloader">
	        <div class="jumper">
	            <div></div>
	            <div></div>
	            <div></div>
	        </div>
	    </div>-->  
	    <!-- ***** Preloader End ***** -->
	    
	    <!-- Header -->
	    <header>
			<nav class="navbar navbar-expand-lg">
				<div class="container">
					<h2 class="navbar-brand"><a href="https://hemimorphite.github.io/">Hemimorphite</a></h2>
					<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
						<span class="icon"></span>
					</button>
					<div class="collapse navbar-collapse" id="navbarResponsive">
						<ul class="navbar-nav ms-auto">
							<li class="nav-item ">
								<a class="nav-link" href="https://hemimorphite.github.io/">Home
									
								</a>
							</li>
						
						
						
						

						
						
						

						
						  	
						  	<li class="nav-item ">
								<a class="nav-link" href="https://hemimorphite.github.io/about">About
									
								</a>
							</li>
						  	
						  	
						
						
						

						
						
						

						
						
						

						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						

						
						  	
						  	
						
						
						</ul>
					</div>
				</div>
			</nav>
	    </header>
	    
		<section>
			<div class="container">
				<div class="row">
					<div class="col-12">
						<script type="text/javascript">
							atOptions = {
								'key' : '9cf40e8a46ab80f525196d3376630858',
								'format' : 'iframe',
								'height' : 90,
								'width' : 728,
								'params' : {}
							};
						</script>
						<script type="text/javascript" src="//www.topcreativeformat.com/9cf40e8a46ab80f525196d3376630858/invoke.js"></script>
					</div>
				</div>
			</div>
		</section>

	    <!-- Page Content -->
<section>
	<div class="container">
		<div class="row">
			<div class="col-12">
				<script type="text/javascript">
					atOptions = {
						'key' : '9cf40e8a46ab80f525196d3376630858',
						'format' : 'iframe',
						'height' : 90,
						'width' : 728,
						'params' : {}
					};
				</script>
				<script type="text/javascript" src="//www.topcreativeformat.com/9cf40e8a46ab80f525196d3376630858/invoke.js"></script>
			</div>
			<div class="col-lg-2">
				<a href="https://hemimorphite.github.io/" type="button" class="btn btn-all ms-auto"><i class="fa-solid fa-arrow-left"></i> All posts</a>

				<div>
					<script type="text/javascript">
						atOptions = {
							'key' : '038e6b1f96b2e2f8ee26abfaebf2b477',
							'format' : 'iframe',
							'height' : 300,
							'width' : 160,
							'params' : {}
						};
					</script>
					<script type="text/javascript" src="//www.topcreativeformat.com/038e6b1f96b2e2f8ee26abfaebf2b477/invoke.js"></script>
				</div>
				<div>
					<script type="text/javascript">
						atOptions = {
							'key' : '49182664b5d567ebee9725d9737c0006',
							'format' : 'iframe',
							'height' : 600,
							'width' : 160,
							'params' : {}
						};
					</script>
					<script type="text/javascript" src="//www.topcreativeformat.com/49182664b5d567ebee9725d9737c0006/invoke.js"></script>
				</div>
				<div>
					<script type="text/javascript">
						atOptions = {
							'key' : '038e6b1f96b2e2f8ee26abfaebf2b477',
							'format' : 'iframe',
							'height' : 300,
							'width' : 160,
							'params' : {}
						};
					</script>
					<script type="text/javascript" src="//www.topcreativeformat.com/038e6b1f96b2e2f8ee26abfaebf2b477/invoke.js"></script>
				</div>
				<div>
					<script type="text/javascript">
						atOptions = {
							'key' : '49182664b5d567ebee9725d9737c0006',
							'format' : 'iframe',
							'height' : 600,
							'width' : 160,
							'params' : {}
						};
					</script>
					<script type="text/javascript" src="//www.topcreativeformat.com/49182664b5d567ebee9725d9737c0006/invoke.js"></script>
				</div>
			</div>
			<div class="col-lg-10">
				<div class="blog-post">
    <h2 class="post-title">Doubly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published February 01, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/doublylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Doubly Linked List</h3>
		
        <p>A doubly linked list is a linear data structure consisting of a sequence of elements, called nodes, where each node points to both its previous and next nodes in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations.</p>
		
		<p>Each node in a doubly linked list contains three fields:</p>
		
        <ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence.</li>
			<li><b>Previous Pointer</b>: A reference (or pointer) to the previous node in the sequence.</li>
		</ul>

        <p>The doubly linked list forms a linear collection of elements where each node points to both its successor and its predecessor. The first node, known as the head, has a <code>NULL</code> reference for its previous pointer, indicating the beginning of the list. The last node has a <code>NULL</code> reference for its next pointer, marking the end of the list.</p>
		
		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. If the list is empty, the head points to <code>NULL</code>.</p>
		
		<p>Insertions and deletions of nodes, particularly at the beginning, middle, or end of the list, are more efficient compared to arrays since you do not need to shift elements. However, managing both the previous and next pointers requires extra attention.</p>
		
		<p>The nodes in a doubly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next and previous nodes through pointers, and they can be located anywhere in memory.</p>
		
		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>
		
		<p>Each node in a doubly linked list requires extra memory for the two pointers (next and previous references), which slightly increases memory usage compared to arrays or singly linked lists.</p>
		
		<p>Here's a visual representation of a doubly linked list:</p>
		
<pre><code class="language-bash hljs">
               HEAD
		        ↓
NULL ← [Prev | Data | Next] ⇄ [Prev | Data | Next] ⇄ [Prev | Data | Next] → NULL
</code></pre>
		
		<p>In the above representation:</p>
		
		<ul>
			<li>The <code>Head</code> points to the first node of the list, providing quick access to the start of the list.</li>
			<li>Each node contains <code>Data</code>, a <code>Next</code> pointer to the next node, and a <code>Previous</code> pointer to the previous node.</li>
			<li>The last node in the list has its <code>Next</code> pointer set to <code>NULL</code>, indicating the end of the list. Its <code>Prev</code> pointer points to the previous node.</li>
			<li>The <code>Prev</code> pointer of the first node is <code>NULL</code>, as there is no node before it.</li>
		</ul>
		
		<p>A simple doubly linked list with three nodes could look like this:</p>
		
<pre><code class="language-bash hljs">
               HEAD
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
		
		<p>In the above example:</p>
		
		<ul>
			<li>The head points to the first node containing the data <code>10</code>. The <code>Prev</code> pointer of this node is <code>NULL</code>, as there is no node before it.</li>
			<li>The second node contains the data <code>20</code>. Its <code>Prev</code> pointer points to the first node, and its <code>Next</code> pointer points to the third node.</li>
			<li>The third node contains the data <code>30</code>. Its <code>Prev</code> pointer points to the second node, and its <code>Next</code> pointer is <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common doubly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-plaintext hljs">
											   HEAD
												↓
								NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
								</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
<pre><code class="language-plaintext hljs">
              HEAD
               ↓
NULL ← [Prev | 5 | Next] ⇄ [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a doubly linked list is \(O(1)\) (constant time). If the list is empty, the following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>, as there is no node after it.</li>
							<li>Set the <code>prev</code> pointer of the new node to <code>NULL</code>, as it will become the first node.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						If the list is not empty, the following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list).</li>
							<li>If the list is not empty, set the <code>prev</code> pointer of the current head node to point to the new node.</li>
							<li>Set the <code>prev</code> pointer of the new node to <code>NULL</code>, as it will become the first node.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a doubly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] ⇄ [Prev | 40 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning.  The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node <code>NULL</code>, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer is <code>NULL</code>).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 25 | Next]  ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node after a node in a doubly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the given node.</li>
							<li>Update its <code>prev</code> pointer of the node following the given node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node after a node in a doubly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertBeforeNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately before a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> before the node containing <code>20</code>. After calling <code>insertBeforeNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 25 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node before a node in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the preceding node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>prev</code> pointer of the target node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node before a node in a doubly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a doubly linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 35 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the preceding node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>prev</code> pointer of the target node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a doubly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a new node at a specified position in a linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Set the head pointer to the next node</li>
							<li>Set the <code>prev</code> pointer of the new head node (if it exists) to <code>NULL</code>.</li>
							<li>Deallocate the memory for the old head node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a doubly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] → NULL
</code></pre>							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the second-to-last node.</li>
							<li>Set the <code>next</code> pointer of the second-to-last node to <code>null</code>.</li>
							<li>Deallocate the memory for the old last node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position to delete is 0, it means the head node should be removed. If the specified position is out of bounds, and a message is printed.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to remove a node at position <code>3</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
							<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the node before the target position.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the node after the target node (if it exists).</li>
							<li>Update the <code>prev</code> pointer of the node after the target node (if it exists) to point to the preceding node.</li>
							<li>Deallocate the memory for the removed node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a doubly linked list and perform an action, such as printing the node's value.</li>
					<li><b>Time complexity</b>: The time complexity of traverse function in a linked list is \(O(n)\) (linear time). The function iterates through each node in the linked list exactly once, from the head to the end (<code>NULL</code>). Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of traverse function in a linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>
			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 30 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 10 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of reverse function in a doubly linked list is \(O(n)\) (linear time). The function traverses each node of the linked list exactly once. Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of reverse function in a doubly linked list is \(O(1)\) (constant space).  The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes. This amount of space does not depend on the size of the linked list.</li>
				</ul>
			</li>
			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a doubly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of search function in a linked list is \(O(n)\) (linear time).The search function traverses the linked list node by node. In the worst case, it may need to look at every node in the list to find the key (or determine that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of search function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of extra space to store variables, such as pointers for the current node. The space required does not depend on the size of the list because the function does not use any additional data structures or dynamic memory allocations for the search process.</li>
				</ul>
			</li>
			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a doubly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of size function in a linked list is \(O(n)\) (linear time). The function traverses the entire linked list to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of size function in a doubly linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a doubly linked list at a specified index. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of get function in a doubly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of get function in a doubly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a doubly linked list. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of set function in a doubly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of set function in a doubly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a doubly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of <code>isEmpty</code> function in a doubly linked list is \(O(1)\) (constant time). The <code>isEmpty</code> function checks whether the head pointer of the linked list is <code>NULL</code>. This operation is performed in constant time since it only involves a simple comparison, regardless of the size of the linked list.</li>
					<li><b>Space complexity</b>: The space complexity of <code>isEmpty</code> function in a doubly linked list is \(O(1)\) (constant space). The function uses a fixed amount of space to store the result of the comparison (typically a boolean value), regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted linked lists into a single sorted linked list. </li>
					<li><b>Time complexity</b>: The time complexity of merge function in a doubly linked list is \(O(n + m)\) (linear time). The reason for this complexity is that each node from both lists is visited exactly once. In the worst case, the function will traverse both lists entirely, performing comparisons and linking nodes. Where \(n\) is the number of nodes in the first linked list and \(m\) is the number of nodes in the second linked list.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a doubly linked list is \(O(n + m)\) (linear space) due to the call stack storing recursive calls. In the worst case, the maximum depth of recursion will be equal to the total number of nodes in both lists combined, leading to \(n + m\) recursive calls.</li>
				</ul>
			</li>
			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a doubly linked list, in a specific order (typically ascending or descending).</li>
					<li><b>Time complexity</b>: The time complexity of sort function in a doubly linked list, when using merge sort is \(O(n \log n)\) (linearithmic time) because the algorithm consistently divides the list into halves and requires a linear amount of time \(O(n)\) to merge those halves back together. The logarithmic factor \(\log n\) comes from the number of times the list can be divided in half (depth of recursion).</li>
					<li><b>Space complexity</b>: The space complexity of sort function in a doubly linked list, specifically Merge Sort, is \(O(n)\) (linear space) because it requires additional space for the temporary arrays or linked lists used during the merge process. When merging two halves, the algorithm needs space to hold the merged elements before copying them back to the original array or linked list.</li>
				</ul>
			</li>
			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from the list and free up the memory they occupy, effectively making the list empty.</li>
					<li><b>Time complexity</b>: The time complexity of clear function in a doubly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, freeing its memory. Since it processes all nodes in the list, the time complexity is proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of clear function in a doubly linked list is \(O(1)\) (constant space). The function only requires a fixed amount of extra memory for the iteration, typically for a pointer to traverse the list. No additional memory structures are needed, regardless of the size of the linked list.</li>
				</ul>
			</li>
        </ul>
		
		<h3 class="post-subtitle">Non-Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// defines a structure to represent a node in a doubly linked list
typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef != NULL) {
        (*headRef)-&gt;prev = newNode;
    }
    newNode-&gt;next = *headRef;
    *headRef = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }

    Node* newNode = createNode(data);
    newNode-&gt;next = prevNode-&gt;next;
    newNode-&gt;prev = prevNode;
    if (prevNode-&gt;next != NULL) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(data);
    if (*headRef == nextNode) {
        newNode-&gt;next = *headRef;
        (*headRef)-&gt;prev = newNode;
        *headRef = newNode;
        return;
    }

    newNode-&gt;next = nextNode;
    newNode-&gt;prev = nextNode-&gt;prev;
    if (nextNode-&gt;prev != NULL) {
        nextNode-&gt;prev-&gt;next = newNode;
    }
    nextNode-&gt;prev = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    if (position == 0) {
        newNode-&gt;next = *headRef;
        if (*headRef != NULL) {
            (*headRef)-&gt;prev = newNode;
        }
        *headRef = newNode;
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    newNode-&gt;prev = temp;
    if (temp-&gt;next != NULL) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = *headRef;
    *headRef = (*headRef)-&gt;next;
    if (*headRef != NULL) {
        (*headRef)-&gt;prev = NULL;
    }
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;prev != NULL) {
        temp-&gt;prev-&gt;next = NULL;
    } else {
        *headRef = NULL; // List has only one element
    }
    free(temp);
}

// Function to delete a node at a specific position (0-based index)
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    if (position == 0) {
        *headRef = temp-&gt;next;
        if (*headRef != NULL) {
            (*headRef)-&gt;prev = NULL;
        }
        free(temp);
        return;
    }

    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next;
    if (nodeToDelete-&gt;next != NULL) {
        nodeToDelete-&gt;next-&gt;prev = temp;
    }
    free(nodeToDelete);
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d &lt;-&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp-&gt;data == key)
            return 1; // Key found
        temp = temp-&gt;next;
    }
    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** headRef) {
    Node *temp = NULL;
    Node* current = *headRef;
    
    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    if (temp != NULL) {
        *headRef = temp-&gt;prev;
    }
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    while (current != NULL) {
        if (count == index) {
            current-&gt;data = newValue;
            return;
        }
        count++;
        current = current-&gt;next;
    }

    printf("Index out of range\n");
}

// Function to clear the entire linked list and free memory
void clear(Node** headRef) {
    Node* current = *headRef;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *headRef = NULL;
}

// Function to get the middle of the linked list
void middle(Node** mid, Node* head) {
    if (head == NULL) return;
    
    Node* slow = head;
    Node* fast = head-&gt;next;
    
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    
    *mid = slow; // Update the pointer to the middle node
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    // Log the current state of head1 and head2
    //printf("Merging: head1 data = %d, head2 data = %d\n", 
    //       head1 ? head1-&gt;data : -1, head2 ? head2-&gt;data : -1);

    // Base case when one of the lists is empty
    if (head1 == NULL) {
        // Log when head1 is NULL and remaining head2 is being added
        if (head2 != NULL) {
            printf("head1 is NULL, adding remaining head2 data: %d\n", head2-&gt;data);
            Node* newNode = createNode(head2-&gt;data); // Create a new node
            *headRef = newNode;
            merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        }
        return;
    }
    if (head2 == NULL) {
        // Log when head2 is NULL and remaining head1 is being added
        if (head1 != NULL) {
            //printf("head2 is NULL, adding remaining head1 data: %d\n", head1-&gt;data);
            Node* newNode = createNode(head1-&gt;data); // Create a new node
            *headRef = newNode;
            merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        }
        return;
    }

    // Compare the data of head1 and head2 and merge accordingly
    if (head1-&gt;data &lt;= head2-&gt;data) {
        // Log when adding data from head1
        //printf("Adding head1 data: %d\n", head1-&gt;data);
        Node* newNode = createNode(head1-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    } else {
        // Log when adding data from head2
        //printf("Adding head2 data: %d\n", head2-&gt;data);
        Node* newNode = createNode(head2-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    }

    // Log when merge is completed for this recursion
    //printf("Merge step completed. headRef data = %d\n", (*headRef)-&gt;data);
}


// Function to sort the doubly linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;
	
	// Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != nullptr) {
        nextToMid-&gt;prev = nullptr;  // Set 'prev' of the second half to null
    }
	
    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}

// Main function to test the doubly linked list operations
int main() {
    Node* list = NULL;
	
	// 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);
	
	// 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);
	
	// 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);
	
	// 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);
	
	// 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);
	
	// 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);
	
	// 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);
	
	// 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}
	
	// 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }
	
	// 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);
	
	// 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));
	
	// 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }
	
	// 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);
    
	// 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node* next;
    Node* prev;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr), prev(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    newNode-&gt;next = head;
    if (head != nullptr) {
        head-&gt;prev = newNode;
    }
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == nullptr) {
        std::cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    if (prevNode-&gt;next != nullptr) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
    newNode-&gt;prev = prevNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        std::cout &lt;&lt; "The list cannot be empty" &lt;&lt; std::endl;
        return;
    }

    if (nextNode == nullptr) {
        std::cout &lt;&lt; "The given next node cannot be NULL" &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // If the nextNode is the head node, handle the insertion at the beginning
    if (headRef == nextNode) {
        newNode-&gt;next = headRef;
        headRef-&gt;prev = newNode;
        headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = headRef;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        std::cout &lt;&lt; "The given next node is not found in the list" &lt;&lt; std::endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);
    if (position == 0) {
        newNode-&gt;next = head;
        if (head != nullptr) {
            head-&gt;prev = newNode;
        }
        head = newNode;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}


// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    head = head-&gt;next;
    if (head != nullptr) {
        head-&gt;prev = nullptr;
    }
    delete temp;
}


// Delete at the end
void deleteAtEnd(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    temp-&gt;prev-&gt;next = nullptr;
    delete temp;
}


// Delete at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node* temp = head;
        head = head-&gt;next;
        if (head != nullptr) {
            head-&gt;prev = nullptr;
        }
        delete temp;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    if (nextNode != nullptr) {
        nextNode-&gt;prev = temp;
    }
    temp-&gt;next = nextNode;
}

// Function to reverse a doubly linked list
void reverse(Node*& head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;

    while (current != nullptr) {
        // Swap next and prev for the current node
        next = current-&gt;next;
        current-&gt;next = prev;
        current-&gt;prev = next;

        // Move to the next node in the original list
        prev = current;
        current = next;
    }

    // Update head to the last node (new head after reverse)
    head = prev;
}

// Function to get the size of a doubly linked list
int size(Node* head) {
    int count = 0;
    Node* temp = head;

    while (temp != nullptr) {
        count++;  // Increment count for each node
        temp = temp-&gt;next;  // Move to the next node
    }

    return count;
}

// Function to access an element at a specific index (0-based) in a doubly linked list
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;

    // Traverse the list to find the node at the specified index
    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data;  // Return the data at the index
        count++;
        temp = temp-&gt;next;  // Move to the next node
    }

    return -1;  // Index out of range
}

// Function to set an element at a specific index (0-based) in a doubly linked list
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;  // Move to the next node
    }

    cout &lt;&lt; "Index out of range\n";  // Handle case where index exceeds list length
}

// Search for an element in a doubly linked list
bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;  // Element found
        temp = temp-&gt;next;
    }
    return false;  // Element not found
}

// Traverse the list (forward)
void traverse(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " &lt;-&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Find the middle of the list
void middle(Node*& mid, Node* head) {
    if (head == nullptr) {
        mid = nullptr;
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != nullptr && fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    mid = slow;
}

// Merge two sorted lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    if (head1-&gt;data &lt;= head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    }
}

// Sort the list using merge sort
void sort(Node*& head) {
    if (head == nullptr || head-&gt;next == nullptr)
        return;

    Node* mid = nullptr;
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;
	
	// Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != nullptr) {
        nextToMid->prev = nullptr;  // Set 'prev' of the second half to null
    }
	
    Node* left = head;
    Node* right = nextToMid;

    sort(left);
    sort(right);

    merge(head, left, right);
}

// Clear the list
void clear(Node*& head) {
    Node* current = head;
    while (current != nullptr) {
        Node* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

int main() {
    Node* list = nullptr;  // Initialize an empty doubly linked list

    // Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // Insert element at position 2
    insertAtPosition(list, 4, 2);

    cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // Delete the first node
    deleteAtBeginning(list);

    cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // Delete the last node
    deleteAtEnd(list);

    cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // Delete the node at position 2
    deleteAtPosition(list, 2);

    cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);

    // Search for an element
    int key = 6;
    if (search(list, key)) {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; endl;
    }

    // Reverse the list
    reverse(list);

    cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // Get the size of the list
    cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; endl;

    // Clear the list
    clear(list);

    cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class DoublyLinkedList {

    // Node structure for doubly linked list
    static class Node {
        int data;
        Node next;
        Node prev;

        // Constructor to create a new node
        Node(int data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        if (head != null) {
            head.prev = newNode;
        }
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        Node newNode = new Node(data);
        if (position == 0) {
            if (head != null) {
                head.prev = newNode;
            }
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null) {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }
	
	// Insert after a given node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be null");
            return;
        }
        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
        newNode.prev = prevNode;
        if (newNode.next != null) {
            newNode.next.prev = newNode;
        }
    }

    // Insert before a given node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (nextNode == null) {
            System.out.println("The given next node cannot be null");
            return head;
        }
        Node newNode = new Node(data);
        newNode.prev = nextNode.prev;
        newNode.next = nextNode;
        nextNode.prev = newNode;
        if (newNode.prev != null) {
            newNode.prev.next = newNode;
        } else {
            head = newNode;
        }
        return head;
    }
	
    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        Node newHead = head.next;
        if (newHead != null) {
            newHead.prev = null;
        }
        return newHead;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.prev.next = null;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return deleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        Node toDelete = temp.next;
        temp.next = toDelete.next;
        if (toDelete.next != null) {
            toDelete.next.prev = temp;
        }
        return head;
    }

    // Get element at a specific index
    public static int get(Node head, int index) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
        return -1; // Return -1 if the index is out of range
    }

    // Set element at a specific index
    public static void set(Node head, int index, int newValue) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
    }

    // Traverse the list
    public static void traverse(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Search for an element
    public static boolean search(Node head, int key) {
        Node temp = head;
        while (temp != null) {
            if (temp.data == key) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node reverse(Node head) {
        Node temp = null;
        Node current = head;

        // Swap next and prev pointers for each node
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        // After the loop, temp will be the last node, so update head
        if (temp != null) {
            head = temp.prev;
        }

        return head;
    }

    // Merge two sorted lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.data &lt;= head2.data) {
            head1.next = merge(head1.next, head2);
            if (head1.next != null) {
                head1.next.prev = head1;
            }
            return head1;
        } else {
            head2.next = merge(head1, head2.next);
            if (head2.next != null) {
                head2.next.prev = head2;
            }
            return head2;
        }
    }

    // Find the middle of the list
    public static Node middle(Node head) {
        if (head == null) return null;

        Node slow = head;
        Node fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == null) return head;

        // Find the middle node
        Node mid = middle(head);
        Node nextToMid = mid.next;
        mid.next = null;
		
		// Properly break the list into two halves
		if (nextToMid != null) {
			nextToMid.prev = null;  // Set the 'prev' pointer of the second half to null
		}
	
        // Recursively split and sort both halves
        Node left = sort(head);
        Node right = sort(nextToMid);

        // Merge the sorted halves
        return merge(left, right);
    }

    // Get the size of the list
    public static int size(Node head) {
        int count = 0;
        Node temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node clear(Node head) {
        return null;
    }

    // Main method to test
    public static void main(String[] args) {
        Node head = null;

        // Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		    
		    Node second = new Node(20);
		    insertAfterNode(second, 25);
        System.out.println("List after inserting 25 after 20:");
        traverse(head);
        
        head = insertBeforeNode(head, second, 15);
        System.out.println("List after inserting 15 before 20:");
        traverse(head);
		
        // Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);

        // Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // Get the size of the list
        System.out.println("Size of the list: " + size(head));

        // Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
        traverse(head);

        // Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

public class DoublyLinkedList
{
    // Node structure for doubly linked list
    public class Node
    {
        public int data;
        public Node next;
        public Node prev;

        // Constructor to create a new node
        public Node(int data)
        {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data);
        newNode.next = head;
        if (head != null)
        {
            head.prev = newNode;
        }
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null)
        {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.next = head;
            if (head != null)
            {
                head.prev = newNode;
            }
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null)
        {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }
	
	// Insert a new node after a given node
	public static Node InsertAfterNode(Node head, int target, int data)
	{
		Node temp = head;
		while (temp != null && temp.data != target)
		{
			temp = temp.next;
		}

		if (temp == null)
		{
			Console.WriteLine($"Node with value {target} not found.");
			return head;
		}

		Node newNode = new Node(data);
		newNode.next = temp.next;
		newNode.prev = temp;
		
		if (temp.next != null)
		{
			temp.next.prev = newNode;
		}
		temp.next = newNode;
		
		return head;
	}

	// Insert a new node before a given node
	public static Node InsertBeforeNode(Node head, int target, int data)
	{
		if (head == null)
		{
			Console.WriteLine("List is empty.");
			return null;
		}

		if (head.data == target)
		{
			return InsertAtBeginning(head, data);
		}

		Node temp = head;
		while (temp != null && temp.data != target)
		{
			temp = temp.next;
		}

		if (temp == null)
		{
			Console.WriteLine($"Node with value {target} not found.");
			return head;
		}

		Node newNode = new Node(data);
		newNode.next = temp;
		newNode.prev = temp.prev;

		if (temp.prev != null)
		{
			temp.prev.next = newNode;
		}
		temp.prev = newNode;

		return head;
	}

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        if (head.next != null)
        {
            head.next.prev = null;
        }
        return head.next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.next != null)
        {
            temp = temp.next;
        }
        if (temp.prev != null)
        {
            temp.prev.next = null;
        }
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return DeleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.next;
        }

        if (temp == null || temp.next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        if (temp.next.next != null)
        {
            temp.next.next.prev = temp;
        }
        temp.next = temp.next.next;
        return head;
    }

    // Get element at a specific index
    public static int Get(Node head, int index)
    {
        int count = 0;
        Node temp = head;

        while (temp != null)
        {
            if (count == index)
            {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        Console.WriteLine("Index out of range");
        return -1;
    }

    // Set element at a specific index
    public static void Set(Node head, int index, int newValue)
    {
        int count = 0;
        Node temp = head;

        while (temp != null)
        {
            if (count == index)
            {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        }

        Console.WriteLine("Index out of range");
    }

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, int key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.data == key)
            {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node temp = null;
        Node current = head;

        while (current != null)
        {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        if (temp != null)
        {
            head = temp.prev;
        }
        return head;
    }

    // Find the middle of the list
	public static Node Middle(Node head)
	{
		if (head == null) return null;

		Node slow = head, fast = head;
		
		while (fast.next != null && fast.next.next != null)
		{
			slow = slow.next;
			fast = fast.next.next;
		}

		return slow;
	}

	// Sort the list using merge sort
	public static Node Sort(Node head)
	{
		if (head == null || head.next == null) return head;

		Node mid = Middle(head);
		Node nextToMid = mid.next;

		// Properly break the list into two halves
		mid.next = null;
		if (nextToMid != null) 
		{
			nextToMid.prev = null;
		}

		Node left = Sort(head);
		Node right = Sort(nextToMid);

		return Merge(left, right);
	}

	// Merge two sorted lists
	public static Node Merge(Node head1, Node head2)
	{
		if (head1 == null) return head2;
		if (head2 == null) return head1;

		if (head1.data &lt;= head2.data)
		{
			head1.next = Merge(head1.next, head2);
			if (head1.next != null)
			{
				head1.next.prev = head1;
			}
			return head1;
		}
		else
		{
			head2.next = Merge(head1, head2.next);
			if (head2.next != null)
			{
				head2.next.prev = head2;
			}
			return head2;
		}
	}

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node Clear(Node head)
    {
        return null;
    }

    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning: ");
        Traverse(head);

        // Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end: ");
        Traverse(head);

        // Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2: ");
        Traverse(head);
		
  		head = InsertAfterNode(head, 4, 8);
  		Console.WriteLine("List after inserting 8 after 4:");
  		Traverse(head);
  
  		head = InsertBeforeNode(head, 4, 6);
  		Console.WriteLine("List after inserting 6 before 4:");
  		Traverse(head);

        // Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning: ");
        Traverse(head);

        // Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end: ");
        Traverse(head);

        // Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2: ");
        Traverse(head);

        // Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine("Element " + key + " found in the list");
        }
        else
        {
            Console.WriteLine("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing: ");
        Traverse(head);

        // Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));

        // Sort the list
        head = Sort(head);

        Console.WriteLine("Sorted list:");
        Traverse(head);

        // Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing: ");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-cpp hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for doubly linked list
typedef struct Node {
    StackElement element;     // Stack element data
    struct Node* next;        // Pointer to the next node
    struct Node* prev;        // Pointer to the previous node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    newNode-&gt;next = *head;
    (*head)-&gt;prev = newNode;
    *head = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a node after a given previous node
void insertAfterNode(Node** head, Node* prevNode, StackElement element) {
    if (*head == NULL || prevNode == NULL) {
        printf("The list cannot be empty or the previous node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(element);
    newNode-&gt;next = prevNode-&gt;next;
    if (prevNode-&gt;next != NULL) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
    newNode-&gt;prev = prevNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    if (*head == NULL || nextNode == NULL) {
        printf("The list cannot be empty or the next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(element);
    newNode-&gt;prev = nextNode-&gt;prev;
    if (nextNode-&gt;prev != NULL) {
        nextNode-&gt;prev-&gt;next = newNode;
    }
    nextNode-&gt;prev = newNode;
    newNode-&gt;next = nextNode;

    // If nextNode is the head node
    if (newNode-&gt;prev == NULL) {
        *head = newNode;
    }
}

// Function to insert a node at a specific position
void insertAtPosition(Node** head, StackElement element, int position) {
    if (position == 0) {
        insertAtBeginning(head, element);
        return;
    }

    Node* newNode = createNode(element);
    Node* temp = *head;
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != NULL) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *head;
    *head = (*head)-&gt;next;
    if (*head != NULL) {
        (*head)-&gt;prev = NULL;
    }
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;prev != NULL) {
        temp-&gt;prev-&gt;next = NULL;
    } else {
        *head = NULL; // Only one element in the list
    }
    free(temp);
}

// Function to delete a node at a given position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    if (position == 0) {
        *head = temp-&gt;next;
        if (*head != NULL) {
            (*head)-&gt;prev = NULL;
        }
        free(temp);
        return;
    }

    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    if (nextNode != NULL) {
        nextNode-&gt;prev = temp;
    }
    free(temp-&gt;next);
    temp-&gt;next = nextNode;
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%s &lt;-&gt; ", temp-&gt;element.toString);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to reverse the linked list
void reverse(Node** head) {
    Node* temp = NULL;
    Node* current = *head;
    
    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }
    
    if (temp != NULL) {
        *head = temp-&gt;prev;
    }
}


// Function to clear the entire linked list and free memory
void clear(Node** head) {
    Node* current = *head;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *head = NULL;
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    Node* temp = head;

    while (temp != NULL) {
        // Call toString to get the string representation of the data in the current node
        char* currentStr = temp-&gt;element.toString;
        char* keyStr = keyElement.toString;

        // Compare the string representations of the current node's data and the key element's data
        if (strcmp(currentStr, keyStr) == 0) {
            return 1; // Key found
        }

        temp = temp-&gt;next;
    }

    return 0; // Key not found
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;element;
        count++;
        temp = temp-&gt;next;
    }
    StackElement emptyElement = {NULL, ""};
    return emptyElement; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head2 = head2-&gt;next;
        }
        return;
    }
    if (head2 == NULL) {
        while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head1 = head1-&gt;next;
        }
        return;
    }

    if (strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt; 0) {
        Node* newNode = createNode(head1-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    } else {
        Node* newNode = createNode(head2-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    }
}

// Function to get the middle of the linked list
void middle(Node* head, Node** middle) {
    if (head == NULL) {
        *middle = NULL; // Set middle node to NULL if list is empty
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    *middle = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(head, &mid);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;

    // Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != NULL) {
        nextToMid-&gt;prev = NULL;  // Set 'prev' of the second half to null
    }

    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


struct Car {
    char model[20];
    int year;
};

struct Person {
    char name[20];
    int age;
};

// Main function to test the doubly linked list operations
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements into the list**
    insertAtBeginning(&personList, personElement1);
    insertAtEnd(&personList, personElement2);
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 2. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 3. **Insert before a node**
    insertBeforeNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 4. **Insert after a node**
    insertAfterNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 5. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 6. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 7. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 8. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 9. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 10. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 11. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 12. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 13. **Sort the linked list**
    printf("\nList before sorting:\n");
    traverse(personList);
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 14. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 15. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for doubly linked list
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;
    Node* prev; // Add prev pointer

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr), prev(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    newNode-&gt;next = head;
    if (head != nullptr) {
        head-&gt;prev = newNode;
    }
    head = newNode;
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    newNode-&gt;prev = prevNode;

    if (prevNode-&gt;next != nullptr) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    
    if (head == nextNode) {
        newNode-&gt;next = head;
        head-&gt;prev = newNode;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "The given next node is not found in the list\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        newNode-&gt;next = head;
        if (head != nullptr) {
            head-&gt;prev = newNode;
        }
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    head = head-&gt;next;
    if (head != nullptr) {
        head-&gt;prev = nullptr;
    }
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    temp-&gt;prev-&gt;next = nullptr;
    delete temp;
}

// Delete at a specific position
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node&lt;T&gt;* temp = head;
        head = head-&gt;next;
        if (head != nullptr) {
            head-&gt;prev = nullptr;
        }
        delete temp;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node&lt;T&gt;* nextNode = temp-&gt;next-&gt;next;
    if (nextNode != nullptr) {
        nextNode-&gt;prev = temp;
    }
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " &lt;-&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Reverse the list
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* temp = nullptr;

    // Reverse the next and prev pointers of all nodes
    while (current != nullptr) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    // Reset the head to the last node
    if (temp != nullptr) {
        head = temp-&gt;prev;
    }
}

// Get the size of the list
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    int count = 0;
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Function to access an element at a specific index (0-based)
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    int count = 0;
    Node&lt;T&gt;* temp = head;

    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data; // Return the data at the index
        count++;
        temp = temp-&gt;next;
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to set an element at a specific index (0-based)
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    Node&lt;T&gt;* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = element; // Update the node's value
            return;                  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;     // Move to the next node
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    Node&lt;T&gt;* temp = head;
    
    // Traverse the list in the forward direction
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;  // Element found
        temp = temp-&gt;next;
    }

    // If not found, return false
    return false;
}

// Function to merge two lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    // Merge the two lists based on data comparison (using &lt; operator)
    if (head1-&gt;data &lt; head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
        // Update the prev pointer of the next node in the merged list
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
        // Update the prev pointer of the next node in the merged list
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    }
}

// Function to find the middle node of the linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;* head, Node&lt;T&gt;*& mid) {
    if (head == nullptr) {
        mid = nullptr; // Set middle node to nullptr if the list is empty
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head-&gt;next;

    while (fast != nullptr) {
        fast = fast-&gt;next;
        if (fast != nullptr) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    mid = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    if (headRef == nullptr || headRef-&gt;next == nullptr)
        return;

    Node&lt;T&gt;* mid = nullptr;
    middle(headRef, mid);
    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;
    
    // Properly handle the 'prev' pointers for the second half of the list
    if (nextToMid != nullptr) {
        nextToMid-&gt;prev = nullptr;  // Set 'prev' of the second half to null
    }
    
    // Sort the two halves
    sort(headRef);
    sort(nextToMid);

    // Merge the sorted halves
    Node&lt;T&gt;* mergedHead = nullptr;
    merge(mergedHead, headRef, nextToMid);
    headRef = mergedHead; // Update the original head reference
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    while (current != nullptr) {
        Node&lt;T&gt;* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;(const Person& other) const {
        if (name == other.name) {
            return age &lt; other.age;  // If names are the same, sort by age
        }
        return name &lt; other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};

int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // Insert elements into the list
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    insertBeforeNode(head, secondNode, eve);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // Insert after a node (insert after the second node)
    insertAfterNode(secondNode, eve);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);

    // Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;

    // Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // Sort the linked list (by name first, then by age)
    cout &lt;&lt; "\nList before sorting:\n";
    traverse(head);
    sort(head);
    cout &lt;&lt; "\nList after sorting:\n";
    traverse(head);
    
    // Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
    
    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class LinkedList&lt;T&gt; {

    // Node structure for doubly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;
        Node&lt;T&gt; prev;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head != null) {
            head.prev = newNode;
        }
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head == null) {
            return newNode;
        }
        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; head, T data, int position) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (position == 0) {
            newNode.next = head;
            if (head != null) {
                head.prev = newNode;
            }
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null) {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert before a specific node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data) {
        if (head == null) return null;

        if (head == targetNode) {
            return insertAtBeginning(head, data);
        }

        Node&lt;T&gt; temp = head;
        while (temp != null && temp.next != targetNode) {
            temp = temp.next;
        }

        if (temp != null) {
            Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
            newNode.next = temp.next;
            if (temp.next != null) {
                temp.next.prev = newNode;
            }
            temp.next = newNode;
            newNode.prev = temp;
        }
        return head;
    }

    // Insert after a specific node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; node, T data) {
        if (node == null) return;

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = node.next;
        if (node.next != null) {
            node.next.prev = newNode;
        }
        node.next = newNode;
        newNode.prev = node;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        if (head.next != null) {
            head.next.prev = null;
        }
        return head.next;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.prev.next = null;
        return head;
    }

    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; head, T key) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; head) {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Get element at a specific index
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Set element at a specific index
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            System.out.print(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Sort the list
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
        if (head == null || head.next == null) return head;

        Node&lt;T&gt; mid = middle(head);
        Node&lt;T&gt; nextToMid = mid.next;
        mid.next = null;
        
        // Properly handle the 'prev' pointers for a doubly linked list
        if (nextToMid != null) {
            nextToMid.prev = null;  // Set 'prev' of the second half to null
        }
    
        Node&lt;T&gt; left = sort(head);
        Node&lt;T&gt; right = sort(nextToMid);

        return merge(left, right);
    }

    // Merge two sorted lists
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; left, Node&lt;T&gt; right) {
        if (left == null) return right;
        if (right == null) return left;

        if (left.data.compareTo(right.data) &lt;= 0) {
            left.next = merge(left.next, right);
            if (left.next != null) {
                left.next.prev = left;
            }
            return left;
        } else {
            right.next = merge(left, right.next);
            if (right.next != null) {
                right.next.prev = right;
            }
            return right;
        }
    }

    // Find the middle of the list
    public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
        if (head == null) return null;

        Node&lt;T&gt; slow = head;
        Node&lt;T&gt; fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Clear the list by removing all nodes
    public static &lt;T&gt; void clear(Node&lt;T&gt; head) {
        Node&lt;T&gt; current = head;
        while (current != null) {
            Node&lt;T&gt; next = current.next;
            current.next = null;  // Disconnect the current node
            current.prev = null;  // Disconnect the previous node
            current = next;       // Move to the next node
        }
    }
    
    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }

        @Override
        public int compareTo(Person other) {
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }

    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // Insert elements into the list
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);

        // Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // Get size of the list
        System.out.println("\nSize of the list: " + size(head));

        // Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // Sort the linked list (by name first, then by age)
        System.out.println("\nList before sorting:");
        traverse(head);
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
        
        // Clear the list
        clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;
    public Node&lt;T&gt; Prev;

    public Node(T data)
    {
        Data = data;
        Next = null;
        Prev = null;
    }
}

class Program
{
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = head };
        if (head != null) head.Prev = newNode;
        return newNode;
    }

    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null) return newNode;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Next = newNode;
        newNode.Prev = temp;
        return head;
    }

    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (position == 0) { newNode.Next = head; if (head != null) head.Prev = newNode; return newNode; }
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) temp = temp.Next;
        if (temp == null) { Console.WriteLine("Position out of bounds"); return head; }
        newNode.Next = temp.Next;
        newNode.Prev = temp;
        if (temp.Next != null) temp.Next.Prev = newNode;
        temp.Next = newNode;
        return head;
    }

    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null) return null;
        if (head == targetNode) return InsertAtBeginning(head, data);
        Node&lt;T&gt; temp = head;
        while (temp != null && temp.Next != targetNode) temp = temp.Next;
        if (temp != null)
        {
            Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = temp.Next, Prev = temp };
            if (temp.Next != null) temp.Next.Prev = newNode;
            temp.Next = newNode;
        }
        return head;
    }

    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next, Prev = node };
        if (node.Next != null) node.Next.Prev = newNode;
        node.Next = newNode;
    }

    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        head = head.Next;
        if (head != null) head.Prev = null;
        return head;
    }

    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null || head.Next == null) return null;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Prev.Next = null;
        return head;
    }

    // Search for an element
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        }
        return false;
    }

    // Get size of the list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Traverse the list and print elements
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " &lt;-&gt; ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Get an element at specific index
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Set (modify) an element at specific index
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }
    
    // Sort the linked list (Merge Sort)
    static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == null) return head;

        // Split the list into two halves
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; nextToMid = mid.Next;
        mid.Next = null;
        if (nextToMid != null) nextToMid.Prev = null;

        // Recursively sort both halves
        Node&lt;T&gt; left = Sort(head);
        Node&lt;T&gt; right = Sort(nextToMid);

        // Merge the sorted halves
        return Merge(left, right);
    }

    // Merge two sorted lists
    static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; left, Node&lt;T&gt; right) where T : IComparable&lt;T&gt;
    {
        if (left == null) return right;
        if (right == null) return left;

        if (left.Data.CompareTo(right.Data) &lt;= 0)
        {
            left.Next = Merge(left.Next, right);
            if (left.Next != null) left.Next.Prev = left;
            return left;
        }
        else
        {
            right.Next = Merge(left, right.Next);
            if (right.Next != null) right.Next.Prev = right;
            return right;
        }
    }

    // Find the middle node of the list
    static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        Node&lt;T&gt; slow = head, fast = head.Next;

        while (fast != null && fast.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }
    
    // Clear the linked list
    static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        head = null;
        return head;
    }
    
    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // Insert elements into the list
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);

        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);

        // Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);

        // Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        head = InsertBeforeNode(head, secondNode, eve);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);

        // Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);

        // Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);

        // Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);

        // Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));

        // Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

        // Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

        // Sort the linked list (by name first, then by age)
        Console.WriteLine("\nList before sorting:");
        Traverse(head);
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);
    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";

}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/doubly-linked-list" class="tag">doubly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>


				<div class="container">
					<div class="row">
						<div class="col-md-6">
							<script type="text/javascript">
								atOptions = {
									'key' : '24dfaf1e2babad270db4c0eae11415cc',
									'format' : 'iframe',
									'height' : 60,
									'width' : 468,
									'params' : {}
								};
							</script>
							<script type="text/javascript" src="//www.topcreativeformat.com/24dfaf1e2babad270db4c0eae11415cc/invoke.js"></script>
						</div>
						<div class="col-md-6">
							<script type="text/javascript">
								atOptions = {
									'key' : '24dfaf1e2babad270db4c0eae11415cc',
									'format' : 'iframe',
									'height' : 60,
									'width' : 468,
									'params' : {}
								};
							</script>
							<script type="text/javascript" src="//www.topcreativeformat.com/24dfaf1e2babad270db4c0eae11415cc/invoke.js"></script>
						</div>
						<div class="col-md-6">
							<script type="text/javascript">
								atOptions = {
									'key' : '08760f2487e830ed5039902de4007bec',
									'format' : 'iframe',
									'height' : 250,
									'width' : 300,
									'params' : {}
								};
							</script>
							<script type="text/javascript" src="//www.topcreativeformat.com/08760f2487e830ed5039902de4007bec/invoke.js"></script>
						</div>
						<div class="col-md-6">
							<script type="text/javascript">
								atOptions = {
									'key' : '08760f2487e830ed5039902de4007bec',
									'format' : 'iframe',
									'height' : 250,
									'width' : 300,
									'params' : {}
								};
							</script>
							<script type="text/javascript" src="//www.topcreativeformat.com/08760f2487e830ed5039902de4007bec/invoke.js"></script>
						</div>
					</div>
				</div>
				<div id="disqus_thread"></div>
			</div>

			<div class="col-12" style="border-bottom:0.1rem solid #eee;margin-top:2rem;margin-bottom:5rem;"></div>
		</div>
	</div>
</section>

<section>
	<div class="container">
		<div class="row">
			<div class="col-12">
				<div class="section-heading d-flex align-items-center">  
					<h2>Related Posts</h2>
					<a href="https://hemimorphite.github.io/" type="button" class="btn btn-all ms-auto">All posts <i class="fa-solid fa-arrow-right"></i></a>
				</div>
				<div class="related-posts">
					<div class="row">
						
						
						
						
						
						
						<div class="col-md-6 col-lg-4">
							<div class="blog-post">
								<div class="blog-thumb">
									<a href="https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/"><img src="https://hemimorphite.github.io/assets/images/circularsinglylinked.jpg" alt=""></a>
								</div>
								<div class="blog-eyebrow">Tutorial</div>
								<h4 class="blog-title"><a href="https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/">Circular Singly Linked List Data Structure</a></h4>
							</div>
						</div>
						
						
						
						
						
						
						<div class="col-md-6 col-lg-4">
							<div class="blog-post">
								<div class="blog-thumb">
									<a href="https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/"><img src="https://hemimorphite.github.io/assets/images/singlylinked.jpg" alt=""></a>
								</div>
								<div class="blog-eyebrow">Tutorial</div>
								<h4 class="blog-title"><a href="https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/">Singly Linked List Data Structure</a></h4>
							</div>
						</div>
						
						
						
						
						<div class="col-md-6 col-lg-4">
							<div class="blog-post">
								<div class="blog-thumb">
									<a href="https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/"><img src="https://hemimorphite.github.io/assets/images/dynamicarray.jpg" alt=""></a>
								</div>
								<div class="blog-eyebrow">Tutorial</div>
								<h4 class="blog-title"><a href="https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/">Dynamic Array Data Structure</a></h4>
							</div>
						</div>
						
						
						
						
						<div class="col-md-6 col-lg-4">
							<div class="blog-post">
								<div class="blog-thumb">
									<a href="https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/"><img src="https://hemimorphite.github.io/assets/images/linearstack.jpg" alt=""></a>
								</div>
								<div class="blog-eyebrow">Tutorial</div>
								<h4 class="blog-title"><a href="https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/">Linear Stack Data Structure</a></h4>
							</div>
						</div>
						
						
						
					</div>
				</div>
			</div>
		</div>
	</div>
</section>

		<section>
			<div class="container">
				<div class="row">
					<div class="col-md-6">
						<script async="async" data-cfasync="false" src="//pl23622823.highrevenuenetwork.com/82849ac901fcdf553b99a113d233ce38/invoke.js"></script>
						<div id="container-82849ac901fcdf553b99a113d233ce38"></div>
					</div>
					<div class="col-md-6">
						<script type="text/javascript">
							atOptions = {
								'key' : '08760f2487e830ed5039902de4007bec',
								'format' : 'iframe',
								'height' : 250,
								'width' : 300,
								'params' : {}
							};
						</script>
						<script type="text/javascript" src="//www.topcreativeformat.com/08760f2487e830ed5039902de4007bec/invoke.js"></script>
					</div>
				</div>
			</div>
		</section>

	    <footer>
			<div class="container">
				<div class="row">
					<div class="col-lg-12">
						<div class="copyright-text">
						<p>&copy; 2025 Copyright hemimorphite. All Rights Reserved</p>
						</div>
					</div>
				</div>
			</div>
		</footer>

		<script src="https://hemimorphite.github.io/assets/vendor/jquery/jquery.min.js"></script>
	    <script src="https://hemimorphite.github.io/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
	    <script src="https://hemimorphite.github.io/assets/vendor/highlight.js/js/highlight.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
	    <script>
			//<![CDATA[
			/* highlight.js | https://unpkg.com/highlightjs-badge@0.1.8/highlightjs-badge.min.js */
			"use strict";!function(e,o){"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?o(e,!0):function(e){if(!e.document)throw new Error("A window with a document is required");return o(e)}:o(e)}("undefined"!=typeof window?window:this,function(y,e){if("boolean"!=typeof o)var o=!1;function t(e){var o,m={templateSelector:"#CodeBadgeTemplate",contentSelector:"body",loadDelay:0,copyIconClass:"fa fa-copy",copyIconContent:"",checkIconClass:"fa fa-check text-success",checkIconContent:"",onBeforeCodeCopied:null};function t(){m.loadDelay?setTimeout(n,loadDelay):n()}function n(){if(!document.querySelector(m.templateSelector)){var e=document.createElement("div");e.innerHTML=function(){for(var e=["<style>","@media print {","   .code-badge { display: none; }","}","    .code-badge-pre {","        position: relative;","    }","    .code-badge {","        display: flex;","        flex-direction: row;","        white-space: normal;","        background: transparent;","        background: #fff;","        color: #333;","        font-size: 0.875em;","        opacity: 0.5;","        transition: opacity linear 0.5s;","        border-radius: 0 0 0 7px;","        padding: 5px 8px 5px 8px;","        position: absolute;","        right: 0;","        top: 0;","    }","    .code-badge.active {","        opacity: 0.8;","    }","","    .code-badge:hover {","        opacity: .95;","    }","","    .code-badge a,","    .code-badge a:hover {","        text-decoration: none;","    }","","    .code-badge-language {","        margin-right: 10px;","        font-weight: 600;","        color: goldenrod;","    }","    .code-badge-copy-icon {","        font-size: 1.2em;","        cursor: pointer;","        padding: 0 7px;","    }","    .fa.text-success:{ color: limegreen !important }","</style>",'<div id="CodeBadgeTemplate" style="display:none">','    <div class="code-badge">','        <div class="code-badge-language" ></div>','        <div  title="Copy to clipboard">','            <i class=" code-badge-copy-icon"></i></i></a>',"        </div>","     </div>","</div>"],o="",t=0;t<e.length;t++)o+=e[t]+"\n";return o}();var o=e.querySelector("style"),t=e.querySelector(m.templateSelector);document.body.appendChild(o),document.body.appendChild(t)}for(var n=document.querySelector(m.templateSelector).innerHTML,c=document.querySelectorAll("pre>code.hljs"),a=0;a<c.length;a++){var r=c[a];if(!r.querySelector(".code-badge")){for(var d="",l=0;l<r.classList.length;l++){var i=r.classList[l];if("language-"===i.substr(0,9)){d=r.classList[l].replace("language-","");break}if("lang-"===i.substr(0,5)){d=r.classList[l].replace("lang-","");break}if(!d)for(var s=0;s<r.classList.length;s++)if("hljs"!=r.classList[s]){d=r.classList[s];break}}"ps"==(d=d?d.toLowerCase():"text")?d="powershell":"cs"==d?d="csharp":"js"==d?d="javascript":"ts"==d?d="typescript":"fox"==d&&(d="foxpro");var p=n.replace("",d).replace("",m.copyIconClass).trim(),u=document.createElement("div");u.innerHTML=p,u=u.querySelector(".code-badge");var g=r.parentElement;g.classList.add("code-badge-pre"),m.copyIconContent&&(u.querySelector(".code-badge-copy-icon").innerText=m.copyIconContent),g.insertBefore(u,r)}}document.querySelector(m.contentSelector).addEventListener("click",function(e){return e.srcElement.classList.contains("code-badge-copy-icon")&&(e.preventDefault(),e.cancelBubble=!0,function(e){var o=e.srcElement.parentElement.parentElement.parentElement,t=o.querySelector("pre>code"),n=t.textContent||t.innerText;m.onBeforeCodeCopied&&(n=m.onBeforeCodeCopied(n,t));var c=document.createElement("textarea");c.value=n.trim(),document.body.appendChild(c),c.style.display="block",y.document.documentMode?c.setSelectionRange(0,c.value.length):c.select();document.execCommand("copy"),document.body.removeChild(c),function(e){var o=m.copyIconClass.split(" "),t=m.checkIconClass.split(" "),n=e.querySelector(".code-badge-copy-icon");n.innerText=m.checkIconContent;for(var c=0;c<o.length;c++)n.classList.remove(o[c]);for(c=0;c<t.length;c++)n.classList.add(t[c]);setTimeout(function(){n.innerText=m.copyIconContent;for(var e=0;e<t.length;e++)n.classList.remove(t[e]);for(e=0;e<o.length;e++)n.classList.add(o[e])},2e3)}(o)}(e)),!1})}o=e,Object.assign(m,o),"loading"==document.readyState?document.addEventListener("DOMContentLoaded",t):t()}y.highlightJsBadge=t,y.module&&y.module.exports&&(y.module.exports.highlightJsBadge=t),o&&t()});   
			//]]>
		</script>

	    <!-- Additional Scripts -->
	    <script src="https://hemimorphite.github.io/assets/js/custom.js"></script>
	    <script>
	    	let url = new URL("https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/");
			let paths = url.pathname.split('/').slice(1);

		    /**
		    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
		    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
		    if(typeof paths[3] !== 'undefined') {
		    	var disqus_config = function () {
				    this.page.url = "https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/";  // Replace PAGE_URL with your page's canonical URL variable
				    this.page.identifier = btoa(paths[3]); // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			    };
			    
			    (function() { // DON'T EDIT BELOW THIS LINE
			    var d = document, s = d.createElement('script');
			    s.src = 'https://hemimorphite-github-io.disqus.com/embed.js';
			    s.setAttribute('data-timestamp', +new Date());
			    (d.head || d.body).appendChild(s);
			    })();	
		    }
		    
		</script>
	    <script id="dsq-count-scr" src="https://hemimorphite-github-io.disqus.com/count.js" async></script>
		
  	</body>
</html>