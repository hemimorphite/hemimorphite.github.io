<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hemimorphite.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hemimorphite.github.io/" rel="alternate" type="text/html" /><updated>2025-02-05T13:07:04+00:00</updated><id>https://hemimorphite.github.io/feed.xml</id><title type="html">Hemimorphite</title><subtitle>Gain a better understanding of mathematics, chemistry, physics, and computer science. Our tutorials provide clear explanations and practical examples to help you learn and master these subjects. Helping learners of all levels to grasp fundamental concepts and hone their skills.</subtitle><entry xml:lang="en"><title type="html">Circular Singly Linked List Data Structure</title><link href="https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/" rel="alternate" type="text/html" title="Circular Singly Linked List Data Structure" /><published>2025-02-04T16:20:00+00:00</published><updated>2025-02-04T16:20:00+00:00</updated><id>https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Circular Singly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published February 04, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/circularsinglylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Circular Singly Linked List</h3>

		<p>A circular singly linked list is a variation of a singly linked list where the last node points back to the first node, forming a circular structure. It is a linear data structure consisting of a sequence of elements, called nodes, where each node points to the next node in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations. Each node contains two fields:</p>

		<ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence. In the case of the last node, the next pointer points back to the first node.</li>
		</ul>

        <p>The circular singly linked list forms a linear collection of elements where each node points to its successor, and the last node points back to the first node, creating a circular structure. It is a dynamic data structure, meaning it can grow or shrink in size during runtime, as nodes can be added or removed without requiring memory to be reallocated.</p>

		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. In a circular singly linked list, the last node points back to the head, forming a loop. If the list is empty, the head points to <code>NULL</code>.</p>

		<p>Unlike arrays that have a fixed size, a circular singly linked list dynamically allocates memory for each node when it is created. This means the size of the list can grow or shrink as nodes are added or removed at runtime.</p>

		<p>Insertions and deletions of nodes, particularly at the beginning or middle of the list, are more efficient compared to arrays since you do not need to shift elements.</p>

		<p>Circular singly linked lists can be traversed in a loop starting from the head and continuing back to the head after reaching the tail. However, there is no way to traverse backward, which can be a limitation in some use cases.</p>

		<p>The nodes in a circular singly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next through pointers, and they can be located anywhere in memory.</p>

		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>

		<p>Each node in a circular singly linked list requires extra memory for the pointer (next reference), which slightly increases memory usage compared to arrays.</p>

		<p>The last node in a circular singly linked list points back to the head, instead of having its next pointer set to <code>NULL</code>.</p>

		<p>Here's a visual representation of a circular singly linked list:</p>

		<pre><code class="language-bash hljs">Head -&gt; [Data | Next] -&gt; [Data | Next] -&gt; [Data | Next] -&gt; Head</code></pre>

		<p>In the above representation:</p>

		<ul>
			<li>The <code>Head</code> points to the first node of the list.</li>
			<li>Each node contains <code>Data</code> and a <code>Next</code> pointer to the next node.</li>
			<li>The last node's <code>Next</code> pointer points back to the <code>Head</code>, indicating the circular structure.</li>
		</ul>

		
		<p>A simple circular singly linked list with three nodes could look like this:</p>

		<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>

		<p>In the above example:</p>

		<ul>
			<li>The <code>Head</code> points to the first node containing the data <code>10</code>.</li>
			<li>The second node contains the data <code>20</code> and points to the third node.</li>
			<li>The third node contains the data <code>30</code> and points back to the <code>Head</code>, indicating the circular structure of the list.</li>
		</ul>

		
		<p>Here's a detailed breakdown of common circular singly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a circular singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [5 | Next] -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a circular singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>If the list is not empty, set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list). If the list is empty, set the <code>next</code> pointer of the new node to point to itself, creating a circular structure.</li>
							<li>Update the head pointer to point to the new node.</li>
							<li>If the list is not empty, the last node's <code>next</code> pointer should be updated to point to the new head.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a circular singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a circular singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; [40 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a circular singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning. The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to point to itself, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer points to the head).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to point to the head.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a circular singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [25 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a circular singly linked list immediately after a given node. If the target node doesn't exist, the function does nothing and simply returns control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [25 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node after a given node in a circular singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node after a node in a circular singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a circular singly linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [35 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a circular singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target position).</li>
							<li>Update the <code>next</code> pointer of the new node to point to the next node in the sequence.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointers takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a new node at a specified position in a circular singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a circular singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [20 | Next] -&gt; [30 | Next]-&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the beginning of a circular singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>If the list is empty, return.</li>
							<li>If there is only one node, set the head to <code>NULL</code> (empty list).</li>
							<li>Otherwise:
								<ul>
									<li>Find the last node in the list (the node pointing to head).</li>
									<li>Update the last node's <code>next</code> pointer to point to the second node.</li>
									<li>Set the head pointer to the second node.</li>
									<li>Deallocate the memory of the old head node.</li>
								</ul>
							</li>
						</ul>
						Since no traversal is required in the case of a one-node list, and only a single traversal is required for a multi-node list, this operation still takes \(O(1)\) on average.
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a circular singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a circular singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a circular singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>If the list is empty, return.</li>
							<li>If there is only one node, set the head to <code>NULL</code> (empty list).</li>
							<li>Otherwise:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list to find the second-to-last node (the node whose <code>next</code> pointer points to the last node).</li>
									<li>Update the <code>next</code> pointer of the second-to-last node to point to the head, maintaining the circular structure.</li>
									<li>Deallocate the memory for the old last node.</li>
								</ul>
							</li>
						</ul>
						Since traversal is required to reach the second-to-last node, the worst-case time complexity is \(O(n)\), where \(n\) is the number of nodes in the list.
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a circular singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a circular singly linked list. Positions are usually indexed starting from 0 or 1. If the position is 0 (or 1, based on indexing), it means the head node should be removed. If the specified position is out of bounds, a message is printed, and no changes are made to the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular singly linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] &gt; Head</code></pre>
							</li>
							<li>You want to remove the node at position <code>2</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a circular singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>If the list is empty, return.</li>
							<li>If the position is 0 (or 1, based on indexing), remove the head node:
								<ul>
									<li>If there is only one node, set <code>head = NULL</code>.</li>
									<li>Otherwise, find the last node (the node whose <code>next</code> points to the head).</li>
									<li>Update the head pointer to the next node.</li>
									<li>Update the last node's <code>next</code> pointer to point to the new head.</li>
									<li>Deallocate the memory of the removed node.</li>
								</ul>
							</li>
							<li>If the position is greater than 0, traverse the list to find the node before the target node.</li>
							<li>Update its <code>next</code> pointer to skip the target node and point to the node after it.</li>
							<li>Deallocate the memory of the removed node.</li>
						</ul>
						Since traversal is required to reach the node before the target, the worst-case time complexity is \(O(n)\), where \(n\) is the number of nodes in the list.
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a circular singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references, and it does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>

			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a circular singly linked list and performs an action, such as printing the node's value. Unlike a singly linked list, traversal starts at the head and continues until the head is encountered again, ensuring the circular structure is maintained.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>traverse()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, from the head back to the head. Since every node is visited once, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>traverse()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>

			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a circular singly linked list. Unlike a regular singly linked list, the last node's <code>next</code> pointer must be correctly updated to point to the new head, ensuring the circular structure is maintained.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following circular linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; Head</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [30 | Next] -&gt; [20 | Next] -&gt; [10 | Next] -&gt; Head</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of the <code>reverse()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses each node exactly once and updates pointers accordingly.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>reverse()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes, regardless of the list size.</li>
				</ul>
			</li>

			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a circular singly linked list. Unlike a regular singly linked list, the traversal must stop when the search wraps around back to the head, ensuring we do not loop indefinitely.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>search()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function may need to examine every node in the list before finding the key (or determining that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of the <code>search()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space to store variables, such as a pointer to the current node. No additional data structures are used.</li>
				</ul>
			</li>

			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a circular singly linked list. Unlike a regular singly linked list, traversal must stop when the function loops back to the head to avoid infinite loops.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>size()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the entire linked list once to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>size()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function uses only a fixed amount of extra space for variables, regardless of the size of the list.</li>
				</ul>
			</li>

			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a circular singly linked list at a specified index. Since the list is circular, traversal stops when the head is encountered again. If the index is out of range, a message is printed indicating that the index is invalid.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>get()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the list until it reaches the specified index, stopping if it loops back to the head before finding the index.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>get()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space for variables, regardless of the list size.</li>
				</ul>
			</li>

			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a circular singly linked list. Since the list is circular, traversal stops when the head is encountered again. If the index is out of range, a message is printed indicating that the index is invalid.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>set()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the list until it reaches the specified index, stopping if it loops back to the head before finding the index.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>set()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of extra space for variables, regardless of the list size.</li>
				</ul>
			</li>

			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a circular singly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>isEmpty()</code> function in a circular singly linked list is \(O(1)\) (constant time). The function only checks if the head pointer is <code>NULL</code>, which takes constant time.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>isEmpty()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function does not use any additional memory beyond a single pointer check.</li>
				</ul>
			</li>

			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted circular singly linked lists into a single sorted circular singly linked list while maintaining circularity.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>merge()</code> function in a circular singly linked list is \(O(n + m)\) (linear time). Each node from both lists is visited exactly once, and linking operations are performed in constant time. Where \(n\) is the number of nodes in the first circular linked list and \(m\) is the number of nodes in the second circular linked list.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>merge()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function uses a fixed number of pointers without any additional data structures, ensuring that the space required does not depend on the size of the input lists.</li>
				</ul>
			</li>

			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a circular singly linked list in a specific order (typically ascending or descending) while maintaining its circular nature.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>sort()</code> function in a circular singly linked list, when using merge sort, is \(O(n \log n)\) (linearithmic time). The algorithm recursively divides the list into halves and requires \(O(n)\) time to merge them back together. The logarithmic factor \(\log n\) results from the number of times the list is split in half.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>sort()</code> function in a circular singly linked list, using Merge Sort, is \(O(\log n)\) (logarithmic space) due to recursion depth. If implemented iteratively, space complexity can be reduced to \(O(1)\), ensuring no extra space is used beyond a few pointers.</li>
				</ul>
			</li>

			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from a circular singly linked list, freeing up the memory they occupy and making the list empty. The head pointer is set to <code>NULL</code>, breaking the circular link.</li>
					<li><b>Time complexity</b>: The time complexity of the <code>clear()</code> function in a circular singly linked list is \(O(n)\) (linear time). The function traverses the list once, freeing each node's memory.</li>
					<li><b>Space complexity</b>: The space complexity of the <code>clear()</code> function in a circular singly linked list is \(O(1)\) (constant space). The function only uses a fixed amount of space for temporary pointers during traversal, regardless of the list size.</li>
				</ul>
			</li>

        </ul>
		
		<h3 class="post-subtitle">Non-Generic Circular Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic circular singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Defines a structure to represent a node in a circular singly linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = newNode;  // Points to itself initially (circular behavior)
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
    } else {
        Node* temp = *headRef;
        while (temp-&gt;next != *headRef) {  // Traverse until we find the last node
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;  // Update last node's next to new node
        newNode-&gt;next = *headRef;  // New node points to head
        *headRef = newNode;  // Update head
    }
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    if (*headRef == NULL) {
        *headRef = createNode(data);
    } else {
        Node* temp = *headRef;
        while (temp-&gt;next != *headRef) {  // Traverse until we find the last node
            temp = temp-&gt;next;
        }
        Node* newNode = createNode(data);
        temp-&gt;next = newNode;
        newNode-&gt;next = *headRef;  // Make the new node point to the head
    }
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }
    
    Node* newNode = createNode(data);
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(data);
    
    if (*headRef == nextNode) {  // If the nextNode is the head, insert at beginning
        insertAtBeginning(headRef, data);
        return;
    }

    Node* temp = *headRef;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    if (position == 0) {  // Insert at the beginning
        insertAtBeginning(headRef, data);
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *headRef;
    if (temp-&gt;next == *headRef) {  // If there's only one node
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the last node
    Node* last = *headRef;
    while (last-&gt;next != *headRef) {
        last = last-&gt;next;
    }

    last-&gt;next = (*headRef)-&gt;next;  // Last node's next points to second node
    *headRef = (*headRef)-&gt;next;  // Update head
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    if (temp-&gt;next == *headRef) {  // Only one node
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the second last node
    Node* last = *headRef;
    while (last-&gt;next != *headRef) {
        last = last-&gt;next;
    }

    // Delete last node
    Node* secondLast = *headRef;
    while (secondLast-&gt;next != last) {
        secondLast = secondLast-&gt;next;
    }

    secondLast-&gt;next = *headRef;  // Second last node points to head
    free(last);
}

// Function to delete a node at a specific position (0-based index) in a circular singly linked list
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    // If the position is 0, we need to delete the head
    if (position == 0) {
        // If there is only one node in the list
        if (temp-&gt;next == *headRef) {
            free(temp);
            *headRef = NULL;
            return;
        }

        // Traverse to the last node
        Node* last = *headRef;
        while (last-&gt;next != *headRef) {
            last = last-&gt;next;
        }

        // Update the head and unlink the node
        last-&gt;next = temp-&gt;next;
        *headRef = temp-&gt;next;
        free(temp);
        return;
    }

    // Find the previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
        if (temp == *headRef) {
            // If we have reached the head again, the position is out of bounds
            printf("Position out of bounds\n");
            return;
        }
    }

    // If position is more than number of nodes or temp is NULL
    if (temp == NULL || temp-&gt;next == *headRef) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next; // Unlink the node from the list
    free(nodeToDelete); // Free the memory of the deleted node
}

// Function to traverse the circular list and print all elements
void traverse(Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }

    Node* temp = head;
    do {
        printf("%d -&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    } while (temp != head);  // Stop when we reach the head again
    printf("(head)\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    if (head == NULL) return 0;

    Node* temp = head;
    do {
        if (temp-&gt;data == key)
            return 1;
        temp = temp-&gt;next;
    } while (temp != head);
    
    return 0;
}

// Function to get the size of the circular linked list
int size(Node* head) {
    if (head == NULL) return 0;
    
    int size = 1;
    Node* temp = head-&gt;next;
    while (temp != head) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    if (head == NULL) return -1;

    int count = 0;
    Node* temp = head;
    do {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    } while (temp != head);
    
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    int count = 0;
    Node* current = head;
    do {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;
        }
        count++;
        current = current-&gt;next;
    } while (current != head);
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to reverse the circular linked list
void reverse(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == *headRef) {
        return;  // No need to reverse for empty or single node
    }

    Node *prev = NULL, *current = *headRef, *next = NULL;
    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != *headRef);
    
    (*headRef)-&gt;next = prev;  // Make the last node point to the new head
    *headRef = prev;
}

// Function to clear the entire circular linked list and free memory
void clear(Node** headRef) {
    if (*headRef == NULL) return;
    
    Node* current = *headRef;
    Node* next;
    do {
        next = current-&gt;next;
        free(current);
        current = next;
    } while (current != *headRef);

    *headRef = NULL;
}
// Function to find the middle of a circular singly linked list
void middle(Node** mid, Node* head) {
    if (head == NULL || head-&gt;next == head) {
        *mid = head;
        return;
    }

    Node* slow = head;
    Node* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    *mid = slow;
}

// Function to merge two circular linked lists
void merge(Node** headRef, Node* head1, Node* head2) {
    Node* tempHead = NULL, *last = NULL;
    Node* first1 = head1, *first2 = head2;
    
    printf("Starting merge...\n");

    if (head1 == NULL) {
        printf("First list is empty. Returning a new node from the second list.\n");
        Node* newNode = createNode(head2-&gt;data); // Create a new node with the data of the first node of head2
        *headRef = newNode; // Set the new node as the head
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = NULL; // Handle circular structure
        return;
    }
    if (head2 == NULL) {
        printf("Second list is empty. Returning a new node from the first list.\n");
        Node* newNode = createNode(head1-&gt;data); // Create a new node with the data of the first node of head1
        *headRef = newNode; // Set the new node as the head
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = NULL; // Handle circular structure
        return;
    }

    printf("Both lists are non-empty. Merging...\n");

    do {
        Node* newNode;
        if (head1 && (head2 == NULL || head1-&gt;data &lt;= head2-&gt;data)) {
            printf("Adding node from List 1: %d\n", head1-&gt;data);
            newNode = createNode(head1-&gt;data);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                printf("End of List 1 reached.\n");
                head1 = NULL;  // Stop merging this list
            }
        } else {
            printf("Adding node from List 2: %d\n", head2-&gt;data);
            newNode = createNode(head2-&gt;data);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                printf("End of List 2 reached.\n");
                head2 = NULL;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            printf("New head node created: %d\n", tempHead-&gt;data);
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != NULL || head2 != NULL);

    // Make the list circular
    last-&gt;next = tempHead;
    *headRef = tempHead;
    printf("Merge completed. Circular list created with head: %d\n", (*headRef)-&gt;data);
}

// Function to sort a circular singly linked list (Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == *headRef)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = head; // Break circularity for first half
    Node* secondHalf = nextToMid;

    // Find last node of second half
    while (secondHalf-&gt;next != head)
        secondHalf = secondHalf-&gt;next;
    
    secondHalf-&gt;next = nextToMid; // Break circularity for second half

    // Sort both halves
    sort(&head);
    sort(&nextToMid);

    // Merge sorted halves
    merge(headRef, head, nextToMid);
}

// Main function to test the circular linked list operations
int main() {
    Node* list = NULL; // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}
	
    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }

    // 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);

    // 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);

    // 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic circular singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for circular singly linked list
struct Node {
    int data;
    Node* next;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (!head) {
        newNode-&gt;next = newNode;
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != head) temp = temp-&gt;next;
    temp-&gt;next = newNode;
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (!head) {
        newNode-&gt;next = newNode;
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != head) temp = temp-&gt;next;
    temp-&gt;next = newNode;
    newNode-&gt;next = head;
}

// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (!head) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != head) temp = temp-&gt;next;
    Node* toDelete = head;
    temp-&gt;next = head-&gt;next;
    head = head-&gt;next;
    delete toDelete;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        cout &lt;&lt; "The list cannot be empty." &lt;&lt; endl;
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL." &lt;&lt; endl;
        return;
    }

    Node* newNode = new Node(data);

    // If inserting before the head, update head reference
    if (headRef == nextNode) {
        // Find the last node to update its next pointer
        Node* temp = headRef;
        while (temp-&gt;next != headRef) {
            temp = temp-&gt;next;
        }

        temp-&gt;next = newNode; // Update last node's next pointer
        newNode-&gt;next = headRef;
        headRef = newNode; // New node becomes the head
        return;
    }

    // Find the node just before nextNode
    Node* temp = headRef;
    while (temp-&gt;next != headRef && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;next != nextNode) {
        cout &lt;&lt; "The given next node is not found in the list." &lt;&lt; endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);

    // If inserting at position 0 (beginning)
    if (position == 0) {
        if (head == nullptr) {
            newNode-&gt;next = newNode; // First node points to itself
            head = newNode;
        } else {
            // Find the last node
            Node* temp = head;
            while (temp-&gt;next != head) {
                temp = temp-&gt;next;
            }

            // Insert the new node at the beginning
            newNode-&gt;next = head;
            temp-&gt;next = newNode;
            head = newNode;
        }
        return;
    }

    // Traverse to the (position-1)th node
    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp-&gt;next != head; i++) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;next == head && position &gt; 0) {
        cout &lt;&lt; "Position out of bounds.\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the end
void deleteAtEnd(Node*& head) {
    if (!head) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next-&gt;next != head) temp = temp-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = head;
}

// Traverse the list
void traverse(Node* head) {
    if (!head) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    do {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    } while (temp != head);
    cout &lt;&lt; "(head)\n";
}

// Function to delete a node at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    Node* temp = head;

    // Case 1: Deleting the head node
    if (position == 0) {
        if (head-&gt;next == head) {
            delete head; // Only one node in the list
            head = nullptr;
            return;
        }

        // Find the last node to update its next pointer
        Node* last = head;
        while (last-&gt;next != head) {
            last = last-&gt;next;
        }

        last-&gt;next = head-&gt;next;
        head = head-&gt;next;
        delete temp;
        return;
    }

    // Case 2: Deleting a node at position &gt; 0
    Node* prev = nullptr;
    for (int i = 0; i &lt; position; i++) {
        prev = temp;
        temp = temp-&gt;next;

        // If we circle back to the head, position is out of bounds
        if (temp == head) {
            cout &lt;&lt; "Position out of bounds\n";
            return;
        }
    }

    prev-&gt;next = temp-&gt;next;
    delete temp;
}

// Function to check if the list is empty
bool isEmpty(Node* head) {
    return head == nullptr;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return -1;
    }

    Node* temp = head;
    int count = 0;

    do {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    cout &lt;&lt; "Index out of range\n";
    return -1;
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    Node* temp = head;
    int count = 0;

    do {
        if (count == index) {
            temp-&gt;data = newValue;
            return;
        }
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    cout &lt;&lt; "Index out of range\n";
}

// Function to search for an element in a circular linked list
bool search(Node* head, int key) {
    if (head == nullptr) return false;

    Node* temp = head;
    do {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    } while (temp != head);

    return false;
}

// Reverse the list
void reverse(Node*& head) {
    if (!head || head-&gt;next == head) return;
    Node* prev = nullptr, *current = head, *next = nullptr, *tail = head;
    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != head);
    head-&gt;next = prev;
    head = prev;
}

// Get size of the list
int size(Node* head) {
    if (!head) return 0;
    int count = 0;
    Node* temp = head;
    do {
        count++;
        temp = temp-&gt;next;
    } while (temp != head);
    return count;
}

// Clear the list
void clear(Node*& head) {
    if (!head) return; // If the list is empty, return immediately.

    Node* temp = head;
    Node* nextNode;

    // Traverse and delete each node
    while (temp-&gt;next != head) {
        nextNode = temp-&gt;next;
        delete temp;
        temp = nextNode;
    }

    // Delete the last remaining node
    delete temp;

    head = nullptr; // Set head to null after clearing the list
}

// Function to merge two sorted circular linked lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    Node* tempHead = nullptr, *last = nullptr;
    Node* first1 = head1, *first2 = head2;
    
    //std::cout &lt;&lt; "Starting merge...\n";

    if (head1 == nullptr) {
        //std::cout &lt;&lt; "First list is empty. Returning a new node from the second list.\n";
        Node* newNode = new Node(head2-&gt;data); // Create a new node with the data of the first node of head2
        headRef = newNode; // Set the new node as the head
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = nullptr; // Handle circular structure
        return;
    }
    if (head2 == nullptr) {
        //std::cout &lt;&lt; "Second list is empty. Returning a new node from the first list.\n";
        Node* newNode = new Node(head1-&gt;data); // Create a new node with the data of the first node of head1
        headRef = newNode; // Set the new node as the head
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = nullptr; // Handle circular structure
        return;
    }

    //std::cout &lt;&lt; "Both lists are non-empty. Merging...\n";

    do {
        Node* newNode;
        if (head1 && (head2 == nullptr || head1-&gt;data &lt;= head2-&gt;data)) {
            //std::cout &lt;&lt; "Adding node from List 1: " &lt;&lt; head1-&gt;data &lt;&lt; "\n";
            newNode = new Node(head1-&gt;data);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                //std::cout &lt;&lt; "End of List 1 reached.\n";
                head1 = nullptr;  // Stop merging this list
            }
        } else {
            //std::cout &lt;&lt; "Adding node from List 2: " &lt;&lt; head2-&gt;data &lt;&lt; "\n";
            newNode = new Node(head2-&gt;data);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                //std::cout &lt;&lt; "End of List 2 reached.\n";
                head2 = nullptr;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            //std::cout &lt;&lt; "New head node created: " &lt;&lt; tempHead-&gt;data &lt;&lt; "\n";
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != nullptr || head2 != nullptr);

    // Make the list circular
    last-&gt;next = tempHead;
    headRef = tempHead;
    //std::cout &lt;&lt; "Merge completed. Circular list created with head: " &lt;&lt; headRef-&gt;data &lt;&lt; "\n";
}


// Function to find the middle of a circular linked list
void middle(Node*& mid, Node* head) {
    if (head == nullptr || head-&gt;next == head) {  // Check if list is empty or contains one node
        mid = head;
        return;
    }

    Node* slow = head;
    Node* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    mid = slow;  // Assign the slow pointer to mid (middle node)
}

void sort(Node*& headRef) {
    // If the list is empty or contains a single node, no need to sort
    if (headRef == nullptr || headRef-&gt;next == headRef)
        return;

    Node* head = headRef;
    Node* mid = nullptr;

    // Find the middle node
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = head;  // Break circularity for first half
    Node* secondHalf = nextToMid;

    // Find the last node of the second half
    while (secondHalf-&gt;next != head)
        secondHalf = secondHalf-&gt;next;

    secondHalf-&gt;next = nextToMid;  // Break circularity for second half

    // Sort both halves recursively
    sort(head);
    sort(nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


int main() {
    Node* list = nullptr;  // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    std::cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    std::cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(list, 4, 2);

    std::cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    std::cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    std::cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(list);

    std::cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(list);

    std::cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(list, 2);

    std::cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);
	
	// 9. Check if the list is empty
    if (isEmpty(list)) {
        cout &lt;&lt; "The list is empty." &lt;&lt; endl;
    } else {
		cout &lt;&lt; "The list is not empty." &lt;&lt; endl;
	}
	
    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; std::endl;
    }

    // 11. Reverse the list
    reverse(list);

    std::cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // 12. Sort the list
    sort(list);

    std::cout &lt;&lt; "List after sorting: ";
    traverse(list);

    // 13. Get the size of the list
    std::cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; std::endl;

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        std::cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Index " &lt;&lt; index &lt;&lt; " is out of range." &lt;&lt; std::endl;
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    std::cout &lt;&lt; "List after setting value 10 at index 2: ";
    traverse(list);

    // 16. Clear the list
    clear(list);

    std::cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic circular singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class CircularLinkedList {

    // Node structure for a circular singly linked list
    static class Node {
        int data;
        Node next;

        // Constructor
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            newNode.next = newNode; // Make it circular
            return newNode;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.next = head;
        return newNode; // New head
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            newNode.next = newNode;
            return newNode;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.next = head;
        return head; // Head remains the same
    }
    
    // Function to insert a new node after a given previous node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be NULL.");
            return;
        }

        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }

    // Function to insert a new node before a given next node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (head == null) {
            System.out.println("The list cannot be empty.");
            return null;
        }

        if (nextNode == null) {
            System.out.println("The given next node cannot be NULL.");
            return head;
        }

        Node newNode = new Node(data);

        // If inserting before the head, update head reference
        if (head == nextNode) {
            Node temp = head;
            while (temp.next != head) {
                temp = temp.next;
            }

            temp.next = newNode;  // Update last node's next pointer
            newNode.next = head;
            return newNode; // New node becomes the head
        }

        // Find the node just before nextNode
        Node temp = head;
        while (temp.next != head && temp.next != nextNode) {
            temp = temp.next;
        }

        if (temp.next != nextNode) {
            System.out.println("The given next node is not found in the list.");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }
    
    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        if (position == 0) {
            return insertAtBeginning(head, data);
        }

        Node newNode = new Node(data);
        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp.next != head; i++) {
            temp = temp.next;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == head) {
            return null;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }

        temp.next = head.next;
        return head.next;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null || head.next == head) {
            return null;
        }

        Node temp = head;
        while (temp.next.next != head) {
            temp = temp.next;
        }
        temp.next = head;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            return null;
        }

        if (position == 0) {
            return deleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp.next != head; i++) {
            temp = temp.next;
        }

        if (temp.next == head) {
            return head;
        }

        temp.next = temp.next.next;
        return head;
    }

    // Traverse the list
    public static void traverse(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }

        Node temp = head;
        do {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        } while (temp != head);
        System.out.println("(head)");
    }
	
	// Check if the list is empty
	public static boolean isEmpty(Node head) {
		return head == null;
	}
	
    // Function to merge two sorted circular linked lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        Node dummy = new Node(0); // Temporary dummy node
        Node tail = dummy;
        Node first1 = head1, first2 = head2;

        do {
            Node newNode;
            if (head1 != null && (head2 == null || head1.data &lt;= head2.data)) {
                newNode = new Node(head1.data);
                head1 = head1.next;
                if (head1 == first1) head1 = null;
            } else {
                newNode = new Node(head2.data);
                head2 = head2.next;
                if (head2 == first2) head2 = null;
            }

            tail.next = newNode;
            tail = newNode;

        } while (head1 != null || head2 != null);

        // Make the merged list circular
        tail.next = dummy.next;
        return dummy.next;
    }

    // Function to find the middle node of a circular linked list
    public static Node middle(Node head) {
        if (head == null || head.next == head) return head;

        Node slow = head, fast = head;
        while (fast.next != head && fast.next.next != head) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    // Function to sort a circular linked list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == head) return head;

        Node mid = middle(head);
        Node secondHalf = mid.next;
        mid.next = head;  // Break circularity for the first half

        // Find last node of second half and break circularity
        Node temp = secondHalf;
        while (temp.next != head) temp = temp.next;
        temp.next = secondHalf;

        // Recursively sort both halves
        Node firstSorted = sort(head);
        Node secondSorted = sort(secondHalf);

        // Merge both halves
        return merge(firstSorted, secondSorted);
    }
    
    // Function to get an element at a specific index (0-based)
    public static int get(Node head, int index) {
        if (head == null) {
            System.out.println("List is empty");
            return -1;
        }

        Node temp = head;
        int count = 0;

        do {
            if (count == index)
                return temp.data;
            count++;
            temp = temp.next;
        } while (temp != head);

        System.out.println("Index out of range");
        return -1;
    }

    // Function to set an element at a specific index (0-based)
    public static void set(Node head, int index, int newValue) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }

        Node temp = head;
        int count = 0;

        do {
            if (count == index) {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        } while (temp != head);

        System.out.println("Index out of range");
    }

    // Function to search for an element in a circular linked list
    public static boolean search(Node head, int key) {
        if (head == null) return false;

        Node temp = head;
        do {
            if (temp.data == key)
                return true;
            temp = temp.next;
        } while (temp != head);

        return false;
    }

    // Function to reverse a circular linked list
    public static Node reverse(Node head) {
        if (head == null || head.next == head) return head;

        Node prev = null, current = head, next = null;
        Node tail = head;

        do {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        } while (current != head);

        head.next = prev; // Fix circular link
        return prev; // New head
    }
    
    // Get the size of the list
    public static int size(Node head) {
        if (head == null) return 0;

        int count = 0;
        Node temp = head;
        do {
            count++;
            temp = temp.next;
        } while (temp != head);
        return count;
    }

    // Clear the circular linked list
	public static void clear(Node head) {
		if (head == null) {
			System.out.println("List is already empty.");
			return null;
		}

		Node current = head;
		do {
			Node next = current.next; // Save the next node
			current.next = null;      // Break the link to the next node
			current = next;           // Move to the next node
		} while (current != head);    // Loop until we reach the head node again

		return null;  // Return null to indicate the list is empty
	}


    // Main method for testing
    public static void main(String[] args) {
        Node head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // 2. Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // 3. Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		
		// 4. Insert after a specific node
        insertAfterNode(head.next, 8);
        System.out.println("List after inserting 8 after second node: ");
        traverse(head);

        // 5. Insert before a specific node
        head = insertBeforeNode(head, head.next, 12);
        System.out.println("List after inserting 12 before second node: ");
        traverse(head);
		
        // 6. Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // 7. Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // 8. Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);
		
		// 9. Check if the list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}
	
        // 10. Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // 11. Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // 12. Get the size of the list
        System.out.println("Size of the list: " + size(head));
		
		// 13. Get element at a specific index
		int indexToGet = 2;
		int value = get(head, indexToGet);
		if (value != -1) {
			System.out.println("Element at index " + indexToGet + ": " + value);
		}

		// 14. Set value at a specific index
		int indexToSet = 1;
		int newValue = 25;
		System.out.println("Setting value at index " + indexToSet + " to " + newValue);
		set(head, indexToSet, newValue);
		
		System.out.println("Updated list after set operation:");
		traverse(head);
	
		// 15. Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
		traverse(head);
		
        // 16. Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic circular singly linked list implementation in C#:</p>
		
		<pre><code class="language-java hljs">using System;

public class CircularLinkedList
{
    // Node structure for circular singly linked list
    public class Node
    {
        public int Data;
        public Node Next;

        // Constructor to create a new node
        public Node(int data)
        {
            Data = data;
            Next = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            newNode.Next = newNode; // Circular link to itself if list is empty
            return newNode;
        }

        Node temp = head;
        // Traverse to the last node to point it to the new node
        while (temp.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = newNode;
        newNode.Next = head; // Link the new node to head
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            newNode.Next = newNode; // Circular link to itself if list is empty
            return newNode;
        }

        Node temp = head;
        // Traverse to the last node
        while (temp.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = newNode;
        newNode.Next = head; // Link the new node to head
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            return InsertAtBeginning(head, data);
        }

        Node temp = head;
        int count = 0;
        // Traverse to the position where new node should be inserted
        while (temp.Next != head && count &lt; position - 1)
        {
            temp = temp.Next;
            count++;
        }

        if (count != position - 1)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Insert after a given node
    public static void InsertAfterNode(Node prevNode, int data)
    {
        if (prevNode == null)
        {
            Console.WriteLine("The given previous node cannot be null");
            return;
        }

        Node newNode = new Node(data);
        newNode.Next = prevNode.Next;
        prevNode.Next = newNode;
    }

    // Insert before a given node
    public static Node InsertBeforeNode(Node head, Node nextNode, int data)
    {
        if (nextNode == null)
        {
            Console.WriteLine("The given next node cannot be null");
            return head;
        }

        if (head == nextNode)
        {
            return InsertAtBeginning(head, data);
        }

        Node temp = head;
        while (temp.Next != head && temp.Next != nextNode)
        {
            temp = temp.Next;
        }

        if (temp.Next == nextNode)
        {
            Node newNode = new Node(data);
            newNode.Next = nextNode;
            temp.Next = newNode;
        }
        else
        {
            Console.WriteLine("The given next node is not present in the list");
        }

        return head;
    }

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == head) // Only one node in the list
        {
            return null;
        }

        Node temp = head;
        // Traverse to the last node to point it to the second node
        while (temp.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = head.Next;
        return head.Next; // New head is the next node
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == head) // Only one node in the list
        {
            return null;
        }

        Node temp = head;
        while (temp.Next.Next != head)
        {
            temp = temp.Next;
        }

        temp.Next = head; // Last node points to the head again
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return DeleteAtBeginning(head);
        }

        Node temp = head;
        int count = 0;
        while (temp.Next != head && count &lt; position - 1)
        {
            temp = temp.Next;
            count++;
        }

        if (count != position - 1)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        temp.Next = temp.Next.Next;
        return head;
    }
	
	// Check if the list is empty
	public static bool IsEmpty(Node head)
	{
		return head == null;
	}
	
    // Traverse the circular list
    public static void Traverse(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty.");
            return;
        }

        Node temp = head;
        do
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        } while (temp != head);
        Console.WriteLine("(head)");
    }
    
    // Function to get an element at a specific index (0-based)
    public static int Get(Node head, int index)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return -1;
        }
    
        Node temp = head;
        int count = 0;
    
        do
        {
            if (count == index)
                return temp.Data;  // Return the data at the specified index
            count++;
            temp = temp.Next;
        } while (temp != head);
    
        Console.WriteLine("Index out of range");
        return -1;  // If index is out of bounds
    }
    
    // Function to set an element at a specific index (0-based)
    public static void Set(Node head, int index, int newValue)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return;
        }
    
        Node temp = head;
        int count = 0;
    
        do
        {
            if (count == index)
            {
                temp.Data = newValue;  // Set the new value at the specified index
                return;
            }
            count++;
            temp = temp.Next;
        } while (temp != head);
    
        Console.WriteLine("Index out of range");  // If index is out of bounds
    }

    // Search for an element in the circular list
    public static bool Search(Node head, int key)
    {
        if (head == null)
        {
            return false;
        }

        Node temp = head;
        do
        {
            if (temp.Data == key)
            {
                return true;
            }
            temp = temp.Next;
        } while (temp != head);

        return false;
    }

    // Reverse the circular linked list
    public static Node Reverse(Node head)
    {
        if (head == null || head.Next == head)
        {
            return head; // No reversal needed for empty or single-node list
        }

        Node prev = null;
        Node current = head;
        Node next = null;

        do
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        } while (current != head);

        head.Next = prev; // Circular link
        return prev; // New head
    }

    // Get the size of the circular list
    public static int Size(Node head)
    {
        if (head == null)
        {
            return 0;
        }

        int count = 0;
        Node temp = head;
        do
        {
            count++;
            temp = temp.Next;
        } while (temp != head);

        return count;
    }
    
    // Function to merge two sorted circular linked lists
    public static Node Merge(Node head1, Node head2)
    {
        if (head1 == null) return head2;
        if (head2 == null) return head1;
    
        Node dummy = new Node(0); // Temporary dummy node
        Node tail = dummy;
        Node first1 = head1, first2 = head2;
    
        do
        {
            Node newNode;
            if (head1 != null && (head2 == null || head1.Data &lt;= head2.Data))
            {
                newNode = new Node(head1.Data);
                head1 = head1.Next;
                if (head1 == first1) head1 = null;
            }
            else
            {
                newNode = new Node(head2.Data);
                head2 = head2.Next;
                if (head2 == first2) head2 = null;
            }
    
            tail.Next = newNode;
            tail = newNode;
    
        } while (head1 != null || head2 != null);
    
        // Make the merged list circular
        tail.Next = dummy.Next;
        return dummy.Next;
    }
    
    // Function to find the middle node of a circular linked list
    public static Node Middle(Node head)
    {
        if (head == null || head.Next == head) return head;
    
        Node slow = head, fast = head;
        while (fast.Next != head && fast.Next.Next != head)
        {
            fast = fast.Next.Next;
            slow = slow.Next;
        }
        return slow;
    }
    
    // Function to sort a circular linked list using merge sort
    public static Node Sort(Node head)
    {
        if (head == null || head.Next == head) return head;
    
        Node mid = Middle(head);
        Node secondHalf = mid.Next;
        mid.Next = head;  // Break circularity for the first half
    
        // Find last node of second half and break circularity
        Node temp = secondHalf;
        while (temp.Next != head) temp = temp.Next;
        temp.Next = secondHalf;
    
        // Recursively sort both halves
        Node firstSorted = Sort(head);
        Node secondSorted = Sort(secondHalf);
    
        // Merge both halves
        return Merge(firstSorted, secondSorted);
    }

    // Clear the circular linked list
	public static Node Clear(Node head)
	{
		if (head == null)
		{
			Console.WriteLine("List is already empty.");
			return null;
		}

		Node current = head;
		do
		{
			Node next = current.Next; // Save the next node
			current.Next = null;      // Break the link to the next node
			current = next;           // Move to the next node
		} while (current != head);    // Loop until we reach the head node again

		return null;  // Return null to indicate the list is empty
	}


    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning:");
        Traverse(head);

        // 2. Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end:");
        Traverse(head);

        // 3. Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2:");
        Traverse(head);

        // 4. Insert after a specific node
        InsertAfterNode(head.Next, 8);
        Console.WriteLine("List after inserting 8 after second node:");
        Traverse(head);

        // 5. Insert before a specific node
        head = InsertBeforeNode(head, head.Next, 12);
        Console.WriteLine("List after inserting 12 before second node:");
        Traverse(head);

        // 6. Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning:");
        Traverse(head);

        // 7. Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end:");
        Traverse(head);

        // 8. Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2:");
        Traverse(head);
		
		// 9. Check if the list is empty
		if (IsEmpty(head))
		{
			Console.WriteLine("The list is empty.");
		}
		else
		{
			Console.WriteLine("The list is not empty.");
		}

        // 10. Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine($"Element {key} found in the list");
        }
        else
        {
            Console.WriteLine($"Element {key} not found in the list");
        }

        // 11. Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing:");
        Traverse(head);

        // 12. Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));
		
		// 13. Get value at a specific index
		int indexToGet = 2;  // 0-based index
		int value = Get(head, indexToGet);
		Console.WriteLine($"Value at index {indexToGet}: {value}");

		// 14. Set a new value at a specific index
		int indexToSet = 2;  // 0-based index
		int newValue = 99;
		Set(head, indexToSet, newValue);

		Console.WriteLine($"List after setting index {indexToSet} to {newValue}:");
		Traverse(head);
	
        // 15. Sort the list
        head = Sort(head);
        Console.WriteLine("Sorted list:");
        Traverse(head);

        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing:");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Circular Singly Linked List Implementation</h3>
		
		<p>Here is the Generic circular singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for circular singly linked list
typedef struct Node {
    StackElement element;
    struct Node* next;     // Pointer to the next node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = newNode; // In circular list, the node points to itself initially
    return newNode;
}

// Function to insert a node at the beginning of the list (in a circular way)
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);

    if (*head == NULL) {
        *head = newNode;
    } else {
        Node* temp = *head;
        // Find the last node (which points to the head)
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;  // Set the last node's next to new node
        newNode-&gt;next = *head; // New node points to head
        *head = newNode;       // Update head to the new node
    }
}

// Function to insert a node at the end of the list (in a circular way)
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);

    if (*head == NULL) {
        *head = newNode;
    } else {
        Node* temp = *head;
        // Find the last node
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;  // Set the last node's next to new node
        newNode-&gt;next = *head; // New node points to head
    }
}

// Function to insert a node after a given previous node
void insertAfterNode(Node* prevNode, StackElement element) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // Insert the new node after prevNode
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    // Check if the head is NULL (list is empty)
    if (*head == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    // Check if the nextNode is NULL
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the nextNode is the head node, handle the insertion at beginning
    if (*head == nextNode) {
        // Insert the new node before the head node
        Node* temp = *head;
        while (temp-&gt;next != *head) { // Find the last node
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    // If temp is NULL, then nextNode is not found in the list
    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position in a circular singly linked list
void insertAtPosition(Node** head, StackElement element, int position) {
    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the list is empty and position is 0, insert as the only node
    if (*head == NULL) {
        if (position == 0) {
            *head = newNode;
            newNode-&gt;next = *head; // Make it circular
        } else {
            printf("Position out of bounds\n");
        }
        return;
    }

    // If position is at the beginning (position 0)
    if (position == 0) {
        Node* temp = *head;
        // Find the last node (that points to the head)
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        // Insert the new node at the beginning
        temp-&gt;next = newNode;
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    // Traverse the list to find the correct position
    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp-&gt;next != *head; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes in the list
    if (temp-&gt;next == *head && position &gt; 0) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    // Insert the new node at the specified position
    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}


// Function to delete the first node
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (*head == (*head)-&gt;next) {
        free(*head);
        *head = NULL;
    } else {
        Node* temp = *head;
        // Find the last node
        while (temp-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = (*head)-&gt;next; // Last node points to the second node
        free(*head);
        *head = temp-&gt;next;
    }
}

// Function to delete the last node
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (*head == (*head)-&gt;next) {
        free(*head);
        *head = NULL;
    } else {
        Node* temp = *head;
        // Traverse to the second-last node
        while (temp-&gt;next-&gt;next != *head) {
            temp = temp-&gt;next;
        }
        free(temp-&gt;next);       // Free the last node
        temp-&gt;next = *head;     // Set the second-last node's next to head
    }
}

// Function to delete a node at a specific position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    if (position == 0) {
        deleteAtBeginning(head);
        return;
    }

    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == *head) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next;
    free(nodeToDelete);
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = head;
    do {
        printf("%s -&gt; ", temp-&gt;element.toString);
        temp = temp-&gt;next;
    } while (temp != head);
    printf("HEAD\n"); // To signify it's a circular list
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    if (head == NULL) {
        return 0;
    }

    Node* temp = head;
    do {
        if (strcmp(temp-&gt;element.toString, keyElement.toString) == 0) {
            return 1; // Found
        }
        temp = temp-&gt;next;
    } while (temp != head);

    return 0; // Not found
}

// Function to reverse the circular linked list (O(n) time complexity)
void reverse(Node** head) {
    if (*head == NULL || (*head)-&gt;next == *head) {
        return;
    }

    Node *prev = NULL, *current = *head, *next = NULL;
    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != *head);

    (*head)-&gt;next = prev;
    *head = prev;
}

// Function to get the size of the list
int size(Node* head) {
    int size = 0;
    if (head == NULL) return size;

    Node* temp = head;
    do {
        size++;
        temp = temp-&gt;next;
    } while (temp != head);

    return size;
}
// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}
// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;

    // If the list is empty
    if (head == NULL) {
        StackElement emptyElement = {NULL, ""};
        return emptyElement; // Return empty element if the list is empty
    }

    // Traverse the list
    do {
        if (count == index) {
            return temp-&gt;element;  // Found the element at the specified index
        }
        count++;
        temp = temp-&gt;next;
    } while (temp != head);  // Stop when we loop back to the head node

    // If the index is out of range
    StackElement emptyElement = {NULL, ""};
    return emptyElement;
}
// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // If the list is empty
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }

    // Traverse the list
    do {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;  // Exit after updating
        }
        count++;
        current = current-&gt;next;
    } while (current != head);  // Stop when we loop back to the head node

    printf("Index out of range\n");  // Handle case where index exceeds list length
}
// Function to find the middle of a circular singly linked list
void middle(Node** mid, Node* head) {
    if (head == NULL || head-&gt;next == head) {
        *mid = head;
        return;
    }

    Node* slow = head;
    Node* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    *mid = slow;
}

// Function to merge two circular linked lists
void merge(Node** headRef, Node* head1, Node* head2) {
    Node* tempHead = NULL, *last = NULL;
    Node* first1 = head1, *first2 = head2;
    
    printf("Starting merge...\n");

    if (head1 == NULL) {
        printf("First list is empty. Returning a new node from the second list.\n");
        Node* newNode = createNode(head2-&gt;element); // Create a new node with the data of the first node of head2
        *headRef = newNode; // Set the new node as the head
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = NULL; // Handle circular structure
        return;
    }
    if (head2 == NULL) {
        printf("Second list is empty. Returning a new node from the first list.\n");
        Node* newNode = createNode(head1-&gt;element); // Create a new node with the data of the first node of head1
        *headRef = newNode; // Set the new node as the head
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = NULL; // Handle circular structure
        return;
    }

    printf("Both lists are non-empty. Merging...\n");

    do {
        Node* newNode;
        if (head1 && (head2 == NULL || strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt;= 0)) {
            printf("Adding node from List 1: %s\n", head1-&gt;element.toString);
            newNode = createNode(head1-&gt;element);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                printf("End of List 1 reached.\n");
                head1 = NULL;  // Stop merging this list
            }
        } else {
            printf("Adding node from List 2: %s\n", head2-&gt;element.toString);
            newNode = createNode(head2-&gt;element);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                printf("End of List 2 reached.\n");
                head2 = NULL;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            printf("New head node created: %s\n", tempHead-&gt;element.toString);
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != NULL || head2 != NULL);

    // Make the list circular
    last-&gt;next = tempHead;
    *headRef = tempHead;
    printf("Merge completed. Circular list created with head: %s\n", (*headRef)-&gt;element.toString);
}

// Function to sort a circular singly linked list (Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == *headRef)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = head; // Break circularity for first half
    Node* secondHalf = nextToMid;

    // Find last node of second half
    while (secondHalf-&gt;next != head)
        secondHalf = secondHalf-&gt;next;
    
    secondHalf-&gt;next = nextToMid; // Break circularity for second half

    // Sort both halves
    sort(&head);
    sort(&nextToMid);

    // Merge sorted halves
    merge(headRef, head, nextToMid);
}
// Function to clear the entire linked list and free memory
void clear(Node** head) {
    if (*head == NULL) return;

    Node* current = *head;
    Node* next = NULL;
    do {
        next = current-&gt;next;
        free(current);
        current = next;
    } while (current != *head);

    *head = NULL;
}
struct Person {
    char name[20];
    int age;
};
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements at the beginning**
    insertAtBeginning(&personList, personElement1);
    insertAtBeginning(&personList, personElement2);
	
	// 2. Insert elements at the end
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 3. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 4. **Insert before a node**
    insertBeforeNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 5. **Insert after a node**
    insertAfterNode(personList-&gt;next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 6. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 7. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 8. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 9. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 10. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 11. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 12. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 13. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 14. **Sort the linked list**
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 15. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 16. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic circular singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for circular singly linked list template
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (!head) {
        head = newNode;
        newNode-&gt;next = head;
    } else {
        Node&lt;T&gt;* temp = head;
        while (temp-&gt;next != head)
            temp = temp-&gt;next;
        temp-&gt;next = newNode;
        newNode-&gt;next = head;
        head = newNode;
    }
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (!head) {
        head = newNode;
        newNode-&gt;next = head;
    } else {
        Node&lt;T&gt;* temp = head;
        while (temp-&gt;next != head)
            temp = temp-&gt;next;
        temp-&gt;next = newNode;
        newNode-&gt;next = head;
    }
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }
    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    if (head == nextNode) { // Insert before head
        Node&lt;T&gt;* temp = head;
        while (temp-&gt;next != head) {
            temp = temp-&gt;next;
        }
        temp-&gt;next = newNode;
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    do {
        if (temp-&gt;next == nextNode) {
            newNode-&gt;next = temp-&gt;next;
            temp-&gt;next = newNode;
            return;
        }
        temp = temp-&gt;next;
    } while (temp != head);
    
    cout &lt;&lt; "The given next node is not found in the list\n";
    delete newNode;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        if (head == nullptr) {
            head = newNode;
            newNode-&gt;next = head; // Circular link
        } else {
            Node&lt;T&gt;* temp = head;
            while (temp-&gt;next != head) {
                temp = temp-&gt;next;
            }
            temp-&gt;next = newNode;
            newNode-&gt;next = head;
            head = newNode;
        }
        return;
    }
    
    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1; i++) {
        temp = temp-&gt;next;
        if (temp == head) {
            cout &lt;&lt; "Position out of bounds\n";
            delete newNode;
            return;
        }
    }
    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (!head) return;
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node&lt;T&gt;* temp = head;
    Node&lt;T&gt;* last = head;
    while (last-&gt;next != head)
        last = last-&gt;next;
    head = head-&gt;next;
    last-&gt;next = head;
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (!head) return;
    if (head-&gt;next == head) {
        delete head;
        head = nullptr;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next-&gt;next != head)
        temp = temp-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = head;
}

// Delete at a specific position in a Circular Singly Linked List
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    Node&lt;T&gt;* temp = head;
    // If deleting the head node
    if (position == 0) {
        // If the list has only one node
        if (head-&gt;next == head) {
            delete head;
            head = nullptr;
            return;
        }

        // Find the last node to update its next pointer
        Node&lt;T&gt;* last = head;
        while (last-&gt;next != head) {
            last = last-&gt;next;
        }

        last-&gt;next = head-&gt;next;
        Node&lt;T&gt;* toDelete = head;
        head = head-&gt;next;
        delete toDelete;
        return;
    }

    // Traverse to the node before the one to be deleted
    Node&lt;T&gt;* prev = head;
    for (int i = 0; i &lt; position - 1 && prev-&gt;next != head; i++) {
        prev = prev-&gt;next;
    }

    if (prev-&gt;next == head) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    // Delete the node
    Node&lt;T&gt;* toDelete = prev-&gt;next;
    prev-&gt;next = toDelete-&gt;next;
    delete toDelete;
}

// check if the list is empty
template &lt;typename T&gt;
bool isEmpty(Node&lt;T&gt;* head) {
    return head == nullptr;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    if (!head) {
        cout &lt;&lt; "NULL\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    do {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    } while (temp != head);
    cout &lt;&lt; "(head)\n";
}

// Search for an element in a Circular Singly Linked List
template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    if (head == nullptr) return false; // Empty list

    Node&lt;T&gt;* temp = head;
    do {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    } while (temp != head); // Loop until we reach the head again

    return false;
}

// Reverse a Circular Singly Linked List
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    if (head == nullptr || head-&gt;next == head) return; // Empty list or single node

    Node&lt;T&gt;* prev = nullptr;
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* next = nullptr;
    Node&lt;T&gt;* tail = head; // Keep track of the last node

    do {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    } while (current != head);

    // Fix head and tail pointers
    head-&gt;next = prev;  // Make original head's next point to new head
    head = prev;        // Update head to new first element
}

// Get the size of a Circular Singly Linked List
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    if (head == nullptr) return 0; // Empty list

    int count = 0;
    Node&lt;T&gt;* temp = head;
    do {
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    return count;
}

// Get an element at a specific index in a Circular Singly Linked List
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    if (head == nullptr) throw out_of_range("Index out of range");

    Node&lt;T&gt;* temp = head;
    int count = 0;

    do {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    throw out_of_range("Index out of range");
}


// Set an element at a specific index in a Circular Singly Linked List
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    if (head == nullptr) throw out_of_range("Index out of range");

    Node&lt;T&gt;* temp = head;
    int count = 0;

    do {
        if (count == index) {
            temp-&gt;data = element;
            return;
        }
        count++;
        temp = temp-&gt;next;
    } while (temp != head);

    throw out_of_range("Index out of range");
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    if (!head) return;
    Node&lt;T&gt;* temp = head;
    Node&lt;T&gt;* nextNode;
    do {
        nextNode = temp-&gt;next;
        delete temp;
        temp = nextNode;
    } while (temp != head);
    head = nullptr;
}

// Function to merge two sorted circular linked lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    Node&lt;T&gt;* tempHead = nullptr, *last = nullptr;
    Node&lt;T&gt;* first1 = head1, *first2 = head2;

    //std::cout &lt;&lt; "Starting merge...\n";

    if (head1 == nullptr) {
        //std::cout &lt;&lt; "First list is empty. Returning a new node from the second list.\n";
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(head2-&gt;data);
        headRef = newNode;
        head2 = head2-&gt;next;
        if (head2 == first2) head2 = nullptr;
        return;
    }
    if (head2 == nullptr) {
        //std::cout &lt;&lt; "Second list is empty. Returning a new node from the first list.\n";
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(head1-&gt;data);
        headRef = newNode;
        head1 = head1-&gt;next;
        if (head1 == first1) head1 = nullptr;
        return;
    }

    //std::cout &lt;&lt; "Both lists are non-empty. Merging...\n";

    do {
        Node&lt;T&gt;* newNode;
        if (head1 && (head2 == nullptr || head1-&gt;data &lt;= head2-&gt;data)) {
            //std::cout &lt;&lt; "Adding node from List 1: " &lt;&lt; (head1-&gt;data).toString() &lt;&lt; "\n";
            newNode = new Node&lt;T&gt;(head1-&gt;data);
            head1 = head1-&gt;next;
            if (head1 == first1) {
                head1 = nullptr;
            }
        } else {
            //std::cout &lt;&lt; "Adding node from List 2: " &lt;&lt; (head2-&gt;data).toString() &lt;&lt; "\n";
            newNode = new Node&lt;T&gt;(head2-&gt;data);
            head2 = head2-&gt;next;
            if (head2 == first2) {
                head2 = nullptr;
            }
        }

        if (!tempHead) {
            tempHead = newNode;
            //std::cout &lt;&lt; "New head node created: " &lt;&lt; (tempHead-&gt;data).toString() &lt;&lt; "\n";
        } else {
            last-&gt;next = newNode;
        }
        last = newNode;
    } while (head1 != nullptr || head2 != nullptr);

    // Make the list circular
    last-&gt;next = tempHead;
    headRef = tempHead;
    //std::cout &lt;&lt; "Merge completed. Circular list created with head: " &lt;&lt; (headRef-&gt;data).toString() &lt;&lt; "\n";
}
// Function to find the middle of a circular linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;*& mid, Node&lt;T&gt;* head) {
    if (head == nullptr || head-&gt;next == head) {  // Check if list is empty or contains one node
        mid = head;
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head;

    // Move fast two steps and slow one step
    while (fast-&gt;next != head && fast-&gt;next-&gt;next != head) {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }

    mid = slow;  // Assign the slow pointer to mid (middle node)
}

template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    // If the list is empty or contains a single node, no need to sort
    if (headRef == nullptr || headRef-&gt;next == headRef) {
        //std::cout &lt;&lt; "List is empty or has only one node. No sorting needed.\n";
        return;
    }

    //std::cout &lt;&lt; "Starting sort...\n";

    Node&lt;T&gt;* head = headRef;
    Node&lt;T&gt;* mid = nullptr;

    // Find the middle node
    //std::cout &lt;&lt; "Finding middle node...\n";
    middle(mid, head);
    //std::cout &lt;&lt; "Middle node found: " &lt;&lt; mid-&gt;data.toString() &lt;&lt; "\n";

    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = head;  // Break circularity for first half
    Node&lt;T&gt;* secondHalf = nextToMid;

    // Find the last node of the second half
    Node&lt;T&gt;* last = secondHalf;
    while (last-&gt;next != head)
        last = last-&gt;next;

    last-&gt;next = nextToMid;  // Break circularity for second half

    //std::cout &lt;&lt; "Splitting list into two halves:\n";
    //std::cout &lt;&lt; "First half starts with: " &lt;&lt; head-&gt;data.toString() &lt;&lt; "\n";
    //std::cout &lt;&lt; "Second half starts with: " &lt;&lt; secondHalf-&gt;data.toString() &lt;&lt; "\n";

    // Sort both halves recursively
    //std::cout &lt;&lt; "Sorting first half...\n";
    sort(head);
    //std::cout &lt;&lt; "Sorting second half...\n";
    sort(nextToMid);

    // Merge the sorted halves
    //std::cout &lt;&lt; "Merging sorted halves...\n";
    merge(headRef, head, nextToMid);
    //std::cout &lt;&lt; "Merge completed. Circular list created with head: " &lt;&lt; headRef-&gt;data.toString() &lt;&lt; "\n";
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;=(const Person& other) const {
        if (name == other.name) {
            return age &lt;= other.age;  // If names are the same, sort by age
        }
        return name &lt;= other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};
// Main function for testing
int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // 1. Insert elements at the beginning
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
	
	// 2. Insert elements at the beginning
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // 3. Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // 4. Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    Person george("George", 32);
    insertBeforeNode(head, secondNode, george);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // 5. Insert after a node (insert after the second node)
    Person joyce("Joyce", 27);
    insertAfterNode(secondNode, joyce);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // 6. Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // 7. Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);
	
	// 8. Delete at a specific position
	deleteAtPosition(head, 2);
    cout &lt;&lt; "\nList after deleting node at position 2:\n";
    traverse(head);
	
    // 9. Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // 10. Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;
	
	// 11. Check if list is empty
	if (isEmpty(head)) {
		cout &lt;&lt; "The linked list is empty.\n";
	} else {
		cout &lt;&lt; "The linked list is not empty.\n";
	}

    // 12. Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 13. Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 14. Sort the linked list (by name first, then by age)
    sort(head);
    cout &lt;&lt; "\nList after sorting:" &lt;&lt; endl;
    traverse(head);
	
	// 15. Reverse the list
    reverse(head);

    cout &lt;&lt; "\nReversed List:" &lt;&lt; endl;
    traverse(head);


	// 16. Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
	
    return 0;
}</code></pre>
		
		<p>Here is the Generic circular singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class CircularLinkedList&lt;T&gt; {

    // Node structure for circular singly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; tail, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (tail == null) {
            newNode.next = newNode; // Point to itself
            return newNode;
        }
        newNode.next = tail.next;
        tail.next = newNode;
        return tail;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; tail, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (tail == null) {
            newNode.next = newNode;
            return newNode;
        }
        newNode.next = tail.next;
        tail.next = newNode;
        return newNode; // New tail
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; tail, T data, int position) {
        if (tail == null || position == 0) {
            return insertAtBeginning(tail, data);
        }

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        Node&lt;T&gt; temp = tail.next;
        for (int i = 0; i &lt; position - 1 && temp != tail; i++) {
            temp = temp.next;
        }
        newNode.next = temp.next;
        temp.next = newNode;

        if (temp == tail) {
            return newNode; // New tail
        }
        return tail;
    }

    // Function to insert a new node after a given previous node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; prevNode, T data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be NULL.");
            return;
        }

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }

    // Function to insert a new node before a given next node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; nextNode, T data) {
        if (head == null) {
            System.out.println("The list cannot be empty.");
            return null;
        }

        if (nextNode == null) {
            System.out.println("The given next node cannot be NULL.");
            return head;
        }

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);

        // If inserting before the head, update head reference
        if (head == nextNode) {
            Node&lt;T&gt; temp = head;
            while (temp.next != head) {
                temp = temp.next;
            }

            temp.next = newNode;  // Update last node's next pointer
            newNode.next = head;
            return newNode; // New node becomes the head
        }

        // Find the node just before nextNode
        Node&lt;T&gt; temp = head;
        while (temp.next != head && temp.next != nextNode) {
            temp = temp.next;
        }

        if (temp.next != nextNode) {
            System.out.println("The given next node is not found in the list.");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; tail) {
        if (tail == null) {
            System.out.println("List is empty");
            return null;
        }
        if (tail.next == tail) { // Single node case
            return null;
        }
        tail.next = tail.next.next;
        return tail;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; tail) {
        if (tail == null) {
            System.out.println("List is empty");
            return null;
        }
        if (tail.next == tail) { // Single node case
            return null;
        }

        Node&lt;T&gt; temp = tail.next;
        while (temp.next != tail) {
            temp = temp.next;
        }
        temp.next = tail.next; // Skip tail node
        return temp; // New tail
    }
    
    // Delete at a specific position (Generic)
    public static &lt;T&gt; Node&lt;T&gt; deleteAtPosition(Node&lt;T&gt; tail, int position) {
        if (tail == null) {
            return null;
        }
    
        if (position == 0) {
            return deleteAtBeginning(tail);
        }
    
        Node&lt;T&gt; temp = tail.next;
        for (int i = 0; i &lt; position - 1 && temp.next != tail.next; i++) {
            temp = temp.next;
        }
    
        if (temp.next == tail.next) {
            return tail; // Position out of bounds, return unchanged tail
        }
    
        // If deleting the tail node, update tail reference
        if (temp.next == tail) {
            tail = temp;
        }
    
        temp.next = temp.next.next;
        return tail;
    }
    
    // Function to get an element at a specific index (0-based)
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
    
        Node&lt;T&gt; temp = head;
        int count = 0;
    
        do {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        } while (temp != head);
    
        System.out.println("Index out of range");
        return null;
    }
    
    // Function to set an element at a specific index (0-based)
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }
    
        Node&lt;T&gt; temp = head;
        int count = 0;
    
        do {
            if (count == index) {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        } while (temp != head);
    
        System.out.println("Index out of range");
    }
	
	// check if the list is empty
	public static &lt;T&gt; boolean isEmpty(Node&lt;T&gt; head) {
		return head == null;
	}
	
    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; tail, T key) {
        if (tail == null) return false;

        Node&lt;T&gt; temp = tail.next;
        do {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        } while (temp != tail.next);

        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; tail) {
        if (tail == null) return 0;

        int count = 0;
        Node&lt;T&gt; temp = tail.next;
        do {
            count++;
            temp = temp.next;
        } while (temp != tail.next);
        return count;
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; tail) {
        if (tail == null) {
            System.out.println("NULL");
            return;
        }

        Node&lt;T&gt; temp = tail.next;
        do {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        } while (temp != tail.next);
        System.out.println("(back to head)");
    }
    
	public static &lt;T&gt; Node&lt;T&gt; reverse(Node&lt;T&gt; head) {
		if (head == null || head.next == head)
			return head; // Empty list or single node remains the same

		Node&lt;T&gt; prev = null;
		Node&lt;T&gt; current = head;
		Node&lt;T&gt; next = null;
		Node&lt;T&gt; last = head;

		// Find the last node
		while (last.next != head)
			last = last.next;

		do {
			next = current.next; // Store next node
			current.next = prev; // Reverse pointer
			prev = current;      // Move prev forward
			current = next;      // Move current forward
		} while (current != head);

		// Adjust pointers to maintain circular nature
		head.next = prev;  // Original head now points to the new last node
		last.next = prev;  // Last node points to the new head
		return prev;       // New head of the reversed circular list
	}

    // Function to find the middle node of a circular linked list
	public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
		if (head == null || head.next == head) return head;

		Node&lt;T&gt; slow = head, fast = head;
		while (fast.next != head && fast.next.next != head) {
			fast = fast.next.next;
			slow = slow.next;
		}
		return slow;
	}

	// Function to sort a circular linked list using merge sort (requires Comparable&lt;T&gt;)
	public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
		if (head == null || head.next == head) return head;

		Node&lt;T&gt; mid = middle(head);
		Node&lt;T&gt; secondHalf = mid.next;
		mid.next = head;  // Break circularity for the first half

		// Find last node of second half and break circularity
		Node&lt;T&gt; temp = secondHalf;
		while (temp.next != head) temp = temp.next;
		temp.next = secondHalf;

		// Recursively sort both halves
		Node&lt;T&gt; firstSorted = sort(head);
		Node&lt;T&gt; secondSorted = sort(secondHalf);

		// Merge both halves
		return merge(firstSorted, secondSorted);
	}

	public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; head1, Node&lt;T&gt; head2) {
		if (head1 == null) return head2;
		if (head2 == null) return head1;

		Node&lt;T&gt; tempHead = null, last = null;
		Node&lt;T&gt; first1 = head1, first2 = head2;

		do {
			Node&lt;T&gt; newNode;
			if (head1 != null && (head2 == null || head1.data.compareTo(head2.data) &lt;= 0)) {
				newNode = new Node&lt;&gt;(head1.data);
				head1 = head1.next;
				if (head1 == first1) head1 = null;
			} else {
				newNode = new Node&lt;&gt;(head2.data);
				head2 = head2.next;
				if (head2 == first2) head2 = null;
			}

			if (tempHead == null) {
				tempHead = newNode;
			} else {
				last.next = newNode;
			}
			last = newNode;
		} while (head1 != null || head2 != null);

		// Make the list circular
		last.next = tempHead;
		return tempHead;
	}


	// Clear the list
	public static &lt;T&gt; Node&lt;T&gt; clear(Node&lt;T&gt; head) {
		if (head == null) return null;  // If the list is already empty, return null
    
		Node&lt;T&gt; current = head;
		do {
			Node&lt;T&gt; next = current.next; // Save reference to next node
			current.next = null;            // Break the link to the next node
			current = next;                   // Move to the next node
		} while (current != head);            // Stop when we've looped back to the head
		
		return null;  // Return null to indicate the list is empty
	}

    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }

        @Override
        public int compareTo(Person other) {
            // Compare by name first, then by age
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }

    // Main method for testing
    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
		
		// 2. Insert elements at the end
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // 5. Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // 6. Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // 7. Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);
		
		// 8. Delete at a specific position
		head = deleteAtPosition(head, 2);
		System.out.println("\nList after deleting node at position 2:");
		traverse(head);

        // 9. Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // 10. Get size of the list
        System.out.println("\nSize of the list: " + size(head));
		
		// 11. Check if list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}


        // 12. Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 13. Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 14. Sort the linked list (by name first, then by age)
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
		
		// 15. Reverse the list
		head = reverse(head);

		System.out.println("\nList after reversing:");
		traverse(head);

		// 16. Clear the list
        head = clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
}</code></pre>
		
		<p>Here is the Generic circular singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;

    public Node(T data)
    {
        Data = data;
        Next = null;
    }
}

class Program
{
    // Insert at beginning
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null)
        {
            newNode.Next = newNode; // Point to itself in a circular list
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        while (temp.Next != head) temp = temp.Next; // Find the last node
        temp.Next = newNode;
        newNode.Next = head;
        return newNode;
    }

    // Insert at end
    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null)
        {
            newNode.Next = newNode;
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        while (temp.Next != head) temp = temp.Next; // Find the last node
        temp.Next = newNode;
        newNode.Next = head;
        return head;
    }

    // Insert at position
    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        if (position == 0) return InsertAtBeginning(head, data);
        
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp.Next != head; i++) temp = temp.Next;

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }
    
    // Insert before node
    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null || targetNode == null) return head;
        if (head == targetNode) return InsertAtBeginning(head, data);
    
        Node&lt;T&gt; temp = head;
        do
        {
            if (temp.Next == targetNode)
            {
                Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = targetNode };
                temp.Next = newNode;
                return head;
            }
            temp = temp.Next;
        } while (temp != head);
    
        return head; // Target node not found
    }
    
    // Insert after node
    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
    
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next };
        node.Next = newNode;
    }


    // Delete at beginning
    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        if (head.Next == head) return null; // Only one node

        Node&lt;T&gt; temp = head;
        while (temp.Next != head) temp = temp.Next; // Find last node
        temp.Next = head.Next;
        return head.Next;
    }

    // Delete at end
    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        if (head.Next == head) return null; // Only one node

        Node&lt;T&gt; temp = head;
        while (temp.Next.Next != head) temp = temp.Next; // Find second last node
        temp.Next = head;
        return head;
    }
    
    // Delete at a specific position
    static Node&lt;T&gt; DeleteAtPosition&lt;T&gt;(Node&lt;T&gt; head, int position)
    {
        if (head == null) return null; // Empty list
    
        Node&lt;T&gt; temp = head, prev = null;
    
        // If deleting the head node
        if (position == 0)
        {
            if (head.Next == head) // Only one node in the list
                return null;
    
            // Find the last node to update its `Next` pointer
            while (temp.Next != head)
                temp = temp.Next;
    
            temp.Next = head.Next; // Point last node to the new head
            return head.Next;
        }
    
        // Traverse to the position
        int count = 0;
        do
        {
            prev = temp;
            temp = temp.Next;
            count++;
        } while (temp != head && count &lt; position);
    
        // If position is out of bounds
        if (count != position)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }
    
        prev.Next = temp.Next; // Remove node by updating pointer
        return head;
    }

    // Search for an element in a circular singly linked list
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        if (head == null) return false; // Handle case of empty list
    
        Node&lt;T&gt; temp = head;
        do
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        return false;
    }
    
    // Get size of a circular singly linked list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return 0; // Handle case of empty list
    
        int count = 0;
        Node&lt;T&gt; temp = head;
        do
        {
            count++;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        return count;
    }

    // Check if the circular singly linked list is empty
    static bool IsEmpty&lt;T&gt;(Node&lt;T&gt; head)
    {
        return head == null;
    }

    // Get an element at a specific index in a circular singly linked list
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        if (head == null) throw new Exception("List is empty");
    
        int count = 0;
        Node&lt;T&gt; temp = head;
        do
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        throw new Exception("Index out of range");
    }
    
    // Set (modify) an element at a specific index in a circular singly linked list
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        if (head == null) throw new Exception("List is empty");
    
        int count = 0;
        Node&lt;T&gt; temp = head;
        do
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        } while (temp != head); // Stop when we've looped back to the head
    
        throw new Exception("Index out of range");
    }


    // Traverse the circular list
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty.");
            return;
        }

        Node&lt;T&gt; temp = head;
        do
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        } while (temp != head);

        Console.WriteLine("(back to head)");
    }
    
    // Reverse a circular singly linked list
    static Node&lt;T&gt; Reverse&lt;T&gt;(Node&lt;T&gt; head)
	{
		if (head == null || head.Next == head) return head; // Handle empty or single-element list
		
		Node&lt;T&gt; prev = null;
		Node&lt;T&gt; current = head;
		Node&lt;T&gt; next = null;
		
		// Traverse the list and reverse the links
		do
		{
			next = current.Next; // Save the next node
			current.Next = prev; // Reverse the current node's link
			prev = current;      // Move prev to the current node
			current = next;      // Move to the next node
		} while (current != head); // Stop when we've looped back to the head
		
		// After the loop, `prev` is pointing to the new head
		head = prev; // Update the head reference to the new first node
		
		// The last node's `Next` should point to the new head
		current.Next = head; // The previous tail should point to the new head
		
		return head; // Return the new head
	}
    
    public static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; head1, Node&lt;T&gt; head2) where T : IComparable&lt;T&gt;
    {
        if (head1 == null) return head2;
        if (head2 == null) return head1;
    
        Node&lt;T&gt; dummy = new Node&lt;T&gt;(default(T)); // Temporary dummy node
        Node&lt;T&gt; tail = dummy;
        Node&lt;T&gt; first1 = head1, first2 = head2;
    
        do
        {
            Node&lt;T&gt; newNode;
            if (head1 != null && (head2 == null || head1.Data.CompareTo(head2.Data) &lt;= 0))
            {
                newNode = new Node&lt;T&gt;(head1.Data);
                head1 = head1.Next;
                if (head1 == first1) head1 = null;
            }
            else
            {
                newNode = new Node&lt;T&gt;(head2.Data);
                head2 = head2.Next;
                if (head2 == first2) head2 = null;
            }
    
            tail.Next = newNode;
            tail = newNode;
    
        } while (head1 != null || head2 != null);
    
        // Make the merged list circular
        tail.Next = dummy.Next;
        return dummy.Next;
    }

    
    public static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == head) return head;
    
        Node&lt;T&gt; slow = head, fast = head;
        while (fast.Next != head && fast.Next.Next != head)
        {
            fast = fast.Next.Next;
            slow = slow.Next;
        }
        return slow;
    }

    public static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == head) return head;
    
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; secondHalf = mid.Next;
        mid.Next = head;  // Break circularity for the first half
    
        // Find last node of second half and break circularity
        Node&lt;T&gt; temp = secondHalf;
        while (temp.Next != head) temp = temp.Next;
        temp.Next = secondHalf;
    
        // Recursively sort both halves
        Node&lt;T&gt; firstSorted = Sort(head);
        Node&lt;T&gt; secondSorted = Sort(secondHalf);
    
        // Merge both halves
        return Merge(firstSorted, secondSorted);
    }
    
    public static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;  // If the list is already empty, return null
        
        Node&lt;T&gt; current = head;
        do
        {
            Node&lt;T&gt; next = current.Next; // Save reference to next node
            current.Next = null;         // Break the link to the next node
            current = next;              // Move to the next node
        } while (current != head);       // Stop when we've looped back to the head
        
        return null;  // Return null to indicate the list is empty
    }



    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);
        
        // Initialize the linked list
        Node&lt;Person&gt; head = null;
        
        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        
        // 2. Insert elements at the end
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);
        
        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);
        
        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);
        
        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        Person jack = new Person("Jack", 29);
        head = InsertBeforeNode(head, secondNode, jack);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);
        
        // 5. Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);
        
        // 6. Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);
        
        // 7. Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);
        
        // 8. Delete node at position 2
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("\nList after deleting at position 2:");
        Traverse(head);

        // 9. Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));
        
        // 10. Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));
        
        // 11. Check if the list is empty
        if (IsEmpty(head))
        {
            Console.WriteLine("The list is empty.");
        }
        else
        {
            Console.WriteLine("The list is not empty.");
        }
    
        // 12. Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 13. Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 14. Sort the linked list (by name first, then by age)
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // 15. Reverse the list
        head = Reverse(head);
    
        Console.WriteLine("\nList after reversing:");
        Traverse(head);
    
        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);

    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";
}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/circular-singly-linked-list" class="tag">circular singly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2025/02/04/circular-singly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2025" /><category term="month-02" /><category term="day-04" /><category term="data structure" /><category term="linked list" /><category term="circular singly linked list" /><summary type="html"><![CDATA[A Circular Singly Linked List is a type of linked list where each node points to the next node, and the last node links back to the first, forming a continuous loop. This structure allows efficient insertion, deletion, and traversal without a null reference at the end. It is commonly used in scenarios requiring continuous iteration over elements. Learn about its implementation, operations, and properties in this detailed guide.]]></summary></entry><entry xml:lang="en"><title type="html">Doubly Linked List Data Structure</title><link href="https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" rel="alternate" type="text/html" title="Doubly Linked List Data Structure" /><published>2025-02-01T14:20:00+00:00</published><updated>2025-02-01T14:20:00+00:00</updated><id>https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Doubly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published February 01, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/doublylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Doubly Linked List</h3>
		
        <p>A doubly linked list is a linear data structure consisting of a sequence of elements, called nodes, where each node points to both its previous and next nodes in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations.</p>
		
		<p>Each node in a doubly linked list contains three fields:</p>
		
        <ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence.</li>
			<li><b>Previous Pointer</b>: A reference (or pointer) to the previous node in the sequence.</li>
		</ul>

        <p>The doubly linked list forms a linear collection of elements where each node points to both its successor and its predecessor. The first node, known as the head, has a <code>NULL</code> reference for its previous pointer, indicating the beginning of the list. The last node has a <code>NULL</code> reference for its next pointer, marking the end of the list.</p>
		
		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. If the list is empty, the head points to <code>NULL</code>.</p>
		
		<p>Insertions and deletions of nodes, particularly at the beginning, middle, or end of the list, are more efficient compared to arrays since you do not need to shift elements. However, managing both the previous and next pointers requires extra attention.</p>
		
		<p>The nodes in a doubly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next and previous nodes through pointers, and they can be located anywhere in memory.</p>
		
		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>
		
		<p>Each node in a doubly linked list requires extra memory for the two pointers (next and previous references), which slightly increases memory usage compared to arrays or singly linked lists.</p>
		
		<p>Here's a visual representation of a doubly linked list:</p>
		
		<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | Data | Next] ⇄ [Prev | Data | Next] ⇄ [Prev | Data | Next] → NULL
</code></pre>
		
		<p>In the above representation:</p>
		
		<ul>
			<li>The <code>Head</code> points to the first node of the list, providing quick access to the start of the list.</li>
			<li>Each node contains <code>Data</code>, a <code>Next</code> pointer to the next node, and a <code>Previous</code> pointer to the previous node.</li>
			<li>The last node in the list has its <code>Next</code> pointer set to <code>NULL</code>, indicating the end of the list. Its <code>Prev</code> pointer points to the previous node.</li>
			<li>The <code>Prev</code> pointer of the first node is <code>NULL</code>, as there is no node before it.</li>
		</ul>
		
		<p>A simple doubly linked list with three nodes could look like this:</p>
		
		<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
		
		<p>In the above example:</p>
		
		<ul>
			<li>The head points to the first node containing the data <code>10</code>. The <code>Prev</code> pointer of this node is <code>NULL</code>, as there is no node before it.</li>
			<li>The second node contains the data <code>20</code>. Its <code>Prev</code> pointer points to the first node, and its <code>Next</code> pointer points to the third node.</li>
			<li>The third node contains the data <code>30</code>. Its <code>Prev</code> pointer points to the second node, and its <code>Next</code> pointer is <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common doubly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
							<pre><code class="language-bash hljs">
              HEAD 
		       ↓
NULL ← [Prev | 5 | Next] ⇄ [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a doubly linked list is \(O(1)\) (constant time). If the list is empty, the following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>, as there is no node after it.</li>
							<li>Set the <code>prev</code> pointer of the new node to <code>NULL</code>, as it will become the first node.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						If the list is not empty, the following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list).</li>
							<li>If the list is not empty, set the <code>prev</code> pointer of the current head node to point to the new node.</li>
							<li>Set the <code>prev</code> pointer of the new node to <code>NULL</code>, as it will become the first node.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a doubly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] ⇄ [Prev | 40 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning.  The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node <code>NULL</code>, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer is <code>NULL</code>).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 25 | Next]  ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node after a node in a doubly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the given node.</li>
							<li>Update its <code>prev</code> pointer of the node following the given node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node after a node in a doubly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertBeforeNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately before a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> before the node containing <code>20</code>. After calling <code>insertBeforeNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 25 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node before a node in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the preceding node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>prev</code> pointer of the target node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node before a node in a doubly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a doubly linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 35 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Set the <code>prev</code> pointer of the new node to point to the preceding node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>prev</code> pointer of the target node to point to the new node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a doubly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a new node at a specified position in a linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Set the head pointer to the next node</li>
							<li>Set the <code>prev</code> pointer of the new head node (if it exists) to <code>NULL</code>.</li>
							<li>Deallocate the memory for the old head node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a doubly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] → NULL
</code></pre>							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the second-to-last node.</li>
							<li>Set the <code>next</code> pointer of the second-to-last node to <code>null</code>.</li>
							<li>Deallocate the memory for the old last node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position to delete is 0, it means the head node should be removed. If the specified position is out of bounds, and a message is printed.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>You want to remove a node at position <code>3</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
							<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a doubly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the node before the target position.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the node after the target node (if it exists).</li>
							<li>Update the <code>prev</code> pointer of the node after the target node (if it exists) to point to the preceding node.</li>
							<li>Deallocate the memory for the removed node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a doubly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a doubly linked list and perform an action, such as printing the node's value.</li>
					<li><b>Time complexity</b>: The time complexity of traverse function in a linked list is \(O(n)\) (linear time). The function iterates through each node in the linked list exactly once, from the head to the end (<code>NULL</code>). Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of traverse function in a linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>
			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a doubly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 10 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 30 | Next] → NULL
</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">
               HEAD 
		        ↓
NULL ← [Prev | 30 | Next] ⇄ [Prev | 20 | Next] ⇄ [Prev | 10 | Next] → NULL
</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of reverse function in a doubly linked list is \(O(n)\) (linear time). The function traverses each node of the linked list exactly once. Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of reverse function in a doubly linked list is \(O(1)\) (constant space).  The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes. This amount of space does not depend on the size of the linked list.</li>
				</ul>
			</li>
			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a doubly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of search function in a linked list is \(O(n)\) (linear time).The search function traverses the linked list node by node. In the worst case, it may need to look at every node in the list to find the key (or determine that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of search function in a linked list is \(O(1)\) (constant space). The function uses a constant amount of extra space to store variables, such as pointers for the current node. The space required does not depend on the size of the list because the function does not use any additional data structures or dynamic memory allocations for the search process.</li>
				</ul>
			</li>
			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a doubly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of size function in a linked list is \(O(n)\) (linear time). The function traverses the entire linked list to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of size function in a doubly linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a doubly linked list at a specified index. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of get function in a doubly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of get function in a doubly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a doubly linked list. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of set function in a doubly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of set function in a doubly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a doubly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of <code>isEmpty</code> function in a doubly linked list is \(O(1)\) (constant time). The <code>isEmpty</code> function checks whether the head pointer of the linked list is <code>NULL</code>. This operation is performed in constant time since it only involves a simple comparison, regardless of the size of the linked list.</li>
					<li><b>Space complexity</b>: The space complexity of <code>isEmpty</code> function in a doubly linked list is \(O(1)\) (constant space). The function uses a fixed amount of space to store the result of the comparison (typically a boolean value), regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted linked lists into a single sorted linked list. </li>
					<li><b>Time complexity</b>: The time complexity of merge function in a doubly linked list is \(O(n + m)\) (linear time). The reason for this complexity is that each node from both lists is visited exactly once. In the worst case, the function will traverse both lists entirely, performing comparisons and linking nodes. Where \(n\) is the number of nodes in the first linked list and \(m\) is the number of nodes in the second linked list.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a doubly linked list is \(O(n + m)\) (linear space) due to the call stack storing recursive calls. In the worst case, the maximum depth of recursion will be equal to the total number of nodes in both lists combined, leading to \(n + m\) recursive calls.</li>
				</ul>
			</li>
			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a doubly linked list, in a specific order (typically ascending or descending).</li>
					<li><b>Time complexity</b>: The time complexity of sort function in a doubly linked list, when using merge sort is \(O(n \log n)\) (linearithmic time) because the algorithm consistently divides the list into halves and requires a linear amount of time \(O(n)\) to merge those halves back together. The logarithmic factor \(\log n\) comes from the number of times the list can be divided in half (depth of recursion).</li>
					<li><b>Space complexity</b>: The space complexity of sort function in a doubly linked list, specifically Merge Sort, is \(O(n)\) (linear space) because it requires additional space for the temporary arrays or linked lists used during the merge process. When merging two halves, the algorithm needs space to hold the merged elements before copying them back to the original array or linked list.</li>
				</ul>
			</li>
			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from the list and free up the memory they occupy, effectively making the list empty.</li>
					<li><b>Time complexity</b>: The time complexity of clear function in a doubly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, freeing its memory. Since it processes all nodes in the list, the time complexity is proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of clear function in a doubly linked list is \(O(1)\) (constant space). The function only requires a fixed amount of extra memory for the iteration, typically for a pointer to traverse the list. No additional memory structures are needed, regardless of the size of the linked list.</li>
				</ul>
			</li>
        </ul>
		
		<h3 class="post-subtitle">Non-Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// defines a structure to represent a node in a doubly linked list
typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef != NULL) {
        (*headRef)-&gt;prev = newNode;
    }
    newNode-&gt;next = *headRef;
    *headRef = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }

    Node* newNode = createNode(data);
    newNode-&gt;next = prevNode-&gt;next;
    newNode-&gt;prev = prevNode;
    if (prevNode-&gt;next != NULL) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(data);
    if (*headRef == nextNode) {
        newNode-&gt;next = *headRef;
        (*headRef)-&gt;prev = newNode;
        *headRef = newNode;
        return;
    }

    newNode-&gt;next = nextNode;
    newNode-&gt;prev = nextNode-&gt;prev;
    if (nextNode-&gt;prev != NULL) {
        nextNode-&gt;prev-&gt;next = newNode;
    }
    nextNode-&gt;prev = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    if (position == 0) {
        newNode-&gt;next = *headRef;
        if (*headRef != NULL) {
            (*headRef)-&gt;prev = newNode;
        }
        *headRef = newNode;
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    newNode-&gt;prev = temp;
    if (temp-&gt;next != NULL) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = *headRef;
    *headRef = (*headRef)-&gt;next;
    if (*headRef != NULL) {
        (*headRef)-&gt;prev = NULL;
    }
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;prev != NULL) {
        temp-&gt;prev-&gt;next = NULL;
    } else {
        *headRef = NULL; // List has only one element
    }
    free(temp);
}

// Function to delete a node at a specific position (0-based index)
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    if (position == 0) {
        *headRef = temp-&gt;next;
        if (*headRef != NULL) {
            (*headRef)-&gt;prev = NULL;
        }
        free(temp);
        return;
    }

    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = nodeToDelete-&gt;next;
    if (nodeToDelete-&gt;next != NULL) {
        nodeToDelete-&gt;next-&gt;prev = temp;
    }
    free(nodeToDelete);
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d &lt;-&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp-&gt;data == key)
            return 1; // Key found
        temp = temp-&gt;next;
    }
    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** headRef) {
    Node *temp = NULL;
    Node* current = *headRef;
    
    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    if (temp != NULL) {
        *headRef = temp-&gt;prev;
    }
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    while (current != NULL) {
        if (count == index) {
            current-&gt;data = newValue;
            return;
        }
        count++;
        current = current-&gt;next;
    }

    printf("Index out of range\n");
}

// Function to clear the entire linked list and free memory
void clear(Node** headRef) {
    Node* current = *headRef;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *headRef = NULL;
}

// Function to get the middle of the linked list
void middle(Node** mid, Node* head) {
    if (head == NULL) return;
    
    Node* slow = head;
    Node* fast = head-&gt;next;
    
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    
    *mid = slow; // Update the pointer to the middle node
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    // Log the current state of head1 and head2
    //printf("Merging: head1 data = %d, head2 data = %d\n", 
    //       head1 ? head1-&gt;data : -1, head2 ? head2-&gt;data : -1);

    // Base case when one of the lists is empty
    if (head1 == NULL) {
        // Log when head1 is NULL and remaining head2 is being added
        if (head2 != NULL) {
            printf("head1 is NULL, adding remaining head2 data: %d\n", head2-&gt;data);
            Node* newNode = createNode(head2-&gt;data); // Create a new node
            *headRef = newNode;
            merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        }
        return;
    }
    if (head2 == NULL) {
        // Log when head2 is NULL and remaining head1 is being added
        if (head1 != NULL) {
            //printf("head2 is NULL, adding remaining head1 data: %d\n", head1-&gt;data);
            Node* newNode = createNode(head1-&gt;data); // Create a new node
            *headRef = newNode;
            merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        }
        return;
    }

    // Compare the data of head1 and head2 and merge accordingly
    if (head1-&gt;data &lt;= head2-&gt;data) {
        // Log when adding data from head1
        //printf("Adding head1 data: %d\n", head1-&gt;data);
        Node* newNode = createNode(head1-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    } else {
        // Log when adding data from head2
        //printf("Adding head2 data: %d\n", head2-&gt;data);
        Node* newNode = createNode(head2-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    }

    // Log when merge is completed for this recursion
    //printf("Merge step completed. headRef data = %d\n", (*headRef)-&gt;data);
}


// Function to sort the doubly linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;
	
	// Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != nullptr) {
        nextToMid-&gt;prev = nullptr;  // Set 'prev' of the second half to null
    }
	
    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}

// Main function to test the doubly linked list operations
int main() {
    Node* list = NULL;
	
	// 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);
	
	// 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);
	
	// 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);
	
	// 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);
	
	// 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);
	
	// 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);
	
	// 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);
	
	// 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}
	
	// 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }
	
	// 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);
	
	// 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));
	
	// 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }
	
	// 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);
    
	// 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node* next;
    Node* prev;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr), prev(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    newNode-&gt;next = head;
    if (head != nullptr) {
        head-&gt;prev = newNode;
    }
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == nullptr) {
        std::cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    if (prevNode-&gt;next != nullptr) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
    newNode-&gt;prev = prevNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        std::cout &lt;&lt; "The list cannot be empty" &lt;&lt; std::endl;
        return;
    }

    if (nextNode == nullptr) {
        std::cout &lt;&lt; "The given next node cannot be NULL" &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // If the nextNode is the head node, handle the insertion at the beginning
    if (headRef == nextNode) {
        newNode-&gt;next = headRef;
        headRef-&gt;prev = newNode;
        headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = headRef;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        std::cout &lt;&lt; "The given next node is not found in the list" &lt;&lt; std::endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);
    if (position == 0) {
        newNode-&gt;next = head;
        if (head != nullptr) {
            head-&gt;prev = newNode;
        }
        head = newNode;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}


// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    head = head-&gt;next;
    if (head != nullptr) {
        head-&gt;prev = nullptr;
    }
    delete temp;
}


// Delete at the end
void deleteAtEnd(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    temp-&gt;prev-&gt;next = nullptr;
    delete temp;
}


// Delete at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node* temp = head;
        head = head-&gt;next;
        if (head != nullptr) {
            head-&gt;prev = nullptr;
        }
        delete temp;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    if (nextNode != nullptr) {
        nextNode-&gt;prev = temp;
    }
    temp-&gt;next = nextNode;
}

// Function to reverse a doubly linked list
void reverse(Node*& head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;

    while (current != nullptr) {
        // Swap next and prev for the current node
        next = current-&gt;next;
        current-&gt;next = prev;
        current-&gt;prev = next;

        // Move to the next node in the original list
        prev = current;
        current = next;
    }

    // Update head to the last node (new head after reverse)
    head = prev;
}

// Function to get the size of a doubly linked list
int size(Node* head) {
    int count = 0;
    Node* temp = head;

    while (temp != nullptr) {
        count++;  // Increment count for each node
        temp = temp-&gt;next;  // Move to the next node
    }

    return count;
}

// Function to access an element at a specific index (0-based) in a doubly linked list
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;

    // Traverse the list to find the node at the specified index
    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data;  // Return the data at the index
        count++;
        temp = temp-&gt;next;  // Move to the next node
    }

    return -1;  // Index out of range
}

// Function to set an element at a specific index (0-based) in a doubly linked list
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;  // Move to the next node
    }

    cout &lt;&lt; "Index out of range\n";  // Handle case where index exceeds list length
}

// Search for an element in a doubly linked list
bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;  // Element found
        temp = temp-&gt;next;
    }
    return false;  // Element not found
}

// Traverse the list (forward)
void traverse(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " &lt;-&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Find the middle of the list
void middle(Node*& mid, Node* head) {
    if (head == nullptr) {
        mid = nullptr;
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != nullptr && fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    mid = slow;
}

// Merge two sorted lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    if (head1-&gt;data &lt;= head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    }
}

// Sort the list using merge sort
void sort(Node*& head) {
    if (head == nullptr || head-&gt;next == nullptr)
        return;

    Node* mid = nullptr;
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;
	
	// Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != nullptr) {
        nextToMid->prev = nullptr;  // Set 'prev' of the second half to null
    }
	
    Node* left = head;
    Node* right = nextToMid;

    sort(left);
    sort(right);

    merge(head, left, right);
}

// Clear the list
void clear(Node*& head) {
    Node* current = head;
    while (current != nullptr) {
        Node* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

int main() {
    Node* list = nullptr;  // Initialize an empty doubly linked list

    // Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // Insert element at position 2
    insertAtPosition(list, 4, 2);

    cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // Delete the first node
    deleteAtBeginning(list);

    cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // Delete the last node
    deleteAtEnd(list);

    cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // Delete the node at position 2
    deleteAtPosition(list, 2);

    cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);

    // Search for an element
    int key = 6;
    if (search(list, key)) {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; endl;
    }

    // Reverse the list
    reverse(list);

    cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // Get the size of the list
    cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; endl;

    // Clear the list
    clear(list);

    cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class DoublyLinkedList {

    // Node structure for doubly linked list
    static class Node {
        int data;
        Node next;
        Node prev;

        // Constructor to create a new node
        Node(int data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        if (head != null) {
            head.prev = newNode;
        }
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        Node newNode = new Node(data);
        if (position == 0) {
            if (head != null) {
                head.prev = newNode;
            }
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null) {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }
	
	// Insert after a given node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be null");
            return;
        }
        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
        newNode.prev = prevNode;
        if (newNode.next != null) {
            newNode.next.prev = newNode;
        }
    }

    // Insert before a given node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (nextNode == null) {
            System.out.println("The given next node cannot be null");
            return head;
        }
        Node newNode = new Node(data);
        newNode.prev = nextNode.prev;
        newNode.next = nextNode;
        nextNode.prev = newNode;
        if (newNode.prev != null) {
            newNode.prev.next = newNode;
        } else {
            head = newNode;
        }
        return head;
    }
	
    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        Node newHead = head.next;
        if (newHead != null) {
            newHead.prev = null;
        }
        return newHead;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.prev.next = null;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return deleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        Node toDelete = temp.next;
        temp.next = toDelete.next;
        if (toDelete.next != null) {
            toDelete.next.prev = temp;
        }
        return head;
    }

    // Get element at a specific index
    public static int get(Node head, int index) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
        return -1; // Return -1 if the index is out of range
    }

    // Set element at a specific index
    public static void set(Node head, int index, int newValue) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
    }

    // Traverse the list
    public static void traverse(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Search for an element
    public static boolean search(Node head, int key) {
        Node temp = head;
        while (temp != null) {
            if (temp.data == key) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node reverse(Node head) {
        Node temp = null;
        Node current = head;

        // Swap next and prev pointers for each node
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        // After the loop, temp will be the last node, so update head
        if (temp != null) {
            head = temp.prev;
        }

        return head;
    }

    // Merge two sorted lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.data &lt;= head2.data) {
            head1.next = merge(head1.next, head2);
            if (head1.next != null) {
                head1.next.prev = head1;
            }
            return head1;
        } else {
            head2.next = merge(head1, head2.next);
            if (head2.next != null) {
                head2.next.prev = head2;
            }
            return head2;
        }
    }

    // Find the middle of the list
    public static Node middle(Node head) {
        if (head == null) return null;

        Node slow = head;
        Node fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == null) return head;

        // Find the middle node
        Node mid = middle(head);
        Node nextToMid = mid.next;
        mid.next = null;
		
		// Properly break the list into two halves
		if (nextToMid != null) {
			nextToMid.prev = null;  // Set the 'prev' pointer of the second half to null
		}
	
        // Recursively split and sort both halves
        Node left = sort(head);
        Node right = sort(nextToMid);

        // Merge the sorted halves
        return merge(left, right);
    }

    // Get the size of the list
    public static int size(Node head) {
        int count = 0;
        Node temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node clear(Node head) {
        return null;
    }

    // Main method to test
    public static void main(String[] args) {
        Node head = null;

        // Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		    
		    Node second = new Node(20);
		    insertAfterNode(second, 25);
        System.out.println("List after inserting 25 after 20:");
        traverse(head);
        
        head = insertBeforeNode(head, second, 15);
        System.out.println("List after inserting 15 before 20:");
        traverse(head);
		
        // Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);

        // Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // Get the size of the list
        System.out.println("Size of the list: " + size(head));

        // Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
        traverse(head);

        // Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

public class DoublyLinkedList
{
    // Node structure for doubly linked list
    public class Node
    {
        public int data;
        public Node next;
        public Node prev;

        // Constructor to create a new node
        public Node(int data)
        {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data);
        newNode.next = head;
        if (head != null)
        {
            head.prev = newNode;
        }
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null)
        {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.next = head;
            if (head != null)
            {
                head.prev = newNode;
            }
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null)
        {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }
	
	// Insert a new node after a given node
	public static Node InsertAfterNode(Node head, int target, int data)
	{
		Node temp = head;
		while (temp != null && temp.data != target)
		{
			temp = temp.next;
		}

		if (temp == null)
		{
			Console.WriteLine($"Node with value {target} not found.");
			return head;
		}

		Node newNode = new Node(data);
		newNode.next = temp.next;
		newNode.prev = temp;
		
		if (temp.next != null)
		{
			temp.next.prev = newNode;
		}
		temp.next = newNode;
		
		return head;
	}

	// Insert a new node before a given node
	public static Node InsertBeforeNode(Node head, int target, int data)
	{
		if (head == null)
		{
			Console.WriteLine("List is empty.");
			return null;
		}

		if (head.data == target)
		{
			return InsertAtBeginning(head, data);
		}

		Node temp = head;
		while (temp != null && temp.data != target)
		{
			temp = temp.next;
		}

		if (temp == null)
		{
			Console.WriteLine($"Node with value {target} not found.");
			return head;
		}

		Node newNode = new Node(data);
		newNode.next = temp;
		newNode.prev = temp.prev;

		if (temp.prev != null)
		{
			temp.prev.next = newNode;
		}
		temp.prev = newNode;

		return head;
	}

    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        if (head.next != null)
        {
            head.next.prev = null;
        }
        return head.next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.next != null)
        {
            temp = temp.next;
        }
        if (temp.prev != null)
        {
            temp.prev.next = null;
        }
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return DeleteAtBeginning(head);
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.next;
        }

        if (temp == null || temp.next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        if (temp.next.next != null)
        {
            temp.next.next.prev = temp;
        }
        temp.next = temp.next.next;
        return head;
    }

    // Get element at a specific index
    public static int Get(Node head, int index)
    {
        int count = 0;
        Node temp = head;

        while (temp != null)
        {
            if (count == index)
            {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        Console.WriteLine("Index out of range");
        return -1;
    }

    // Set element at a specific index
    public static void Set(Node head, int index, int newValue)
    {
        int count = 0;
        Node temp = head;

        while (temp != null)
        {
            if (count == index)
            {
                temp.data = newValue;
                return;
            }
            count++;
            temp = temp.next;
        }

        Console.WriteLine("Index out of range");
    }

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, int key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.data == key)
            {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node temp = null;
        Node current = head;

        while (current != null)
        {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        if (temp != null)
        {
            head = temp.prev;
        }
        return head;
    }

    // Find the middle of the list
	public static Node Middle(Node head)
	{
		if (head == null) return null;

		Node slow = head, fast = head;
		
		while (fast.next != null && fast.next.next != null)
		{
			slow = slow.next;
			fast = fast.next.next;
		}

		return slow;
	}

	// Sort the list using merge sort
	public static Node Sort(Node head)
	{
		if (head == null || head.next == null) return head;

		Node mid = Middle(head);
		Node nextToMid = mid.next;

		// Properly break the list into two halves
		mid.next = null;
		if (nextToMid != null) 
		{
			nextToMid.prev = null;
		}

		Node left = Sort(head);
		Node right = Sort(nextToMid);

		return Merge(left, right);
	}

	// Merge two sorted lists
	public static Node Merge(Node head1, Node head2)
	{
		if (head1 == null) return head2;
		if (head2 == null) return head1;

		if (head1.data &lt;= head2.data)
		{
			head1.next = Merge(head1.next, head2);
			if (head1.next != null)
			{
				head1.next.prev = head1;
			}
			return head1;
		}
		else
		{
			head2.next = Merge(head1, head2.next);
			if (head2.next != null)
			{
				head2.next.prev = head2;
			}
			return head2;
		}
	}

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the list
    public static Node Clear(Node head)
    {
        return null;
    }

    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning: ");
        Traverse(head);

        // Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end: ");
        Traverse(head);

        // Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2: ");
        Traverse(head);
		
  		head = InsertAfterNode(head, 4, 8);
  		Console.WriteLine("List after inserting 8 after 4:");
  		Traverse(head);
  
  		head = InsertBeforeNode(head, 4, 6);
  		Console.WriteLine("List after inserting 6 before 4:");
  		Traverse(head);

        // Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning: ");
        Traverse(head);

        // Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end: ");
        Traverse(head);

        // Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2: ");
        Traverse(head);

        // Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine("Element " + key + " found in the list");
        }
        else
        {
            Console.WriteLine("Element " + key + " not found in the list");
        }

        // Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing: ");
        Traverse(head);

        // Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));

        // Sort the list
        head = Sort(head);

        Console.WriteLine("Sorted list:");
        Traverse(head);

        // Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing: ");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-cpp hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for doubly linked list
typedef struct Node {
    StackElement element;     // Stack element data
    struct Node* next;        // Pointer to the next node
    struct Node* prev;        // Pointer to the previous node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    newNode-&gt;next = *head;
    (*head)-&gt;prev = newNode;
    *head = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a node after a given previous node
void insertAfterNode(Node** head, Node* prevNode, StackElement element) {
    if (*head == NULL || prevNode == NULL) {
        printf("The list cannot be empty or the previous node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(element);
    newNode-&gt;next = prevNode-&gt;next;
    if (prevNode-&gt;next != NULL) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
    newNode-&gt;prev = prevNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    if (*head == NULL || nextNode == NULL) {
        printf("The list cannot be empty or the next node cannot be NULL\n");
        return;
    }

    Node* newNode = createNode(element);
    newNode-&gt;prev = nextNode-&gt;prev;
    if (nextNode-&gt;prev != NULL) {
        nextNode-&gt;prev-&gt;next = newNode;
    }
    nextNode-&gt;prev = newNode;
    newNode-&gt;next = nextNode;

    // If nextNode is the head node
    if (newNode-&gt;prev == NULL) {
        *head = newNode;
    }
}

// Function to insert a node at a specific position
void insertAtPosition(Node** head, StackElement element, int position) {
    if (position == 0) {
        insertAtBeginning(head, element);
        return;
    }

    Node* newNode = createNode(element);
    Node* temp = *head;
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != NULL) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *head;
    *head = (*head)-&gt;next;
    if (*head != NULL) {
        (*head)-&gt;prev = NULL;
    }
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    if (temp-&gt;prev != NULL) {
        temp-&gt;prev-&gt;next = NULL;
    } else {
        *head = NULL; // Only one element in the list
    }
    free(temp);
}

// Function to delete a node at a given position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    if (position == 0) {
        *head = temp-&gt;next;
        if (*head != NULL) {
            (*head)-&gt;prev = NULL;
        }
        free(temp);
        return;
    }

    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    if (nextNode != NULL) {
        nextNode-&gt;prev = temp;
    }
    free(temp-&gt;next);
    temp-&gt;next = nextNode;
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%s &lt;-&gt; ", temp-&gt;element.toString);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to reverse the linked list
void reverse(Node** head) {
    Node* temp = NULL;
    Node* current = *head;
    
    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }
    
    if (temp != NULL) {
        *head = temp-&gt;prev;
    }
}


// Function to clear the entire linked list and free memory
void clear(Node** head) {
    Node* current = *head;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *head = NULL;
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    Node* temp = head;

    while (temp != NULL) {
        // Call toString to get the string representation of the data in the current node
        char* currentStr = temp-&gt;element.toString;
        char* keyStr = keyElement.toString;

        // Compare the string representations of the current node's data and the key element's data
        if (strcmp(currentStr, keyStr) == 0) {
            return 1; // Key found
        }

        temp = temp-&gt;next;
    }

    return 0; // Key not found
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;element;
        count++;
        temp = temp-&gt;next;
    }
    StackElement emptyElement = {NULL, ""};
    return emptyElement; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head2 = head2-&gt;next;
        }
        return;
    }
    if (head2 == NULL) {
        while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head1 = head1-&gt;next;
        }
        return;
    }

    if (strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt; 0) {
        Node* newNode = createNode(head1-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    } else {
        Node* newNode = createNode(head2-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        if ((*headRef)-&gt;next != NULL) {
            (*headRef)-&gt;next-&gt;prev = *headRef;
        }
    }
}

// Function to get the middle of the linked list
void middle(Node* head, Node** middle) {
    if (head == NULL) {
        *middle = NULL; // Set middle node to NULL if list is empty
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    *middle = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(head, &mid);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;

    // Properly handle the 'prev' pointers for a doubly linked list
    if (nextToMid != NULL) {
        nextToMid-&gt;prev = NULL;  // Set 'prev' of the second half to null
    }

    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


struct Car {
    char model[20];
    int year;
};

struct Person {
    char name[20];
    int age;
};

// Main function to test the doubly linked list operations
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements into the list**
    insertAtBeginning(&personList, personElement1);
    insertAtEnd(&personList, personElement2);
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 2. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 3. **Insert before a node**
    insertBeforeNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 4. **Insert after a node**
    insertAfterNode(&personList, personList-&gt;next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 5. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 6. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 7. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 8. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 9. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 10. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 11. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 12. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 13. **Sort the linked list**
    printf("\nList before sorting:\n");
    traverse(personList);
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 14. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 15. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for doubly linked list
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;
    Node* prev; // Add prev pointer

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr), prev(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    newNode-&gt;next = head;
    if (head != nullptr) {
        head-&gt;prev = newNode;
    }
    head = newNode;
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    newNode-&gt;prev = prevNode;

    if (prevNode-&gt;next != nullptr) {
        prevNode-&gt;next-&gt;prev = newNode;
    }
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    
    if (head == nextNode) {
        newNode-&gt;next = head;
        head-&gt;prev = newNode;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "The given next node is not found in the list\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        newNode-&gt;next = head;
        if (head != nullptr) {
            head-&gt;prev = newNode;
        }
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    if (temp-&gt;next != nullptr) {
        temp-&gt;next-&gt;prev = newNode;
    }
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    head = head-&gt;next;
    if (head != nullptr) {
        head-&gt;prev = nullptr;
    }
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    temp-&gt;prev-&gt;next = nullptr;
    delete temp;
}

// Delete at a specific position
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node&lt;T&gt;* temp = head;
        head = head-&gt;next;
        if (head != nullptr) {
            head-&gt;prev = nullptr;
        }
        delete temp;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node&lt;T&gt;* nextNode = temp-&gt;next-&gt;next;
    if (nextNode != nullptr) {
        nextNode-&gt;prev = temp;
    }
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " &lt;-&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Reverse the list
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* temp = nullptr;

    // Reverse the next and prev pointers of all nodes
    while (current != nullptr) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    // Reset the head to the last node
    if (temp != nullptr) {
        head = temp-&gt;prev;
    }
}

// Get the size of the list
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    int count = 0;
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Function to access an element at a specific index (0-based)
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    int count = 0;
    Node&lt;T&gt;* temp = head;

    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data; // Return the data at the index
        count++;
        temp = temp-&gt;next;
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to set an element at a specific index (0-based)
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    Node&lt;T&gt;* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = element; // Update the node's value
            return;                  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;     // Move to the next node
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    Node&lt;T&gt;* temp = head;
    
    // Traverse the list in the forward direction
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;  // Element found
        temp = temp-&gt;next;
    }

    // If not found, return false
    return false;
}

// Function to merge two lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    // Merge the two lists based on data comparison (using &lt; operator)
    if (head1-&gt;data &lt; head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
        // Update the prev pointer of the next node in the merged list
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
        // Update the prev pointer of the next node in the merged list
        if (headRef-&gt;next != nullptr) {
            headRef-&gt;next-&gt;prev = headRef;
        }
    }
}

// Function to find the middle node of the linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;* head, Node&lt;T&gt;*& mid) {
    if (head == nullptr) {
        mid = nullptr; // Set middle node to nullptr if the list is empty
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head-&gt;next;

    while (fast != nullptr) {
        fast = fast-&gt;next;
        if (fast != nullptr) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    mid = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    if (headRef == nullptr || headRef-&gt;next == nullptr)
        return;

    Node&lt;T&gt;* mid = nullptr;
    middle(headRef, mid);
    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;
    
    // Properly handle the 'prev' pointers for the second half of the list
    if (nextToMid != nullptr) {
        nextToMid-&gt;prev = nullptr;  // Set 'prev' of the second half to null
    }
    
    // Sort the two halves
    sort(headRef);
    sort(nextToMid);

    // Merge the sorted halves
    Node&lt;T&gt;* mergedHead = nullptr;
    merge(mergedHead, headRef, nextToMid);
    headRef = mergedHead; // Update the original head reference
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    while (current != nullptr) {
        Node&lt;T&gt;* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;(const Person& other) const {
        if (name == other.name) {
            return age &lt; other.age;  // If names are the same, sort by age
        }
        return name &lt; other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};

int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // Insert elements into the list
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    insertBeforeNode(head, secondNode, eve);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // Insert after a node (insert after the second node)
    insertAfterNode(secondNode, eve);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);

    // Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;

    // Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // Sort the linked list (by name first, then by age)
    cout &lt;&lt; "\nList before sorting:\n";
    traverse(head);
    sort(head);
    cout &lt;&lt; "\nList after sorting:\n";
    traverse(head);
    
    // Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
    
    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class LinkedList&lt;T&gt; {

    // Node structure for doubly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;
        Node&lt;T&gt; prev;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head != null) {
            head.prev = newNode;
        }
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head == null) {
            return newNode;
        }
        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; head, T data, int position) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (position == 0) {
            newNode.next = head;
            if (head != null) {
                head.prev = newNode;
            }
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        if (temp.next != null) {
            temp.next.prev = newNode;
        }
        temp.next = newNode;
        newNode.prev = temp;
        return head;
    }

    // Insert before a specific node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data) {
        if (head == null) return null;

        if (head == targetNode) {
            return insertAtBeginning(head, data);
        }

        Node&lt;T&gt; temp = head;
        while (temp != null && temp.next != targetNode) {
            temp = temp.next;
        }

        if (temp != null) {
            Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
            newNode.next = temp.next;
            if (temp.next != null) {
                temp.next.prev = newNode;
            }
            temp.next = newNode;
            newNode.prev = temp;
        }
        return head;
    }

    // Insert after a specific node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; node, T data) {
        if (node == null) return;

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = node.next;
        if (node.next != null) {
            node.next.prev = newNode;
        }
        node.next = newNode;
        newNode.prev = node;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        if (head.next != null) {
            head.next.prev = null;
        }
        return head.next;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.prev.next = null;
        return head;
    }

    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; head, T key) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; head) {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Get element at a specific index
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Set element at a specific index
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            System.out.print(temp.data + " &lt;-&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }

    // Sort the list
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
        if (head == null || head.next == null) return head;

        Node&lt;T&gt; mid = middle(head);
        Node&lt;T&gt; nextToMid = mid.next;
        mid.next = null;
        
        // Properly handle the 'prev' pointers for a doubly linked list
        if (nextToMid != null) {
            nextToMid.prev = null;  // Set 'prev' of the second half to null
        }
    
        Node&lt;T&gt; left = sort(head);
        Node&lt;T&gt; right = sort(nextToMid);

        return merge(left, right);
    }

    // Merge two sorted lists
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; left, Node&lt;T&gt; right) {
        if (left == null) return right;
        if (right == null) return left;

        if (left.data.compareTo(right.data) &lt;= 0) {
            left.next = merge(left.next, right);
            if (left.next != null) {
                left.next.prev = left;
            }
            return left;
        } else {
            right.next = merge(left, right.next);
            if (right.next != null) {
                right.next.prev = right;
            }
            return right;
        }
    }

    // Find the middle of the list
    public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
        if (head == null) return null;

        Node&lt;T&gt; slow = head;
        Node&lt;T&gt; fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Clear the list by removing all nodes
    public static &lt;T&gt; void clear(Node&lt;T&gt; head) {
        Node&lt;T&gt; current = head;
        while (current != null) {
            Node&lt;T&gt; next = current.next;
            current.next = null;  // Disconnect the current node
            current.prev = null;  // Disconnect the previous node
            current = next;       // Move to the next node
        }
    }
    
    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }

        @Override
        public int compareTo(Person other) {
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }

    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // Insert elements into the list
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);

        // Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // Get size of the list
        System.out.println("\nSize of the list: " + size(head));

        // Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // Sort the linked list (by name first, then by age)
        System.out.println("\nList before sorting:");
        traverse(head);
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
        
        // Clear the list
        clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;
    public Node&lt;T&gt; Prev;

    public Node(T data)
    {
        Data = data;
        Next = null;
        Prev = null;
    }
}

class Program
{
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = head };
        if (head != null) head.Prev = newNode;
        return newNode;
    }

    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null) return newNode;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Next = newNode;
        newNode.Prev = temp;
        return head;
    }

    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (position == 0) { newNode.Next = head; if (head != null) head.Prev = newNode; return newNode; }
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) temp = temp.Next;
        if (temp == null) { Console.WriteLine("Position out of bounds"); return head; }
        newNode.Next = temp.Next;
        newNode.Prev = temp;
        if (temp.Next != null) temp.Next.Prev = newNode;
        temp.Next = newNode;
        return head;
    }

    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null) return null;
        if (head == targetNode) return InsertAtBeginning(head, data);
        Node&lt;T&gt; temp = head;
        while (temp != null && temp.Next != targetNode) temp = temp.Next;
        if (temp != null)
        {
            Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = temp.Next, Prev = temp };
            if (temp.Next != null) temp.Next.Prev = newNode;
            temp.Next = newNode;
        }
        return head;
    }

    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next, Prev = node };
        if (node.Next != null) node.Next.Prev = newNode;
        node.Next = newNode;
    }

    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        head = head.Next;
        if (head != null) head.Prev = null;
        return head;
    }

    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null || head.Next == null) return null;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Prev.Next = null;
        return head;
    }

    // Search for an element
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        }
        return false;
    }

    // Get size of the list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Traverse the list and print elements
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " &lt;-&gt; ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Get an element at specific index
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Set (modify) an element at specific index
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }
    
    // Sort the linked list (Merge Sort)
    static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == null) return head;

        // Split the list into two halves
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; nextToMid = mid.Next;
        mid.Next = null;
        if (nextToMid != null) nextToMid.Prev = null;

        // Recursively sort both halves
        Node&lt;T&gt; left = Sort(head);
        Node&lt;T&gt; right = Sort(nextToMid);

        // Merge the sorted halves
        return Merge(left, right);
    }

    // Merge two sorted lists
    static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; left, Node&lt;T&gt; right) where T : IComparable&lt;T&gt;
    {
        if (left == null) return right;
        if (right == null) return left;

        if (left.Data.CompareTo(right.Data) &lt;= 0)
        {
            left.Next = Merge(left.Next, right);
            if (left.Next != null) left.Next.Prev = left;
            return left;
        }
        else
        {
            right.Next = Merge(left, right.Next);
            if (right.Next != null) right.Next.Prev = right;
            return right;
        }
    }

    // Find the middle node of the list
    static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        Node&lt;T&gt; slow = head, fast = head.Next;

        while (fast != null && fast.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }
    
    // Clear the linked list
    static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        head = null;
        return head;
    }
    
    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // Insert elements into the list
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);

        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);

        // Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);

        // Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        head = InsertBeforeNode(head, secondNode, eve);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);

        // Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);

        // Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);

        // Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);

        // Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));

        // Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

        // Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

        // Sort the linked list (by name first, then by age)
        Console.WriteLine("\nList before sorting:");
        Traverse(head);
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);
    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";

}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/doubly-linked-list" class="tag">doubly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2025/02/01/doubly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2025" /><category term="month-02" /><category term="day-01" /><category term="data structure" /><category term="linked list" /><category term="doubly linked list" /><summary type="html"><![CDATA[A Doubly Linked List is a dynamic data structure where each node contains data and two pointers, one pointing to the next node and another to the previous node. This bidirectional linking enables efficient insertion, deletion, and traversal in both directions, making it ideal for applications like undo or redo functionality, navigation systems, and memory management. Unlike singly linked lists, doubly linked lists allow easier manipulation of elements at both ends but require extra memory for storing an additional pointer. Learn how doubly linked lists work, their advantages, and implementations in this comprehensive guide.]]></summary></entry><entry xml:lang="en"><title type="html">Solving Recurrences - Master Theorem</title><link href="https://hemimorphite.github.io/2025/01/14/master-theorem/" rel="alternate" type="text/html" title="Solving Recurrences - Master Theorem" /><published>2025-01-14T10:20:00+00:00</published><updated>2025-01-14T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2025/01/14/master-theorem</id><content type="html" xml:base="https://hemimorphite.github.io/2025/01/14/master-theorem/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Solving Recurrences - Master Theorem</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published January 14, 2025</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/mastertheorem.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h4 class="post-subtitle">Divide and Conquer Recurrence Relations</h4>
		
		<p>Suppose that a recursive algorithm divides a problem of size \(n\) into a subproblems. Assume each subproblem is of size \(\frac{n}{b}\). Suppose \(f(n)\) extra operations are needed in the conquer step. Then \(T(n)\) represents the number of operations to solve a problem of size \(n\) satisfies the following recurrence relation:</p>
		
		<div class="equation-container">
		\[ T(n) = aT(\frac{n}{b}) + f(n), \]
        </div>
		
		<p>where:</p>
		
		<ul>
			<li>\(T(n)\) represents the total time complexity for solving a problem of size \(n\).</li>
			<li>\(a\) represents number of subproblems the problem is divided into.</li>
			<li>\(\frac{n}{b}\) represents the size of each subproblem.</li>
			<li>\(f(n)\) represents the cost of dividing the problem into subproblems and combining their solutions. This is the work done outside of the recursive calls.</li>
		</ul>
		
		<p>The recursion \(T(n) = aT(\frac{n}{b}) + f(n)\) stops:</p>
		
		<ul>
			<li>When \(T(n)\) is applied to the base case (usually \(n=1\)). The recursion halts at this point because the problem size can no longer be divided further.</li>
			<li>At the depth of the recursion tree, which corresponds to the number of times the problem size \(n\) can be divided by \(b\) until reaching the base case.</li>
		</ul>
		
		<h4 class="post-subtitle">The Asymptotic Growth of Geometric Series</h4>
		
		<div class="lemma">
			<p>Let \(r\) be a positive constant. Then,</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{n} r^{i} = 
			\begin{cases} 
			\Theta(r^{n}), & \text{if } r \gt 1 \\
			\Theta(n), & \text{if } r = 1 \\
			\Theta(1), & \text{if } r \lt 1 
			\end{cases}, \]
			</div>
			
			<p>That is, if geometric progression is increasing, then the series grows as its last (and largest) term. If it is constant, then it grows as the number of terms. Finally, if it is decreasing, it is bounded by a constant.</p>
		</div>
		
		<div class="proof">
			<p>The sum of the first \(n+1\) terms of a geometric sequence is given by the formula:</p>
			
			<div class="equation-container">
			\[ S(n) = \frac{r^{n+1} - 1}{r - 1} \]
			</div>
			
			<p>where the first term is \(1\), and the common ratio is \(r\).</p>
			
			<p>Finding the lower bound or upper bound of a function involves identifying the dominant term because the dominant term determines the function's growth rate as the input size increases significantly.</p>
			
			<p><b>Case \(r \gt 1\):</b></p>
			
			<p>Each term in the geometric series grows exponentially, starting from \(r^{0}\) (i.e., \(1\)) and ending with \(r^{n}\). As the series progresses, the terms increase rapidly, with the last term dominating the others. As a result, the sum is always greater \(r^{n}\) for \(n \gt 0\). This implies that the sum is bounded below by \(r^{n}\).</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \gt r^{n} \]
			</div>
			
			<p>As \(n\) becomes large, the term \(r^{n+1}\) in the numerator of the geometric series formula dominates the constant \(1\), and the sum of the geometric series can be approximately expressed as \(\frac{r^{n+1}}{r - 1}\).</p>
			
			<p>Thus, the upper bound of the geometric series sum is:</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \lt \frac{r}{r - 1}r^{n} \]
			</div>
			
			<p>We have found both the lower bound and the upper bound for the sum of the geometric series. Thus, we have:</p>
			
			<div class="equation-container">
			\[ r^{n} \lt \frac{r^{n+1} - 1}{r - 1} \lt \frac{r}{r - 1}r^{n} \]
			</div>
			
			<p>Therefore, the asymptotic behavior of \(S(n)\) is:</p>
			
			<div class="equation-container">
			\[ S(n) = \Theta(r^{n}) \]
			</div>
			
			<p><b>Case \(r = 1\):</b></p>
			
			<p>For \(r=1\), the sum of the series is simply the number of terms. The sum grows linearly with \(n\), and we can express the sum as:</p>
			
			<div class="equation-container">
			\[ S(n) = n + 1. \]
			</div>
			
			<p>Therefore, the asymptotic behavior of \(S(n)\) is:</p>
			
			<div class="equation-container">
			\[ S(n) = \Theta(n) \]
			</div>
			
			
			<p><b>Case \(r \lt 1\):</b></p>
			
			<p>Each term in the geometric series decays exponentially, starting from \(r^{0}\) (i.e., \(1\)) and ending with \(r^{n}\). As the series progresses, the terms decrease rapidly, with the first term dominating the others. As a result, the sum is always greater \(1\) for \(n \gt 0\). This implies that the sum is bounded above by \(1\).</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \gt 1 \]
			</div>
			
			<p>As \(n\) becomes large, the term \(r^{n+1}\) in the numerator of the geometric series formula approaches \(0\), and the sum of the geometric series can be approximately expressed as \(\frac{1}{1-r}\).</p>
			
			<p>Thus, the upper bound of the geometric series sum is:</p>
			
			<div class="equation-container">
			\[ \frac{r^{n+1} - 1}{r - 1} \lt \frac{1}{1-r} \]
			</div>
			
			<p>We have found both the lower bound and the upper bound for the sum of the geometric series. Thus, we have:</p>
			
			<div class="equation-container">
			\[ 1 \lt \frac{r^{n+1} - 1}{r - 1} \lt \frac{1}{1-r} \]
			</div>
			
			<p>Therefore, the asymptotic behavior of \(S(n)\) is:</p>
			
			<div class="equation-container">
			\[ S(n) = \Theta(1) \]
			</div>
		</div>
		
		<h4 class="post-subtitle">Simplified Version of Master Theorem</h4>
		
		<p>The simplified version of master theorem is a formula for analyzing the asymptotic behavior of divide-and-conquer recurrences of the form:</p>
		
		<div class="equation-container">
		\[ T(n) = aT(\frac{n}{b}) + cn^{k}, \]
		</div>
		
		<p>where \(a \geq 1\) and \(b \geq 2\) are integer constants, \(c \geq 0\), and \(k \geq 0\) are real constants. \(a\), \(b\), \(c\) and \(d\) do not depend on \(n\). The first term, \(a \cdot T(\frac{n}{b})\), represents the time required for the a recursive calls, each to an input of size \(\frac{n}{b}\); and the second term, \(c \cdot n^{k}\), represents the time required to divide up the input into a pieces of size \(\frac{n}{b}\) each and to combine the results of the recursive calls into the result of the main call.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT(\frac{n}{b}) + cn^{k}, & \text{if } n \gt 1
			\end{cases}, \]
			</div>
			
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(n^{k}), & \text{if } a \lt b^{k} \\
			\Theta(n^{k} \log_{b}(n)), & \text{if } a = b^{k} \\
			\Theta(n^{\log_{b}(a)}), & \text{if } a \gt b^{k}
			\end{cases}. \]
			</div>
			
			<p>Analogus results hold for the \(O\) and \(\Omega\) notations.</p>
		</div>
		
		<div class="proof">
			<p>Consider the tree of recursive calls made by the algorithm:</p>
			
			<ul>
				<li>At level \(0\) (the root), we have one call for input of size \(n\). The time needed by this call, exclusive of the time needed by the calls it makes (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(cn^{k}\) — the second term in the definition of the recurrence.</li>
				<li>At level \(1\) we have the calls made by the call at level \(0\): there are a such calls (one for each subproblem), each working on an input of size \(\frac{n}{b}\). The time needed by each of these calls, exclusive of the time needed by the calls it makes, is \(c\left(\frac{n}{b}\right)^{k}\), so the total time needed by these a calls is \(ac\left(\frac{n}{b}\right)^{k}\).</li>
				<li>At level \(2\) we have the calls made by the calls at level \(1\): there are \(a^{2}\) such calls, each working on an input of size \(\frac{n}{b^{2}}\). Reasoning as before, the total time needed by these \(a^{2}\) calls is \(a^{2}c\left(\frac{n}{b^{2}}\right)^{k}\).</li>
				<li>In general, at level \(i\), we have \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time needed for these calls is \(a^{i}c\left(\frac{n}{b^{i}}\right)^{k}\).</li>
				<li>This continues for every integer \(i = 0, 1, 2, \dots, \log_{b}(n)\). For \(i = \log_{b}(n)\), the input size is \(1\), and we have reached the base case of the recursion. At the base case, the problem is small enough that no further division is needed, and the solution can be solve directly.</li>
			</ul>
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			T(n) &= cn^{k} + aT(\frac{n}{b}) \\
			&= cn^{k} + a(c\left(\frac{n}{b}\right)^{k} + aT(\frac{n}{b^2})) = cn^{k} + ca\left(\frac{n}{b}\right)^{k} + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= cn^{k} + ca\left(\frac{n}{b}\right)^{k} + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} + \dots + a^{\log_{b}(n)}T(1) \\
			&= cn^{k} + ca\left(\frac{n}{b}\right)^{k} + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} + \dots + n^{\log_{b}(a)}T(1) \\
			&= \sum_{i=0}^{\log_{b}(n)-1} ca^{i}\left(\frac{n}{b^{i}}\right)^{k} + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i}. \]
			</div>
			
			<p>The series is a geometric series with ratio \(r=\frac{a}{b^{k}}\). Its growth rate depends on whether \(a\) is smaller, equal, or larger than \(b^{k}\). Consider these three cases.</p>
			
			<p><b>Case 1: \(a \gt b^{k}\)</b>. Given the condition \(a \gt b^{k}\), which implies that the ratio \(r=\frac{a}{b^{k}} \gt 1\).</p>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} r^{i}\) is a geometric series with the common ratio \(r=\frac{a}{b^{k}} \gt 1\) which grows exponentially, and can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
            \[
			\begin{aligned}  
			r^{\log_{b}(n)-1} &\leq& \sum_{i=0}^{\log_{b}(n)-1} r^{i} &\lt& \frac{r^{\log_{b}(n)}}{r-1} \\
			\left(\frac{a}{b^{k}}\right)^{\log_{b}(n)-1} &\leq& \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt& \frac{\left(\frac{a}{b^{k}}\right)^{\log_{b}(n)}}{\frac{a}{b^{k}}-1} \\
			\frac{a^{\log_{b}(n)-1}}{\left(b^{\log_{b}(n)-1}\right)^{k}} &\leq& \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt& \frac{\frac{a^{\log_{b}(n)}}{\left(b^{\log_{b}(n)}\right)^{k}}}{\frac{a}{b^{k}}-1} \\
			\frac{n^{\log_{b}(a)}}{n^{k}}\frac{b^{k}}{a} &\leq& \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt& \frac{n^{\log_{b}(a)}}{n^{k}}\frac{1}{\frac{a}{b^{k}}-1}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}  
			cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\leq& g(n) &\leq& cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \\
			cn^{k}\frac{n^{\log_{b}(a)}}{n^{k}}\frac{b^{k}}{a} &\leq& g(n) &\lt& cn^{k}\frac{n^{\log_{b}(a)}}{n^{k}}\frac{1}{\frac{a}{b^{k}}-1} \\
			c\frac{b^{k}}{a}n^{\log_{b}(a)} &\leq& g(n) &\lt& c\frac{1}{\frac{a}{b^{k}}-1}n^{\log_{b}(a)}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both below and above by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}  
			T(n) &= O\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 2: \(a = b^{k}\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=1\).</p>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} 1\) is an arithmetic series where every term in the series is constant. The sum is simply the constant value multiplied by the number of terms.</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{\log_{b}(n)-1} 1 = \log_{b}(n). \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned} 
			cn^{k}\sum_{i=0}^{\log_{b}(n)-1} 1 &\leq& g(n) &\leq& cn^{k}\sum_{i=0}^{\log_{b}(n)-1} 1 \\
			cn^{k}\log_{b}(n) &\leq& g(n) &\leq& cn^{k}\log_{b}(n). 
			\end{aligned}
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both below and above by constant multiples of \(n^{k}\log_{b}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\log_{b}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= O\left(n^{k}\log_{b}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\log_{b}(n)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\log_{b}(n)\right). \]
			</div>
			
			<p><b>Case 3: \(a \lt b^{k}\)</b>. Given the condition \(a \lt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \lt 1\).</p>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} r^{i}\) is a geometric series with the common ratio \(r=\frac{a}{b^{k}} \lt 1\) which grows exponentially, and can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			1 &\leq \sum_{i=0}^{\log_{b}(n)-1} r^{i} &\lt \frac{1}{1-r} \\
			1 &\leq \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} &\lt \frac{1}{1-\frac{a}{b^{k}}}. 
			\end{aligned}
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{k} &\leq& g(n) &\leq& cn^{k}\frac{1}{1-\frac{a}{b^{k}}} \\
			cn^{k} &\leq& g(n) &\leq& c\frac{1}{1-\frac{a}{b^{k}}}n^{k}. 
			\end{aligned}
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both below and above by constant multiples of \(n^{k}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= O\left(n^{k}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\right). \]
			</div>
		</div>

		<h4 class="post-subtitle">Simplified Version of Master Theorem with Log Factors</h4>
		
		<p>A recurrence such as</p>
		
		<div class="equation-container">
		\[ T(n) = 2T(\frac{n}{2}) + n \log_{2}(n) \]
		</div>
		
		<p>does not exactly fit the form of the master theorem above, since the additive term \(n \log_{2}(n)\) does not look like \(n^{k}\) for some constant \(k\). Such a recurrence can be handled by a more general form of the theorem, as follows.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ 
			T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT(\frac{n}{b}) + cn^{k} \log_{b}^{p}(n), & \text{if } n \gt 1.
			\end{cases}
			\]
			</div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta(n^{\log_{b}(a)}), & \text{if } \log_{b}(a) \gt k \\
			\Theta(n^{k} \log_{b}^{p+1}(n)), & \text{if } \log_{b}(a) = k \text{ and } p \gt -1 \\
			\Theta(n^{k} \log_{b}(\log_{b}(n))), & \text{if } \log_{b}(a) = k \text{ and } p = -1 \\
			\Theta(n^{k}), & \text{if } \log_{b}(a) = k \text{ and } p \lt -1 \\
			\Theta(n^{k} \log_{b}^{p}(n)), & \text{if } \log_{b}(a) \lt k \text{ and } p \gt 0 \\
			\Theta(n^{k}), & \text{if } \log_{b}(a) \lt k \text{ and } p \leq 0.
			\end{cases} \]
            </div>
			
			<p>Analogus results hold for the \(O\) and \(\Omega\) notations.</p>
		</div>
		
		<div class="proof">
			<p>Consider the tree of recursive calls made by the recurrence:</p>
			
			<ul>
				<li>At level \(0\) (the root), there is one call with an input size of \(n\).  The time required for this call, excluding the time needed by the recursive calls it spawns (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(cn^{k} \log_{b}^{p}(n)\).</li>
				<li>At level \(1\), The single call at level 0 spawns \(a\) recursive calls, each working on a subproblem of size \(\frac{n}{b}\). Each of these calls requires \(c\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right)\) time, excluding their own recursive calls. The total time required at this level is therefore \(ac\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right)\).</li>
				<li>At level \(2\),  The \(a\) calls from level \(1\) each spawn \(a\) new calls, resulting in \(a^{2}\) calls at this level. Each of these calls works on an input of size \(\frac{n}{b^{2}}\).  The total time required at this level is \(a^{2}c\left(\frac{n}{b^{2}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{2}}\right)\).</li>
				<li>In general, at level \(i\), there are \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time required for all calls at this level is \(a^{i}c\left(\frac{n}{b^{i}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{i}}\right)\).</li>
				<li>This process continues until \(i = log_{b}(n)\), where the input size reduces to \(1\). At this base case, the problem is small enough to be solved directly without further recursive calls.</li>
			</ul>
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= cn^{k} \log_{b}^{p}(n) + aT(\frac{n}{b}) \\
			&= cn^{k} \log_{b}^{p}(n) + a(c\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + aT(\frac{n}{b^2})) = cn^{k} \log_{b}^{p}(n) + ca\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= cn^{k} \log_{b}^{p}(n) + ca\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{2}}\right) + \dots + a^{\log_{b}(n)}\Theta(1) \\
			&= cn^{k} \log_{b}^{p}(n) + ca\left(\frac{n}{b}\right)^{k} \log_{b}^{p}\left(\frac{n}{b}\right) + ca^{2}\left(\frac{n}{b^{2}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{2}}\right) + \dots + n^{\log_{b}(a)}\Theta(1) \\
			&= \sum_{i=0}^{\log_{b}(n)-1} ca^{i}\left(\frac{n}{b^{i}}\right)^{k} \log_{b}^{p}\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \log_{b}^{p}\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p} + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{k}\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p}. \]
			</div>
			
			<p>The series \(\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(j=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−j\). When \(i=0\), \(j=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(j=1\). Rewriting the summation in terms of \(j\), we have:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{k}}\right)^{i} \left(\log_{b}(n)-i\right)^{p} &= \sum_{j=1}^{\log_{b}(n)} \left(\frac{a}{b^{k}}\right)^{\log_{b}(n)-j} j^{p} \\
			&= \sum_{j=1}^{\log_{b}(n)} \frac{a^{\log_{b}(n)}}{\left(b^{\log_{b}(n)}\right)^{k}}\left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			&= \sum_{j=1}^{\log_{b}(n)} \frac{n^{\log_{b}(a)}}{n^{k}}\left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			&= \frac{n^{\log_{b}(a)}}{n^{k}}\sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= cn^{k}\frac{n^{\log_{b}(a)}}{n^{k}}\sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			&= cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p}. 
			\end{aligned}
			\]
			</div>
			
			<p>The series is classified as a polynomial-geometric series because the terms involve both a geometric factor \(\left(\frac{b^{k}}{a}\right)^{j}\) and a polynomial factor \(j^{p}\). Its growth rate depends on whether \(a\) is smaller, equal, or larger than \(b^{k}\). Consider these cases.</p>
		
			<p><b>Case 1: \(a \gt b^{k}\)</b>. Given the condition \(a \gt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \lt 1\). </p>
			
			<p>Since \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) is a partial sum of \(\sum_{j=1}^{\infty}r^{j} j^{p}\) which converges to a constant , it follows that</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \lt \sum_{j=1}^{\infty}r^{j} j^{p}. \]
			</div>
			
			<p>To prove that the series \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) for \(r \lt 1\) converges to a constant, we will use techniques from calculus, especially the concept of generating functions and differentiation.</p>
			
			<p>We begin with the basic geometric series:</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} r^{j} = \frac{r}{1-r}. \]
			</div>
			
			<p>The series converges to a constant for \(|x| \lt 1\).</p>
			
			<p>To find \(\sum_{j=1}^{\infty} jr^{j}\), we differentiate \(\sum_{j=1}^{\infty} r^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
            \[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{\infty} r^{j}\right) &= \frac{d}{dr}\left(\frac{r}{1-r}\right) \\
			\sum_{j=1}^{\infty} jr^{j-1} &= \frac{1}{(1-r)^{2}}. 
			\end{aligned}
			\]
            </div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} jr^{j} = \frac{r}{(1-r)^{2}}. \]
			</div>
			
			<p>This confirms that for \(p=1\), the series \(\sum_{j=1}^{\infty} jr^{j}\) converges to a constant, and it does not depend on \(n\).</p>
			
			<p>To find \(\sum_{j=1}^{\infty} j^{2}r^{j}\), we differentiate \(\sum_{j=1}^{\infty} jr^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{\infty} jr^{j}\right) &= \frac{d}{dr}\left(\frac{r}{(r-1)^{2}}\right) \\
			\sum_{j=1}^{\infty} j^{2}r^{j-1} &= \frac{r+1}{(1-r)^{3}}.
			\end{aligned} 
			\]
			</div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} j^{2}r^{j} = \frac{r(r+1)}{(1-r)^{3}}. \]
			</div>
			
			<p>This confirms that for \(p=2\), the series \(\sum_{j=1}^{\infty} j^{2}r^{j}\) converges to a constant, and it does not depend on \(n\).</p>
			
			<p>For a general \(p\), we can continue this differentiation process \(p\) times.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\infty} j^{p}r^{j} = \frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right). \]
			</div>
			
			<p>Therefore, based on the previous conclusion, the series \(\sum_{j=1}^{\infty} j^{2}r^{j}\) converges to a constant, and it does not depend on \(n\).</p>
			
			<p>Since each term in the series \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) is smaller than or equal to the first term,  it can serve as a good lower bound for the series.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \geq r. \]
			</div>
			
			<p>Thus, \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ r \leq \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \lt \sum_{j=1}^{\infty} j^{p}r^{j} = \frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right). \]
			</div>
			
			<p>Subtituting into \(g(n)\), where \(r=\frac{b^{k}}{a}\), yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			cn^{\log_{b}(a)}r &\leq& g(n) &\leq& cn^{\log_{b}(a)} \frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right) \\
			crn^{\log_{b}(a)} &\leq& g(n) &\leq& c\frac{d^{p}}{dr^{p}}\left(\frac{r}{1-r}\right)n^{\log_{b}(a)}. 
			\end{aligned} 
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned} 
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 2: \(a = b^{k}\) and \(p \gt -1\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a}=1\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p}. \]
			</div>
			
			<p>\(\sum_{j=1}^{\log_{b}(n)} j^{p}\) is a sum of powers of integers, and can be bounded both below and above using integral approximation:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\int_{j=0}^{\log_{b}(n)} j^{p} \, dj &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \int_{j=1}^{\log_{b}(n)+1} j^{p} \, dj \\
			\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}.
			\end{aligned} 
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} \\
			cn^{\log_{b}(a)} \frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}. 
			\end{aligned} 
			\]
            </div>
			
			<p>To factor out \(\log_{b}^{p+1}(n)\) from \(\left(\log_{b}(n)+1\right)^{p+1}\), we use the binomial expansion.</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\left(\log_{b}(n)+1\right)^{p+1} &= \sum_{k=0}^{p+1}\binom{p+1}{k} \log_{b}^{p+1-k}(n) \\
			&= \log_{b}^{p+1}(n) + (p+1)\log_{b}^{p}(n) + \frac{(p+1)p}{2}\log_{b}^{p-1}(n) + \cdots + 1 \\
			&= \log_{b}^{p+1}(n) \left(1 + (p+1)\frac{1}{\log_{b}(n)} + \frac{(p+1)p}{2}\frac{1}{\log_{b}^{2}(n)} + \cdots + \frac{1}{\log_{b}^{p+1}(n)}\right) \\
			&= \log_{b}^{p+1}(n)\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}. 
			\end{aligned} 
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& cn^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1}\sum_{k=0}^{p+1}\binom{p+1}{k}\frac{1}{\log_{b}^{k}(n)} \\
			c\frac{1}{p+1}n^{\log_{b}(a)}\log_{b}^{p+1}(n) &\leq& g(n) &\leq& c\frac{1}{p+1}\left(\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}\right)n^{\log_{b}(a)}\log_{b}^{p+1}(n). 
			\end{aligned} 
			\]
			</div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right).
			\end{aligned} 
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			
			<p><b>Case 3: \(a = b^{k}\) and \(p = -1\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a}=1\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j}. \]
			</div>
			
			<p>The expression \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\), representing a partial sum of the harmonic series.</p>
			
			<p>The harmonic series, represented by \(H_{n}=\sum_{k=1}^{n} \frac{1}{j}\), can be bounded both below and above as follows:</p> 
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\log_{2}(n+1) &\leq H_{n} \leq \log_{2}(n) + 1 \\
			\log_{2}(n) + \log_{2}\left(1+\frac{1}{n}\right) &\leq H_{n} \leq \log_{2}(n) + 1.
			\end{aligned} 
			\]
            </div>
			
			<p>where \(H_{n}\) is the \(n\)-th harmonic number.</p>
			
			<p>As a result, the partial sum of \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\) satisfies the inequality:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) \leq \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \leq \log_{2}(\log_{b}(n)) + 1. 
			\end{aligned} 
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \\
			cn^{\log_{b}(a)} \left(\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right)\right) &\leq& g(n) &\leq& cn^{\log_{b}(a)} \left(\log_{2}(\log_{b}(n)) + 1\right) \\
			cn^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + cn^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) &\leq& g(n) &\leq& cn^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + cn^{\log_{b}(a)} \\
			cn^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{2}(n)} + cn^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) &\leq& g(n) &\leq& cn^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{2}(n)} + cn^{\log_{b}(a)} \\
			c\frac{1}{\log_{2}(n)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + cn^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) &\leq& g(n) &\leq& c\frac{1}{\log_{2}(n)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + cn^{\log_{b}(a)}.
			\end{aligned} 
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). 
			\end{aligned} 
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p><b>Case 4: \(a = b^{k}\) and \(p \lt -1\)</b>. Given the condition \(a = b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a}=1\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p}. \]
			</div>
			
			<p>Let \(p=-s\), which simplifies the \(g(n)\) to</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{1}{j^{s}}. \]
			</div>
			
			<p>The series \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j^{s}}\) is a partial sum of the p-series.</p>
			
			<p>For \(s \gt 1\), the series \(\sum_{k=1}^{n} \frac{1}{k^{s}}\) converges and can be bounded above and below using integral approximation:</p> 
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\int_{1}^{\infty} \frac{1}{x^{s}} \, dx &\leq& \sum_{k=1}^{n} \frac{1}{k^{s}} &\leq& 1 + \int_{1}^{\infty} \frac{1}{x^{s}} \, dx \\
			\frac{1}{s-1} &\leq& \sum_{k=1}^{n} \frac{1}{k^{s}} &\leq& 1 + \frac{1}{s-1}.
			\end{aligned} 
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} j^{p} \\
			cn^{\log_{b}(a)}\frac{1}{s-1} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \left(1 + \frac{1}{s-1}\right) \\
			c\frac{1}{s-1}n^{\log_{b}(a)} &\leq& g(n) &\leq& c\left(1 + \frac{1}{s-1}\right)n^{\log_{b}(a)}.
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right).
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 5: \(a \lt b^{k}\) and \(p \gt 0\)</b>. Given the condition \(a \lt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \gt 1\).</p>
			
			<p>To find the sum \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) for \(r \gt 1\) and large \(n\), we will use techniques from calculus, especially the concept of generating functions and differentiation.</p>
			
			<p>We begin with the basic geometric series:</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} r^{j} = \frac{r\left(r^{t}-1\right)}{r-1}. \]
			</div>
			
			<p>For large \(t\), the sum of the geometric series can be approximated as follows</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} r^{j} = \frac{r\left(r^{t}-1\right)}{r-1} \lt \frac{r}{r-1}r^{t}. \]
			</div>
			
			<p>To find \(\sum_{j=1}^{t} jr^{j}\), we differentiate \(\sum_{j=1}^{t} r^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{t} r^{j}\right) &\lt \frac{d}{dr}\left(\frac{r}{r-1}r^{t}\right) \\
			\sum_{j=1}^{t} jr^{j-1} &\lt \left(\frac{1}{r-1}-\frac{1}{t(r-1)^{2}}\right)tr^{t}. 
			\end{aligned}
			\]
			</div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} jr^{j} \lt \left(\frac{r}{r-1}-\frac{r}{t(r-1)^{2}}\right)tr^{t}. \]
			</div>
			
			<p>To find \(\sum_{j=1}^{t} j^{2}r^{j}\), we differentiate \(\sum_{j=1}^{t} jr^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{t} jr^{j}\right) &\lt \frac{d}{dr}\left(\left(\frac{r}{r-1}-\frac{r}{t(r-1)^{2}}\right)tr^{t}\right) \\
			\sum_{j=1}^{t} j^{2}r^{j-1} &\lt \left(\frac{1}{r-1}-\frac{2}{t(r-1)^{2}}+\frac{r+1}{t^{2}(r-1)^{3}}\right)t^{2}r^{t}. 
			\end{aligned}
			\]
			</div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{t} j^{2}r^{j} \lt \left(\frac{r}{r-1}-\frac{2r}{t(r-1)^{2}}+\frac{r(r+1)}t^{2}{(r-1)^{3}}\right)t^{2}r^{t}. \]
			</div>
			
			<p>To find \(\sum_{j=1}^{t} j^{3}r^{j}\), we differentiate \(\sum_{j=1}^{t} jr^{j}\) with respect to \(r\):</p>

			<div class="equation-container">
			\[ 
			\begin{aligned}
			\frac{d}{dr}\left(\sum_{j=1}^{t} j^{2}r^{j}\right) &\lt \frac{d}{dr}\left(\left(\frac{r}{r-1}-\frac{2r}{t(r-1)^{2}}+\frac{r(r+1)}t^{2}{(r-1)^{3}}\right)t^{2}r^{t}\right) \\
			\sum_{j=1}^{t} j^{2}r^{j-1} &\lt \left(\frac{1}{r-1}-\frac{3}{t(r-1)^{2}}+\frac{3r(r+1)}{t^{2}(r-1)^{3}}-\frac{r^{2}+4r+1}{t^{3}(r-1)^{4}}\right)t^{3}r^{t}. 
			\end{aligned}
			\]
            </div>
			
			<p>Now, multiply both sides by \(r\)</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{j=1}^{t} j^{2}r^{j} &\lt \left(\frac{r}{r-1}-\frac{3r}{t(r-1)^{2}}+\frac{3r^{2}(r+1)}{t^{2}(r-1)^{3}}-\frac{r(r^{2}+4r+1)}{t^{3}(r-1)^{4}}\right)t^{3}r^{t}. 
			\end{aligned}
			\]
			</div>
			
			<p>For a general \(p\), we can continue this differentiation process \(p\) times.</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{j=1}^{t} j^{p}r^{j} &\lt \frac{d^{p}}{dr^{p}}\left(\frac{r}{r-1}r^{k}\right)
			&= t^{p}r^{t}L(r), 
			\end{aligned}
			\]
            </div>
			
			<p>where \(L(r)\) is a rational function.</p>
			
			<p>The function \(L(r)\) has the form</p>
			
			<div class="equation-container">
			\[ L(r) = \frac{N(r)}{t^{p}(r-1)^{p+1}}. \]
			</div>
			
			<p>where N(r) is a polynomial function.</p>
			
			<p>Therefore, let \(t=\log_{b}(n)\), which gives the upper bound:</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} j^{p}r^{j} \lt t^{p}r^{\log_{b}(n)}L(r). \]
			</div>
			
			<p>Since each term in the sum \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) is smaller than or equal to the last term, it can serve as a good lower bound for the series.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \geq r^{\log_{b}(n)} \log_{b}^{p}(n). \]
			</div>
			
			<p>Thus, \(\sum_{j=1}^{\log_{b}(n)} r^{j} j^{p}\) can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ r^{\log_{b}(n)} \log_{b}^{p}(n) \leq \sum_{j=1}^{\log_{b}(n)} r^{j} j^{p} \lt \log_{b}^{p}(n)r^{\log_{b}(n)}L(r). \]
			</div>
			
			<p>Subtituting into \(g(n)\), where \(r=\frac{b^{k}}{a}\), yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j} j^{p} \\
			cn^{\log_{b}(a)} \left(\frac{b^{k}}{a}\right)^{\log_{b}(n)} \log_{b}^{p}(n) &\leq& g(n) &\lt& cn^{\log_{b}(a)} \log_{b}^{p}(n)\left(\frac{b^{k}}{a}\right)^{\log_{b}(n)}L(r) \\
			cn^{\log_{b}(a)} \frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}} \log_{b}^{p}(n) &\leq& g(n) &\lt& cn^{\log_{b}(a)} \log_{b}^{p}(n)\frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}}L\left(\frac{b^{k}}{a}\right) \\
			cn^{\log_{b}(a)} \frac{n^{k}}{n^{\log_{b}(a)}} \log_{b}^{p}(n) &\lt& g(n) &\leq& cn^{\log_{b}(a)} \frac{n^{k}}{n^{\log_{b}(a)}}\log_{b}^{p}(n)L\left(\frac{b^{k}}{a}\right) \\
			cn^{k}\log_{b}^{p}(n) &\leq& g(n) &\lt& cL\left(\frac{b^{k}}{a}\right)n^{k}\log_{b}^{p}(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{k}\log_{b}^{p}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\log_{b}^{p}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{k}\log_{b}^{p}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\log_{b}^{p}(n)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\log_{b}^{p}(n)\right). \]
			</div>
			
			<p><b>Case 6: \(a \lt b^{k}\) and \(p \lt 0\)</b>. Given the condition \(a \lt b^{k}\), which implies that the ratio \(r=\frac{b^{k}}{a} \gt 1\).</p>
			
			<p>Let \(s=-p\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}}. \]
			</div>
			
			<p>Since \(\frac{r^{j}}{j^{s}} \leq r^{j}\), the series can be bounded above by a geometric series.</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}} &\leq \sum_{j=1}^{\log_{b}(n)} r^{j}
			&\lt \frac{r^{\log_{b}(n)+1}}{r-1}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since each term in the series \(\sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}}\) is smaller than or equal to the last term,  it can serve as a good lower bound for the sum.</p>
			
			<div class="equation-container">
			\[ \sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}} \geq \frac{r^{\log_{b}(n)}}{\log_{b}^{s}(n)}. \]
			</div>
			
			<p>Thus, \(\sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}}\) can be bounded both below and above as follows:</p>
			
			<div class="equation-container">
			\[ \frac{r^{\log_{b}(n)}}{\log_{b}^{s}(n)} \leq \sum_{j=1}^{\log_{b}(n)} \frac{r^{j}}{j^{s}} \lt \frac{r^{\log_{b}(n)+1}}{r-1}. \]
			</div>
			
			<p>Subtituting into \(g(n)\), where \(r=\frac{b^{k}}{a}\), yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j}\frac{1}{j^{s}} &\leq& g(n) &\leq& cn^{\log_{b}(a)} \sum_{j=1}^{\log_{b}(n)} \left(\frac{b^{k}}{a}\right)^{j}\frac{1}{j^{s}} \\
			cn^{\log_{b}(a)} \left(\frac{b^{k}}{a}\right)^{\log_{b}(n)}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \frac{\frac{b^{k}}{a}}{\frac{b^{k}}{a}-1}\left(\frac{b^{k}}{a}\right)^{\log_{b}(n)} \\
			cn^{\log_{b}(a)} \frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \frac{\frac{b^{k}}{a}}{\frac{b^{k}}{a}-1}\frac{\left(b^{\log_{b}(n)}\right)^{k}}{a^{\log_{b}(n)}} \\
			cn^{\log_{b}(a)} \frac{n^{k}}{n^{\log_{b}(a)}}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& cn^{\log_{b}(a)} \frac{\frac{b^{k}}{a}}{\frac{b^{k}}{a}-1}\frac{n^{k}}{n^{\log_{b}(a)}} \\
			cn^{k}\frac{1}{\log_{b}^{s}(n)} &\leq& g(n) &\lt& c\frac{b^{k}}{b^{k}-a}n^{k}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{k}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{k}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{k}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{k}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{k}\right). \]
			</div>
		</div>

		<h4 class="post-subtitle">General Version of Master Theorem</h4>
		
		<p>The general version of master theorem is a formula for analyzing the time complexity of divide-and-conquer recurrences of the form:</p>
		
		<div class="equation-container">
		\[ T(n) = aT(\frac{n}{b}) + f(n), \]
		</div>
		
		<p>where \(a \geq 1\) and \(b \geq 2\) with \(f\) asymptotically positive (Asymptotically positive mean that the function is positive for all sufficiently large \(n\)).</p>
		
		<p>This recurrence describes an algorithm that divides a problem of size \(n\) into a subproblems, each of size \(\frac{n}{b}\), and solves them recursively. Note that \(\frac{n}{b}\) might not be an integer, but replacing \(T\lceil(\frac{n}{b}\rceil)\) with \(T\lceil(\frac{n}{b}\rceil)\) or \(T\lceil(\lfloor\frac{n}{b}\rfloor\rceil)\) does not affect the asymptotic behavior of the recurrence. So we will just ignore floors and ceilings.</p>
		
		<p>The master theorem compares the function \(n^{\log_{b}(a)}\) to the function \(f(n)\). Intuitively, if \(n^{\log_{b}(a)}\) is larger (by a polynomial factor), then the solution is \(T(n) = \Theta(n^{\log_{b}(a)})\). If \(f(n)\) is larger (by a polynomial factor), then the solution is \(T(n) = \Theta(f(n))\). If they are the same size, then we multiply by a logarithmic factor.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\frac{n}{b}\right) + f(n), & \text{if } n \gt 1
			\end{cases}, \]
			</div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\frac{n}{b}\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>Consider the tree of recursive calls made by the algorithm:</p>
			<ul>
				<li>At level \(0\) (the root), there is one call with an input size of \(n\).  The time required for this call, excluding the time needed by the recursive calls it spawns (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(f(n)\).</li>
				<li>At level \(1\), The single call at level 0 spawns \(a\) recursive calls, each working on a subproblem of size \(\frac{n}{b}\). Each of these calls requires \(f\left(\frac{n}{b}\right)\) time, excluding their own recursive calls. The total time required at this level is therefore \(af\left(\frac{n}{b}\right)\).</li>
				<li>At level \(2\),  The \(a\) calls from level \(1\) each spawn \(a\) new calls, resulting in \(a^{2}\) calls at this level. Each of these calls works on an input of size \(\frac{n}{b^{2}}\).  The total time required at this level is \(a^{2}f\left(\frac{n}{b^{2}}\right)\).</li>
				<li>In general, at level \(i\), there are \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time required for all calls at this level is \(a^{i}f\left(\frac{n}{b^{i}}\right)\).</li>
				<li>This process continues until \(i = \lfloor\log_{b}(n)\rfloor\), where the input size reduces to \(1\). At this base case, the problem is small enough to be solved directly without further recursive calls.</li>
			</ul>
			
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= f(n) + aT(\frac{n}{b}) \\
			&= f(n) + a(f\left(\frac{n}{b}\right) + aT(\frac{n}{b^2})) = f(n) + af\left(\frac{n}{b}\right) + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + a^{\log_{b}(n)}T(1)  \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + n^{\log_{b}(a)}\Theta(1)  \\
			&= \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right). \]
			</div>
			
			<p><b>Case 1: \(f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right)\)</b>. Since we have \(f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = O\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)-\epsilon}\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}O\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)-\epsilon}\right). \]
			</div>
			
			<p>Using the meaning of the \(O\)-notation, there exist constants \(c \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\leq \sum_{i=0}^{\log_{b}(n)-1} a^{i}c\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)-\epsilon} \\
			&= cn^{\log_{b}(a)-\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{a}{b^{\log_{b}(a)-\epsilon}}\right)^{i} \\
			&= cn^{\log_{b}(a)-\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{ab^{\epsilon}}{b^{\log_{b}(a)}}\right)^{i} \\
			&= cn^{\log_{b}(a)-\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(b^{\epsilon}\right)^{i}. 
			\end{aligned}
			\]
            </div>
			
			<p>\(\sum_{i=0}^{\log_{b}(n)-1} \left(b^{\epsilon}\right)^{i}\) is a geometric series with the common ratio \(b^{\epsilon}\) which grows exponentially, and can be bounded above as follows:</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			\sum_{i=0}^{\log_{b}(n)-1} \left(b^{\epsilon}\right)^{i} &\leq \frac{\left(b^{\epsilon}\right)^{\log_{b}(n)}}{b^{\epsilon}-1} \\
			&= \frac{n^{\epsilon}}{b^{\epsilon}-1}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &\leq cn^{\log_{b}(a)-\epsilon}\frac{n^{\epsilon}}{b^{\epsilon}-1} \\
			&= c\frac{1}{b^{\epsilon}-1}n^{\log_{b}(a)}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded above by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = O\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= O\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p><b>Case 2: \(f(n) = \Theta\left(n^{\log_{b}(a)}\right)\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)}\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)}\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} 1 &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} 1 \\
			c_{1}n^{\log_{b}(a)}\log_{b}(n) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\log_{b}(n).
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(n)\right). \]
			</div>
			
			
			<p><b>Case 3: \(f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right)\)</b>. Since we have \(f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Omega\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)+\epsilon}\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Omega\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)+\epsilon}\right). \]
			</div>
			
			<p>Using the meaning of the \(\Omega\)-notation, there exist constants \(c \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\geq \sum_{i=0}^{\log_{b}(n)-1} a^{i}c\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)+\epsilon} \\
			&= cn^{\log_{b}(a)+\epsilon} \sum_{i=0}^{\log_{b}(n)-1} a^{i}\left(\frac{1}{b^{\log_{b}(a)+\epsilon}}\right)^{i} \\
			&= cn^{\log_{b}(a)+\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{1}{b^{\epsilon}}\right)^{i}. 
			\end{aligned}
			\]
            </div>
			
			<p>\(\sum_{i=0}^{\lfloor\log_{b}(n)\rfloor-1} \left(\frac{1}{b^{\epsilon}}\right)^{i}\) is a geometric series with the common ratio \(\frac{1}{b^{\epsilon}}\) which decays exponentially, and can be bounded below as follows:</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{\lfloor\log_{b}(n)\rfloor-1} \left(\frac{1}{b^{\epsilon}}\right)^{i} \geq 1. \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\geq cn^{\log_{b}(a)+\epsilon} \sum_{i=0}^{\log_{b}(n)-1} \left(\frac{1}{b^{\epsilon}}\right)^{i} \\
			&= cn^{\log_{b}(a)+\epsilon}. 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded below by constant multiples of \(f(n)=n^{\log_{b}(a)+\epsilon}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Omega\left(f(n)\right). \]
			</div>
			
			<p>Since \(af\left(\frac{n}{b}\right) \leq cf(n)\), it follows that \(f\left(\frac{n}{b}\right) \leq \frac{c}{a}f(n)\).</p>
			
			<p>Now, iterate the recurrence</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			f\left(\frac{n}{b^{2}}\right) &\leq \frac{c}{a}f\left(\frac{n}{b}\right) \\
			&\leq \frac{c}{a}\cdot\frac{c}{a}f(n) \\
			&= \left(\frac{c}{a}\right)^{2}f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Iterate the recurrence once more</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			f\left(\frac{n}{b^{3}}\right) &\leq \frac{c}{a}f\left(\frac{n}{b^{2}}\right) \\
			&\leq \frac{c}{a}\cdot\left(\frac{c}{a}\right)^{2}f(n) \\
			&= \left(\frac{c}{a}\right)^{3}f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>By continuing this process, after \(i\) iterations, we have:</p>
			
			<div class="equation-container">
			\[ f\left(\frac{n}{b^{i}}\right) \leq \left(\frac{c}{a}\right)^{i}f(n). \]
			</div>
			
			<p>Thus, we have:</p>
			
			<div class="equation-container">
			\[ a^{i}f\left(\frac{n}{b^{i}}\right) \leq c^{i}f(n). \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right) \\
			&\leq \sum_{i=0}^{\log_{b}(n)-1} c^{i}f(n) \\
			&= f(n)\sum_{i=0}^{\log_{b}(n)-1} c^{i}. 
			\end{aligned}
			\]
            </div>
			
			<p>\(\sum_{i=0}^{\lfloor\log_{b}(n)\rfloor-1} c^{i}\) is a geometric series with the common ratio \(b^{\epsilon}\) which decays exponentially because \(c \lt 1\), and can be bounded above as follows:</p>
			
			<div class="equation-container">
			\[ f(n)\sum_{i=0}^{\log_{b}(n)-1} c^{i} \leq f(n)\frac{1}{1-c}. \]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			g(n) &\leq f(n)\frac{1}{1-c} \\
			&= \frac{1}{1-c}f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above by constant multiples of \(f(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = O\left(f(n)\right). \]
			</div>
			
			<p>We have \(g(n) = \Omega\left(f(n)\right)\) and \(g(n) = O\left(f(n)\right)\), which implies that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(f(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(f(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(f(n)\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(f(n)\right). \]
			</div>
		</div>

		<p>In the Master Theorem, as given above, there is a gap between cases 1 and 2, and a gap between cases 2 and 3.</p>
		
		<p>The recurrence</p>
		
		<div class="equation-container">
		\[ T(n) = 2T(\frac{n}{2}) + n\log_{2}(n), \]
		</div>
		
		<p>and</p>
		
		<div class="equation-container">
		\[ T(n) = 2T(\frac{n}{2}) + \frac{n}{\log_{2}(n)} \]
		</div>
		
		<p>does not exactly fit the form of the master theorem above.</p>
		
		<p> The Master Theorem works well when \(f(n)\) is a simple polynomial function, like \(n^{d}\), but in this case, \(f(n)=n\log_{2}(n)\) involves both a polynomial part and a logarithmic factor, which is more complicated.</p>
		
		<p>To handle recurrences like this, we need to use an extension of case 2 of the Master Theorem, known as the Generalized Master Theorem or Extended Master Theorem, which can handle additional logarithmic factors.</p>
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be integer constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\frac{n}{b}\right) + f(n), & \text{if } n \gt 1
			\end{cases}. \]
			</div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)} \log_{b}^{k+1}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right) \text{ and } k \gt -1 \\
			\Theta(n^{\log_{b}(a)} \log_{b}(\log_{b}(n))), & \text{if } f(n) = \Theta(n^{\log_{b}(a)} \log_{b}^{k}(n)) \text{ and } k = -1 \\
			\Theta(n^{\log_{b}(a)}), & \text{if } f(n) = \Theta(n^{\log_{b}(a)} \log_{b}^{k}(n)) \text{ and } k \lt -1
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>Consider the tree of recursive calls made by the algorithm:</p>
			<ul>
				<li>At level \(0\) (the root), there is one call with an input size of \(n\).  The time required for this call, excluding the time needed by the recursive calls it spawns (i.e., the time to divide up its input and to combine the results of the calls it makes), is \(f(n)\).</li>
				<li>At level \(1\), The single call at level 0 spawns \(a\) recursive calls, each working on a subproblem of size \(\frac{n}{b}\). Each of these calls requires \(f\left(\frac{n}{b}\right)\) time, excluding their own recursive calls. The total time required at this level is therefore \(af\left(\frac{n}{b}\right)\).</li>
				<li>At level \(2\),  The \(a\) calls from level \(1\) each spawn \(a\) new calls, resulting in \(a^{2}\) calls at this level. Each of these calls works on an input of size \(\frac{n}{b^{2}}\).  The total time required at this level is \(a^{2}f\left(\frac{n}{b^{2}}\right)\).</li>
				<li>In general, at level \(i\), there are \(a^{i}\) calls, each working on an input of size \(\frac{n}{b^{i}}\). The total time required for all calls at this level is \(a^{i}f\left(\frac{n}{b^{i}}\right)\).</li>
				<li>This process continues until \(i = \lfloor\log_{b}(n)\rfloor\), where the input size reduces to \(1\). At this base case, the problem is small enough to be solved directly without further recursive calls.</li>
			</ul>
			
			<p>Thus, the total time required for all the calls at all levels is:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= f(n) + aT(\frac{n}{b}) \\
			&= f(n) + a(f\left(\frac{n}{b}\right) + aT(\frac{n}{b^2})) = f(n) + af\left(\frac{n}{b}\right) + a^{2}T(\frac{n}{b^2}) \\
			\vdots \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + a^{\log_{b}(n)}T(1) \\
			&= f(n) + af\left(\frac{n}{b}\right) + a^{2}f\left(\frac{n}{b^{2}}\right) + \dots + n^{\log_{b}(a)}\Theta(1)  \\
			&= \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right) + \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Let</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}f\left(\frac{n}{b^{i}}\right). \]
			</div>
			
			<p><b>Case 2a: \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\) and \(k \gt -1\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} \left(\log_{b}(n)-i\right)^{k} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{\left(b^{\log_{b}(a)}\right)^{i}} \left(\log_{b}(n)-i\right)^{k} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} \left(\log_{b}(n)-i\right)^{k} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} a^{i}\frac{1}{a^{i}} \left(\log_{b}(n)-i\right)^{k} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k}.
			\end{aligned}
			\]
            </div>
			
			<p>The expression \(\sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(j=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−j\). When \(i=0\), \(j=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(j=1\). Rewriting the summation in terms of \(j\), we have:</p>
			
			<div class="equation-container">
			\[ \sum_{i=0}^{\log_{b}(n)-1} \left(\log_{b}(n)-i\right)^{k} = \sum_{j=1}^{\log_{b}(n)} j^{p}. \]
			</div>
			
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p} \leq g(n) \leq c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p}.
			\]
            </div>
			
			<p>\(\sum_{j=1}^{\log_{b}(n)} j^{p}\) is a sum of powers of integers, and can be bounded both below and above using integral approximation:</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\int_{j=0}^{\log_{b}(n)} j^{p} \, dj &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \int_{j=1}^{\log_{b}(n)+1} j^{p} \, dj \\
			\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& \sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& \frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}.
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} j^{p} \\
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1}. 
			\end{aligned}
			\]
            </div>
			
			<p>To factor out \(\log_{b}^{p+1}(n)\) from \(\left(\log_{b}(n)+1\right)^{p+1}\), we use the binomial expansion.</p>
			
			<div class="equation-container">
        	\[ 
			\begin{aligned}
			\left(\log_{b}(n)+1\right)^{p+1} &= \sum_{k=0}^{p+1}\binom{p+1}{k} \log_{b}^{p+1-k}(n) \\
			&= \log_{b}^{p+1}(n) + (p+1)\log_{b}^{p}(n) + \frac{(p+1)p}{2}\log_{b}^{p-1}(n) + \cdots + 1 \\
			&= \log_{b}^{p+1}(n) \left(1 + (p+1)\frac{1}{\log_{b}(n)} + \frac{(p+1)p}{2}\frac{1}{\log_{b}^{2}(n)} + \cdots + \frac{1}{\log_{b}^{p+1}(n)}\right) \\
			&= \log_{b}^{p+1}(n)\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}. 
			\end{aligned}
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\frac{\left(\log_{b}(n)+1\right)^{p+1}}{p+1} \\
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}^{p+1}(n)}{p+1} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\log_{b}^{p+1}(n)\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)} \\
			c_{1}\frac{1}{p+1}n^{\log_{b}(a)}\log_{b}^{p+1}(n) &\leq& g(n) &\leq& c_{2}\left(\sum_{k=0}^{p+1}\binom{p+1}{k} \frac{1}{\log_{b}^{k}(n)}\right)n^{\log_{b}(a)}\log_{b}^{p+1}(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}^{p+1}(n)\right). \]
			</div>
			
			<p><b>Case 2b: \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\) and \(k=-1\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ g(n) = \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right). \]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \frac{1}{\log_{b}(n)-i} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \frac{1}{\log_{b}(n)-i} \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}(n)-i} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}(n)-i} \\
			c_{1}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i}.
			\end{aligned}
			\]
            </div>
			
			<p>The series \(\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(j=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−j\). When \(i=0\), \(j=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(j=1\). Rewriting the summation in terms of \(j\), we have:</p>
			
			<div class="equation-container">
            \[
			\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\log_{b}(n)-i} = \sum_{j=1}^{\log_{b}(n)} \frac{1}{j}.
			\]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \leq g(n) \leq c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}.
			\]
            </div>
			
			<p>The series \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\) is a partial sum of the harmonic series.</p>
			
			<p>The harmonic series, represented by \(H_{n}=\sum_{j=1}^{n} \frac{1}{j}\), can be bounded as follows:</p> 
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\log_{2}(n+1) &\leq& H_{n} &\leq& \log_{2}(n) + 1 \\
			\log_{2}(n) + \log_{2}\left(1+\frac{1}{n}\right) &\leq& H_{n} &\leq& \log_{2}(n) + 1.
			\end{aligned}
			\]
            </div>
			
			<p>where \(H_{n}\) is the \(n\)-th harmonic number.</p>
			
			<p>As a result, the partial sum of \(\sum_{j=1}^{\log_{b}(n)} \frac{1}{j}\) satisfies the inequality:</p>
			
			<div class="equation-container">
			\[
			\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right) \leq \sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \leq \log_{2}(\log_{b}(n)) + 1. 
			\]
			</div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j} &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\sum_{j=1}^{\log_{b}(n)} \frac{1}{j} \\ 
			c_{1}n^{\log_{b}(a)}\left(\log_{2}(\log_{b}(n)) + \log_{2}\left(1+\frac{1}{\log_{b}(n)}\right)\right) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\left(\log_{2}(\log_{b}(n)) + 1\right) \\
			c_{1}n^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + c_{1}n^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{b}(\log_{b}(n))}\right) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\log_{2}(\log_{b}(n)) + c_{2}n^{\log_{b}(a)} \\
			c_{1}n^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{b}(2)} + c_{1}n^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{2}(\log_{b}(n))}\right) &\leq& g(n) &\leq& c_{2}n^{\log_{b}(a)}\frac{\log_{b}(\log_{b}(n))}{\log_{b}(2)} + c_{2}n^{\log_{b}(a)} \\
			c_{1}\frac{1}{\log_{b}(2)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + c_{1}n^{\log_{b}(a)}\log_{2}\left(1+\frac{1}{\log_{2}(\log_{b}(n))}\right) &\leq& g(n) &\leq& c_{2}\frac{1}{\log_{b}(2)}n^{\log_{b}(a)}\log_{b}(\log_{b}(n)) + c_{2}n^{\log_{b}(a)}.
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\log_{b}(\log_{b}(n))\right). \]
			</div>
			
			<p><b>Case 2c: \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\) and \(k \lt -1\)</b>. Since we have \(f(n) = \Theta\left(n^{\log_{b}(a)} \log_{b}^{k}(n)\right)\), which implies that \(f\left(\frac{n}{b^{i}}\right) = \Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right)\). Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
			\[ 
			\begin{aligned}
			g(n) &= \sum_{i=0}^{\log_{b}(n)-1} a^{i}\Theta\left(\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right)\right). 
			\end{aligned}
			\]
			</div>
			
			<p>Using the meaning of the \(\Theta\)-notation, there exist constants \(c_{1} \gt 0\), \(c_{2} \gt 0\) and \(n_{0} \gt 0\) such that for all \(n \geq n_{0}\):</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right) &\leq g(n) &\leq \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\left(\frac{n}{b^{i}}\right)^{\log_{b}(a)} \log_{b}^{k}\left(\frac{n}{b^{i}}\right).
			\end{aligned}
			\]
            </div>
			
			<p>Let \(k=-r\), which simplifies the \(g(n)\) to</p>
			
			<div class="equation-container">
            \[
			\begin{aligned} 
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \log_{b}^{-r}\left(\frac{n}{b^{i}}\right) &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}\frac{n^{\log_{b}(a)}}{\left(b^{\log_{b}(a)}\right)^{i}} \log_{b}^{-r}\left(\frac{n}{b^{i}}\right) \\
			\sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{1}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}^{r}\left(\frac{n}{b^{i}}\right)} &\leq& g(n) &\leq& \sum_{i=0}^{\log_{b}(n)-1} a^{i}c_{2}n^{\log_{b}(a)}\frac{1}{a^{i}} \frac{1}{\log_{b}^{r}\left(\frac{n}{b^{i}}\right)} \\
			c_{1}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} &\leq& g(n) &\leq&  c_{2}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} \\
			c_{1}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} &\leq& g(n) &\leq&  c_{2}n^{\log_{b}(a)} \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}}.
			\end{aligned}
			\]
            </div>
			
			<p>The expression \(\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}}\) can be simplified by reindexing the terms to make the summation easier to analyze. Define \(k=\log_{b}(n)−i\), which implies \(i=\log_{b}(n)−k\). When \(i=0\), \(k=\log_{b}(n)\), and when \(i=\log_{b}(n)-1\), \(k=1\). Rewriting the summation in terms of \(k\), we have:</p>
			
			<div class="equation-container">
            \[
			\sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} = \sum_{k=1}^{\log_{b}(n)} \frac{1}{k^{r}}.
			\]
            </div>
			
			<p>The series \(\sum_{k=1}^{\log_{b}(n)} \frac{1}{k^{r}}\) is a partial sum of the p-series.</p>
			
			<p>For \(r \gt 1\), the p-series, represented by \(\sum_{k=1}^{n} \frac{1}{k^{r}}\), converges and can be bounded above and below using integral approximation:</p> 
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			\int_{k=1}^{\infty} \frac{1}{k^r} \, dk &\leq& \sum_{k=1}^{n} \frac{1}{k^{r}} &\leq& 1 + \int_{k=1}^{\infty} \frac{1}{k^{r}} \, dk \\
			\frac{1}{r-1} &\leq& \sum_{k=1}^{n} \frac{1}{k^{r}} &\leq& 1 + \frac{1}{r-1}.
			\end{aligned}
			\]
            </div>
			
			<p>As a result, the partial sum of \(\sum_{k=1}^{\log_{b}(n)} \frac{1}{k^{r}}\) satisfies the inequality:</p>
			
			<div class="equation-container">
            \[ \frac{1}{r-1} \leq \sum_{i=0}^{\log_{b}(n)-1} \frac{1}{\left(\log_{b}(n)-i\right)^{r}} \leq 1 + \frac{1}{r-1}. \]
            </div>
			
			<p>Subtituting into \(g(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			c_{1}n^{\log_{b}(a)} \frac{1}{r-1} &\leq& g(n) &\leq&  c_{2}n^{\log_{b}(a)} \left(1 + \frac{1}{r-1}\right) \\
			c_{1}\frac{1}{r-1} n^{\log_{b}(a)} &\leq& g(n) &\leq& c_{2}\left(1 + \frac{1}{r-1}\right)n^{\log_{b}(a)}.
			\end{aligned}
			\]
            </div>
			
			<p>Since \(g(n)\) is bounded both above and below by constant multiples of \(n^{\log_{b}(a)}\), we can conclude that</p>
			
			<div class="equation-container">
			\[ g(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
			
			<p>Subtituting into \(T(n)\) yields</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			T(n) &= \Theta\left(n^{\log_{b}(a)}\right) + \Theta\left(n^{\log_{b}(a)}\right) \\
			&= \Theta\left(n^{\log_{b}(a)}\right). 
			\end{aligned}
			\]
            </div>
			
			<p>Thus, the asymptotic growth of \(T(n)\) is</p>
			
			<div class="equation-container">
			\[ T(n) = \Theta\left(n^{\log_{b}(a)}\right). \]
			</div>
		</div>

		<p>In the preceding analysis we assumed that the input size \(n\) is a positive integer that is a power of \(b \gt 1\), and therefore that \(b\) is also an integer. It turns out that, essentially, the Master Theorem holds even if \(n\) is not necessarily a power of \(b\) and \(b \gt 1\) is a real number, not necessarily an integer. If \(n\) is not a power of \(b\), however, the previous recurrence expression is not a legitimate recurrence: sooner or later as we keep dividing the input size by \(b\) we will end up with a non-natural number and then the recurrence is not defined.</p>
		
		<p>In general, a divide-and-conquer algorithm breaks a problem of size \(n\) into a subproblems, \(a_{1}\) of which have size \(\lceil \frac{n}{b} \rceil\) and \(a_{2}\) have size \(\lfloor \frac{n}{b} \rfloor\), for some non-negative integers \(a_{1}\) and \(a_{2}\) such that \(a_{1} + a_{2} = a\). Thus, the following recurrence describes the running time of such an algorithm, when \(n\) is not necessarily a power of \(b\), and \(b \gt 1\) is not necessarily an integer.</p>
		
		<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			a_{1}T\left(\lceil \frac{n}{b} \rceil\right) + a_{2}T\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \gt 1,
			\end{cases} \]
        </div>
		
		<p>where \(a_{1}\), \(a_{2}\) are non-negative integers such that \(a_{1} + a_{2} = a\).</p>
		
		<p>or</p>
		
		<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } 1 \leq n \leq \frac{b}{b-1} \\
			aT\left(\lceil \frac{n}{b} \rceil\right) + f(n), & \text{if } n \geq \frac{b}{b-1},
			\end{cases} \]
        </div>
		
		<p>or</p>
		
		<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } 1 \leq n \leq \frac{b}{b-1} \\
			aT\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \geq \frac{b}{b-1}.
			\end{cases} \]
        </div>
			
		<p>We need to extend our analysis to allow situations in which floors and ceilings appear in the master recurrence.</p>
		
		<div class="theorem">
			<p>Let \(a_{1} + a_{2} = a \geq 1\) and \(b \gt 1\) be real constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
            \[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			a_{1}T\left(\lceil \frac{n}{b} \rceil\right) + a_{2}T\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \gt 1.
			\end{cases} \]
            </div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>The monotonicity property allows us to apply techniques like induction to prove bounds for \(T(n)\).</p>
			
			<div class="equation-container">
			\[ T(a) \leq T(b) \text{ for any } a \leq b \]
			</div>
			
			<p>The running time \(T(a)\) represents the worst-case running time for a problem of size \(a\) and \(T(b)\) represents the worst-case running time for a problem of size \(b\).</p>
			
			<p>Every input of size \(a\) can be seen as a part (or subset) of the inputs of size \(b\), because if \(a \leq b\), any instance of the problem that can be solved for \(a\)-sized inputs can also be considered a part of the problem for \(b\)-sized inputs.</p>
			
			<p>For example, if a problem involves sorting an array, the set of possible arrays of size \(a\) is a subset of the set of possible arrays of size \(b\) when \(a \lt b\).</p>
			
			<p>Therefore, the worst-case running time for the smaller problem (size \(a\)) is essentially a subset of the worst-case running time for the larger problem (size \(b\)). In other words, the worst-case scenario for a problem of size \(a\) will not exceed the worst-case scenario for a problem of size \(b\).</p>
			
			<p>Since \(\lfloor\frac{n}{b}\rfloor \leq \lceil\frac{n}{b}\rceil \lt \frac{n}{b} + 1\), we replace \(\lfloor\frac{n}{b}\rfloor\) with \(\lceil\frac{n}{b}\rceil\) in the recurrence relation because \(\lceil\frac{n}{b}\rceil\) is larger, ensuring an upper bound on the running time. Furthermore, the size of \(\lceil\frac{n}{b}\rceil\) can be bounded by \(\frac{n}{b} + 1\). This simplification helps establish a tighter upper bound for analyzing the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) \leq (a_{1} + a_{2})T(\lceil\frac{n}{b}\rceil) + f(n) \lt (a_{1} + a_{2})T(\frac{n}{b} + 1) + f(n). \]
			</div>
			
			<p>To simplify the recurrence and analyze it more effectively, we apply the change-of-function trick by defining a new function:</p>
			
			<div class="equation-container">
			\[ S(n) = T(n+l). \]
			</div>
			
			<p>This simplifies the recurrence:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			S(n) &= T(n+l) \\
			&\leq (a_{1} + a_{2})T(\frac{n+b}{b} + 1) + f(n) \\
			&= (a_{1} + a_{2})T(\frac{n}{b} + 2) + f(n) \\
			&= (a_{1} + a_{2})S(\frac{n}{b}) + f(n) \\
			&= aS(\frac{n}{b}) + f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Summarizing the above inequalities we have</p>
			
			<div class="equation-container">
			\[ S(n) \leq aS(\frac{n}{b}) + f(n). \]
			</div>
			
			<p>Applying this inequality repeatedly, and using the geometric series formulas as in the proof of previous theorem we get that</p>
			
			<div class="equation-container">
            \[ S(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n.
			\end{cases} \]
            </div>
			
			<p>By definition of \(S\), \( T(n) = S(n-l) \). Therefore </p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(\left(n-l\right)^{\log_{b}(a)-\epsilon}\right) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(\left(n-l\right)^{\log_{b}(a)} \log_{b}\left(n-l\right)\right) = \Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n-l)) = \Theta(f(n)), & \text{if } f(n) = \Omega\left(\left(n-l\right)^{\log_{b}(a)+\epsilon}\right) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be real constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\lceil \frac{n}{b} \rceil\right) + f(n), & \text{if } n \gt 1
			\end{cases}.
			\]
            </div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n.
			\end{cases} \]
            </div>
		</div>

		<div class="proof">
			<p>The monotonicity property allows us to apply techniques like induction to prove bounds for \(T(n)\).</p>
			
			<div class="equation-container">
			\[ T(a) \leq T(b) \text{ for any } a \leq b \]
			</div>
			
			<p>Since \(\lceil\frac{n}{b}\rceil \lt \frac{n}{b} + 1\), the size of \(\lceil\frac{n}{b}\rceil\) can be bounded by \(\frac{n}{b} + 1\). This simplification helps establish a tighter upper bound for analyzing the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) \leq aT(\lceil\frac{n}{b}\rceil) + f(n) \lt aT(\frac{n}{b} + 1) + f(n). \]
			</div>
			
			<p>To simplify the recurrence and analyze it more effectively, we apply the change-of-function trick by defining a new function:</p>
			
			<div class="equation-container">
			\[ S(n) = T(n+l). \]
			</div>
			
			<p>This simplifies the recurrence:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			S(n) &= T(n+l) \\
			&\leq aT(\frac{n+b}{b} + 1) + f(n) \\
			&= aT(\frac{n}{b} + 2) + f(n) \\
			&= aS(\frac{n}{b}) + f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Summarizing the above inequalities we have</p>
			
			<div class="equation-container">
            \[ S(n) \leq aS(\frac{n}{b}) + f(n). \]
            </div>
			
			<p>Applying this inequality repeatedly, and using the geometric series formulas as in the proof of previous theorem we get that</p>
			
			<div class="equation-container">
            \[ S(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
			
			<p>By definition of \(S\), \( T(n) = S(n-l) \). Therefore </p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(\left(n-l\right)^{\log_{b}(a)-\epsilon}\right) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(\left(n-l\right)^{\log_{b}(a)} \log_{b}\left(n-l\right)\right) = \Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n-l)) = \Theta(f(n)), & \text{if } f(n) = \Omega\left(\left(n-l\right)^{\log_{b}(a)+\epsilon}\right) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>
		
		
		<div class="theorem">
			<p>Let \(a \geq 1\) and \(b \gt 1\) be real constants, and let \(f(n)\) be an asymptotically positive function. Suppose \(T(n)\) is defined for the positive real to satisfy the recurrence</p>
			
			<div class="equation-container">
			\[ T(n) = 
			\begin{cases} 
			\Theta(1), & \text{if } n = 1 \\
			aT\left(\lfloor \frac{n}{b} \rfloor\right) + f(n), & \text{if } n \gt 1
			\end{cases}.
			\]
            </div>
				
			<p>Then the growth of \(T(n)\) can be asymptotically determined under the following assumptions</p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lfloor \frac{n}{b} \rfloor\right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<div class="proof">
			<p>The monotonicity property allows us to apply techniques like induction to prove bounds for \(T(n)\).</p>
			
			<div class="equation-container">
			\[ T(a) \leq T(b) \text{ for any } a \leq b \]
			</div>
			
			<p>Since \(\lfloor\frac{n}{b}\rfloor \leq \lceil\frac{n}{b}\rceil \lt \frac{n}{b} + 1\), we replace \(\lfloor\frac{n}{b}\rfloor\) with \(\lceil\frac{n}{b}\rceil\) in the recurrence relation because \(\lceil\frac{n}{b}\rceil\) is larger, ensuring an upper bound on the running time. Furthermore, the size of \(\lceil\frac{n}{b}\rceil\) can be bounded by \(\frac{n}{b} + 1\). This simplification helps establish a tighter upper bound for analyzing the recurrence.</p>
			
			<div class="equation-container">
			\[ T(n) \leq aT(\lceil\frac{n}{b}\rceil) + f(n) \lt aT(\frac{n}{b} + 1) + f(n). \]
			</div>
			
			<p>To simplify the recurrence and analyze it more effectively, we apply the change-of-function trick by defining a new function:</p>
			
			<div class="equation-container">
			\[ S(n) = T(n+l). \]
			</div>
			
			<p>This simplifies the recurrence:</p>
			
			<div class="equation-container">
            \[ 
			\begin{aligned}
			S(n) &= T(n+l) \\
			&\leq aT(\frac{n+b}{b} + 1) + f(n) \\
			&= aT(\frac{n}{b} + 2) + f(n) \\
			&= aS(\frac{n}{b}) + f(n). 
			\end{aligned}
			\]
            </div>
			
			<p>Summarizing the above inequalities we have</p>
			
			<div class="equation-container">
			\[ S(n) \leq aS(\frac{n}{b}) + f(n). \]
			</div>
			
			<p>Applying this inequality repeatedly, and using the geometric series formulas as in the proof of previous theorem we get that</p>
			
			<div class="equation-container">
            \[ S(n) =
			\begin{cases}
			\Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n)), & \text{if } f(n) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
			
			<p>By definition of \(S\), \( T(n) = S(n-l) \). Therefore </p>
			
			<div class="equation-container">
            \[ T(n) =
			\begin{cases}
			\Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right), & \text{if } f(n) = O\left(\left(n-l\right)^{\log_{b}(a)-\epsilon}\right) = O\left(n^{\log_{b}(a)-\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \\
			\Theta\left(\left(n-l\right)^{\log_{b}(a)} \log_{b}\left(n-l\right)\right) = \Theta\left(n^{\log_{b}(a)} \log_{b}(n)\right), & \text{if } f(n) = \Theta\left(\left(n-l\right)^{\log_{b}(a)}\right) = \Theta\left(n^{\log_{b}(a)}\right) \\
			\Theta(f(n-l)) = \Theta(f(n)), & \text{if } f(n) = \Omega\left(\left(n-l\right)^{\log_{b}(a)+\epsilon}\right) = \Omega\left(n^{\log_{b}(a)+\epsilon}\right) \text{ for some constant } \epsilon \gt 0 \text{ and } af\left(\lceil \frac{n}{b} \rceil \right) \leq cf(n) \text{ for some constant } c \lt 0 \text{ and sufficiently large } n
			\end{cases}. \]
            </div>
		</div>

		<h4 class="post-subtitle">Limitations of Master Theorem</h4>
		
		<p>For master theorem to work:</p>
		
		<ul>
			<li>The Master Theorem only applies to recurrence relations of the form \(T(n) = aT(\frac{n}{b}) + f(n)\). It cannot be used for other forms of recurrence relations.</li>
			<li>The parameters \(a\) and \(b\) must be positive and greater than one. The theorem is not applicable if \(a \leq 0\) or \(b \leq 1\).</li>
			<li>The function \(f(n)\) must be asymptotically positive. If \(f(n)\) is not positive for large \(n\), the theorem cannot be applied.</li>
			<li>The Master Theorem is less effective for non-polynomial \(f(n)\). If \(f(n)\) does not fit into a polynomial form, the theorem might not provide a straightforward solution.</li>
			<li>The theorem assumes that the problem size is reduced by a constant factor \(b\). It cannot handle cases where the subdivision factor \(b\) varies with \(n\).</li>
		</ul>
		
		<h4 class="post-subtitle">Examples</h4>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{2}) + n^{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n^{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(3)}=n^{1.585}\). Since \(f(n)=n^{2}\) is asymptotically larger than \(n^{log_{b}(a)}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=3\), \(b=2\), and \(f(n)=n^{2}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				3\left(\frac{n}{2}\right)^{2} &\leq cn^{2}  \\
				\frac{3n^{2}}{4} &\leq cn^{2}  \\
				\frac{3}{4} &\leq c  \\
				c &\geq \frac{3}{4}
				\end{aligned}
				\]
                </div>
				
				<p>Therefore, the inequality holds for any \(c\) such that \(\frac{3}{4} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 4T(\frac{n}{2}) + n^{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=4\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n^{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(4)}=n^{2}\). Since \(f(n)=n^{2}\) is asymptotically equal to \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 2 of the General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}\log_{b}(n)). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = T(\frac{n}{2}) + 2^{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=1\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=2^{n}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(1)}=1\). Since \(f(n)=2^{n}\) is asymptotically faster than \(n^{log_{b}(a)}=1\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=1\), \(b=2\), and \(f(n)=2^{n}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				2^{\frac{n}{2}} &\leq c2^{n}  \\
				2^{-\frac{n}{2}} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>As \(n\) becomes large, \(2^{-\frac{n}{2}}\) approaches \(0\). Therefore, the inequality holds for any \(c\) such that \(0 \lt c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(2^{n}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2^{n}T(\frac{n}{2}) + n^{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>The Master Theorem cannot be applied directly to this recurrence because:</p>
				
				<ul>
					<li>\(a=2^{n}\) is not a constant.</li>
					<li>\(f(n)=n^{n}\) grows super-exponentially, which is much faster than any polynomial or standard exponential growth.</li>
				</ul>
            </div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 16T(\frac{n}{4}) + n \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=16\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(16)}=n^{4}\). Since \(f(n)=n\) is asymptotically smaller than \(n^{log_{b}(a)}=n^{4}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{4}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2T(\frac{n}{2}) + n \log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=2\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(2)}=n\). Since \(f(n)=n\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n\) due to the additional logarithmic factor, we conclude that this is Case 2a of the Extended General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log^{2}(n)). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2T(\frac{n}{2}) + \frac{n}{\log(n)} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=2\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\frac{n}{\log(n)}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(2)}=n\). Since \(f(n)=\frac{n}{\log(n)}\) is asymptotically slower than \(n^{log_{b}(a)}=n\) due to the additional logarithmic factor, we conclude that this is Case 2b of the Extended General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log(\log(n))). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 2T(\frac{n}{4}) + n^{0.58} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=2\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n^{0.58}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{4}(2)}=n^{0.5}\). Since \(f(n)=n^{0.58}\) is asymptotically faster than \(n^{log_{b}(a)}=n^{0.5}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=2\), \(b=4\), and \(f(n)=n^{0.58}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				2\left(\frac{n}{4}\right)^{0.58} &\leq cn^{0.58}  \\
				\frac{2}{4^{0.58}} &\leq c \\
				\frac{1}{2^{0.16}} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>Therefore, the inequality holds for any \(c\) such that \(\frac{1}{2^{0.16}} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{0.58}). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 0.5T(\frac{n}{2}) + \frac{1}{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>The Master Theorem cannot be applied to this recurrence because \(a \lt 1\).</p>
            </div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 16T(\frac{n}{4}) + n! \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=16\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n!\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{4}(16)}=n^{2}\). Since \(f(n)=n!\) is asymptotically faster than \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=16\), \(b=4\), and \(f(n)=n!\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				16\left(\frac{n}{4}\right)! &\leq cn!  \\
				16\frac{\left(\frac{n}{4}\right)!}{n!} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>The factor \(16\left(\frac{n}{4}\right)!\) grows slower than \(n!\) for large \(n\). Therefore, the inequality holds for any \(c\) such that \(0 \lt c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n!). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = \sqrt{2}T(\frac{n}{2}) + \log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=\sqrt{2}\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(\sqrt{2})}=n^{\frac{1}{2}}\). Since \(f(n)=\log(n)\) is asymptotically slower than \(n^{log_{b}(a)}=n^{\frac{1}{2}}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{\frac{1}{2}}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{2}) + n \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(3)}=n^{1.585}\). Since \(f(n)=n\) is asymptotically smaller than \(n^{log_{b}(a)}=n^{1.585}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{1.585}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{3}) + \sqrt{n} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=\sqrt{n}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(3)}=n\). Since \(f(n)=\sqrt{n}\) is asymptotically slower than \(n^{log_{b}(a)}=n\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{4}) + n\log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=4\)</li>
					<li>\(f(n)=n\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{4}(3)}=n^{0.973}\). Since \(f(n)=n\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n^{0.973}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=3\), \(b=4\), and \(f(n)=n\log(n)\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				3\frac{n}{4}\log\left(\frac{n}{4}\right) &\leq cn\log(n)  \\
				\frac{3}{4}(\log(n)-\log(4)) &\leq c\log(n) \\
				\frac{3}{4}-\frac{3\log(4)}{4\log(n)} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>As \(n\) becomes large, \(\frac{3\log(4)}{4\log(n)}\) approaches \(0\). Therefore, the inequality holds for any \(c\) such that \(\frac{3}{4} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log(n)). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 3T(\frac{n}{3}) + \frac{n}{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=3\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=\frac{n}{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(3)}=n\). Since \(f(n)=\frac{n}{2}\) is asymptotically equal to \(n^{log_{b}(a)}=n\), we conclude that this is Case 2 of the General Master Theorem.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n\log(n)). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 6T(\frac{n}{3}) + n^{2}\log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=6\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=n^{2}\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(6)}=n^{1.631}\). Since \(f(n)=n^{2}\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n^{1.631}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=6\), \(b=3\), and \(f(n)=n^{2}\log(n)\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				6\left(\frac{n}{3}\right)^{2}\log\left(\frac{n}{3}\right) &\leq cn^{2}\log(n)  \\
				6\left(\frac{1}{3}\right)^{2}(\log(n)-\log(3)) &\leq c\log(n) \\
				\frac{2}{3}(\log(n)-\log(3)) &\leq c\log(n) \\
				\frac{2}{3}-\frac{2\log(3)}{3\log(n)} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>As \(n\) becomes large, \(\frac{2\log(3)}{3\log(n)}\) approaches \(0\). Therefore, the inequality holds for any \(\frac{2}{3} \leq c \lt 1\). Since such a \(c\) exists, the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}\log(n)). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 4T(\frac{n}{2}) + \frac{n}{\log(n)} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=4\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\frac{n}{\log(n)}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(4)}=n^{2}\). Since \(f(n)=\frac{n}{\log(n)}\) is asymptotically slower than \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 64T(\frac{n}{8}) - n^{2}\log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>The Master Theorem cannot be applied to this recurrence because \(f(n)\) is not positive.</p>
            </div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 7T(\frac{n}{3}) + n^{2} \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=7\)</li>
					<li>\(b=3\)</li>
					<li>\(f(n)=n^{2}\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{3}(7)}=n^{1.7712}\). Since \(f(n)=n^{2}\log(n)\) is asymptotically faster than \(n^{log_{b}(a)}=n^{1.7712}\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=7\), \(b=3\), and \(f(n)=n^{2}\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				7\left(\frac{n}{3}\right)^{2} &\leq cn^{2}  \\
				\frac{7}{9} &\leq c.
				\end{aligned}
				\]
                </div>
				
				<p>Therefore, the inequality holds for any \(c\) such that \(\frac{2}{3} \leq c \lt 1\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = 4T(\frac{n}{4}) + \log(n) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=4\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=\log(n)\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(4)}=n^{2}\). Since \(f(n)=\log(n)\) is asymptotically slower than \(n^{log_{b}(a)}=n^{2}\), we conclude that this is Case 1 of the General Master Theorem.</p>
				
				<p>Thus, \(n^{log_{b}(a)}\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n^{2}). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = T(\frac{n}{2}) + n(2-\sin(n)) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=1\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n(2-\sin(n))\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(1)}=1\). Since \(f(n)=n(2-\sin(n))\) is asymptotically faster than \(n^{log_{b}(a)}=1\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=1\), \(b=2\), and \(f(n)=n(2-sin(n))\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{n}{2}(2-\sin\left(\frac{n}{2}\right)) &\leq cn(2-\sin(n)) \\
				\frac{1}{2}(2-\sin\left(\frac{n}{2}\right)) &\leq c(2-\sin(n)).
				\end{aligned}
				\]
                </div>
				
				<p>Consider \(n = \pi k\), where \(k \geq 0\) and arbitrarily large. The value of \(\sin(n)\) will always be \(0\) and the value of \(\sin(\frac{n}{2})\) alternates depending on \(k \mod 4\).<p>
				
				<p>If \(k \equiv 0 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = 0\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq 2c \\
				c \geq \frac{1}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 1 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = 1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-1) &\leq 2c \\
				c \geq \frac{1}{4}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 2 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = 0\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq 2c \\
				c \geq \frac{1}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 3 \pmod{4}\), then \(\sin(\frac{k\pi}{2}) = -1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2+1) &\leq 2c \\
				c \geq \frac{3}{4}.
				\end{aligned}
				\]
                </div>
				
				<p>Thus, for all values of \(k\), the largest lower bound on \(c\) is \(c \geq \frac{3}{4}\) and the regularity condition is satisfied.</p>
				
				<p>Thus, \(f(n)\) dominates the growth of \(T(n)\), and we conclude:</p>
				
				<div class="equation-container">
                \[ T(n)=\Theta(n(2-\sin(n))). \]
                </div>
			</div>
        </div>
		
		
		<div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Consider the recurrence</p>
                
				<div class="equation-container">
                \[ T(n) = T(\frac{n}{2}) + n(2-\cos(n)) \]
                </div>
				
                <p>Solution</p>
				
				<p>From the given recurrence:</p>
				
				<ul>
					<li>\(a=1\)</li>
					<li>\(b=2\)</li>
					<li>\(f(n)=n(2-\cos(n))\)</li>
				</ul>
				
				<p>From the Master Theorem, we calculate \(n^{log_{b}(a)}=n^{log_{2}(1)}=1\). Since \(f(n)=n(2-\cos(n))\) is asymptotically faster than \(n^{log_{b}(a)}=1\), we conclude that this is Case 3 of the General Master Theorem.</p>
				
				<p>In Case 3 of the General Master Theorem, we must check the regularity condition \(af(\frac{n}{b}) \leq cf(n)\) for some \(c \lt 1\) and all \(n\) sufficiently large.</p>
				
				<p>Substitute the values \(a=1\), \(b=2\), and \(f(n)=n(2-\cos(n))\) into the expression \(af(\frac{n}{b}) \leq cf(n)\), we get:</p>
				
				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{n}{2}(2-\cos\left(\frac{n}{2}\right)) &\leq cn(2-\cos(n)) \\
				\frac{1}{2}(2-\cos\left(\frac{n}{2}\right)) &\leq c(2-\cos(n)).
				\end{aligned}
				\]
                </div>
				
				<p>Consider \(n = \pi k\), where \(k \geq 0\) and arbitrarily large. The value of \(\cos(n)\) is \((-1)^{k}\) and the value of \(\cos(\frac{n}{2})\) alternates depending on \(k \mod 4\).<p>
				
				<p>If \(k \equiv 0 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = 1\) and \(\cos(n) = 1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-1) &\leq c(2-1) \\
				c \geq \frac{1}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 1 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = 0\) and \(\cos(n) = -1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq c(2+1) \\
				c \geq \frac{1}{3}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 2 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = -1\) and \(\cos(n) = 1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2+1) &\leq c(2-1) \\
				c \geq \frac{3}{2}.
				\end{aligned}
				\]
                </div>
				
				<p>If \(k \equiv 3 \pmod{4}\), then \(\cos(\frac{k\pi}{2}) = 0\) and \(\cos(n) = -1\). The inequality becomes:</p>

				<div class="equation-container">
                \[
				\begin{aligned}
				\frac{1}{2}(2-0) &\leq c(2+1) \\
				c \geq \frac{1}{3}.
				\end{aligned}
				\]
                </div>
				
				<p>Thus, for all values of \(k\), the largest lower bound on \(c\) is \(c \geq \frac{3}{2}\) and it violates the condition that \(c \lt 1\).</p>
				
				<p>Since the regularity condition is not satisfied, this implies that the recurrence does not fit into Case 3 of the General Master Theorem.</p>
            </div>
        </div>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/recurrence" class="tag">recurrence</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/simplified-master-theorem" class="tag">simplified master theorem</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/general-master-theorem" class="tag">general master theorem</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/master-theorem-extension" class="tag">master theorem extension</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/master-theorem-with-logarithmic-factor" class="tag">master theorem with logarithmic factor</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/recursive-algorithm" class="tag">recursive algorithm</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/asymptotic-analysis" class="tag">asymptotic analysis</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2025/01/14/master-theorem/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2025/01/14/master-theorem/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2025/01/14/master-theorem/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2025" /><category term="month-01" /><category term="day-14" /><category term="math" /><category term="recurrence" /><category term="simplified master theorem" /><category term="general master theorem" /><category term="master theorem extension" /><category term="master theorem with logarithmic factor" /><category term="recursive algorithm" /><category term="asymptotic analysis" /><summary type="html"><![CDATA[Learn how to solve recurrence relations using the Master Theorem and its application to recurrences with logarithmic factors. This comprehensive guide covers the step-by-step process of analyzing recursive algorithms to determine their time complexity. We explore how to apply the Master Theorem to different forms of recurrences. The article provides in-depth explanations of the key concepts of the Master Theorem, including Case 1, Case 2, Case 2 extension, and Case 3, and walks you through the conditions required for each case. With practical examples, including detailed solutions, this resource will help you master asymptotic analysis and efficiently determine the runtime of recursive functions.]]></summary></entry><entry xml:lang="en"><title type="html">Deriving Binet’s Formula</title><link href="https://hemimorphite.github.io/2024/12/09/deriving-binets-formula/" rel="alternate" type="text/html" title="Deriving Binet’s Formula" /><published>2024-12-09T08:20:00+00:00</published><updated>2024-12-09T08:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/12/09/deriving-binets-formula</id><content type="html" xml:base="https://hemimorphite.github.io/2024/12/09/deriving-binets-formula/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Deriving Binet's Formula</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published December 09, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/binetformula.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		
        <p>The Fibonacci sequence, one of the most renowned number sequences in mathematics, is named after Leonardo of Pisa, a prominent mathematician of the European Middle Ages. Born in 1170 into the Bonacci family, Leonardo later became known as Fibonacci — a name derived from the Latin phrase Filius Bonacci, meaning "son of Bonacci."</p>

        <p>In his book Liber Abaci (1202), he introduced the now-famous Fibonacci sequence:</p>
		
		<div class="equation-container">
        \[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... \]
        </div>
		
		<p>This sequence arose from an arithmetic problem about counting rabbit pairs, where each term represents the total number of rabbit pairs in a given month. The pattern is that each term is the sum of the two preceding terms. This means the Fibonacci sequence can be defined recursively as follows:</p>
		
		<div class="equation-container">
        \[ F_{0} = 1, F_{1} = 1, F_{n} = F_{n-1} + F_{n-2} \text{ for } n \geq 2 \]
        </div>
		
		<p>It turns out that the Fibonacci sequence also has a closed-form expression, known as Binet's formula. It is given by:</p>
		
		<div class="equation-container">
        \[ F_{n} = \frac{\phi^{n} - \psi^{n}}{\sqrt{5}}, \]
        </div>
		
		<p>where:</p>
		
		<div class="equation-container">
        \[ \phi = \frac{1 + \sqrt{5}}{2}, \quad \psi = \frac{1 - \sqrt{5}}{2}. \]
        </div>
		
		<p>Here, \(\phi\) and \(\psi\) are the roots of the characteristic equation associated with the Fibonacci recurrence relation. Binet's formula provides an exact value for \(F_{n}\) without requiring recursive computation, beautifully connecting the Fibonacci sequence to algebra and the golden ratio.</p>
		
		<p>For any sequence of numbers, there exists an associated generating function that encodes the sequence into a formal power series. Given a sequence \(\{a_n\}_{n=0}^{\infty}\), the generating function \(G(x)\) is defined as:</p>
		
		<div class="equation-container">
        \[ G(x) = \sum_{n=0}^{\infty} a_n x^{n}  \]
        </div>
		
		<p>If we change the sequence by adding \(k\) zeros to the left \(\{0, 0, ..., 0, a_{0}, a_{1}, a_{2}, ... \}\), then the new generating function is \(x^{k}G(x) = a_{0} x^{k} + a_{1} x^{k+1} + a_{2} x^{k+2} + ...\).</p>
		
		<p>Recall that the Fibonacci sequence are defined by the recurrence relation</p>
		
		<div class="equation-container">
        \[ F_{0} = 1, F_{1} = 1, F_{n} = F_{n-1} + F_{n-2} \text{ for } n \geq 2 \]
        </div>
		
		<p>We begin by defining the generating function for the Fibonacci sequence as the formal power series whose coefficients are the Fibonacci sequence themselves,</p>
		
		<div class="equation-container">
        \[ F(x) = \sum_{n=0}^{\infty} F_{n} x^{n} \]
        </div>
		
		<p>When dealing with a recurrence relation like the Fibonacci sequence, where the recurrence starts with two defined initial terms (\(F_{0}\) and \(F_{1}\)), shifting the generating function twice to the right is necessary to properly represent the recurrence algebraically.</p>
		
		<p>We multiply the generating function for the Fibonacci sequence with \(x\) and \(x^{2}\) to shift the terms:</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		F(x)  &= \phantom{ \;\; } F_{0} + F_{1} x + F_{2} x^{2} + F_{3} x^{3} + F_{4} x^{4} + F_{5} x^{5} + F_{6} x^{6} + \dots \\
		xF(x) &= \phantom{F_{0} x +} F_{0} x + F_{1} x^{2} + F_{2} x^{3} + F_{3} x^{4} + F_{4} x^{5} + F_{5} x^{6} + \dots \\
		x^{2}F(x) &= \phantom{F_{0} x + F_{1} x +} F_{0} x^{2} + F_{1} x^{3} + F_{2} x^{4} + F_{3} x^{5} + F_{4} x^{6} + \dots
		\end{aligned}
		\]
        </div>

		<p>When we multiply \(F(x)\) by \(x\), it shifts all terms of the sequence to the right by one position:</p>
		
		<div class="equation-container">
        \[ xF(x) = x\sum_{n=0}^{\infty} F_{n} x^{n} = \sum_{n=0}^{\infty} F_{n} x^{n+1} = \sum_{n=1}^{\infty} F_{n-1} x^{n} \]
        </div>
		
		<p>When we multiply \(F(x)\) by \(x^{2}\), it shifts all terms of the sequence to the right by two positions:</p>
		
		<div class="equation-container">
        \[ x^{2}F(x) = x^{2}\sum_{n=0}^{\infty} F_{n} x^{n} = \sum_{n=0}^{\infty} F_{n} x^{n+2} = \sum_{n=2}^{\infty} F_{n-2} x^{n} \]
        </div>
		
		<p>The initial terms \(F_{0}\) and \(F_{1}\) need to be added explicitly because they are not part of the recurrence relation and subsitute the recurrence relation for \(F_{n}\) into the coefficients of the sum.</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		F(x) &= F_{0} + F_{1} x^{1} + \sum_{n=2}^{\infty} F_{n} x^{n} \\
		&= F_{0} + F_{1} x + \sum_{n=2}^{\infty} \left(F_{n-1} + F_{n-2}\right) x^{n} \\
		&= F_{0} + F_{1} x + \sum_{n=2}^{\infty} F_{n-1} x^{n} + \sum_{n=2}^{\infty} F_{n-2} x^{n} \\
		&= F_{0} + F_{1} x + x\sum_{n=2}^{\infty} F_{n-1} x^{n-1} + x^{2}\sum_{n=2}^{\infty} F_{n-2} x^{n-2} \\
		&= F_{0} + F_{1} x + x\left(\sum_{n=0}^{\infty} F_{n} x^{n} - F_{0}\right) + x^{2}\sum_{n=0}^{\infty} F_{n} x^{n} \\
		&= F_{0} + F_{1} x + x(F(x) - F_{0}) + x^{2} F(x) \\
		&= F_{0} + F_{1} x + x F(x) - F_{0} x + x^{2} F(x)
		\end{aligned}
		\]
        </div>
		
		<p>From the initial conditions \(F_{0} = 0\) and \(F_{1} = 1\), the equation simplifies to:</p>
		
		<div class="equation-container">
        \[ F(x) = x + x F(x) + x^{2} F(x) \]
        </div>
		
		<p>Sovling for the generating function, we get:</p>
		
		<div class="equation-container">
        \[ F(x) = \frac{x}{1 - x - x^{2}} \]
        </div>
		
		<p>Now that we have found a closed form for the generating function, all that remains is to express this function as a power series. After doing so, we may match its coefficients term-by-term with the corresponding Fibonacci numbers. The roots of the polynomial \(1 − x − x^{2}\) are \(-\phi\) and \(-\psi\), where</p>
		
		<div class="equation-container">
        \[ \phi = \frac{1 + \sqrt{5}}{2} \]
        </div>
		
		<p>and</p>
		
		<div class="equation-container">
        \[ \psi = \frac{1 - \sqrt{5}}{2}, \]
        </div>
		
		<p>so the polynomial factors as \(1-x-x^{2}=-(x+\phi)(x+\psi)\).</p>
		
		<p>In order to express the generating function as a power series, we will use the partial fraction decomposition to express it in the form</p>
		
		<div class="equation-container">
        \[ F(x) = -\frac{x}{(x+\phi)(x+\psi)} = \frac{A}{x+\phi} + \frac{B}{x+\psi}, \]
        </div>
		
		<p>which is equivalent to</p>
		
		<div class="equation-container">
        \[ -x = A(x+\psi) + B(x+\phi). \]
        </div>
		
		<p>Letting \(x=-\phi\):</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		-x &= A(x+\psi) + B(x+\phi) \\
		-(-\phi) &= A(-\phi+\psi) + B(-\phi+\phi) \\
		\phi &= A(-\phi+\psi) \\
		A &= \frac{\phi}{\psi-\phi}
		\end{aligned}
		\]
        </div>
		
		<p>Using the fact that \(\psi-\phi=-\sqrt{5}\), we get:</p>
		
		<div class="equation-container">
        \[ A = -\frac{\phi}{\sqrt{5}}. \]
        </div>
		
		<p>Letting \(x=-\psi\):</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		-x &= A(x+\psi) + B(x+\phi) \\
		-(-\psi) &= A(-\psi+\psi) + B(-\psi+\phi) \\
		\psi &= B(-\psi+\phi) \\
		B &= \frac{\psi}{\phi-\psi}
		\end{aligned}
		\]
        </div>
		
		<p>Using the fact that \(\phi-\psi=\sqrt{5}\), we get:</p>
		
		<div class="equation-container">
        \[ B = \frac{\psi}{\sqrt{5}}. \]
        </div>
		
		<p>Now substitute these values of \(A\) and \(B\) into the partial fraction decomposition and we get:</p>
		
		<div class="equation-container">
        \[ F(x) = \frac{1}{\sqrt{5}}\left(\frac{\psi}{x+\psi} - \frac{\phi}{x+\phi}\right). \]
        </div>
		
		<p>Recall that the sum of a geometric series is given by</p>
		
		<div class="equation-container">
        \[ \frac{1}{1-x} = \sum_{n=0}^{\infty} x^{n}, \]
        </div>
		
		<p>assuming \(|x| \lt 1\) for convergence.</p>
		
		<p>The roots \(\phi\) and \(\psi\) are conjugates of each other, and they satisfy the product of the roots relationships:</p>
		
		<div class="equation-container">
        \[ \phi \cdot \psi = -1. \]
        </div>
		
		<p>Using the fact that \(\phi=-\frac{1}{\psi}\), we can rewrite the first term of the generating function as</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		\frac{\psi}{x+\psi} &= \frac{1}{1+\frac{x}{\psi}} \\
		&= \frac{1}{1-\phi x} \\
		&= \sum_{n=0}^{\infty} \phi^{n} x^{n}.
		\end{aligned}
		\]
        </div>
		
		<p>Similarly,</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		\frac{\phi}{x+\phi} &= \frac{1}{1+\frac{x}{\phi}} \\
		&= \frac{1}{1-\psi x} \\
		&= \sum_{n=0}^{\infty} \psi^{n} x^{n}.
		\end{aligned}
		\]
        </div>
		
		<p>so</p>
		
		<div class="equation-container">
        \[
		\begin{aligned}
		F(x) &= \frac{1}{\sqrt{5}}\left(\frac{\psi}{x+\psi} - \frac{\phi}{x+\phi}\right) \\
		&= \frac{1}{\sqrt{5}}\left(\sum_{n=0}^{\infty} \phi^{n} x^{n} - \sum_{n=0}^{\infty} \psi^{n} x^{n}\right) \\
		&= \sum_{n=0}^{\infty} \frac{1}{\sqrt{5}} (\phi^{n} - \psi^{n}) x^{n}.
		\end{aligned}
		\]
        </div>
		
		<p>Since the definition of \(F(x)\) was</p>
		
		<div class="equation-container">
        \[ F(x) = \sum_{n=0}^{\infty} F_{n} x^{n}, \]
        </div>
		
		<p>we match the coefficients on corresponding powers of \(x\) in these two expressions for \(F(x)\) to finally arrive at the desired closed form for the n-th Fibonacci number,</p>
		
		<div class="equation-container">
        \[ F_{n} = \frac{1}{\sqrt{5}} (\phi^{n} - \psi^{n}). \]
        </div>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/fibonacci" class="tag">fibonacci</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/recurrence-relation" class="tag">recurrence relation</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/generating-function" class="tag">generating function</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/binet-formula" class="tag">binet formula</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/12/09/deriving-binets-formula/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/12/09/deriving-binets-formula/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/12/09/deriving-binets-formula/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-12" /><category term="day-09" /><category term="math" /><category term="fibonacci" /><category term="recurrence relation" /><category term="generating function" /><category term="binet formula" /><summary type="html"><![CDATA[Explore the fascinating derivation of Binet's Formula, a closed-form expression for Fibonacci numbers, using mathematical tools like recurrence relations, generating functions, and properties of the golden ratio.]]></summary></entry><entry xml:lang="en"><title type="html">Recurrence Relations</title><link href="https://hemimorphite.github.io/2024/10/14/recurrence-relations/" rel="alternate" type="text/html" title="Recurrence Relations" /><published>2024-10-14T10:20:00+00:00</published><updated>2024-10-14T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/10/14/recurrence-relations</id><content type="html" xml:base="https://hemimorphite.github.io/2024/10/14/recurrence-relations/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Recurrence Relations</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published October 14, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/recurrencerelation.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3>Recurrence Relation Definition</h3>
		
        <p>Recurrences, or recurrence relations, are equations that define sequences of values using recursion and initial values. Recurrences can be linear or non-linear, homogeneous or non-homogeneous, and first order or higher order.</p>

        <p>For example,</p>
		
		\[ 3, 6, 9, 12, 15, ...\]
		
		<p>For this sequence, the rule is add three.</p>
		
		<p>Each number in a sequence is called a term and is identified by its position within the sequence. We write them as follows:</p>
		
		<ul>
			<li>The first term \(T(1) = 3\)</li>
			<li>The second term \(T(2) = 6\)</li>
			<li>The third term \(T(3) = 9\)</li>
			<li>The fourth term \(T(4) = 12\)</li>
			<li>The nth term \(T(n)\)</li>
		</ul>
		
		<p>To generate this sequence we can use the nnth term formula for the sequence. For this sequence, the \(n\)th term would be \(T(n) = 3n\).</p>
		
		<p>When \(n = 1\), \(T(1) = 3(1) = 3\).</p>
		
		<p>When \(n = 2\), \(T(2) = 3(2) = 6\), and so on.</p>
		
		<p>Another way of generating this sequence would be to use the recurrence relation, where each term is generated using the previous value. These recurrence relations are algorithms and can generate any term in the sequence.</p>
		
		<p>When \(n = 1\), \(T(1) = 3\).</p>
		
		<p>When \(n = 2\), \(T(2) = 3 + 3 = 6\).</p>
		
		<p>When \(n = 3\), \(T(3) = 6 + 3 = 9\), and so on.</p>
		
		<p>Hence, the recurrence equation can be written as the formula:</p>
		
		\[ T(n+1) = T(n) + 3 \]
		
		<p>The initial value, \(T(1)\), would need to be provided. The initial value could also be \(T(0)\).</p>
		
		<p>A recurrence relation for a sequence \(T(1), T(2), ..., T(n)\) is a formula that calculates each term \(T(k)\) in terms of \(T(k-1), T(k-2), ..., T(k-i)\) for some integer \(i\). The initial conditions for a recurrence relation specify values for \(T(1), T(2), ..., T(k-1)\).</p>
		
		<h3>Classifying Recurrence Relations</h3>
		
		<p>Recurrence relations are often classified based on how the terms are combined, the nature of their coefficients, and the number and nature of the previous terms involved. Below is a breakdown of the key classifications for recurrence relations:</p>
		
		<h4>1. By the Number of Previous Terms Used</h4>
		
		<h5>1.1. First-Order Recurrence Relations</h5>
		
		<p>In first-order recurrence relations, only the immediately previous term is used to compute the next term. These relations are the simplest type and are often easy to solve.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n-1) \]
		
		<p>In this example, the next term is twice the previous term.</p>
		
		<h6>Example 2: First-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n-1) + n \]
		
		<p>In this example, the next term depends on the previous term plus an additional term \(n\).</p>
		
		<h5>1.2. Second-Order Recurrence Relations</h5>
		
		<p>In second-order recurrence relations, the next term depends on the two previous terms. These relations are more complex than first-order ones, and the solution method is different (e.g., using the characteristic equation).</p>
		
		<h6>Example 1: Second-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n-1) + 3T(n-2) \]
		
		<p>In this example, the next term is calculated based on a linear combination of the two previous terms.</p>
		
		<h6>Example 2: Second-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n−1) + T(n−2) + 1 \]
		
		<p>In this example, the next term is calculated based on a linear combination of the two previous terms plus an additional term (a constant value).</p>
		
		<h5>1.3. Higher-Order Recurrence Relations</h5>
		
		<p>In higher-order recurrence relations, the next term depends on three or more previous terms. These relations are even more complex and often require advanced techniques (such as matrix methods or generating functions) for solving.</p>
		
		<h6>Example 1: Higher-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n-1) + T(n-2) + T(n-3) \]
		
		<p>In this example, the next term is calculated based on a linear combination of the three previous terms.</p>
		
		<h6>Example 2: Higher-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n-1) + 3T(n−2) + T(n−3) + n^{2} \]
		
		<p>In this example, the next term depends on a combination of the previous three terms and a quadratic function of \(n\).</p>
		
		<h4>2. By the Nature of the Coefficients</h4>
		
		<h5>2.1. Constant-Coefficient Recurrence Relations</h5>
		
		<p>In Constant-Coefficient Recurrence Relations, the coefficients multiplying the previous terms are constant (i.e., they do not depend on nn). This is the most common type of recurrence relation and is often easier to solve.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) \]
		
		<p>In this example, the next term depends on a linear combination of the previous term with constant coefficients.</p>
		
		<h6>Example 2: Second-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = 2T(n−1) + 3T(n−2) + 1 \]
		
		<p>In this example, the next term depends on a linear combination of the previous terms with constant coefficients, and an additional unit (such as a constant value) is added at each step.</p>
		
		<h5>2.2. Variable-Coefficient Recurrence Relations</h5>
		
		<p>In Variable-Coefficient Recurrence Relations, the coefficients multiplying the previous terms are functions of \(n\) (i.e., they change as \(n\) increases). These are generally more complex than constant-coefficient recurrences.</p>
		
		<h6>Example 1: First-Order Variable-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = nT(n-1) \]
		
		<p>In this example, the next term depends on the previous term with variable coefficient.</p>
		
		<h6>Example 2: Second-Order Variable-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = (n-1)T(n−1) + nT(n−2) + 1 \]
		
		<p>In this example, the next term depends on the previous terms with variable coefficients, and an additional unit (such as a constant value) is added at each step.</p>
		
		<h4>3. By the Combination of Terms</h4>
		
		<h5>3.1. Linear Recurrence Relations</h5>
		
		<p>In linear recurrence relations, a sequence is defined using linear combinations of its previous terms.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) + 2T(n-2) \]
		
		<p>In this example, the next term depends on a linear combination of the two previous terms with constant coefficients.</p>
		
		<h5>3.1. Nonlinear Recurrence Relations</h5>
		
		<p>In nonlinear recurrence relations, a sequence is defined based on one or more previous terms, using a nonlinear operations (e.g., squaring, multiplying, taking powers, etc.).</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Nonlinear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = T(n-1)^{2} + n \]
		
		<p>In this example, the next term depends on the non-linear previous term which is squared and a additional term.</p>
		
		<h4>4. By the Presence of additional terms</h4>
		
		<h5>4.1. Homogeneous Recurrence Relations</h5>
		
		<p>In homogeneous recurrence relations, a sequence is defined based on its previous terms, and it relies solely on the values of those terms without any additional independent term.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) + 2T(n-2) \]
		
		<p>In this example, the next term depends on a linear combination of the two previous terms with constant coefficients and there are no additional independent terms.</p>
		
		<h5>4.2. Non-Homogeneous Recurrence Relations</h5>
		
		<p>In non-homogeneous recurrence relations, a sequence is defined based on its previous terms, and it includes additional independent terms.</p>
		
		<h6>Example 1: First-Order Constant-Coefficient Linear Non-Homogeneous Recurrence</h6>
		
		\[ T(n) = 3T(n-1) + 2T(n-2) + n \]
		
		<p>In this example, the next term depends on a linear combination of the two previous terms with constant coefficients plus the additional independent term.</p>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/recurrence-relation" class="tag">recurrence relation</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/recursion" class="tag">recursion</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/10/14/recurrence-relations/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/10/14/recurrence-relations/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/10/14/recurrence-relations/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-10" /><category term="day-14" /><category term="math" /><category term="recurrence relation" /><category term="recursion" /><summary type="html"><![CDATA[Explore the fundamentals of recurrence relations, a key concept in mathematics and algorithm design. This guide introduces different types of recurrence relations, including linear, divide-and-conquer, and homogeneous recurrences.]]></summary></entry><entry xml:lang="en"><title type="html">Singly Linked List Data Structure</title><link href="https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/" rel="alternate" type="text/html" title="Singly Linked List Data Structure" /><published>2024-10-14T10:20:00+00:00</published><updated>2024-10-14T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Singly Linked List Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published October 14, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/singlylinked.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		<h3 class="post-subtitle">Singly Linked List</h3>
		
        <p>A singly linked list is a linear data structure consisting of a sequence of elements, called nodes, where each node points to the next node in the sequence. Unlike arrays, elements in a linked list are not stored in contiguous memory locations. Each node contains two fields:</p>

        <ul>
			<li><b>Data</b>: The value or information stored in the node.</li>
			<li><b>Next Pointer</b>: A reference (or pointer) to the next node in the sequence.</li>
		</ul>

        <p>The singly linked list forms a linear collection of elements where each node points to its successor, and the last node points to <code>NULL</code>, indicating the end of the list. It is a dynamic data structure, meaning it can grow or shrink in size during runtime, as nodes can be added or removed without requiring memory to be reallocated.</p>
		
		<p>The head is the first node in the list, and it serves as the entry point for traversing the list. If the list is empty, the head points to <code>NULL</code>.</p>
		
		<p>Unlike arrays that have a fixed size, a singly linked list dynamically allocates memory for each node when it is created. This means the size of the list can grow or shrink as nodes are added or removed at runtime.</p>
		
		<p>Insertions and deletions of nodes, particularly at the beginning or middle of the list, are more efficient compared to arrays since you do not need to shift elements.</p>
		
		<p>Singly linked lists can only be traversed in one direction, from the head to the tail. There is no way to traverse backward from the tail to the head, which can be a limitation in some use cases.</p>
		
		<p>The nodes in a singly linked list do not need to be stored in contiguous memory locations, unlike arrays. Each node is linked to the next through pointers, and they can be located anywhere in memory.</p>
		
		<p>The size of the linked list is not fixed, and it is determined by the number of nodes present in the list at any given time. This makes it more flexible for applications where the number of elements is unknown or changes frequently.</p>
		
		<p>Each node in a singly linked list requires extra memory for the pointer (next reference), which slightly increases memory usage compared to arrays.</p>
		
		<p>The last node in a singly linked list is called the tail. Its next pointer is set to <code>NULL</code>, indicating that it is the end of the list.</p>
		
		<p>Here's a visual representation of a singly linked list:</p>
		
		<pre><code class="language-bash hljs">Head -&gt; [Data | Next] -&gt; [Data | Next] -&gt; [Data | NULL]</code></pre>
		
		<p>In the above representation:</p>
		
		<ul>
			<li>The <code>Head</code> points to the first node of the list.</li>
			<li>Each node contains <code>Data</code> and a <code>Next</code> pointer to the next node.</li>
			<li>The last node in the list has its <code>Next</code> pointer set to <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>A simple singly linked list with three nodes could look like this:</p>
		
		<pre><code class="language-bash hljs">Head -> [10 | Next] -> [20 | Next] -> [30 | NULL]</code></pre>
		
		<p>In the above example:</p>
		
		<ul>
			<li>The head points to the first node containing the data <code>10</code>.</li>
			<li>The second node contains the data <code>20</code> and points to the third node.</li>
			<li>The third node contains the data <code>30</code> and points to <code>NULL</code>, indicating the end of the list.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common singly linked list operations:</p>
		
        <ul>
            <li><code>insertAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the start (or head) of a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>5</code> at the beginning of the list. After calling <code>insertAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [5 | Next] -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the beginning of a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>If the list is not empty, set the <code>next</code> pointer of the new node to point to the current head node (the first node in the list). If the list is empty, set the <code>next</code> pointer of the new node to point to <code>NULL</code>.</li>
							<li>Update the head pointer to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the beginning of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at the end (or tail) of a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>40</code> at the end of the list. After calling <code>insertAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | Next] -&gt; [40 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of inserting a node at the end of a singly linked list is \(O(n)\) (linear time) in the general case.<br>
						<ul>
							<li><b>Best Case (Empty List)</b>: If the list is empty, inserting a new node at the end is the same as inserting at the beginning. The following steps are performed:<br>
								<ul>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node <code>NULL</code>, as it will be the only node in the list.</li>
									<li>Update the head pointer to point to the new node.</li>
								</ul><br>
								Since no traversal is required, this operation takes constant time, \(O(1)\).
							</li>
							<li><b>Average/Worst Case (Non-Empty List)</b>: If the list is not empty, you have to traverse the entire list to reach the last node. The following steps are performed:
								<ul>
									<li>Start from the head node.</li>
									<li>Traverse the list by following the <code>next</code> pointers until you reach the last node (the node whose <code>next</code> pointer is <code>NULL</code>).</li>
									<li>Create a new node.</li>
									<li>Set the <code>next</code> pointer of the new node to <code>NULL</code>.</li>
									<li>Update the <code>next</code> pointer of the last node to point to the new node.</li>
								</ul><br>
								The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
							</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a node at the end of a singly linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAfterNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node in a singly linked list immediately after a given node. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> after the node containing <code>20</code>. After calling <code>insertAfterNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [25 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Set the <code>next</code> pointer of the new node to point to the node that follows the given node.</li>
							<li>Update the <code>next</code> pointer of the given node to point to the new node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node after a node in a singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertBeforeNode()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node before a given node in a singly linked list. If the target node doesn't exist, you may opt to do nothing and just return control to the caller without modifying the list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert the value <code>25</code> before the node containing <code>20</code>. After calling <code>insertBeforeNode()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [25 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a node before a node in a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Update the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for inserting a node before a node in a singly linked list is \(O(1)\) (constant time). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>insertAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts a new node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position is 1 (or 0, based on indexing), this implies insertion at the beginning of the list. If the position is greater than the size of the list or less than 1, the function may return an error or take no action since the insertion would be out of range.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to insert a new node with value <code>35</code> at position <code>3</code>. After calling <code>insertAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [35 | NULL] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for inserting a new node at a specified position in a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Create a new node.</li>
							<li>Locate the preceding node (the node whose <code>next</code> pointer points to the target node).</li>
							<li>Update the <code>next</code> pointer of the new node to point to the target node.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the new node.</li>
						</ul><br>
						The traversal takes \(O(n)\) time, where \(n\) is the number of nodes in the list. Updating the pointer takes \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity of inserting a new node at a specified position in a linked list is \(O(1)\) (constant space). The space required to allocate the new node is a fixed amount and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtBeginning()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the start (or head) of a singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to delete the value <code>10</code> at the beginning of the list. After calling <code>deleteAtBeginning()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the beginning of a singly linked list is \(O(1)\) (constant time). The following steps are performed:<br>
						<ul>
							<li>Set the head pointer to the next node</li>
							<li>Deallocate the memory for the old head node.</li>
						</ul><br>
						Since no traversal is required, this operation takes constant time, \(O(1)\).
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the beginning of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
            <li><code>deleteAtEnd()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at the end (or tail) of a singly linked list. If the list is empty, it prints a message "List is empty" and returns, since there is no node to delete.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to remove the value <code>30</code> at the end of the list. After calling <code>deleteAtEnd()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at the end of a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the second-to-last node.</li>
							<li>Update the <code>next</code> pointer of the second-to-last node to <code>null</code>.</li>
							<li>Deallocate the memory for the old last node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at the end of a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>deleteAtPosition()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes a node at a specified position in a linked list. Positions are usually indexed starting from 0 or 1. If the position to delete is 0, it means the head node should be removed. If the specified position is out of bounds, and a message is printed.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>You want to remove a node at position <code>3</code>. After calling <code>deleteAtPosition()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity for removing a node at a specified position in a singly linked list is \(O(n)\) (linear time). The following steps are performed:<br>
						<ul>
							<li>Start at the head node.</li>
							<li>Traverse until reaching the node before the target position.</li>
							<li>Update the <code>next</code> pointer of the preceding node to point to the node after the target node.</li>
							<li>Deallocate the memory for the removed node.</li>
						</ul><br>
					</li>
					<li><b>Space complexity</b>: The space complexity for removing a node at a specified position in a singly linked list is \(O(1)\) (constant space). Only a fixed amount of space is used to store references to the head node and does not depend on the size of the list. No additional data structures or auxiliary space are used in the process.</li>
				</ul>
			</li>
			<li><code>traverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Visits each node in a singly linked list and perform an action, such as printing the node's value.</li>
					<li><b>Time complexity</b>: The time complexity of traverse function in a linked list is \(O(n)\) (linear time). The function iterates through each node in the linked list exactly once, from the head to the end (<code>NULL</code>). Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of traverse function in a linked list is \(O(1)\) (constant space). The function only uses a constant amount of space to store variables such as the current node reference during the traversal. Regardless of the size of the linked list, the amount of extra space used does not change.</li>
				</ul>
			</li>
			<li><code>reverse()</code>:<br>
				<ul>
					<li><b>Description</b>: Reverses the order of nodes in a singly linked list.</li>
					<li><b>Example</b>:
						<ul>
							<li>Suppose you have the following linked list:<br>
								<pre><code class="language-bash hljs">Head -&gt; [10 | Next] -&gt; [20 | Next] -&gt; [30 | NULL]</code></pre>
							</li>
							<li>After calling <code>reverse()</code>, the list becomes:<br>
								<pre><code class="language-bash hljs">Head -&gt; [30 | Next] -&gt; [20 | Next] -&gt; [10 | NULL]</code></pre>
							</li>
						</ul>
					</li>
					<li><b>Time complexity</b>: The time complexity of reverse function in a linked list is \(O(n)\) (linear time). The function traverses each node of the linked list exactly once. Thus, the number of operations performed is directly proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of reverse function in a linked list is \(O(1)\) (constant space).  The function only uses a fixed amount of extra space for variables, such as pointers for the current, previous, and next nodes. This amount of space does not depend on the size of the linked list.</li>
				</ul>
			</li>
			<li><code>search()</code>:<br>
				<ul>
					<li><b>Description</b>: Finds whether a specific element (or key) exists in a singly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of search function in a singly linked list is \(O(n)\) (linear time).The search function traverses the linked list node by node. In the worst case, it may need to look at every node in the list to find the key (or determine that it is not present).</li>
					<li><b>Space complexity</b>: The space complexity of search function in a singly linked list is \(O(1)\) (constant space). The function uses a constant amount of extra space to store variables, such as pointers for the current node. The space required does not depend on the size of the list because the function does not use any additional data structures or dynamic memory allocations for the search process.</li>
				</ul>
			</li>
			<li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Calculates and returns the number of nodes in a singly linked list.</li>
					<li><b>Time complexity</b>: The time complexity of size function in a singly linked list is \(O(n)\) (linear time). The function traverses the entire linked list to count the number of nodes, where \(n\) is the number of nodes in the list.</li>
					<li><b>Space complexity</b>: The space complexity of size function in a singly linked list is \(O(1)\) (constant space). The function uses a constant amount of space for variables regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves the value of a node in a singly linked list at a specified index. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of get function in a singly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of get function in a singly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Updates the value of a node at a specified index in a singly linked list. If the end of the list is reached before finding the specified index, a message is printed indicating that the index is out of range.</li>
					<li><b>Time complexity</b>: The time complexity of set function in a singly linked list is \(O(n)\) (linear time). The function traverses the linked list until it reaches the specified index. In the worst case, it might have to go through all the nodes if the index is at the end of the list or if the list is very long.</li>
					<li><b>Space complexity</b>: The space complexity of set function in a singly linked list is \(O(1)\) (constant space). The function only uses a constant amount of space for variables, such as the pointer to the current node and the index being tracked. This space requirement does not depend on the size of the list.</li>
				</ul>
			</li>
			<li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether a singly linked list is empty.</li>
					<li><b>Time complexity</b>: The time complexity of isEmpty function in a singly linked list is \(O(1)\) (constant time). The <code>isEmpty</code> function checks whether the head pointer of the linked list is <code>NULL</code>. This operation is performed in constant time since it only involves a simple comparison, regardless of the size of the linked list.</li>
					<li><b>Space complexity</b>: The space complexity of isEmpty function in a singly linked list is \(O(1)\) (constant space). The function uses a fixed amount of space to store the result of the comparison (typically a boolean value), regardless of the size of the linked list.</li>
				</ul>
			</li>
			<li><code>merge()</code>:<br>
				<ul>
					<li><b>Description</b>: Combines two sorted linked lists into a single sorted linked list. </li>
					<li><b>Time complexity</b>: The time complexity of merge function in a singly linked list is \(O(n + m)\) (linear time). The reason for this complexity is that each node from both lists is visited exactly once. In the worst case, the function will traverse both lists entirely, performing comparisons and linking nodes. Where \(n\) is the number of nodes in the first linked list and \(m\) is the number of nodes in the second linked list.</li>
					<li><b>Space complexity</b>: The space complexity of merge function in a singly linked list is \(O(n + m)\) (linear space) due to the call stack storing recursive calls. In the worst case, the maximum depth of recursion will be equal to the total number of nodes in both lists combined, leading to \(n + m\) recursive calls.</li>
				</ul>
			</li>
			<li><code>sort()</code>:<br>
				<ul>
					<li><b>Description</b>: Arranges the elements of a singly linked list, in a specific order (typically ascending or descending).</li>
					<li><b>Time complexity</b>: The time complexity of sort function in a singly linked list, when using merge sort is \(O(n \log n)\) (linearithmic time) because the algorithm consistently divides the list into halves and requires a linear amount of time \(O(n)\) to merge those halves back together. The logarithmic factor \(\log n\) comes from the number of times the list can be divided in half (depth of recursion).</li>
					<li><b>Space complexity</b>: The space complexity of sort function in a singly linked list, specifically Merge Sort, is \(O(n)\) (linear space) because it requires additional space for the temporary arrays or linked lists used during the merge process. When merging two halves, the algorithm needs space to hold the merged elements before copying them back to the original array or linked list.</li>
				</ul>
			</li>
			<li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all nodes from the list and free up the memory they occupy, effectively making the list empty.</li>
					<li><b>Time complexity</b>: The time complexity of clear function in a singly linked list is \(O(n)\) (linear time). The function iterates through each node exactly once, freeing its memory. Since it processes all nodes in the list, the time complexity is proportional to the number of nodes.</li>
					<li><b>Space complexity</b>: The space complexity of clear function in a singly linked list is \(O(1)\) (constant space). The function only requires a fixed amount of extra memory for the iteration, typically for a pointer to traverse the list. No additional memory structures are needed, regardless of the size of the linked list.</li>
				</ul>
			</li>
        </ul>
		
		<h3 class="post-subtitle">Non-Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Non-Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// defines a structure to represent a node in a singly linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** headRef, int data) {
    Node* newNode = createNode(data);
    newNode-&gt;next = *headRef;
    *headRef = newNode;
}

// Function to insert a node at the end of the list
void insertAtEnd(Node** headRef, int data) {
    Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    Node* temp = *headRef;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL.\n");
        return;
    }
	
	Node* newNode = createNode(data);
	
    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node** headRef, Node* nextNode, int data) {
    if (*headRef == NULL) {
        printf("The list cannot be empty\n");
        return;
    }
    
	if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }
	
	Node* newNode = createNode(data);
	
    // If the nextNode is the head node, handle the insertion at beginning
    if (*headRef == nextNode) {
        newNode-&gt;next = *headRef;
        *headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = *headRef;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position (0-based index)
void insertAtPosition(Node** headRef, int data, int position) {
    Node* newNode = createNode(data);
    
    // If position is at the beginning
    if (position == 0) {
        newNode-&gt;next = *headRef;
        *headRef = newNode;
        return;
    }

    Node* temp = *headRef;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes
    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = *headRef;
    *headRef = (*headRef)-&gt;next;
    free(temp);
}

// Function to delete a node at the end of the list
void deleteAtEnd(Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;
    
    // If there's only one node in the list
    if (temp-&gt;next == NULL) {
        free(temp);
        *headRef = NULL;
        return;
    }

    // Traverse to the second last node
    while (temp-&gt;next-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    // Free the last node
    free(temp-&gt;next);
    temp-&gt;next = NULL;
}

// Function to delete a node at a specific position (0-based index)
void deleteAtPosition(Node** headRef, int position) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *headRef;

    // If head needs to be removed
    if (position == 0) {
        *headRef = temp-&gt;next; // Change head
        free(temp); // Free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    // If position is more than number of nodes
    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nextNode = temp-&gt;next-&gt;next;
    free(temp-&gt;next); // Free memory
    temp-&gt;next = nextNode; // Unlink the deleted node from the list
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d -&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, int key) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp-&gt;data == key)
            return 1; // Key found
        temp = temp-&gt;next;
    }
    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** headRef) {
    Node *prev = NULL, *current = *headRef, *next = NULL;
    while (current != NULL) {
        next = current-&gt;next; // Store next
        current-&gt;next = prev; // Reverse current node's pointer
        prev = current;       // Move pointers one position ahead
        current = next;
    }
    *headRef = prev;
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
		//while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;data); // Create a new node
            *headRef = newNode;
            //headRef = &((*headRef)-&gt;next);
            //head2 = head2-&gt;next;
			merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
        //}
        return;
    }
    if (head2 == NULL) {
        //while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;data); // Create a new node
            *headRef = newNode;
            //headRef = &((*headRef)-&gt;next);
            //head1 = head1-&gt;next;
			merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
        //}
        return;
    }

    if (head1-&gt;data &lt;= head2-&gt;data) {
        Node* newNode = createNode(head1-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
    } else {
        Node* newNode = createNode(head2-&gt;data); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
    }
}
// Function to get the middle of the linked list
void middle(Node** mid, Node* head) {
    if (head == NULL) return;
    
    Node* slow = head;
    Node* fast = head-&gt;next;
    
    while (fast != NULL) {
        fast = fast-&gt;next;
        if (fast != NULL) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }
    
    *mid = slow; // Update the pointer to the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
    middle(&mid, head);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;
  
    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}

// Function to clear the entire linked list and free memory
void clear(Node** headRef) {
    Node* current = *headRef;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *headRef = NULL;
}

// Main function to test the linked list operations
int main() {
    Node* list = NULL; // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(&list, 5);
    insertAtBeginning(&list, 3);
    insertAtBeginning(&list, 1);

    printf("List after inserting at the beginning: ");
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(&list, 7);
    insertAtEnd(&list, 9);

    printf("List after inserting at the end: ");
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(&list, 4, 2);

    printf("List after inserting 4 at position 2: ");
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    printf("List after inserting 6 after the second node: ");
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != NULL && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(&list, temp, 8);

    printf("List after inserting 8 before the node with value 7: ");
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(&list);

    printf("List after deleting the first node: ");
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(&list);

    printf("List after deleting the last node: ");
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(&list, 2);

    printf("List after deleting the node at position 2: ");
    traverse(list);
	
	// 9. Check if list is empty
	if (isEmpty(list)) {
		printf("The list is empty.\n");
	} else {
		printf("The list is not empty.\n");
	}


    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        printf("Element %d found in the list.\n", key);
    } else {
        printf("Element %d not found in the list.\n", key);
    }

    // 11. Reverse the list
    reverse(&list);

    printf("List after reversing: ");
    traverse(list);

    // 12. Sort the list
    sort(&list);

    printf("List after sorting: ");
    traverse(list);

    // 13. Get the size of the list
    printf("Size of the list: %d\n", size(list));

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        printf("Element at index %d: %d\n", index, value);
    } else {
        printf("Index %d is out of range.\n", index);
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    printf("List after setting value 10 at index 2: ");
    traverse(list);

    // 16. Clear the list
    clear(&list);

    printf("List after clearing: ");
    traverse(list);

    return 0;
}</code></pre>

		<p>Here is the Non-Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;

using namespace std;

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;

    // Constructor to create a new node
    Node(int data) : data(data), next(nullptr) {}
};

// Insert at the beginning
void insertAtBeginning(Node*& head, int data) {
    Node* newNode = new Node(data);
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
void insertAtEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a new node after a given previous node
void insertAfterNode(Node* prevNode, int data) {
    // Check if the previous node is NULL
    if (prevNode == nullptr) {
        std::cout &lt;&lt; "The given previous node cannot be NULL." &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // Insert the new node after the previous node
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a new node before a given next node
void insertBeforeNode(Node*& headRef, Node* nextNode, int data) {
    if (headRef == nullptr) {
        std::cout &lt;&lt; "The list cannot be empty" &lt;&lt; std::endl;
        return;
    }

    if (nextNode == nullptr) {
        std::cout &lt;&lt; "The given next node cannot be NULL" &lt;&lt; std::endl;
        return;
    }

    Node* newNode = new Node(data);

    // If the nextNode is the head node, handle the insertion at the beginning
    if (headRef == nextNode) {
        newNode-&gt;next = headRef;
        headRef = newNode;
        return;
    }

    // Find the node just before the nextNode
    Node* temp = headRef;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        std::cout &lt;&lt; "The given next node is not found in the list" &lt;&lt; std::endl;
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Insert at a specific position
void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = new Node(data);
    if (position == 0) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}


// Delete at the beginning
void deleteAtBeginning(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node* temp = head;
    head = head-&gt;next;
    delete temp;
}


// Delete at the end
void deleteAtEnd(Node*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node* temp = head;
    while (temp-&gt;next-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    delete temp-&gt;next;
    temp-&gt;next = nullptr;
}


// Delete at a specific position
void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node* temp = head;
        head = head-&gt;next;
        delete temp;
        return;
    }

    Node* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Function to access an element at a specific index (0-based)
int get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data;
        count++;
        temp = temp-&gt;next;
    }
    return -1; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, int newValue) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = newValue;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    cout &lt;&lt; "Index out of range\n"; // Handle case where index exceeds list length
}

// Function to check if the list is empty
bool isEmpty(Node* head) {
    return head == nullptr;
}

// Traverse the list
void traverse(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; temp-&gt;data &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}


// Search for an element
bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    }
    return false;
}


// Reverse the list
void reverse(Node*& head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;

    while (current != nullptr) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    head = prev;
}


// Get the size of the list
int size(Node* head) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Merge two sorted lists
void merge(Node*& headRef, Node* head1, Node* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        if (head2 != nullptr) {
            //std::cout &lt;&lt; "head1 is null, adding node from head2 with data: " &lt;&lt; head2-&gt;data &lt;&lt; std::endl;
            headRef = new Node(head2-&gt;data);
            merge(headRef-&gt;next, head1, head2-&gt;next); // Continue merging head2
        }
        return;
    }
    if (head2 == nullptr) {
        if (head1 != nullptr) {
            //std::cout &lt;&lt; "head2 is null, adding node from head1 with data: " &lt;&lt; head1-&gt;data &lt;&lt; std::endl;
            headRef = new Node(head1-&gt;data);
            merge(headRef-&gt;next, head1-&gt;next, head2); // Continue merging head1
        }
        return;
    }

    // Merge the two lists
    if (head1-&gt;data &lt;= head2-&gt;data) {
        //std::cout &lt;&lt; "Choosing node from head1 with data: " &lt;&lt; head1-&gt;data &lt;&lt; std::endl;
        headRef = new Node(head1-&gt;data);
        merge(headRef-&gt;next, head1-&gt;next, head2); // Move head1 forward
    } else {
        //std::cout &lt;&lt; "Choosing node from head2 with data: " &lt;&lt; head2-&gt;data &lt;&lt; std::endl;
        headRef = new Node(head2-&gt;data);
        merge(headRef-&gt;next, head1, head2-&gt;next); // Move head2 forward
    }
}


// Find the middle of the list
void middle(Node*& mid, Node* head) {
    if (head == nullptr) {
        mid = nullptr;
        return;
    }

    Node* slow = head;
    Node* fast = head-&gt;next;

    while (fast != nullptr && fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    mid = slow;
}


// Sort the list using merge sort
void sort(Node*& head) {
    if (head == nullptr || head-&gt;next == nullptr)
        return;

    Node* mid = nullptr;
    middle(mid, head);

    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;

    Node* left = head;
    Node* right = nextToMid;

    sort(left);
    sort(right);

    merge(head, left, right);
}

// Clear the list
void clear(Node*& head) {
    Node* current = head;
    while (current != nullptr) {
        Node* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

int main() {
    Node* list = nullptr;  // Initialize an empty linked list

    // 1. Insert elements at the beginning
    insertAtBeginning(list, 5);
    insertAtBeginning(list, 3);
    insertAtBeginning(list, 1);

    std::cout &lt;&lt; "List after inserting at the beginning: ";
    traverse(list);

    // 2. Insert elements at the end
    insertAtEnd(list, 7);
    insertAtEnd(list, 9);

    std::cout &lt;&lt; "List after inserting at the end: ";
    traverse(list);

    // 3. Insert element at position 2
    insertAtPosition(list, 4, 2);

    std::cout &lt;&lt; "List after inserting 4 at position 2: ";
    traverse(list);

    // 4. Insert element after the second node
    Node* secondNode = list-&gt;next;
    insertAfterNode(secondNode, 6);

    std::cout &lt;&lt; "List after inserting 6 after the second node: ";
    traverse(list);

    // 5. Insert element before the node with value 7
    Node* temp = list;
    while (temp != nullptr && temp-&gt;data != 7) {
        temp = temp-&gt;next;
    }
    insertBeforeNode(list, temp, 8);

    std::cout &lt;&lt; "List after inserting 8 before the node with value 7: ";
    traverse(list);

    // 6. Delete the first node
    deleteAtBeginning(list);

    std::cout &lt;&lt; "List after deleting the first node: ";
    traverse(list);

    // 7. Delete the last node
    deleteAtEnd(list);

    std::cout &lt;&lt; "List after deleting the last node: ";
    traverse(list);

    // 8. Delete the node at position 2
    deleteAtPosition(list, 2);

    std::cout &lt;&lt; "List after deleting the node at position 2: ";
    traverse(list);
	
	// 9. Check if the list is empty
    if (isEmpty(list)) {
        cout &lt;&lt; "The list is empty." &lt;&lt; endl;
    } else {
		cout &lt;&lt; "The list is not empty." &lt;&lt; endl;
	}
	
    // 10. Search for an element
    int key = 6;
    if (search(list, key)) {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found in the list." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " not found in the list." &lt;&lt; std::endl;
    }

    // 11. Reverse the list
    reverse(list);

    std::cout &lt;&lt; "List after reversing: ";
    traverse(list);

    // 12. Sort the list
    sort(list);

    std::cout &lt;&lt; "List after sorting: ";
    traverse(list);

    // 13. Get the size of the list
    std::cout &lt;&lt; "Size of the list: " &lt;&lt; size(list) &lt;&lt; std::endl;

    // 14. Access an element at a specific index
    int index = 2;
    int value = get(list, index);
    if (value != -1) {
        std::cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Index " &lt;&lt; index &lt;&lt; " is out of range." &lt;&lt; std::endl;
    }

    // 15. Set a new value at a specific index
    set(list, 2, 10);
    std::cout &lt;&lt; "List after setting value 10 at index 2: ";
    traverse(list);

    // 16. Clear the list
    clear(list);

    std::cout &lt;&lt; "List after clearing: ";
    traverse(list);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">public class LinkedList {

    // Node structure for singly linked list
    static class Node {
        int data;
        Node next;

        // Constructor to create a new node
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static Node insertAtBeginning(Node head, int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static Node insertAtEnd(Node head, int data) {
        Node newNode = new Node(data);
        if (head == null) {
            return newNode;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node insertAtPosition(Node head, int data, int position) {
        Node newNode = new Node(data);
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }
	
	// Insert after a given node
    public static void insertAfterNode(Node prevNode, int data) {
        if (prevNode == null) {
            System.out.println("The given previous node cannot be NULL.");
            return;
        }

        Node newNode = new Node(data);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }

    // Insert before a given node
    public static Node insertBeforeNode(Node head, Node nextNode, int data) {
        if (head == null) {
            System.out.println("The list cannot be empty");
            return head;
        }

        if (nextNode == null) {
            System.out.println("The given next node cannot be NULL");
            return head;
        }

        Node newNode = new Node(data);

        if (head == nextNode) {
            newNode.next = head;
            return newNode;
        }

        Node temp = head;
        while (temp != null && temp.next != nextNode) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("The given next node is not found in the list");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }
	
    // Delete at the beginning
    public static Node deleteAtBeginning(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        return head.next;
    }

    // Delete at the end
    public static Node deleteAtEnd(Node head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node temp = head;
        while (temp.next.next != null) {
            temp = temp.next;
        }
        temp.next = null;
        return head;
    }

    // Delete at a specific position
    public static Node deleteAtPosition(Node head, int position) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (position == 0) {
            return head.next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        temp.next = temp.next.next;
        return head;
    }
	
	// Get element at a specific index
    public static int get(Node head, int index) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
        return -1; // Return -1 if the index is out of range
    }

    // Set element at a specific index
    public static void set(Node head, int index, int newValue) {
        int count = 0;
        Node temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        System.out.println("Index out of range");
    }

    // Traverse the list
    public static void traverse(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " -> ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }
	
	// Check if the list is empty
	public static boolean isEmpty(Node head) {
		return head == null;
	}

    // Search for an element
    public static boolean search(Node head, int key) {
        Node temp = head;
        while (temp != null) {
            if (temp.data == key) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Reverse the list
    public static Node reverse(Node head) {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }
	
	// Merge two sorted lists
    public static Node merge(Node head1, Node head2) {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.data &lt;= head2.data) {
            head1.next = merge(head1.next, head2);
            return head1;
        } else {
            head2.next = merge(head1, head2.next);
            return head2;
        }
    }

    // Find the middle of the list
    public static Node middle(Node head) {
        if (head == null) return null;

        Node slow = head;
        Node fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node sort(Node head) {
        if (head == null || head.next == null) return head;

        // Find the middle node
        Node mid = middle(head);
        Node nextToMid = mid.next;
        mid.next = null;

        // Recursively split and sort both halves
        Node left = sort(head);
        Node right = sort(nextToMid);

        // Merge the sorted halves
        return merge(left, right);
    }
	
    // Get the size of the list
    public static int size(Node head) {
        int count = 0;
        Node temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Clear the entire list
	public static Node clear(Node head) {
		Node current = head;
		while (current != null) {
			Node nextNode = current.next;  // Save reference to the next node
			current.next = null;           // Break the link to the next node
			current = nextNode;            // Move to the next node
		}
		return null;  // Set head to null to indicate the list is empty
	}


    // Main method to test
    public static void main(String[] args) {
        Node head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, 5);
        head = insertAtBeginning(head, 10);
        head = insertAtBeginning(head, 3);

        System.out.println("List after inserting at the beginning: ");
        traverse(head);

        // 2. Insert element at the end
        head = insertAtEnd(head, 7);
        head = insertAtEnd(head, 2);

        System.out.println("List after inserting at the end: ");
        traverse(head);

        // 3. Insert at a specific position
        head = insertAtPosition(head, 4, 2);
        System.out.println("List after inserting at position 2: ");
        traverse(head);
		
		// 4. Insert after a specific node
        insertAfterNode(head.next, 8);
        System.out.println("List after inserting 8 after second node: ");
        traverse(head);

        // 5. Insert before a specific node
        head = insertBeforeNode(head, head.next, 12);
        System.out.println("List after inserting 12 before second node: ");
        traverse(head);
		
        // 6. Delete at the beginning
        head = deleteAtBeginning(head);
        System.out.println("List after deleting at the beginning: ");
        traverse(head);

        // 7. Delete at the end
        head = deleteAtEnd(head);
        System.out.println("List after deleting at the end: ");
        traverse(head);

        // 8. Delete at a specific position
        head = deleteAtPosition(head, 2);
        System.out.println("List after deleting at position 2: ");
        traverse(head);
		
		// 9. Check if the list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}
	
        // 10. Search for an element
        int key = 7;
        if (search(head, key)) {
            System.out.println("Element " + key + " found in the list");
        } else {
            System.out.println("Element " + key + " not found in the list");
        }

        // 11. Reverse the list
        head = reverse(head);
        System.out.println("List after reversing: ");
        traverse(head);

        // 12. Get the size of the list
        System.out.println("Size of the list: " + size(head));
		
		// 13. Get element at a specific index
		int indexToGet = 2;
		int value = get(head, indexToGet);
		if (value != -1) {
			System.out.println("Element at index " + indexToGet + ": " + value);
		}

		// 14. Set value at a specific index
		int indexToSet = 1;
		int newValue = 25;
		System.out.println("Setting value at index " + indexToSet + " to " + newValue);
		set(head, indexToSet, newValue);
		
		System.out.println("Updated list after set operation:");
		traverse(head);
	
		// 15. Sort the list
        head = sort(head);

        System.out.println("Sorted list:");
		traverse(head);
		
        // 16. Clear the list
        head = clear(head);
        System.out.println("List after clearing: ");
        traverse(head);
    }
}</code></pre>
		
		<p>Here is the Non-Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-java hljs">using System;

public class LinkedList
{
    // Node structure for singly linked list
    public class Node
    {
        public int Data;
        public Node Next;

        // Constructor to create a new node
        public Node(int data)
        {
            Data = data;
            Next = null;
        }
    }

    // Insert at the beginning
    public static Node InsertAtBeginning(Node head, int data)
    {
        Node newNode = new Node(data)
        {
            Next = head
        };
        return newNode;
    }

    // Insert at the end
    public static Node InsertAtEnd(Node head, int data)
    {
        Node newNode = new Node(data);
        if (head == null)
        {
            return newNode;
        }
        Node temp = head;
        while (temp.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = newNode;
        return head;
    }

    // Insert at a specific position
    public static Node InsertAtPosition(Node head, int data, int position)
    {
        Node newNode = new Node(data);
        if (position == 0)
        {
            newNode.Next = head;
            return newNode;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }
	
	// Insert after a given node
    public static void InsertAfterNode(Node prevNode, int data)
    {
        if (prevNode == null)
        {
            Console.WriteLine("The given previous node cannot be null");
            return;
        }
        Node newNode = new Node(data);
        newNode.Next = prevNode.Next;
        prevNode.Next = newNode;
    }

    // Insert before a given node
    public static Node InsertBeforeNode(Node head, Node nextNode, int data)
    {
        if (nextNode == null)
        {
            Console.WriteLine("The given next node cannot be null");
            return head;
        }
        if (head == nextNode)
        {
            return InsertAtBeginning(head, data);
        }
        Node temp = head;
        while (temp != null && temp.Next != nextNode)
        {
            temp = temp.Next;
        }
        if (temp == null)
        {
            Console.WriteLine("The given next node is not present in the list");
            return head;
        }
        Node newNode = new Node(data);
        newNode.Next = nextNode;
        temp.Next = newNode;
        return head;
    }


    // Delete at the beginning
    public static Node DeleteAtBeginning(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
        return head.Next;
    }

    // Delete at the end
    public static Node DeleteAtEnd(Node head)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (head.Next == null)
        {
            return null;
        }

        Node temp = head;
        while (temp.Next.Next != null)
        {
            temp = temp.Next;
        }
        temp.Next = null;
        return head;
    }

    // Delete at a specific position
    public static Node DeleteAtPosition(Node head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }

        if (position == 0)
        {
            return head.Next;
        }

        Node temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }

        if (temp == null || temp.Next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }

        temp.Next = temp.Next.Next;
        return head;
    }
	
	// Function to access an element at a specific index (0-based)
	public static int Get(Node head, int index)
	{
		int count = 0;
		Node temp = head;
		while (temp != null)
		{
			if (count == index)
				return temp.Data;
			count++;
			temp = temp.Next;
		}
		Console.WriteLine("Index out of range");
		return -1; // Index out of range
	}

	// Function to set an element at a specific index (0-based)
	public static void Set(Node head, int index, int newValue)
	{
		Node current = head;
		int count = 0;

		// Traverse the list until the specified index
		while (current != null)
		{
			if (count == index)
			{
				current.Data = newValue; // Update the node's value
				return;                 // Exit the function after the update
			}
			count++;
			current = current.Next;     // Move to the next node
		}

		Console.WriteLine("Index out of range"); // Handle case where index exceeds list length
	}
	
	// Check if the list is empty
	public static bool IsEmpty(Node head)
	{
		return head == null;
	}

    // Traverse the list
    public static void Traverse(Node head)
    {
        Node temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " -> ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Search for an element
    public static bool Search(Node head, int key)
    {
        Node temp = head;
        while (temp != null)
        {
            if (temp.Data == key)
            {
                return true;
            }
            temp = temp.Next;
        }
        return false;
    }

    // Reverse the list
    public static Node Reverse(Node head)
    {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null)
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Get the size of the list
    public static int Size(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }
	
	 // Merge two sorted lists
    public static Node Merge(Node head1, Node head2)
    {
        if (head1 == null) return head2;
        if (head2 == null) return head1;

        if (head1.Data &lt;= head2.Data)
        {
            head1.Next = Merge(head1.Next, head2);
            return head1;
        }
        else
        {
            head2.Next = Merge(head1, head2.Next);
            return head2;
        }
    }

    // Find the middle of the list
    public static Node Middle(Node head)
    {
        if (head == null) return null;

        Node slow = head;
        Node fast = head;

        while (fast.Next != null && fast.Next.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }

    // Sort the list using merge sort
    public static Node Sort(Node head)
    {
        if (head == null || head.Next == null)
            return head;

        // Find the middle of the list
        Node middle = Middle(head);
        Node nextToMiddle = middle.Next;

        // Split the list into two halves
        middle.Next = null;

        // Recursively sort the two halves
        Node left = Sort(head);
        Node right = Sort(nextToMiddle);

        // Merge the sorted halves
        return Merge(left, right);
    }
	
    // Clear the entire list
	public static Node Clear(Node head)
	{
		Node current = head;
		while (current != null)
		{
			Node nextNode = current.Next;  // Save reference to the next node
			current.Next = null;           // Break the link to the next node
			current = nextNode;            // Move to the next node
		}
		return null;  // Return null to indicate the list is empty
	}


    // Main method to test
    public static void Main(string[] args)
    {
        Node head = null;

        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, 5);
        head = InsertAtBeginning(head, 10);
        head = InsertAtBeginning(head, 3);

        Console.WriteLine("List after inserting at the beginning:");
        Traverse(head);

        // 2. Insert element at the end
        head = InsertAtEnd(head, 7);
        head = InsertAtEnd(head, 2);

        Console.WriteLine("List after inserting at the end:");
        Traverse(head);

        // 3. Insert at a specific position
        head = InsertAtPosition(head, 4, 2);
        Console.WriteLine("List after inserting at position 2:");
        Traverse(head);

        // 4. Insert after a specific node
        InsertAfterNode(head.Next, 8);
        Console.WriteLine("List after inserting 8 after second node:");
        Traverse(head);

        // 5. Insert before a specific node
        head = InsertBeforeNode(head, head.Next, 12);
        Console.WriteLine("List after inserting 12 before second node:");
        Traverse(head);

        // 6. Delete at the beginning
        head = DeleteAtBeginning(head);
        Console.WriteLine("List after deleting at the beginning:");
        Traverse(head);

        // 7. Delete at the end
        head = DeleteAtEnd(head);
        Console.WriteLine("List after deleting at the end:");
        Traverse(head);

        // 8. Delete at a specific position
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("List after deleting at position 2:");
        Traverse(head);
		
		// 9. Check if the list is empty
		if (IsEmpty(head))
		{
			Console.WriteLine("The list is empty.");
		}
		else
		{
			Console.WriteLine("The list is not empty.");
		}

        // 10. Search for an element
        int key = 7;
        if (Search(head, key))
        {
            Console.WriteLine($"Element {key} found in the list");
        }
        else
        {
            Console.WriteLine($"Element {key} not found in the list");
        }

        // 11. Reverse the list
        head = Reverse(head);
        Console.WriteLine("List after reversing:");
        Traverse(head);

        // 12. Get the size of the list
        Console.WriteLine("Size of the list: " + Size(head));
		
		// 13. Get value at a specific index
		int indexToGet = 2;  // 0-based index
		int value = Get(head, indexToGet);
		Console.WriteLine($"Value at index {indexToGet}: {value}");

		// 14. Set a new value at a specific index
		int indexToSet = 2;  // 0-based index
		int newValue = 99;
		Set(head, indexToSet, newValue);

		Console.WriteLine($"List after setting index {indexToSet} to {newValue}:");
		Traverse(head);
	
        // 15. Sort the list
        head = Sort(head);
        Console.WriteLine("Sorted list:");
        Traverse(head);

        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("List after clearing:");
        Traverse(head);
    }
}</code></pre>
		
		<h3 class="post-subtitle">Generic Singly Linked List Implementation</h3>
		
		<p>Here is the Generic singly linked list implementation in C:</p>
        
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// StackElement structure to hold data and a toString function pointer
typedef struct {
    void* data;           // Pointer to hold the actual data
    char* toString;       // This will be modified to hold the string representation
} StackElement;

// Node structure for singly linked list
typedef struct Node {
    StackElement element;
    struct Node* next;     // Pointer to the next node
} Node;

// Function to create a new node
Node* createNode(StackElement element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    newNode-&gt;next = *head;
    *head = newNode;
}

// Function to insert a node at the end of the list (generic)
void insertAtEnd(Node** head, StackElement element) {
    Node* newNode = createNode(element);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a node after a given previous node
void insertAfterNode(Node* prevNode, StackElement element) {
    // Check if the previous node is NULL
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // Insert the new node after prevNode
    newNode->next = prevNode->next;
    prevNode->next = newNode;
}

// Function to insert a node before a given next node
void insertBeforeNode(Node** head, Node* nextNode, StackElement element) {
    // Check if the head is NULL (list is empty)
    if (*head == NULL) {
        printf("The list cannot be empty\n");
        return;
    }

    // Check if the nextNode is NULL
    if (nextNode == NULL) {
        printf("The given next node cannot be NULL\n");
        return;
    }

    // Create the new node with the given StackElement
    Node* newNode = createNode(element);

    // If the nextNode is the head node, handle the insertion at beginning
    if (*head == nextNode) {
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while (temp != NULL && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    // If temp is NULL, then nextNode is not found in the list
    if (temp == NULL) {
        printf("The given next node is not found in the list\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to insert a node at a specific position
void insertAtPosition(Node** head, StackElement element, int position) {
    Node* newNode = createNode(element);
    
    // If position is at the beginning
    if (position == 0) {
        newNode-&gt;next = *head;
        *head = newNode;
        return;
    }

    Node* temp = *head;
    for (int i = 0; i &lt; position - 1 && temp != NULL; i++) {
        temp = temp-&gt;next;
    }

    // If position is greater than the number of nodes
    if (temp == NULL) {
        printf("Position out of bounds\n");
        free(newNode);
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Function to delete a node at the beginning of the list
void deleteAtBeginning(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }
    
    Node* temp = *head;           // Temporary pointer to the head node
    *head = (*head)-&gt;next;        // Move the head to the next node
    
    free(temp);                   // Free the node
}

/// Function to delete a node at the end of the list
void deleteAtEnd(Node** head) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    // If there's only one node in the list
    if (temp-&gt;next == NULL) {
        free(temp);                 // Free the node
        *head = NULL;
        return;
    }

    // Traverse to the second last node
    while (temp-&gt;next-&gt;next != NULL) {
        temp = temp-&gt;next;
    }

    free(temp-&gt;next);                 // Free the last node
    temp-&gt;next = NULL;                // Set the second last node's next to NULL
}

// Function to delete a node at a given position
void deleteAtPosition(Node** head, int position) {
    if (*head == NULL) {
        printf("List is empty\n");
        return;
    }

    Node* temp = *head;

    // If head needs to be removed
    if (position == 0) {
        *head = temp-&gt;next; // Change head
        free(temp); // Free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i = 0; temp != NULL && i &lt; position - 1; i++) {
        temp = temp-&gt;next;
    }

    // If position is more than number of nodes
    if (temp == NULL || temp-&gt;next == NULL) {
        printf("Position out of bounds\n");
        return;
    }

    // Node temp-&gt;next is the node to be deleted
    Node* nextNode = temp-&gt;next-&gt;next;

    free(temp-&gt;next);                 // Free the node
    temp-&gt;next = nextNode;            // Unlink the deleted node from the list
}

// Function to traverse the list and print all elements
void traverse(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        char* str = temp-&gt;element.toString;
        printf("%s -&gt; ", str);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Function to search for an element in the list
int search(Node* head, StackElement keyElement) {
    Node* temp = head;

    while (temp != NULL) {
        // Call toString to get the string representation of the data in the current node
        char* currentStr = temp-&gt;element.toString;
        char* keyStr = keyElement.toString;

        // Compare the string representations of the current node's data and the key element's data
        if (strcmp(currentStr, keyStr) == 0) {
            return 1; // Key found
        }
		
        temp = temp-&gt;next;
    }

    return 0; // Key not found
}

// Function to reverse the linked list
void reverse(Node** head) {
    Node *prev = NULL, *current = *head, *next = NULL;
    while (current != NULL) {
        next = current-&gt;next; // Store next
        current-&gt;next = prev; // Reverse current node's pointer
        prev = current;       // Move pointers one position ahead
        current = next;
    }
    *head = prev;
}

// Function to get the size of the linked list
int size(Node* head) {
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp-&gt;next;
    }
    return size;
}

// Function to check if the list is empty
int isEmpty(Node* head) {
    return head == NULL;
}

// Function to access an element at a specific index (0-based)
StackElement get(Node* head, int index) {
    int count = 0;
    Node* temp = head;
    while (temp != NULL) {
        if (count == index)
            return temp-&gt;element;
        count++;
        temp = temp-&gt;next;
    }
    StackElement emptyElement = {NULL, ""};
    return emptyElement; // Index out of range
}

// Function to set an element at a specific index (0-based)
void set(Node* head, int index, StackElement element) {
    Node* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != NULL) {
        if (count == index) {
            current-&gt;element = element;  // Update the node's value
            return;                    // Exit the function after the update
        }
        count++;
        current = current-&gt;next;      // Move to the next node
    }
    
    printf("Index out of range\n"); // Handle case where index exceeds list length
}

// Function to merge two lists
void merge(Node** headRef, Node* head1, Node* head2) {
    if (head1 == NULL) {
        while (head2 != NULL) {
            Node* newNode = createNode(head2-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head2 = head2-&gt;next;
        }
        return;
    }
    if (head2 == NULL) {
        while (head1 != NULL) {
            Node* newNode = createNode(head1-&gt;element); // Create a new node
            *headRef = newNode;
            headRef = &((*headRef)-&gt;next);
            head1 = head1-&gt;next;
        }
        return;
    }

    if (strcmp(head1-&gt;element.toString, head2-&gt;element.toString) &lt; 0) {
        Node* newNode = createNode(head1-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1-&gt;next, head2);
    } else {
        Node* newNode = createNode(head2-&gt;element); // Create a new node
        *headRef = newNode;
        merge(&((*headRef)-&gt;next), head1, head2-&gt;next);
    }
}

// Function to get the middle of the linked list
void middle(Node* head, Node** middle) {
    if (head == NULL) {
        *middle = NULL; // Set middle node to NULL if list is empty
        return;
    }

    Node* slow = head;
    Node* fast = head->next;

    while (fast != NULL) {
        fast = fast->next;
        if (fast != NULL) {
            slow = slow->next;
            fast = fast->next;
        }
    }

    *middle = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
void sort(Node** headRef) {
    if (*headRef == NULL || (*headRef)-&gt;next == NULL)
        return;

    Node* head = *headRef;
    Node* mid = NULL;
	middle(head, &mid);
    Node* nextToMid = mid-&gt;next;
    mid-&gt;next = NULL;

    // Sort the two halves
    sort(&head);
    sort(&nextToMid);

    // Merge the sorted halves
    merge(headRef, head, nextToMid);
}


// Function to clear the entire linked list and free memory
void clear(Node** head) {
    Node* current = *head;
    Node* next;
    
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    
    *head = NULL;
}

struct Person {
    char name[20];
    int age;
};

// Main function to test the linked list operations
int main() {
    // Create People
    struct Person alice = {"Alice", 30};
    struct Person john = {"John", 19};
    struct Person albert = {"Albert", 28};
    struct Person robert = {"Robert", 20};

    // Create StackElement for people
    StackElement personElement1 = {&alice, "Person{name:\"Alice\", age:30}"};
    StackElement personElement2 = {&john, "Person{name:\"John\", age:19}"};
    StackElement personElement3 = {&albert, "Person{name:\"Albert\", age:28}"};
    StackElement personElement4 = {&robert, "Person{name:\"Robert\", age:20}"};

    // Initialize Linked List
    Node* personList = NULL;

    // 1. **Insert elements at the beginning**
    insertAtBeginning(&personList, personElement1);
    insertAtBeginning(&personList, personElement2);
	
	// 2. **Insert elements at the beginning**
    insertAtEnd(&personList, personElement3);
    insertAtEnd(&personList, personElement4);
    printf("\nList after inserting elements:\n");
    traverse(personList);

    // 3. **Insert at a specific position**
    StackElement newElement = {&alice, "Person{name:\"Eve\", age:22}"};
    insertAtPosition(&personList, newElement, 2);
    printf("\nList after inserting at position 2:\n");
    traverse(personList);

    // 4. **Insert before a node**
    insertBeforeNode(&personList, personList->next, newElement);
    printf("\nList after inserting before second node:\n");
    traverse(personList);

    // 5. **Insert after a node**
    insertAfterNode(personList->next, newElement);
    printf("\nList after inserting after second node:\n");
    traverse(personList);

    // 6. **Delete the first node**
    deleteAtBeginning(&personList);
    printf("\nList after deleting first node:\n");
    traverse(personList);

    // 7. **Delete the last node**
    deleteAtEnd(&personList);
    printf("\nList after deleting last node:\n");
    traverse(personList);

    // 8. **Delete at a specific position**
    deleteAtPosition(&personList, 1);
    printf("\nList after deleting node at position 1:\n");
    traverse(personList);

    // 9. **Search for an element**
    int found = search(personList, personElement3);
    printf("\nSearch result for 'Albert': %s\n", found ? "Found" : "Not Found");

    // 10. **Get size of list**
    printf("\nSize of the list: %d\n", size(personList));

    // 11. **Check if list is empty**
    printf("\nIs the list empty? %s\n", isEmpty(personList) ? "Yes" : "No");

    // 12. **Access an element by index**
    StackElement retrievedElement = get(personList, 1);
    printf("\nElement at index 1: %s\n", retrievedElement.toString);

    // 13. **Modify an element at an index**
    StackElement modifiedElement = {&john, "Person{name:\"Updated John\", age:25}"};
    set(personList, 1, modifiedElement);
    printf("\nList after updating element at index 1:\n");
    traverse(personList);

    // 14. **Sort the linked list**
    printf("\nList before sorting:\n");
    traverse(personList);
    sort(&personList);
    printf("\nList after sorting:\n");
    traverse(personList);

    // 15. **Reverse the linked list**
    reverse(&personList);
    printf("\nList after reversing:\n");
    traverse(personList);

    // 16. **Clear the list**
    clear(&personList);
    printf("\nList after clearing:\n");
    traverse(personList);

    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

// Node structure for singly linked list template
template &lt;typename T&gt;
struct Node {
    T data;
    Node* next;

    // Constructor to create a new node
    Node(T data) : data(data), next(nullptr) {}
};

// Insert at the beginning
template &lt;typename T&gt;
void insertAtBeginning(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    newNode-&gt;next = head;
    head = newNode;
}

// Insert at the end
template &lt;typename T&gt;
void insertAtEnd(Node&lt;T&gt;*& head, T data) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Function to insert a node after a given previous node
template &lt;typename T&gt;
void insertAfterNode(Node&lt;T&gt;* prevNode, T element) {
    if (prevNode == nullptr) {
        cout &lt;&lt; "The given previous node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    newNode-&gt;next = prevNode-&gt;next;
    prevNode-&gt;next = newNode;
}

// Function to insert a node before a given next node
template &lt;typename T&gt;
void insertBeforeNode(Node&lt;T&gt;*& head, Node&lt;T&gt;* nextNode, T element) {
    if (head == nullptr) {
        cout &lt;&lt; "The list cannot be empty\n";
        return;
    }

    if (nextNode == nullptr) {
        cout &lt;&lt; "The given next node cannot be NULL\n";
        return;
    }

    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
    
    if (head == nextNode) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp != nullptr && temp-&gt;next != nextNode) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "The given next node is not found in the list\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Insert at a specific position
template &lt;typename T&gt;
void insertAtPosition(Node&lt;T&gt;*& head, T data, int position) {
    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(data);
    if (position == 0) {
        newNode-&gt;next = head;
        head = newNode;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        delete newNode;
        return;
    }

    newNode-&gt;next = temp-&gt;next;
    temp-&gt;next = newNode;
}

// Delete at the beginning
template &lt;typename T&gt;
void deleteAtBeginning(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }
    Node&lt;T&gt;* temp = head;
    head = head-&gt;next;
    delete temp;
}

// Delete at the end
template &lt;typename T&gt;
void deleteAtEnd(Node&lt;T&gt;*& head) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (head-&gt;next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }

    Node&lt;T&gt;* temp = head;
    while (temp-&gt;next-&gt;next != nullptr) {
        temp = temp-&gt;next;
    }

    delete temp-&gt;next;
    temp-&gt;next = nullptr;
}

// Delete at a specific position
template &lt;typename T&gt;
void deleteAtPosition(Node&lt;T&gt;*& head, int position) {
    if (head == nullptr) {
        cout &lt;&lt; "List is empty\n";
        return;
    }

    if (position == 0) {
        Node&lt;T&gt;* temp = head;
        head = head-&gt;next;
        delete temp;
        return;
    }

    Node&lt;T&gt;* temp = head;
    for (int i = 0; i &lt; position - 1 && temp != nullptr; i++) {
        temp = temp-&gt;next;
    }

    if (temp == nullptr || temp-&gt;next == nullptr) {
        cout &lt;&lt; "Position out of bounds\n";
        return;
    }

    Node&lt;T&gt;* nextNode = temp-&gt;next-&gt;next;
    delete temp-&gt;next;
    temp-&gt;next = nextNode;
}

// Traverse the list
template &lt;typename T&gt;
void traverse(Node&lt;T&gt;* head) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        cout &lt;&lt; (temp-&gt;data).toString() &lt;&lt; " -&gt; ";  // Using toString()
        temp = temp-&gt;next;
    }
    cout &lt;&lt; "NULL\n";
}

// Search for an element
template &lt;typename T&gt;
bool search(Node&lt;T&gt;* head, T key) {
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        if (temp-&gt;data == key)
            return true;
        temp = temp-&gt;next;
    }
    return false;
}

// Reverse the list
template &lt;typename T&gt;
void reverse(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* prev = nullptr;
    Node&lt;T&gt;* current = head;
    Node&lt;T&gt;* next = nullptr;

    while (current != nullptr) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    head = prev;
}

// Get the size of the list
template &lt;typename T&gt;
int size(Node&lt;T&gt;* head) {
    int count = 0;
    Node&lt;T&gt;* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp-&gt;next;
    }
    return count;
}

// Function to access an element at a specific index (0-based)
template &lt;typename T&gt;
T get(Node&lt;T&gt;* head, int index) {
    int count = 0;
    Node&lt;T&gt;* temp = head;

    while (temp != nullptr) {
        if (count == index)
            return temp-&gt;data; // Return the data at the index
        count++;
        temp = temp-&gt;next;
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to set an element at a specific index (0-based)
template &lt;typename T&gt;
void set(Node&lt;T&gt;* head, int index, T element) {
    Node&lt;T&gt;* current = head;
    int count = 0;

    // Traverse the list until the specified index
    while (current != nullptr) {
        if (count == index) {
            current-&gt;data = element; // Update the node's value
            return;                  // Exit the function after the update
        }
        count++;
        current = current-&gt;next;     // Move to the next node
    }

    throw out_of_range("Index out of range"); // Throw exception if index is invalid
}

// Function to check if the list is empty
template &lt;typename T&gt;
bool isEmpty(Node&lt;T&gt;* head) {
    return head == nullptr;
}

// Function to merge two lists
template &lt;typename T&gt;
void merge(Node&lt;T&gt;*& headRef, Node&lt;T&gt;* head1, Node&lt;T&gt;* head2) {
    // Handle base cases for empty lists
    if (head1 == nullptr) {
        headRef = head2;
        return;
    }
    if (head2 == nullptr) {
        headRef = head1;
        return;
    }

    // Merge the two lists based on data comparison (using &lt; operator)
    if (head1-&gt;data &lt; head2-&gt;data) {
        headRef = head1;
        merge(headRef-&gt;next, head1-&gt;next, head2);
    } else {
        headRef = head2;
        merge(headRef-&gt;next, head1, head2-&gt;next);
    }
}

// Function to find the middle node of the linked list
template &lt;typename T&gt;
void middle(Node&lt;T&gt;* head, Node&lt;T&gt;*& mid) {
    if (head == nullptr) {
        mid = nullptr; // Set middle node to nullptr if the list is empty
        return;
    }

    Node&lt;T&gt;* slow = head;
    Node&lt;T&gt;* fast = head-&gt;next;

    while (fast != nullptr) {
        fast = fast-&gt;next;
        if (fast != nullptr) {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
    }

    mid = slow; // Update the middle node
}

// Function to sort the linked list (using Merge Sort)
template &lt;typename T&gt;
void sort(Node&lt;T&gt;*& headRef) {
    if (headRef == nullptr || headRef-&gt;next == nullptr)
        return;

    Node&lt;T&gt;* mid = nullptr;
    middle(headRef, mid);
    Node&lt;T&gt;* nextToMid = mid-&gt;next;
    mid-&gt;next = nullptr;

    // Sort the two halves
    sort(headRef);
    sort(nextToMid);

    // Merge the sorted halves
    Node&lt;T&gt;* mergedHead = nullptr;
    merge(mergedHead, headRef, nextToMid);
    headRef = mergedHead; // Update the original head reference
}

// Clear the list
template &lt;typename T&gt;
void clear(Node&lt;T&gt;*& head) {
    Node&lt;T&gt;* current = head;
    while (current != nullptr) {
        Node&lt;T&gt;* next = current-&gt;next;
        delete current;
        current = next;
    }
    head = nullptr;
}

// Person class to demonstrate
class Person {
public:
    string name;
    int age;

    Person(string name, int age) : name(name), age(age) {}

    // Define &lt; operator for sorting purposes (sort by name, then by age)
    bool operator&lt;(const Person& other) const {
        if (name == other.name) {
            return age &lt; other.age;  // If names are the same, sort by age
        }
        return name &lt; other.name;  // Otherwise, sort by name
    }
    
    // Overload the equality operator to compare Person objects
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
    
    string toString() const {
        return "Person{name: " + name + ", age: " + to_string(age) + "}";
    }
};

// Testing the Person class with merge
int main() {
    // Create Person objects
    Person alice("Alice", 30);
    Person john("John", 19);
    Person albert("Albert", 28);
    Person robert("Robert", 20);

    // Initialize the linked list
    Node&lt;Person&gt;* head = nullptr;

    // 1. Insert elements at the beginning
    insertAtBeginning(head, alice);
    insertAtBeginning(head, john);
	
	// 2. Insert elements at the beginning
    insertAtEnd(head, albert);
    insertAtEnd(head, robert);

    cout &lt;&lt; "\nList after inserting elements:\n";
    traverse(head);

    // 3. Insert at a specific position
    Person eve("Eve", 22);
    insertAtPosition(head, eve, 2);
    cout &lt;&lt; "\nList after inserting at position 2:\n";
    traverse(head);

    // 4. Insert before a node (insert before the second node)
    Node&lt;Person&gt;* secondNode = head-&gt;next; // Find the second node
    Person george("George", 32);
    insertBeforeNode(head, secondNode, george);
    cout &lt;&lt; "\nList after inserting before second node:\n";
    traverse(head);

    // 5. Insert after a node (insert after the second node)
    Person joyce("Joyce", 27);
    insertAfterNode(secondNode, joyce);  // Insert after the second node
    cout &lt;&lt; "\nList after inserting after second node:\n";
    traverse(head);

    // 6. Delete the first node
    deleteAtBeginning(head);
    cout &lt;&lt; "\nList after deleting first node:\n";
    traverse(head);

    // 7. Delete the last node
    deleteAtEnd(head);
    cout &lt;&lt; "\nList after deleting last node:\n";
    traverse(head);
	
	// 8. Delete at a specific position
	deleteAtPosition(head, 2);
    cout &lt;&lt; "\nList after deleting node at position 2:\n";
    traverse(head);
	
    // 9. Search for an element
    bool found = search(head, albert);
    cout &lt;&lt; "\nSearch result for 'Albert': " &lt;&lt; (found ? "Found" : "Not Found") &lt;&lt; endl;

    // 10. Get size of the list
    cout &lt;&lt; "\nSize of the list: " &lt;&lt; size(head) &lt;&lt; endl;
	
	// 11. Check if list is empty
	if (isEmpty(head)) {
		cout &lt;&lt; "The linked list is empty.\n";
	} else {
		cout &lt;&lt; "The linked list is not empty.\n";
	}

    // 12. Get an element
    try {
        Person p = get(head, 2);
        cout &lt;&lt; "\nElement at index 2: " &lt;&lt; p.toString() &lt;&lt; endl;
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 13. Set (modify) an element
    try {
        Person updatedJohn("John", 25);
        set(head, 1, updatedJohn);
        cout &lt;&lt; "\nList after modifying index 1:\n";
        traverse(head);
    } catch (const exception& e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    // 14. Sort the linked list (by name first, then by age)
    sort(head);
    cout &lt;&lt; "\nList after sorting:" &lt;&lt; endl;
    traverse(head);
	
	// 15. Reverse the list
    reverse(head);

    cout &lt;&lt; "\nReversed List:" &lt;&lt; endl;
    traverse(head);


	// 16. Clear the list
    clear(head);

    cout &lt;&lt; "\nList after clearing:" &lt;&lt; endl;
    traverse(head);  // Should print NULL, as the list is cleared
	
    return 0;
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in Java:</p>
		
		<pre><code class="language-java hljs">class LinkedList&lt;T&gt; {

    // Node structure for singly linked list
    static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        // Constructor to create a new node
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    // Insert at the beginning
    public static &lt;T&gt; Node&lt;T&gt; insertAtBeginning(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = head;
        return newNode;
    }

    // Insert at the end
    public static &lt;T&gt; Node&lt;T&gt; insertAtEnd(Node&lt;T&gt; head, T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (head == null) {
            return newNode;
        }
        Node&lt;T&gt; temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    // Insert at a specific position
    public static &lt;T&gt; Node&lt;T&gt; insertAtPosition(Node&lt;T&gt; head, T data, int position) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }

        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) {
            temp = temp.next;
        }

        if (temp == null) {
            System.out.println("Position out of bounds");
            return head;
        }

        newNode.next = temp.next;
        temp.next = newNode;
        return head;
    }

    // Insert before a specific node
    public static &lt;T&gt; Node&lt;T&gt; insertBeforeNode(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data) {
        if (head == null) return null;

        if (head == targetNode) {
            return insertAtBeginning(head, data);
        }

        Node&lt;T&gt; temp = head;
        while (temp != null && temp.next != targetNode) {
            temp = temp.next;
        }

        if (temp != null) {
            Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
            newNode.next = temp.next;
            temp.next = newNode;
        }
        return head;
    }

    // Insert after a specific node
    public static &lt;T&gt; void insertAfterNode(Node&lt;T&gt; node, T data) {
        if (node == null) return;

        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.next = node.next;
        node.next = newNode;
    }

    // Delete at the beginning
    public static &lt;T&gt; Node&lt;T&gt; deleteAtBeginning(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }
        return head.next;
    }

    // Delete at the end
    public static &lt;T&gt; Node&lt;T&gt; deleteAtEnd(Node&lt;T&gt; head) {
        if (head == null) {
            System.out.println("List is empty");
            return null;
        }

        if (head.next == null) {
            return null;
        }

        Node&lt;T&gt; temp = head;
        while (temp.next.next != null) {
            temp = temp.next;
        }
        temp.next = null;
        return head;
    }
	
	// Delete at a specific position
	public static &lt;T&gt; Node&lt;T&gt; deleteAtPosition(Node&lt;T&gt; head, int position) {
		if (head == null) {
			System.out.println("List is empty");
			return null;
		}

		if (position == 0) {
			return head.next;
		}

		Node&lt;T&gt; temp = head;
		for (int i = 0; i &lt; position - 1 && temp.next != null; i++) {
			temp = temp.next;
		}

		if (temp.next == null) {
			System.out.println("Position out of bounds");
			return head;
		}

		temp.next = temp.next.next;
		return head;
	}
	
	// check if the list is empty
	public static &lt;T&gt; boolean isEmpty(Node&lt;T&gt; head) {
		return head == null;
	}

    // Search for an element
    public static &lt;T&gt; boolean search(Node&lt;T&gt; head, T key) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            if (temp.data.equals(key)) {
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    // Get the size of the list
    public static &lt;T&gt; int size(Node&lt;T&gt; head) {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

    // Get element at a specific index
    public static &lt;T&gt; T get(Node&lt;T&gt; head, int index) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                return temp.data;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Set element at a specific index
    public static &lt;T&gt; void set(Node&lt;T&gt; head, int index, T newValue) throws Exception {
        int count = 0;
        Node&lt;T&gt; temp = head;

        while (temp != null) {
            if (count == index) {
                temp.data = newValue; // Update the value at the index
                return;
            }
            count++;
            temp = temp.next;
        }

        throw new Exception("Index out of range");
    }

    // Traverse the list
    public static &lt;T&gt; void traverse(Node&lt;T&gt; head) {
        Node&lt;T&gt; temp = head;
        while (temp != null) {
            System.out.print(temp.data + " -&gt; ");
            temp = temp.next;
        }
        System.out.println("NULL");
    }
	
	// reverse the list
	public static &lt;T&gt; Node&lt;T&gt; reverse(Node&lt;T&gt; head) {
		Node&lt;T&gt; prev = null;
		Node&lt;T&gt; current = head;
		Node&lt;T&gt; next = null;

		while (current != null) {
			next = current.next;  // Store next node
			current.next = prev;  // Reverse current node's pointer
			prev = current;       // Move prev forward
			current = next;       // Move current forward
		}

		return prev;  // New head of the reversed list
	}

    // Sort the list (by name first, then by age)
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; sort(Node&lt;T&gt; head) {
        if (head == null || head.next == null) return head;

        Node&lt;T&gt; mid = middle(head);
        Node&lt;T&gt; nextToMid = mid.next;
        mid.next = null;

        Node&lt;T&gt; left = sort(head);
        Node&lt;T&gt; right = sort(nextToMid);

        return merge(left, right);
    }

    // Merge two sorted lists
    public static &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;T&gt; merge(Node&lt;T&gt; left, Node&lt;T&gt; right) {
        if (left == null) return right;
        if (right == null) return left;

        if (left.data.compareTo(right.data) &lt;= 0) {
            left.next = merge(left.next, right);
            return left;
        } else {
            right.next = merge(left, right.next);
            return right;
        }
    }

    // Find the middle of the list
    public static &lt;T&gt; Node&lt;T&gt; middle(Node&lt;T&gt; head) {
        if (head == null) return null;

        Node&lt;T&gt; slow = head;
        Node&lt;T&gt; fast = head.next;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
    
	public static &lt;T&gt; Node&lt;T&gt; clear(Node&lt;T&gt; head) {
        Node&lt;T&gt; current = head;
        while (current != null) {  // Traverse the list until we reach the end
            Node&lt;T&gt; next = current.next;  // Save reference to the next node
            current.next = null;          // Break the link to the next node
            current = next;               // Move to the next node
        }
        return null;  // Set the head to null to indicate the list is empty
    }
	
    // Person class
    static class Person implements Comparable&lt;Person&gt; {
        String name;
        int age;
    
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Person{name: " + name + ", age: " + age + "}";
        }
    
        @Override
        public int compareTo(Person other) {
            // Compare by name first, then by age
            int nameComparison = this.name.compareTo(other.name);
            if (nameComparison != 0) {
                return nameComparison;
            }
            return Integer.compare(this.age, other.age);
        }
    }
    
    public static void main(String[] args) {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);

        // Initialize the linked list
        Node&lt;Person&gt; head = null;

        // 1. Insert elements at the beginning
        head = insertAtBeginning(head, alice);
        head = insertAtBeginning(head, john);
		
		// 2. Insert elements at the end
        head = insertAtEnd(head, albert);
        head = insertAtEnd(head, robert);

        System.out.println("\nList after inserting elements:");
        traverse(head);

        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = insertAtPosition(head, eve, 2);
        System.out.println("\nList after inserting at position 2:");
        traverse(head);

        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.next; // Find the second node
        head = insertBeforeNode(head, secondNode, eve);
        System.out.println("\nList after inserting before second node:");
        traverse(head);

        // 5. Insert after a node (insert after the second node)
        insertAfterNode(secondNode, eve);  // Insert after the second node
        System.out.println("\nList after inserting after second node:");
        traverse(head);

        // 6. Delete the first node
        head = deleteAtBeginning(head);
        System.out.println("\nList after deleting first node:");
        traverse(head);

        // 7. Delete the last node
        head = deleteAtEnd(head);
        System.out.println("\nList after deleting last node:");
        traverse(head);
		
		// 8. Delete at a specific position
		head = deleteAtPosition(head, 2);
		System.out.println("\nList after deleting node at position 2:");
		traverse(head);

        // 9. Search for an element
        boolean found = search(head, albert);
        System.out.println("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));

        // 10. Get size of the list
        System.out.println("\nSize of the list: " + size(head));
		
		// 11. Check if list is empty
		if (isEmpty(head)) {
			System.out.println("The list is empty.");
		} else {
			System.out.println("The list is not empty.");
		}


        // 12. Get an element
        try {
            Person p = get(head, 2);
            System.out.println("\nElement at index 2: " + p.toString());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 13. Set (modify) an element
        try {
            Person updatedJohn = new Person("John", 25);
            set(head, 1, updatedJohn);
            System.out.println("\nList after modifying index 1:");
            traverse(head);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        // 14. Sort the linked list (by name first, then by age)
        head = sort(head);
        System.out.println("\nList after sorting:");
        traverse(head);
		
		// 15. Reverse the list
		head = reverse(head);

		System.out.println("\nList after reversing:");
		traverse(head);

		// 16. Clear the list
        head = clear(head);
        System.out.println("After clearing the list:");
        traverse(head);  // This should print "NULL" as the list is now empty
    }
    
}</code></pre>
		
		<p>Here is the Generic singly linked list implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T Data;
    public Node&lt;T&gt; Next;

    public Node(T data)
    {
        Data = data;
        Next = null;
    }
}

class Program
{
    // Insert at beginning
    static Node&lt;T&gt; InsertAtBeginning&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = head };
        return newNode;
    }

    // Insert at end
    static Node&lt;T&gt; InsertAtEnd&lt;T&gt;(Node&lt;T&gt; head, T data)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (head == null) return newNode;
        Node&lt;T&gt; temp = head;
        while (temp.Next != null) temp = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Insert at position
    static Node&lt;T&gt; InsertAtPosition&lt;T&gt;(Node&lt;T&gt; head, T data, int position)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);
        if (position == 0) { newNode.Next = head; return newNode; }
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++) temp = temp.Next;
        if (temp == null) { Console.WriteLine("Position out of bounds"); return head; }
        newNode.Next = temp.Next;
        temp.Next = newNode;
        return head;
    }

    // Insert before node
    static Node&lt;T&gt; InsertBeforeNode&lt;T&gt;(Node&lt;T&gt; head, Node&lt;T&gt; targetNode, T data)
    {
        if (head == null) return null;
        if (head == targetNode) return InsertAtBeginning(head, data);
        Node&lt;T&gt; temp = head;
        while (temp != null && temp.Next != targetNode) temp = temp.Next;
        if (temp != null)
        {
            Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = temp.Next };
            temp.Next = newNode;
        }
        return head;
    }

    // Insert after node
    static void InsertAfterNode&lt;T&gt;(Node&lt;T&gt; node, T data)
    {
        if (node == null) return;
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data) { Next = node.Next };
        node.Next = newNode;
    }

    // Delete at beginning
    static Node&lt;T&gt; DeleteAtBeginning&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        return head.Next;
    }

    // Delete at end
    static Node&lt;T&gt; DeleteAtEnd&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) { Console.WriteLine("List is empty"); return null; }
        if (head.Next == null) return null;
        Node&lt;T&gt; temp = head;
        while (temp.Next.Next != null) temp = temp.Next;
        temp.Next = null;
        return head;
    }
    
    // Delete at a specific position
    static Node&lt;T&gt; DeleteAtPosition&lt;T&gt;(Node&lt;T&gt; head, int position)
    {
        if (head == null)
        {
            Console.WriteLine("List is empty");
            return null;
        }
    
        if (position == 0) // Deleting the first node
        {
            return head.Next;
        }
    
        Node&lt;T&gt; temp = head;
        for (int i = 0; i &lt; position - 1 && temp != null; i++)
        {
            temp = temp.Next;
        }
    
        if (temp == null || temp.Next == null)
        {
            Console.WriteLine("Position out of bounds");
            return head;
        }
    
        temp.Next = temp.Next.Next; // Remove the node at the given position
        return head;
    }


    // Search for an element
    static bool Search&lt;T&gt;(Node&lt;T&gt; head, T key)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (temp.Data.Equals(key)) return true;
            temp = temp.Next;
        }
        return false;
    }

    // Get size of the list
    static int Size&lt;T&gt;(Node&lt;T&gt; head)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            count++;
            temp = temp.Next;
        }
        return count;
    }

    // Traverse the list and print elements
    static void Traverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            Console.Write(temp.Data + " -&gt; ");
            temp = temp.Next;
        }
        Console.WriteLine("NULL");
    }

    // Get an element at specific index
    static T Get&lt;T&gt;(Node&lt;T&gt; head, int index)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index) return temp.Data;
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Set (modify) an element at specific index
    static void Set&lt;T&gt;(Node&lt;T&gt; head, int index, T newValue)
    {
        int count = 0;
        Node&lt;T&gt; temp = head;
        while (temp != null)
        {
            if (count == index)
            {
                temp.Data = newValue;
                return;
            }
            count++;
            temp = temp.Next;
        }
        throw new Exception("Index out of range");
    }

    // Sort the linked list (Merge Sort)
    static Node&lt;T&gt; Sort&lt;T&gt;(Node&lt;T&gt; head) where T : IComparable&lt;T&gt;
    {
        if (head == null || head.Next == null) return head;

        // Split the list into two halves
        Node&lt;T&gt; mid = Middle(head);
        Node&lt;T&gt; nextToMid = mid.Next;
        mid.Next = null;

        // Recursively sort both halves
        Node&lt;T&gt; left = Sort(head);
        Node&lt;T&gt; right = Sort(nextToMid);

        // Merge the sorted halves
        return Merge(left, right);
    }
    
    static bool IsEmpty&lt;T&gt;(Node&lt;T&gt; head) {
        return head == null;
    }

    // Reverse the linked list
    static Node&lt;T&gt; Reverse&lt;T&gt;(Node&lt;T&gt; head)
    {
        Node&lt;T&gt; prev = null;
        Node&lt;T&gt; current = head;
        Node&lt;T&gt; next = null;
        
        while (current != null)
        {
            next = current.Next;  // Store next node
            current.Next = prev;  // Reverse the current node's pointer
            prev = current;       // Move prev and current one step forward
            current = next;
        }
        
        head = prev;  // Set the new head to the last node
        return head;
    }

    // Merge two sorted lists
    static Node&lt;T&gt; Merge&lt;T&gt;(Node&lt;T&gt; left, Node&lt;T&gt; right) where T : IComparable&lt;T&gt;
    {
        if (left == null) return right;
        if (right == null) return left;

        if (left.Data.CompareTo(right.Data) &lt;= 0)
        {
            left.Next = Merge(left.Next, right);
            return left;
        }
        else
        {
            right.Next = Merge(left, right.Next);
            return right;
        }
    }

    // Find the middle node of the list
    static Node&lt;T&gt; Middle&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;
        Node&lt;T&gt; slow = head, fast = head.Next;

        while (fast != null && fast.Next != null)
        {
            slow = slow.Next;
            fast = fast.Next.Next;
        }

        return slow;
    }
	
	  // Clear the linked list
    public static Node&lt;T&gt; Clear&lt;T&gt;(Node&lt;T&gt; head)
    {
        if (head == null) return null;  // If the list is already empty, return null
        
        Node&lt;T&gt; current = head;
        while (current != null)  // Traverse the list until we reach the end
        {
            Node&lt;T&gt; next = current.Next;  // Save reference to next node
            current.Next = null;          // Break the link to the next node
            current = next;               // Move to the next node
        }
        
        return null;  // Return null to indicate the list is empty
    }

	
    static void Main()
    {
        // Create Person objects
        Person alice = new Person("Alice", 30);
        Person john = new Person("John", 19);
        Person albert = new Person("Albert", 28);
        Person robert = new Person("Robert", 20);
        
        // Initialize the linked list
        Node&lt;Person&gt; head = null;
        
        // 1. Insert elements at the beginning
        head = InsertAtBeginning(head, alice);
        head = InsertAtBeginning(head, john);
        
        // 2. Insert elements at the end
        head = InsertAtEnd(head, albert);
        head = InsertAtEnd(head, robert);
        
        Console.WriteLine("\nList after inserting elements:");
        Traverse(head);
        
        // 3. Insert at a specific position
        Person eve = new Person("Eve", 22);
        head = InsertAtPosition(head, eve, 2);
        Console.WriteLine("\nList after inserting at position 2:");
        Traverse(head);
        
        // 4. Insert before a node (insert before the second node)
        Node&lt;Person&gt; secondNode = head.Next; // Find the second node
        Person jack = new Person("Jack", 29);
        head = InsertBeforeNode(head, secondNode, jack);
        Console.WriteLine("\nList after inserting before second node:");
        Traverse(head);
        
        // 5. Insert after a node (insert after the second node)
        InsertAfterNode(secondNode, eve);  // Insert after the second node
        Console.WriteLine("\nList after inserting after second node:");
        Traverse(head);
        
        // 6. Delete the first node
        head = DeleteAtBeginning(head);
        Console.WriteLine("\nList after deleting first node:");
        Traverse(head);
        
        // 7. Delete the last node
        head = DeleteAtEnd(head);
        Console.WriteLine("\nList after deleting last node:");
        Traverse(head);
        
        // 8. Delete node at position 2
        head = DeleteAtPosition(head, 2);
        Console.WriteLine("\nList after deleting at position 2:");
        Traverse(head);

        // 9. Search for an element
        bool found = Search(head, albert);
        Console.WriteLine("\nSearch result for 'Albert': " + (found ? "Found" : "Not Found"));
        
        // 10. Get size of the list
        Console.WriteLine("\nSize of the list: " + Size(head));
        
        // 11. Check if the list is empty
        if (IsEmpty(head))
        {
            Console.WriteLine("The list is empty.");
        }
        else
        {
            Console.WriteLine("The list is not empty.");
        }
    
        // 12. Get an element
        try
        {
            Person p = Get(head, 2);
            Console.WriteLine("\nElement at index 2: " + p.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 13. Set (modify) an element
        try
        {
            Person updatedJohn = new Person("John", 25);
            Set(head, 1, updatedJohn);
            Console.WriteLine("\nList after modifying index 1:");
            Traverse(head);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        
        // 14. Sort the linked list (by name first, then by age)
        head = Sort(head);
        Console.WriteLine("\nList after sorting:");
        Traverse(head);
        
        // 15. Reverse the list
        head = Reverse(head);
    
        Console.WriteLine("\nList after reversing:");
        Traverse(head);
    
        // 16. Clear the list
        head = Clear(head);
        Console.WriteLine("\nList after clearing:");
        Traverse(head);
    }
}

class Person : IComparable&lt;Person&gt;
{
    public string Name;
    public int Age;
    public Person(string name, int age) { Name = name; Age = age; }
    public int CompareTo(Person other)
    {
        // Sort by Name, then Age
        return Name.CompareTo(other.Name) != 0 ? Name.CompareTo(other.Name) : Age.CompareTo(other.Age);
    }
    public override string ToString() =&gt; $"Person{{name: {Name}, age: {Age}}}";
}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linked-list" class="tag">linked list</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/singly-linked-list" class="tag">singly linked list</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/10/14/singly-linked-list-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-10" /><category term="day-14" /><category term="data structure" /><category term="linked list" /><category term="singly linked list" /><summary type="html"><![CDATA[Discover the essential concepts of singly linked list data structures in this detailed tutorial designed for both beginners and experienced learners. This guide offers a thorough exploration of the implementation process, complete with illustrative examples that demonstrate key operations such as node creation, insertion, deletion, sorting, searching, and traversal.]]></summary></entry><entry xml:lang="en"><title type="html">Dynamic Array Data Structure</title><link href="https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/" rel="alternate" type="text/html" title="Dynamic Array Data Structure" /><published>2024-10-11T10:20:00+00:00</published><updated>2024-10-11T10:20:00+00:00</updated><id>https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Dynamic Array Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published October 11, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/dynamicarray.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		
		<h3 class="post-subtitle">Dynamic Array</h3>
		
        <p>A dynamic array is unlike a regular array with a fixed size, can automatically resize itself when elements are added or removed. This allows for more flexible use, especially when the number of elements is not known in advance. Dynamic arrays are commonly implemented by allocating a larger array when needed and copying the elements from the old array to the new one.</p>

        <p>Dynamic arrays have many key features that make them a popular choice among programmers. Some of the key features of dynamic arrays are:</p>
		
		<ul>
			<li><b>Dynamic Resizing</b>: A dynamic array can automatically resize itself when its capacity is exceeded. Initially, a dynamic array starts with a small capacity, but as more elements are added, the array grows, typically by doubling its size. This allows it to accommodate more elements efficiently.</li>
			<li><b>Efficient Element Access</b>: Dynamic arrays provide constant-time access to elements via indices. You can access any element in the array in \(O(1)\) time using its index, just like a regular array.</li>
			<li><b>Flexible Size</b>: Unlike fixed-size arrays, which have a predetermined capacity, a dynamic array can grow or shrink based on the number of elements it holds.</li>
			<li><b>Amortized Constant-Time Append</b>: Adding an element at the end of a dynamic array is efficient and usually takes \(O(1)\) time. When the array reaches its capacity, the array is resized (which takes \(O(n)\) time for the copy operation), but this happens infrequently. Therefore, the average time complexity for appending an element is amortized \(O(1)\).</li>
			<li><b>Efficient Memory Management</b>: Dynamic arrays allocate memory only when needed. Although resizing (doubling the size of the array) may lead to some temporarily unused memory (as the array can grow to be larger than the number of elements), this approach minimizes memory reallocations and ensures that elements are stored contiguously in memory.</li>
			<li><b>Index-Based Insertions and Deletions</b>: Inserting or deleting elements at specific indices can be done in a dynamic array, but these operations require shifting elements, making them \(O(n)\) in the worst case. Inserting at the end (append) is faster, while inserting or deleting in the middle requires moving elements to maintain the order.</li>
			<li><b>Contiguous Memory Allocation</b>: Like regular arrays, elements in a dynamic array are stored in a contiguous block of memory. This provides cache-friendly access to data, improving performance when iterating over the elements.</li>
		</ul>
		
		<p>Here's a detailed breakdown of common dynamic array operations:</p>

        <ul>
            <li><code>add()</code>:<br>
				<ul>
					<li><b>Description</b>: Adds an element to the end of the array. If the current size equals the capacity, the array is resized (usually doubled), and the element is added.</li>
					<li><b>Time complexity</b>:<br>
						<ul>
							<li>If the dynamic array has enough capacity to accommodate the new element, adding the element is a simple operation, requiring constant time i.e. \(O(1)\) to place the new element at the end of the array.</li>
							<li>If the dynamic array is full, a new larger array must be allocated (typically twice the current size), and all the existing elements must be copied to the new array. This resizing operation takes linear time (\(O(n)\), where \(n\) is the number of elements in the array).</li>
						</ul>
					</li>
					<li><b>Space complexity</b>:<br>
						<ul>
							<li>If the dynamic array has enough capacity to accommodate the new element, no additional space is needed. This operation takes constant space i.e. \(O(1)\).</li>
							<li>If the dynamic array is full, a new larger array must be allocated (typically twice the current size), and all the existing elements must be copied to the new array. The new array requires \(O(n)\) space (where \(n\) is the current number of elements).</li>
						</ul>
					</li>
				</ul>
			</li>
            <li><code>get()</code>:<br>
				<ul>
					<li><b>Description</b>: Retrieves an element at a specified index. Returns the element at the given index without modifying the array.</li>
					<li><b>Time complexity</b>: Accessing an element in a dynamic array is straightforward since arrays allow random access. This means that you can directly access any element by its index in constant time i.e. \(O(1)\).</li>
					<li><b>Space complexity</b>: Accessing an element does not require any additional space apart from the memory already allocated for the array itself. Therefore this operation takes constant space i.e. \(O(1)\).</li>
				</ul>
			</li>
            <li><code>set()</code>:<br>
				<ul>
					<li><b>Description</b>: Adds an element to the end of the array. If the current size equals the capacity, the array is resized (usually doubled), and the element is added.</li>
					<li><b>Time complexity</b>: Setting an element at any index is a constant-time operation i.e. \(O(1)\) because it directly changes the value at the memory location corresponding to the index.</li>
					<li><b>Space complexity</b>: No extra memory is allocated; you are just modifying the existing space. This operation takes constant space i.e. \(O(1)\).</li>
				</ul>
			</li>
            <li><code>remove()</code>:<br>
				<ul>
					<li><b>Description</b>: Deletes an element from a specified index. Removes the element and shifts the subsequent elements to fill the gap.</li>
					<li><b>Time complexity</b>:<br>
						<ul>
							<li>Removing the last element does not require shifting any elements. This is straightforward as it involves just updating the size of the array by decreasing it by 1. This operation takes constatnt time (\(O(1)\).</li>
							<li>Removing an element from any other position requires shifting all elements to the left to fill the gap left by the removed element. Every element after the removed element needs to be shifted one position to the left, resulting in a linear time complexity in the worst case. This operation requires linear time i.e. \(O(n)\) (where \(n\) is the number of elements after the removed element)</li>
						</ul>
					</li>
					<li><b>Space complexity</b>: No additional space is required to remove an element from the array, as you are modifying the existing array structure. This operation takes constant space i.e. \(O(1)\).</li>
				</ul>
			</li>
            <li><code>insert()</code>:<br>
				<ul>
					<li><b>Description</b>: Inserts an element at a specified index. If the array is full, it resizes the array. The specified index is filled, and subsequent elements are shifted to the right.</li>
					<li><b>Time complexity</b>:<br>
						<ul>
							<li>If the dynamic array has enough capacity to accommodate the new element, inserting to the end of the array without any additional operations. This operation requires constant time i.e. \(O(1)\) to place the new element at the end of the array.</li>
							<li>If the dynamic array is full, a new larger array must be allocated (typically twice the current size), and all the existing elements must be copied to the new array. This resizing operation takes linear time (\(O(n)\), where \(n\) is the number of elements in the array).</li>
							<li>When an element is inserted anywhere other than the end (e.g., in the middle), all subsequent elements need to be shifted one position to the right to make space for the new element. This shifting operation requires time proportional to the number of elements after the insertion point, resulting in a linear time complexity \(O(n)\).</li>
						</ul>
					</li>
					<li><b>Space complexity</b>:<br>
						<ul>
							<li>If the dynamic array has enough capacity to accommodate the new element, no additional space is needed. This operation takes constant space i.e. \(O(1)\).</li>
							<li>If the dynamic array is full, a new larger array must be allocated (typically twice the current size), and all the existing elements must be copied to the new array. The new array requires \(O(n)\) space (where \(n\) is the current number of elements).</li>
						</ul>
					</li>
				</ul>
			</li>
            <li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Returns the number of elements currently stored in the array. Simply returns the <code>size</code> attribute.</li>
					<li><b>Time complexity</b>: Retrieving the size of a dynamic array is an \(O(1)\) operation because the size is typically stored as a separate variable (e.g., size or length). When you call the size method, it simply returns this value without needing to iterate over the array or perform any additional calculations.</li>
					<li><b>Space complexity</b>: The operation does not require any additional space beyond what is already used to store the size variable.</li>
				</ul>
			</li>
			<li><code>resize()</code>:<br>
				<ul>
					<li><b>Description</b>: Changes the capacity of the array. Creates a new larger or smaller array and copies existing elements into it.</li>
					<li><b>Time complexity</b>: The resize operation takes linear time because you need to copy all existing elements from the old array to the new one. If the current size of the array is \(n\), it will require \(n\) time to copy each element over. This operation takes linear time i.e. \(O(n)\).</li>
					<li><b>Space complexity</b>: When you create a new array, it will require \(n\) space to hold the existing elements (where \(n\) is the number of elements in the current array). Additionally, the size of the new array is typically twice that of the old one, so the overall space allocation for the new array would also be proportional to \(n\). This operation takes linear time i.e. \(O(n)\).</li>
				</ul>
			</li>
            <li><code>clear()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes all elements from the array. Sets the size to zero, effectively clearing the contents, but the capacity may remain unchanged.</li>
					<li><b>Time complexity</b>: The <code>clear</code> operation involves iterating through all elements to free up any dynamically allocated resources or simply resetting references, it takes linear time \(O(n)\), where \(n\) is the current number of elements in the array.
					</li>
					<li><b>Space complexity</b>: The <code>clear</code> operation does not allocate any new space or increase the overall memory usage. This operation takes constant space i.e. \(O(1)\).</li>
				</ul>
			</li>
            <li><code>display()</code>:<br>
				<ul>
					<li><b>Description</b>: Displays all elements in the array. Iterates through the array and prints each element.</li>
					<li><b>Time complexity</b>: The display operation involves iterating through all elements of the dynamic array from index <code>0</code> to <code>size - 1</code> to print each element. The time complexity of this operation is \(O(n)\), where \(n\) is the number of elements in the dynamic array.</li>
					<li><b>Space complexity</b>: The display operation does not require any additional memory proportional to the number of elements, except for a fixed amount of space used for variables like the loop counter. Therefore, the space complexity is \(O(1)\).</li>
				</ul>
			</li>
        </ul>
		
		<p>Most current programming languages include built-in or standard library functions for creating and managing dynamic arrays.</p>
        
		<p>In C, there is no built-in dynamic array type like in higher-level languages (e.g., C++, Java, C#).</p>
		
		<p>In C++, the built-in dynamic array is provided by the <code>std::vector</code> class, which is part of the Standard Template Library (STL). Vectors in C++ provide a dynamic array implementation that automatically resizes as elements are added or removed.</p>
        
		<p>Here is the basic example of using <code>std::vector</code>:</p>
		
        <pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // Create a vector of integers
    std::vector&lt;int&gt; dynamicArray;

    // Add elements to the vector using push_back()
    dynamicArray.push_back(10);
    dynamicArray.push_back(20);
    dynamicArray.push_back(30);
    dynamicArray.push_back(40);

    // Access elements using the [] operator or at() method
    std::cout &lt;&lt; "Element at index 2: " &lt;&lt; dynamicArray[2] &lt;&lt; std::endl;

    // Modify an element
    dynamicArray[2] = 50;

    std::cout &lt;&lt; "Array after modification: ";
    for (int i = 0; i &lt; dynamicArray.size(); i++) {
        std::cout &lt;&lt; dynamicArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Remove the last element using pop_back()
    dynamicArray.pop_back();

    std::cout &lt;&lt; "Array after removing the last element: ";
    for (int i = 0; i &lt; dynamicArray.size(); i++) {
        std::cout &lt;&lt; dynamicArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
	
	// Resize the vector to size 5, new elements initialized to 0
    dynamicArray.resize(5);

    std::cout &lt;&lt; "After resizing to larger size: ";
    for (int i = 0; i &lt; dynamicArray.size(); i++) {
        std::cout &lt;&lt; dynamicArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
	
	// Resize the vector to size 3, excess elements are truncated
    dynamicArray.resize(3);
	
	std::cout &lt;&lt; "After resizing to smaller size: ";
    for (int i = 0; i &lt; dynamicArray.size(); i++) {
        std::cout &lt;&lt; dynamicArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
	
	// Clear all elements from the vector
    dynamicArray.clear();

    std::cout &lt;&lt; "Vector size after clear: " &lt;&lt; vec.size() &lt;&lt; std::endl;
	
    return 0;
}</code></pre>

        <p>In Java, the built-in dynamic array is represented by the <code>ArrayList</code> class, which is part of the Java Collections Framework.</p>
        
		<p>Here is the basic example of using <code>ArrayList</code>:</p>
		
        <pre><code class="language-java hljs">import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();

        arrayList.add(1); // Adds 1 to the list
        arrayList.add(2); // Adds 2 to the list
        arrayList.add(3); // Adds 3 to the list
		arrayList.add(4); // Adds 4 to the list
        
        System.out.println("ArrayList: " + arrayList);
		
		System.out.println("Element at index 1: " + arrayList.get(1));
		
		arrayList.set(1, 10); // Updates the element at index 1 to 10
        System.out.println("Updated ArrayList: " + arrayList);
		
		arrayList.remove(1); // Removes the element at index 1
        System.out.println("ArrayList after removal: " + arrayList);
		
		System.out.println("Size of ArrayList: " + arrayList.size());
		
		arrayList.clear(); // Clears all elements from the list
        System.out.println("ArrayList after clear: " + arrayList);
    }
}</code></pre>

        <p>In C#, the built-in dynamic array is represented by the <code>List&lt;T&gt;</code> class from the <code>System.Collections.Generic</code> namespace. The <code>List&lt;T&gt;</code> is similar to an array but with the ability to automatically resize itself when more elements are added, much like dynamic arrays in other languages such as Java's <code>ArrayList</code>.</p>
        
		<p>Here is the basic example of using <code>List&lt;T&gt;</code>:</p>
		
        <pre><code class="language-csharp hljs">using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Creating a List of integers with initial capacity
        List&lt;int&gt; numbers = new List&lt;int&gt;();

        // Adding elements to the List
        numbers.Add(1);
        numbers.Add(2);
        numbers.Add(3);
        numbers.Add(4);

        // Accessing elements by index
        Console.WriteLine("Element at index 2: " + numbers[2]);

        // Modifying an element
        numbers[2] = 10;
        Console.WriteLine("After modification, element at index 2: " + numbers[2]);

        // Iterating through the List
        Console.WriteLine("Elements in List:");
        foreach (int number in numbers)
        {
            Console.WriteLine(number);
        }

        // Checking the size of the List
        Console.WriteLine("Size of List: " + numbers.Count);

        // Removing an element
        numbers.RemoveAt(2); // Remove element at index 2
        Console.WriteLine("After removal, size of List: " + numbers.Count);
        
        // Displaying the elements after removal
        Console.WriteLine("Elements in List after removal:");
        foreach (int number in numbers)
        {
            Console.WriteLine(number);
        }
    }
}</code></pre>
        
		
		<h3 class="post-subtitle">Non-Generic Dynamic Array Implementation</h3>
		
		<p>Here is the Non-Generic Dynamic Array implementation in C:</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct DynamicArray {
    int *array;  // Array to hold elements
    int capacity; // Capacity of the dynamic array
    int size;     // Current number of elements
};

// Initialize dynamic array
void init(struct DynamicArray *dArray, int capacity) {
    dArray-&gt;array = (int *)malloc(capacity * sizeof(int));
    dArray-&gt;capacity = capacity;
    dArray-&gt;size = 0;
}

// Resize the dynamic array
void resize(struct DynamicArray *dArray) {
    int newCapacity = dArray-&gt;capacity * 2;
    dArray-&gt;array = (int *)realloc(dArray-&gt;array, newCapacity * sizeof(int));
    dArray-&gt;capacity = newCapacity;
}

// Add an element to the end
void add(struct DynamicArray *dArray, int element) {
    if (dArray-&gt;size == dArray-&gt;capacity) {
        resize(dArray);
    }
    dArray-&gt;array[dArray-&gt;size++] = element;
}

// Get an element by index
int get(struct DynamicArray *dArray, int index) {
    if (index &lt; 0 || index &gt;= dArray-&gt;size) {
        printf("Index out of bounds\n");
        return -1;
    }
    return dArray-&gt;array[index];
}

// Set (update) an element at a specific index
void set(struct DynamicArray *dArray, int index, int element) {
    if (index &lt; 0 || index &gt;= dArray-&gt;size) {
        printf("Index out of bounds\n");
        return;
    }
    dArray-&gt;array[index] = element;
}

// Remove an element by index
void remove(struct DynamicArray *dArray, int index) {
    if (index &lt; 0 || index &gt;= dArray-&gt;size) {
        printf("Index out of bounds\n");
        return;
    }
    for (int i = index; i &lt; dArray-&gt;size - 1; i++) {
        dArray-&gt;array[i] = dArray-&gt;array[i + 1];
    }
    dArray-&gt;size--;
}

// Insert an element at a specific index
void insert(struct DynamicArray *dArray, int index, int element) {
    if (index &lt; 0 || index &gt; dArray-&gt;size) {
        printf("Index out of bounds\n");
        return;
    }
    if (dArray-&gt;size == dArray-&gt;capacity) {
        resize(dArray);
    }
    for (int i = dArray-&gt;size; i &gt; index; i--) {
        dArray-&gt;array[i] = dArray-&gt;array[i - 1];
    }
    dArray-&gt;array[index] = element;
    dArray-&gt;size++;
}

// Return the size of the array
int size(struct DynamicArray *dArray) {
    return dArray-&gt;size;
}

// Clear the array
void clear(struct DynamicArray *dArray) {
    dArray-&gt;size = 0;
}

// Display the array
void display(struct DynamicArray *dArray) {
    if (dArray-&gt;size == 0) {
        printf("Array is empty\n");
    } else {
        for (int i = 0; i &lt; dArray-&gt;size; i++) {
            printf("%d ", dArray-&gt;array[i]);
        }
        printf("\n");
    }
}

// Free the memory allocated to the array
void deallocate(struct DynamicArray *dArray) {
    free(dArray-&gt;array);
    dArray-&gt;array = NULL;
    dArray-&gt;capacity = dArray-&gt;size = 0;
}

int main() {
    struct DynamicArray dArray;
    initArray(&dArray, 2);

    add(&dArray, 10);
    add(&dArray, 20);
    add(&dArray, 30);
    display(&dArray); // Output: 10 20 30

    printf("Element at index 1: %d\n", get(&dArray, 1)); // Output: 20

    set(&dArray, 1, 25);
    display(&dArray); // Output: 10 25 30

    insert(&dArray, 1, 15);
    display(&dArray); // Output: 10 15 25 30

    remove(&dArray, 2);
    display(&dArray); // Output: 10 15 30

    printf("Size: %d\n", size(&dArray)); // Output: 3

    clear(&dArray);
    display(&dArray); // Output: Array is empty

    deallocate(&dArray);

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic Dynamic Array implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;stdexcept&gt; // For exception handling

class DynamicArray {
private:
    int* array;
    int capacity;
    int currentSize;

    // Resize the array when it reaches capacity
    void resize() {
        capacity *= 2;
        int* newArray = new int[capacity];

        // Manually copy elements from the old array to the new array
        for (int i = 0; i &lt; currentSize; ++i) {
            newArray[i] = array[i];
        }

        delete[] array; // Free the old array
        array = newArray; // Assign the new array
    }

public:
    // Constructor to initialize the dynamic array with an initial capacity
    DynamicArray(int initialCapacity = 2) {
        capacity = initialCapacity;
        array = new int[capacity];
        currentSize = 0;
    }

    // Destructor to free allocated memory
    ~DynamicArray() {
        delete[] array;
    }

    // Add an element to the array
    void add(int element) {
        if (currentSize == capacity) {
            resize();
        }
        array[currentSize++] = element;
    }

    // Get an element at a specific index
    int get(int index) const {
        if (index &lt; 0 || index &gt;= currentSize) {
            throw std::out_of_range("Index out of range");
        }
        return array[index];
    }

    // Set (update) an element at a specific index
    void set(int index, int element) {
        if (index &lt; 0 || index &gt;= currentSize) {
            throw std::out_of_range("Index out of range");
        }
        array[index] = element;
    }

    // Remove an element at a specific index
    void remove(int index) {
        if (index &lt; 0 || index &gt;= currentSize) {
            throw std::out_of_range("Index out of range");
        }
        for (int i = index; i &lt; currentSize - 1; ++i) {
            array[i] = array[i + 1];
        }
        --currentSize;
    }

    // Insert an element at a specific index
    void insert(int index, int element) {
        if (index &lt; 0 || index &gt; currentSize) {
            throw std::out_of_range("Index out of range");
        }
        if (currentSize == capacity) {
            resize();
        }
        for (int i = currentSize; i &gt; index; --i) {
            array[i] = array[i - 1];
        }
        array[index] = element;
        ++currentSize;
    }

    // Get the current size of the dynamic array
    int size() const {
        return currentSize;
    }

    // Clear the array
    void clear() {
        currentSize = 0;
        std::cout &lt;&lt; "Array cleared!" &lt;&lt; std::endl;
    }

    // Display all elements in the dynamic array
    void display() const {
        if (currentSize == 0) {
            std::cout &lt;&lt; "Array is empty" &lt;&lt; std::endl;
        } else {
            for (int i = 0; i &lt; currentSize; ++i) {
                std::cout &lt;&lt; array[i] &lt;&lt; " ";
            }
            std::cout &lt;&lt; std::endl;
        }
    }
};

int main() {
    DynamicArray dynamicArray;

    // Adding elements
    dynamicArray.add(1);
    dynamicArray.add(2);
    dynamicArray.add(3);
    dynamicArray.add(4);
    dynamicArray.display(); // Output: Array elements: 1 2 3 4

    // Get element at index 2
    std::cout &lt;&lt; "Element at index 2: " &lt;&lt; dynamicArray.get(2) &lt;&lt; std::endl; // Output: 3

    // Set element at index 1
    dynamicArray.set(1, 20);
    dynamicArray.display(); // Output: Array elements: 1 20 3 4

    // Insert an element at index 2
    dynamicArray.insert(2, 100);
    dynamicArray.display(); // Output: Array elements: 1 20 100 3 4

    // Remove an element at index 3
    dynamicArray.remove(3);
    dynamicArray.display(); // Output: Array elements: 1 20 100 4

    // Get the current size of the array
    std::cout &lt;&lt; "Size: " &lt;&lt; dynamicArray.size() &lt;&lt; std::endl; // Output: Size: 4

    // Clear the array
    dynamicArray.clear();
    dynamicArray.display(); // Output: Array is empty

    return 0;
}</code></pre>
		
		<p>Here is the Non-Generic Dynamic Array implementation in Java:</p>
		
		<pre><code class="language-java hljs">class DynamicArray {
    private int[] array;
    private int size;
    private int capacity;

    // Constructor to initialize array with a specified capacity
    public DynamicArray(int initialCapacity) {
        this.capacity = initialCapacity;
        this.array = new int[capacity];
        this.size = 0;
    }

    // Default constructor with an initial capacity of 2
    public DynamicArray() {
        this(2);
    }

    // Add an element to the dynamic array
    public void add(int element) {
        if (size == capacity) {
            resize();
        }
        array[size++] = element;
    }

    // Get an element at a specific index
    public int get(int index) {
        if (index &gt;= size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        return array[index];
    }

    // Set (update) an element at a specific index
    public void set(int index, int element) {
        if (index &gt;= size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        array[index] = element;
    }

    // Remove an element at a specific index
    public void remove(int index) {
        if (index &gt;= size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        for (int i = index; i &lt; size - 1; i++) {
            array[i] = array[i + 1];
        }
        array[--size] = 0;  // Clear last element
    }

    // Insert an element at a specific index
    public void insert(int index, int element) {
        if (index &gt; size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        if (size == capacity) {
            resize();
        }
        for (int i = size; i &gt; index; i--) {
            array[i] = array[i - 1];
        }
        array[index] = element;
        size++;
    }

    // Get the current size of the array
    public int size() {
        return size;
    }

    // Resize the array when capacity is reached
    private void resize() {
        capacity *= 2;
        int[] newArray = new int[capacity];
        
        // Manually copy elements from the old array to the new array
        for (int i = 0; i &lt; size; i++) {
            newArray[i] = array[i];
        }
        
        array = newArray;
    }

    // Clear the array by setting the size to 0
    public void clear() {
        for (int i = 0; i &lt; size; i++) {
            array[i] = 0;
        }
        size = 0;
        System.out.println("Array cleared!");
    }

    // Display all elements in the dynamic array
    public void display() {
        if (size == 0) {
            System.out.println("Array is empty");
        } else {
            for (int i = 0; i &lt; size; i++) {
                System.out.print(array[i] + " ");
            }
            System.out.println();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        DynamicArray dynamicArray = new DynamicArray();

        // Adding elements
        dynamicArray.add(1);
        dynamicArray.add(2);
        dynamicArray.add(3);
        dynamicArray.add(4);
        dynamicArray.display(); // Output: Array elements: 1 2 3 4

        // Get element at index 2
        System.out.println("Element at index 2: " + dynamicArray.get(2)); // Output: 3

        // Set element at index 1
        dynamicArray.set(1, 20);
        dynamicArray.display(); // Output: Array elements: 1 20 3 4

        // Insert an element at index 2
        dynamicArray.insert(2, 100);
        dynamicArray.display(); // Output: Array elements: 1 20 100 3 4

        // Remove an element at index 3
        dynamicArray.remove(3);
        dynamicArray.display(); // Output: Array elements: 1 20 100 4

        // Get the current size of the array
        System.out.println("Size: " + dynamicArray.size()); // Output: Size: 4

        // Clear the array
        dynamicArray.clear();
        dynamicArray.display(); // Output: Array is empty
    }
}</code></pre>
		
		<p>Here is the Non-Generic Dynamic Array implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class DynamicArray
{
    private int[] array;      // Internal array to store elements
    private int capacity;     // Capacity of the array
    private int size;         // Current number of elements

    // Constructor to initialize array with a default capacity
    public DynamicArray(int initialCapacity = 2)
    {
        capacity = initialCapacity;
        array = new int[capacity];
        size = 0;
    }

    // Add an element to the dynamic array
    public void Add(int element)
    {
        if (size == capacity)
        {
            Resize(); // Resize the array if it's full
        }
        array[size++] = element;
    }

    // Get an element at a specific index
    public int Get(int index)
    {
        if (index &lt; 0 || index &gt;= size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        return array[index];
    }

    // Set (update) an element at a specific index
    public void Set(int index, int element)
    {
        if (index &lt; 0 || index &gt;= size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        array[index] = element;
    }

    // Remove an element at a specific index
    public void Remove(int index)
    {
        if (index &lt; 0 || index &gt;= size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        for (int i = index; i &lt; size - 1; i++)
        {
            array[i] = array[i + 1]; // Shift elements to the left
        }
        size--;
    }

    // Insert an element at a specific index
    public void Insert(int index, int element)
    {
        if (index &lt; 0 || index &gt; size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        if (size == capacity)
        {
            Resize(); // Resize if array is full
        }
        for (int i = size; i &gt; index; i--)
        {
            array[i] = array[i - 1]; // Shift elements to the right
        }
        array[index] = element;
        size++;
    }

    // Get the current size of the array
    public int Size()
    {
        return size;
    }

    // Resize the array when it's full
    private void Resize()
    {
        capacity *= 2;
        int[] newArray = new int[capacity];
        for (int i = 0; i &lt; size; i++)
        {
            newArray[i] = array[i]; // Copy elements to the new array
        }
        array = newArray;
    }

    // Clear the array by setting size to 0
    public void Clear()
    {
        size = 0;
        Console.WriteLine("Array cleared!");
    }

    // Display all elements in the dynamic array
    public void Display()
    {
        if (size == 0)
        {
            Console.WriteLine("Array is empty");
        }
        else
        {
            for (int i = 0; i &lt; size; i++)
            {
                Console.Write(array[i] + " ");
            }
            Console.WriteLine();
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        DynamicArray dynamicArray = new DynamicArray();

        // Adding elements
        dynamicArray.Add(1);
        dynamicArray.Add(2);
        dynamicArray.Add(3);
        dynamicArray.Add(4);
        dynamicArray.Display(); // Output: Array elements: 1 2 3 4

        // Get element at index 2
        Console.WriteLine("Element at index 2: " + dynamicArray.Get(2)); // Output: 3

        // Set element at index 1
        dynamicArray.Set(1, 20);
        dynamicArray.Display(); // Output: Array elements: 1 20 3 4

        // Insert an element at index 2
        dynamicArray.Insert(2, 100);
        dynamicArray.Display(); // Output: Array elements: 1 20 100 3 4

        // Remove an element at index 3
        dynamicArray.Remove(3);
        dynamicArray.Display(); // Output: Array elements: 1 20 100 4

        // Get the current size of the array
        Console.WriteLine("Size: " + dynamicArray.Size()); // Output: Size: 4

        // Clear the array
        dynamicArray.Clear();
        dynamicArray.Display(); // Output: Array is empty
    }
}</code></pre>
		
		
		<h3 class="post-subtitle">Generic Dynamic Array Implementation</h3>
		
		<p>Here is the Generic Dynamic Array implementation in C:</p>
		
		<pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// Define a structure for StackElement
typedef struct {
    void* data;           // Generic pointer to hold data
    char* toString;       // String description of the element
} StackElement;

// Define a structure for the dynamic array of StackElements
typedef struct {
    StackElement* array;   // Array to store StackElements
    int capacity;          // Capacity of the array
    int size;              // Current number of elements
} DynamicArray;

// Function to initialize the dynamic array
void init(DynamicArray* arr, int initialCapacity) {
    arr-&gt;capacity = initialCapacity;
    arr-&gt;size = 0;
    arr-&gt;array = (StackElement*)malloc(initialCapacity * sizeof(StackElement));
}

// Function to resize the dynamic array
void resize(DynamicArray* arr) {
    arr-&gt;capacity *= 2;
    StackElement* newArray = (StackElement*)malloc(arr-&gt;capacity * sizeof(StackElement));

    // Copy elements from the old array to the new array
    for (int i = 0; i &lt; arr-&gt;size; i++) {
        newArray[i] = arr-&gt;array[i];
    }

    free(arr-&gt;array); // Free the old array memory
    arr-&gt;array = newArray;
}

// Function to add an element to the dynamic array
void add(DynamicArray* arr, void* data, const char* description) {
    if (arr-&gt;size == arr-&gt;capacity) {
        resize(arr);
    }
    arr-&gt;array[arr-&gt;size].data = data;
    arr-&gt;array[arr-&gt;size].toString = strdup(description); // Duplicate the string description
    arr-&gt;size++;
}

// Function to get an element at a specific index
StackElement* get(DynamicArray* arr, int index) {
    if (index &lt; 0 || index &gt;= arr-&gt;size) {
        printf("Index out of range\n");
        return NULL;
    }
    return &arr-&gt;array[index];
}

// Function to set an element at a specific index
void set(DynamicArray* arr, int index, void* data, const char* description) {
    if (index &lt; 0 || index &gt;= arr-&gt;size) {
        printf("Index out of range\n");
        return;
    }
    free(arr-&gt;array[index].data);
    arr-&gt;array[index].data = data;
    free(arr-&gt;array[index].toString);  // Free the old string memory
    arr-&gt;array[index].toString = strdup(description);  // Duplicate the new string description
}

// Function to remove an element at a specific index
void remove(DynamicArray* arr, int index) {
    if (index &lt; 0 || index &gt;= arr-&gt;size) {
        printf("Index out of range\n");
        return;
    }
    free(arr-&gt;array[index].toString);  // Free the string memory
    free(arr-&gt;array[index].data);       // Free the Car instance memory
    for (int i = index; i &lt; arr-&gt;size - 1; i++) {
        arr-&gt;array[i] = arr-&gt;array[i + 1];
    }
    arr-&gt;size--;
}

// Function to insert an element at a specific index
void insert(DynamicArray* arr, int index, void* data, const char* description) {
    if (index &lt; 0 || index &gt; arr-&gt;size) {
        printf("Index out of range\n");
        return;
    }
    if (arr-&gt;size == arr-&gt;capacity) {
        resize(arr);
    }
    for (int i = arr-&gt;size; i &gt; index; i--) {
        arr-&gt;array[i] = arr-&gt;array[i - 1];
    }
    arr-&gt;array[index].data = data;
    arr-&gt;array[index].toString = strdup(description); // Duplicate the string description
    arr-&gt;size++;
}

// Function to get the current size of the dynamic array
int size(DynamicArray* arr) {
    return arr-&gt;size;
}

// Function to clear the dynamic array
void deallocate(DynamicArray* arr) {
    for (int i = 0; i &lt; arr-&gt;size; i++) {
        free(arr-&gt;array[i].toString);  // Free the string memory
        free(arr-&gt;array[i].data);       // Free the Car instance memory
    }
    arr-&gt;size = 0;
}

// Function to display the dynamic array
void display(DynamicArray* arr) {
    for (int i = 0; i &lt; arr-&gt;size; i++) {
        printf("%s ", arr-&gt;array[i].toString);
    }
}

// Function to free the dynamic array
void deallocate(DynamicArray* arr) {
    for (int i = 0; i &lt; arr-&gt;size; i++) {
        free(arr-&gt;array[i].toString);  // Free the string memory
        free(arr-&gt;array[i].data);       // Free the Car instance memory
    }
    free(arr-&gt;array);  // Free the array memory
}

// A Car struct to demonstrate the use of StackElement in the dynamic array
typedef struct {
    char model[50];
    int year;
} Car;

// A function to create a string description for a Car
char* carToString(Car* car) {
    char* result = (char*)malloc(100 * sizeof(char));  // Allocate memory for the string
    sprintf(result, "Car{model:\"%s\",year:%d}", car-&gt;model, car-&gt;year);
    return result;
}

// Main function for testing the implementation
int main() {
    DynamicArray carArray;
    // Initialize the dynamic array for StackElements
    init(&carArray, 2);

    // Create cars dynamically and add them to the array
    Car* car1 = (Car*)malloc(sizeof(Car));
    strcpy(car1-&gt;model, "Toyota Camry");
    car1-&gt;year = 2020;
    add(&carArray, car1, carToString(car1));

    Car* car2 = (Car*)malloc(sizeof(Car));
    strcpy(car2-&gt;model, "Honda Accord");
    car2-&gt;year = 2019;
    add(&carArray, car2, carToString(car2));

    Car* car3 = (Car*)malloc(sizeof(Car));
    strcpy(car3-&gt;model, "Tesla Model S");
    car3-&gt;year = 2022;
    add(&carArray, car3, carToString(car3));

    // Display the car array
    printf("Car Array:\n");
    display(&carArray);

    // Demonstrate using getElement, setElement, removeElement, and insertElement
    printf("Size before modifications: %d\n", size(&carArray));

    // Insert a new car
    Car* car4 = (Car*)malloc(sizeof(Car));
    strcpy(car4-&gt;model, "Ford Mustang");
    car4-&gt;year = 2021;
    insert(&carArray, 1, car4, carToString(car4)); // Insert at index 1

    printf("Car Array after insertion:\n");
    display(&carArray);

    // Set a car at index 2
    Car* car5 = (Car*)malloc(sizeof(Car));
    strcpy(car5-&gt;model, "Chevrolet Camaro");
    car5-&gt;year = 2023;
    set(&carArray, 2, car5, carToString(car5)); // Set at index 2

    printf("Car Array after setting new car at index 2:\n");
    display(&carArray);

    // Remove the first car
    remove(&carArray, 0);
    printf("Car Array after removing the first car:\n");
    display(&carArray);

    // Clean up
    deallocate(&carArray);

    return 0;
}</code></pre>
		
		<p>Here is the Generic Dynamic Array implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
#include &lt;stdexcept&gt; // For exception handling

template &lt;typename T&gt;
class DynamicArray {
private:
    T* array;           // Pointer to hold the dynamic array
    int capacity;       // Capacity of the array
    int currentSize;    // Current number of elements in the array

    // Resize the array when capacity is full
    void resize() {
        capacity *= 2;
        T* newArray = new T[capacity];  // Allocate new array with double capacity
        for (int i = 0; i &lt; currentSize; ++i) {
            newArray[i] = array[i];     // Copy elements from old array to new array
        }
        delete[] array;                 // Deallocate old array
        array = newArray;               // Point to the new array
    }

public:
    // Constructor to initialize dynamic array with an initial capacity
    DynamicArray(int initialCapacity = 2) {
        capacity = initialCapacity;
        array = new T[capacity];
        currentSize = 0;
    }

    // Destructor to clean up allocated memory
    ~DynamicArray() {
        delete[] array;
    }

    // Add an element to the array
    void add(const T& element) {
        if (currentSize == capacity) {
            resize();
        }
        array[currentSize++] = element;
    }

    // Get an element at a specific index
    T get(int index) const {
        if (index &lt; 0 || index &gt;= currentSize) {
            throw std::out_of_range("Index out of range");
        }
        return array[index];
    }

    // Set (update) an element at a specific index
    void set(int index, const T& element) {
        if (index &lt; 0 || index &gt;= currentSize) {
            throw std::out_of_range("Index out of range");
        }
        array[index] = element;
    }

    // Remove an element at a specific index
    void remove(int index) {
        if (index &lt; 0 || index &gt;= currentSize) {
            throw std::out_of_range("Index out of range");
        }
        for (int i = index; i &lt; currentSize - 1; ++i) {
            array[i] = array[i + 1];
        }
        --currentSize;
    }

    // Insert an element at a specific index
    void insert(int index, const T& element) {
        if (index &lt; 0 || index &gt; currentSize) {
            throw std::out_of_range("Index out of range");
        }
        if (currentSize == capacity) {
            resize();
        }
        for (int i = currentSize; i &gt; index; --i) {
            array[i] = array[i - 1];  // Shift elements to the right
        }
        array[index] = element;
        ++currentSize;
    }

    // Get the current size of the array
    int size() const {
        return currentSize;
    }

    // Clear the array by resetting the size
    void clear() {
        currentSize = 0;
        std::cout &lt;&lt; "Array cleared!" &lt;&lt; std::endl;
    }

    // Display all elements in the dynamic array
    void display() const {
        if (currentSize == 0) {
            std::cout &lt;&lt; "Array is empty" &lt;&lt; std::endl;
        } else {
            for (int i = 0; i &lt; currentSize; ++i) {
                std::cout &lt;&lt; array[i] &lt;&lt; " ";
            }
            std::cout &lt;&lt; std::endl;
        }
    }
};

// Test the DynamicArray class
int main() {
    DynamicArray&lt;int&gt; dynamicArray;

    // Adding elements
    dynamicArray.add(1);
    dynamicArray.add(2);
    dynamicArray.add(3);
    dynamicArray.add(4);
    dynamicArray.display(); // Output: Array elements: 1 2 3 4

    // Get element at index 2
    std::cout &lt;&lt; "Element at index 2: " &lt;&lt; dynamicArray.get(2) &lt;&lt; std::endl; // Output: 3

    // Set element at index 1
    dynamicArray.set(1, 20);
    dynamicArray.display(); // Output: Array elements: 1 20 3 4

    // Insert an element at index 2
    dynamicArray.insert(2, 100);
    dynamicArray.display(); // Output: Array elements: 1 20 100 3 4

    // Remove an element at index 3
    dynamicArray.remove(3);
    dynamicArray.display(); // Output: Array elements: 1 20 100 4

    // Get the current size of the array
    std::cout &lt;&lt; "Size: " &lt;&lt; dynamicArray.size() &lt;&lt; std::endl; // Output: Size: 4

    // Clear the array
    dynamicArray.clear();
    dynamicArray.display(); // Output: Array is empty

    return 0;
}</code></pre>
		
		<p>Here is the Generic Dynamic Array implementation in Java:</p>
		
		<pre><code class="language-java hljs">class DynamicArray&lt;T&gt; {
    private Object[] array;
    private int size;
    private int capacity;

    // Constructor to initialize array with a specified capacity
    public DynamicArray(int initialCapacity) {
        this.capacity = initialCapacity;
        this.array = new Object[capacity];
        this.size = 0;
    }

    // Default constructor with an initial capacity of 2
    public DynamicArray() {
        this(2);
    }

    // Add an element to the dynamic array
    public void add(T element) {
        if (size == capacity) {
            resize();
        }
        array[size++] = element;
    }

    // Get an element at a specific index
    public T get(int index) {
        if (index &gt;= size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        return (T) array[index];
    }

    // Set (update) an element at a specific index
    public void set(int index, T element) {
        if (index &gt;= size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        array[index] = element;
    }

    // Remove an element at a specific index
    public void remove(int index) {
        if (index &gt;= size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        for (int i = index; i &lt; size - 1; i++) {
            array[i] = array[i + 1];
        }
        array[--size] = null;  // Clear last element
    }

    // Insert an element at a specific index
    public void insert(int index, T element) {
        if (index &gt; size || index &lt; 0) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        if (size == capacity) {
            resize();
        }
        for (int i = size; i &gt; index; i--) {
            array[i] = array[i - 1];
        }
        array[index] = element;
        size++;
    }

    // Get the current size of the array
    public int size() {
        return size;
    }

    // Resize the array when capacity is reached
    private void resize() {
        capacity *= 2;
        Object[] newArray = new Object[capacity];
        
        // Manually copy elements from the old array to the new array
        for (int i = 0; i &lt; size; i++) {
            newArray[i] = array[i];
        }
        array = newArray;
    }

    // Clear the array by setting the size to 0
    public void clear() {
        for (int i = 0; i &lt; size; i++) {
            array[i] = null;
        }
        size = 0;
        System.out.println("Array cleared!");
    }

    // Display all elements in the dynamic array
    public void display() {
        if (size == 0) {
            System.out.println("Array is empty");
        } else {
            for (int i = 0; i &lt; size; i++) {
                System.out.print(array[i] + " ");
            }
            System.out.println();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        DynamicArray&lt;Integer&gt; dynamicArray = new DynamicArray&lt;&gt;();

        // Adding elements
        dynamicArray.add(1);
        dynamicArray.add(2);
        dynamicArray.add(3);
        dynamicArray.add(4);
        dynamicArray.display(); // Output: Array elements: 1 2 3 4

        // Get element at index 2
        System.out.println("Element at index 2: " + dynamicArray.get(2)); // Output: 3

        // Set element at index 1
        dynamicArray.set(1, 20);
        dynamicArray.display(); // Output: Array elements: 1 20 3 4

        // Insert an element at index 2
        dynamicArray.insert(2, 100);
        dynamicArray.display(); // Output: Array elements: 1 20 100 3 4

        // Remove an element at index 3
        dynamicArray.remove(3);
        dynamicArray.display(); // Output: Array elements: 1 20 100 4

        // Get the current size of the array
        System.out.println("Size: " + dynamicArray.size()); // Output: Size: 4

        // Clear the array
        dynamicArray.clear();
        dynamicArray.display(); // Output: Array is empty
    }
}</code></pre>

		<p>Here is the Generic Dynamic Array implementation in C#:</p>

		<pre><code class="language-csharp hljs">using System;

class DynamicArray&lt;T&gt;
{
    private T[] array;      // Internal array to store elements
    private int capacity;   // Capacity of the array
    private int size;       // Current number of elements

    // Constructor to initialize array with a default capacity
    public DynamicArray(int initialCapacity = 2)
    {
        capacity = initialCapacity;
        array = new T[capacity];
        size = 0;
    }

    // Add an element to the dynamic array
    public void Add(T element)
    {
        if (size == capacity)
        {
            Resize(); // Resize the array if it's full
        }
        array[size++] = element;
    }

    // Get an element at a specific index
    public T Get(int index)
    {
        if (index &lt; 0 || index &gt;= size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        return array[index];
    }

    // Set (update) an element at a specific index
    public void Set(int index, T element)
    {
        if (index &lt; 0 || index &gt;= size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        array[index] = element;
    }

    // Remove an element at a specific index
    public void Remove(int index)
    {
        if (index &lt; 0 || index &gt;= size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        for (int i = index; i &lt; size - 1; i++)
        {
            array[i] = array[i + 1]; // Shift elements to the left
        }
        size--;
    }

    // Insert an element at a specific index
    public void Insert(int index, T element)
    {
        if (index &lt; 0 || index &gt; size)
        {
            throw new IndexOutOfRangeException("Index out of range");
        }
        if (size == capacity)
        {
            Resize(); // Resize the array if it's full
        }
        for (int i = size; i &gt; index; i--)
        {
            array[i] = array[i - 1]; // Shift elements to the right
        }
        array[index] = element;
        size++;
    }

    // Get the current size of the array
    public int Size()
    {
        return size;
    }

    // Resize the array when it's full
    private void Resize()
    {
        capacity *= 2;
        T[] newArray = new T[capacity];
        for (int i = 0; i &lt; size; i++)
        {
            newArray[i] = array[i]; // Copy elements to the new array
        }
        array = newArray;
    }

    // Clear the array by setting size to 0
    public void Clear()
    {
        size = 0;
        Console.WriteLine("Array cleared!");
    }

    // Display all elements in the dynamic array
    public void Display()
    {
        if (size == 0)
        {
            Console.WriteLine("Array is empty");
        }
        else
        {
            for (int i = 0; i &lt; size; i++)
            {
                Console.Write(array[i] + " ");
            }
            Console.WriteLine();
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Create a dynamic array for integers
        DynamicArray&lt;int&gt; dynamicArray = new DynamicArray&lt;int&gt;();

        // Adding elements
        dynamicArray.Add(1);
        dynamicArray.Add(2);
        dynamicArray.Add(3);
        dynamicArray.Add(4);
        dynamicArray.Display(); // Output: Array elements: 1 2 3 4

        // Get element at index 2
        Console.WriteLine("Element at index 2: " + dynamicArray.Get(2)); // Output: 3

        // Set element at index 1
        dynamicArray.Set(1, 20);
        dynamicArray.Display(); // Output: Array elements: 1 20 3 4

        // Insert an element at index 2
        dynamicArray.Insert(2, 100);
        dynamicArray.Display(); // Output: Array elements: 1 20 100 3 4

        // Remove an element at index 3
        dynamicArray.Remove(3);
        dynamicArray.Display(); // Output: Array elements: 1 20 100 4

        // Get the current size of the array
        Console.WriteLine("Size: " + dynamicArray.Size()); // Output: Size: 4

        // Clear the array
        dynamicArray.Clear();
        dynamicArray.Display(); // Output: Array is empty

        // Create a dynamic array for strings
        DynamicArray&lt;string&gt; stringArray = new DynamicArray&lt;string&gt;();
        stringArray.Add("Hello");
        stringArray.Add("World");
        stringArray.Display(); // Output: Array elements: Hello World
    }
}</code></pre>

    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/array" class="tag">array</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/dynamic-array" class="tag">dynamic array</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/10/11/dynamic-array-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-10" /><category term="day-11" /><category term="data structure" /><category term="array" /><category term="dynamic array" /><summary type="html"><![CDATA[Discover the Dynamic Array Data Structure, a powerful solution for efficiently managing collections of data that require flexibility and scalability. Unlike static arrays, dynamic arrays automatically resize themselves, allowing for easy addition and removal of elements without the need for manual memory management. This versatile data structure supports essential operations such as initialization, element insertion, retrieval, updating, and deletion, enabling seamless manipulation of diverse data types.]]></summary></entry><entry xml:lang="en"><title type="html">Time and Space Complexity in Algorithm</title><link href="https://hemimorphite.github.io/2024/10/07/time-and-space-complexity-in-algorithm/" rel="alternate" type="text/html" title="Time and Space Complexity in Algorithm" /><published>2024-10-07T06:21:00+00:00</published><updated>2024-10-07T06:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/10/07/time-and-space-complexity-in-algorithm</id><content type="html" xml:base="https://hemimorphite.github.io/2024/10/07/time-and-space-complexity-in-algorithm/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Time and Space Complexity in Algorithm</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published October 07, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/complexity.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Algorithmic complexity is a way of comparing the efficiency of an algorithm. Complexity can be measured in terms of the time that it takes for a program to run (time complexity) or in terms of the memory that it will use (space complexity).</p>

        <p>In computer science, whenever we want to solve some computational problem then we define a set of steps that need to be followed to solve that problem. These steps are collectively known as an algorithm.</p>

        <p>For example, you have two integers <code>a</code> and <code>b</code> and you want to find the sum of those two number. How will you solve this? One possible solution for the above problem can be:</p>

        <ol>
            <li>Take two integers as input</li>
            <li>Create a variable <code>sum</code> to store the sum of two integers</li>
            <li>Put the sum of those two variables in the <code>sum</code> variable</li>
            <li>Return the <code>sum</code> variable</li>
        </ol>

        <pre><code class="language-c hljs">// Taking two integers as input
int sum(int a, int b) 
{
    int sum; // creating the sum variable
    sum = a + b; // storing the sum of a and b
    return sum; // returning the sum variable
}</code></pre>
    
        <p>In the above example, you will find three things i.e. input, algorithm, and output:</p>

        <ul>
            <li><b>Input</b>: Input is something for which you need to write an algorithm and transform it into the desired output. In our example, the input is the two numbers i.e. <code>a</code> and <code>b</code>.</li>
            <li><b>Algorithm</b>: An algorithm is well-defined steps by step procedure that take some value or set of values as input and produce some value or set of values as output. In the above example, we are having three steps to find the sum of two numbers. So, all three steps are collectively called an algorithm to find the sum of two numbers.</li>
            <li><b>Output</b>: Output is the desired result in the problem. For example, if we are finding the sum of two integers <code>a</code> and <code>b</code> then for every value of <code>a</code> and <code>b</code> it must produce the correct sum as an output.</li>
        </ul>

        <p>The efficiency of an algorithm is mainly defined by two factors i.e. space and time. A good algorithm is one that is taking less time and less space, but this is not possible all the time. There is a trade-off between time and space. If you want to reduce the time, then space might increase. Similarly, if you want to reduce the space, then the time may increase. So, you have to compromise with either space or time.</p>

        <h4 class="post-subtitle">Time Complexity</h4>

        <p>Every algorithm requires some amount of time to execute its instruction to perform the task. This time required is called time complexity.</p>

        <p>Time complexity is generally expressed as a function of the input size, often denoted as \(n\). The input size refers to the amount of data the algorithm needs to process (e.g., the number of elements in an array).</p>

        <p>Time complexity analysis ignores machine-dependent details like processor speed, memory cache, or other low-level factors, because these are specific to hardware and can vary greatly. Instead, the focus is on how the algorithm behaves as the input size changes, regardless of these machine-specific factors.</p>

        <p> When calculating time complexity, we consider the number of fundamental operations the algorithm performs (arithmetic, logical, comparison, assignments, etc.). Each of these operations is assumed to take constant time, even though on a real machine, their execution time may differ. The core idea behind time complexity is to measure how the number of operations scales as the input size increases, rather than calculating the exact time each operation takes.</p>

        <p>Time complexity can vary depending on the input data, so algorithms may have different complexities for the worst-case, best-case, and average-case scenarios. The focus is often on worst-case complexity because it gives the upper bound on the algorithm's runtime.</p>

        <p>Calculating the time complexity of an algorithm based on system configuration can be difficult, given that hardware characteristics like CPU speed, memory, and cache sizes vary across systems. This is why time complexity is typically calculated in a machine-independent manner using an abstract model of computation.</p>

        <p>To calculate the time complexity of an algorithm, we need to define a model machine. Let us assume a machine with following assumptions:</p>

        <ul>
            <li>It performs sequential execution. The machine executes instructions one after another, without any parallelism.</li>
            <li>It requires \(1\) unit of time for arithmetic and logical operations. Any arithmetic or logical operation (e.g., addition, subtraction, comparison) takes exactly \(1\) unit of time.</li>
            <li>It requires \(1\) unit of time for assignment and return value. Assigning a value to a variable or returning a value from a function takes \(1\) unit of time.</li>
            <li>It requires \(1\) unit of time for read and write operations. Reading from memory (e.g., accessing array elements) and writing to memory (e.g., updating a variable) both take \(1\) unit of time.</li>
            <li>It requires \(1\) unit of time for increment and decrement operations.</li>
        </ul>

        <p>The following are the primary types of time complexities that commonly appear in algorithm analysis:</p>

        <ul>
            <li>Constant Time Complexity</li>
            <li>Logarithmic Time Complexity</li>
            <li>Linear Time Complexity</li>
            <li>Linearithmic Time Complexity</li>
            <li>Quadratic Time Complexity</li>
            <li>Cubic Time Complexity</li>
            <li>Exponential Time Complexity</li>
            <li>Factorial Time Complexity</li>
        </ul>

        <h5 class="post-subtitle">Constant Time Complexity</h5>

        <p>Constant time complexity, refers to an algorithm or operation that takes the same amount of time to complete, regardless of the size of the input. This means that no matter how large the input data set is, the time it takes to perform the operation remains constant.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int sum(int a, int b)
{
   return a + b;
}</code></pre>

        <p>Let's break down the operations inside the <code>sum</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>The addition and return statement <code>return a + b</code> take \(2\) units of time (\(1\) for addition, \(1\) for return statement).</li>
        </ul>
        
        <p>Totally it takes \(2\) units of time to complete its execution and it is Constant Time Complexity. It does not change based on the input values of <code>a</code> and <code>b</code>. That means for all input values, it requires the same amount of time i.e. \(2\) units.</p>

        <h5 class="post-subtitle">Linear Time Complexity</h5>

        <p>Linear time complexity refers to an algorithm or operation whose time to complete increases linearly with the size of the input data. This means that if you double the input size, the time taken to complete the operation also roughly doubles.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int sum(int arr[], int n)
{
    int sum = 0;
    for(int i = 0; i &lt; n; i++)
        sum = sum + arr[i];
    return sum;
}</code></pre>

        <p>Let's break down the operations inside the sum function above and calculate the total time complexity:</p>

        <ul>
            <li>The initialization <code>int sum = 0</code> takes \(1\) unit of time</li>
            <li>The initialization <code>int i = 0</code> in the <code>for</code> loop takes \(1\) unit of time</li>
            <li>The loop runs \(n\) times, and each iteration involves:<br>
                <ul>
                    <li>The comparison <code>i &gt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(i = n\)).</li>
                    <li>The increment <code>i++</code> takes \(1\) unit of time, repeated n times.</li>
                    <li>Reading an element from the array (array access) <code>arr[i]</code> takes \(1\) unit of time, repeated \(n\) times.</li>
                    <li>The addition and assignment <code>sum = sum + arr[i]</code> take \(2\) units of time (\(1\) for addition, \(1\) for assignment), repeated \(n\) times.</li>
                </ul>
            </li>
            <li>The return statement <code>return sum</code> takes \(1\) unit of time.</li>
        </ul>

        <p>Totally it takes \(5n + 3\) units of time to complete its execution and it is Linear Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases linearly.</p>

        <h5 class="post-subtitle">Logarithmic Time Complexity</h5>

        <p>Logarithmic time complexity describes an algorithm whose running time increases logarithmically as the size of the input data set increases. This means that if the input size doubles, the time taken to complete the operation increases by a constant amount. This complexity is much more efficient than linear time complexity for large inputs.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int countDigits(int n) {
    int digits = 0;

    while (n &gt; 0) {
        n = n / 10;
        digits++;
    }

    return digits;
}</code></pre>
        
        <p>Let's break down the operations inside the <code>countDigits</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>The initialization <code>int digits = 0;</code> takes \(1\) unit of time</li>
            <li>The loop runs \(\lfloor \log_{10}(n) \rfloor + 1\) times, and each iteration involves:<br>
                <ul>
                    <li>The comparison <code>n &gt; 0</code> takes \(1\) unit of time, repeated \(\lfloor \log_{10}(n) \rfloor + 1\) times.</li>
                    <li>The increment <code>digits++</code> takes \(1\) unit of time, repeated \(\lfloor \log_{10}(n) \rfloor + 1\) times.</li>
                </ul>
            </li>
            <li>The return statement <code>return digits</code> takes \(1\) unit of time.</li>
        </ul>

        <p>Totally it takes \(2\lfloor \log_{10}(n) \rfloor + 4\) units of time to complete its execution and it is Logarithmic Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases logarithmically.</p>

        <h5 class="post-subtitle">Quadratic Time Complexity</h5>

        <p>Quadratic time complexity refers to algorithms whose running time increases quadratically as the size of the input data set increases. This means that if the input size doubles, the time taken to complete the operation increases by a factor of four. This type of complexity is often associated with algorithms that involve nested loops.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int sumSquareMatrix(int** matrix, int n) {
    int sum = 0;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            sum += matrix[i][j];
        }
    }

    return sum;
}</code></pre>
		
        <p>Let's break down the operations inside the <code>sumSquareMatrix</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>The initialization <code>int sum = 0</code> takes \(1\) unit of time</li>
            <li>The initialization <code>int i = 0</code> in the outer loop takes \(1\) unit of time</li>
            <li>The outer loop runs \(n\) times, and each iteration involves:<br>
                <ul>
                    <li>The comparison <code>i &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(i = n\)).</li> 
                    <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n\) times.</li> 
                    <li>The initialization <code>int j = 0</code> in the inner loop takes \(1\) unit of time, repeated \(n\) times.</li> 
                    <li>The inner loop runs \(n\) times for each outer loop iteration (the total number of iterations is \(n \cdot n\)), and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>j &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(j = n\)) for each outer loop iteration.</li> 
                            <li>The increment <code>j++</code> takes \(1\) unit of time, repeated \(n\) times for each outer loop iteration.</li> 
                            <li>The array access <code>matrix[i][j]</code> takes 1 unit of time, repeated \(n\) times for each outer loop iteration.</li> 
                            <li>The addition and assignment <code>sum += matrix[i][j]</code> take \(2\) units of time (\(1\) for addition, \(1\) for assignment), repeated \(n\) times for each outer loop iteration.</li> 
                        </ul>
                    </li>
                </ul>
            </li>
            <li>The return statement <code>return sum</code> takes \(1\) unit of time.</li> 
        </ul>

        <p>Totally it takes \(4n^{2} + 4 + 4\) units of time to complete its execution and it is Quadratic Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases quadratically.</p>

        <h5 class="post-subtitle">Cubic Time Complexity</h5>

        <p>Cubic time complexity refers to an algorithm whose running time grows proportionally to the cube of the size of the input. In other words, as the input size \(n\) increases, the number of operations increases as \(n \times n \times n\), or \(n^3\).</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int sumCubeMatrix(int*** matrix, int n) {
    int sum = 0;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            for (int k = 0; k &lt; n; k++) {
                sum += matrix[i][j][k];
            }
        }
    }

    return sum;
}</code></pre>
        
        <p>Let's break down the operations inside the <code>sumCubeMatrix</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>The initialization <code>int sum = 0</code> takes \(1\) unit of time</li>
            <li>The initialization <code>int i = 0</code> in the outer loop takes \(1\) unit of time</li> 
            <li>The outer loop runs \(n\) times, and each iteration involves:<br>
                <ul>
                    <li>The comparison <code>i &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(i = n\)).</li> 
                    <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n\) times.</li>
                    <li>The initialization <code>int j = 0</code> in the middle loop takes \(1\) unit of time, repeated \(n\) times.</li>
                    <li>The middle loop runs \(n\) times for each outer loop iteration (the total number of iterations is \(n \times n\), and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>j &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(j = n\)) for each outer loop iteration.</li> 
                            <li>The increment <code>j++</code> takes \(1\) unit of time, repeated \(n\) times for each outer loop iteration.</li>
                            <li>The initialization <code>int k = 0</code> in the inner loop takes \(1\) unit of time, repeated \(n\) times for each outer loop iteration.</li>
                            <li>The inner loop runs \(n\) times for each middle loop iteration (the total number of iterations is \(n \times n \times n\)), and each iteration involves:<br>
								<ul>
									<li>The comparison <code>k &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(k = n\)) for each middle loop iteration.</li>
									<li>The increment <code>k++</code> takes \(1\) unit of time, repeated \(n\) times for each middle loop iteration.</li>
									<li>The array access <code>matrix[i][j][k]</code> takes \(1\) unit of time, repeated \(n\) times for each middle loop iteration.</li> 
									<li>The addition and assignment <code>sum += matrix[i][j][k]</code> take \(2\) units of time (\(1\) for addition, \(1\) for assignment), repeated \(n\) times for each middle loop iteration.</li>
								</ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>The return statement <code>return sum</code> takes \(1\) unit of time.</li>
        </ul>
        
        <p>Totally it takes \(4n^{3} + 4n^{2} + 4n + 4\) units of time to complete its execution and it is Quadratic Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases quadratically.</p>

        <h5 class="post-subtitle">Exponential Time Complexity</h5>

        <p>Exponential time complexity refers to an algorithm whose growth rate doubles with each additional input. In exponential time algorithms, the number of operations grows extremely fast as the size of the input increases.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int fibonacci(int n) {
    if (n &lt;= 1)
        return n;
    else
        return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>
        
		<p>Here's a representation of the fibonacci tree for \(n = 5\) based on the recursive function:</p>
		
		<pre><code class="language-bash hljs">fibonacci(5)
├── fibonacci(4)
│   ├── fibonacci(3)
│   │   ├── fibonacci(2)
│   │   │   ├── fibonacci(1)
│   │   │   └── fibonacci(0)
│   │   └── fibonacci(1)
│   └── fibonacci(2)
│       ├── fibonacci(1)
│       └── fibonacci(0)
└── fibonacci(3)
    ├── fibonacci(2)
    │   ├── fibonacci(1)
    │   └── fibonacci(0)
    └── fibonacci(1)</code></pre>
		
		<p>This tree structure shows how <code>fibonacci(5)</code> breaks down into smaller subproblems recursively. The leaves of the tree are the base cases, <code>fibonacci(1)</code> and <code>fibonacci(0)</code>.</p>
		
		<p>To count how many times <code>fibonacci(0)</code> and <code>fibonacci(1)</code> are called, we need to track these calls across the recursion tree. Let's count the calls to <code>fibonacci(0)</code> and <code>fibonacci(1)</code> in the recursion tree for <code>fibonacci(5)</code>:</p>
		
		<pre><code class="language-bash hljs">fibonacci(5)
├── fibonacci(4)
│   ├── fibonacci(3)
│   │   ├── fibonacci(2)
│   │   │   ├── fibonacci(1)  &lt;-- 1st call to fibonacci(1)
│   │   │   └── fibonacci(0)  &lt;-- 1st call to fibonacci(0)
│   │   └── fibonacci(1)      &lt;-- 2nd call to fibonacci(1)
│   └── fibonacci(2)
│       ├── fibonacci(1)      &lt;-- 3rd call to fibonacci(1)
│       └── fibonacci(0)      &lt;-- 2nd call to fibonacci(0)
└── fibonacci(3)
    ├── fibonacci(2)
    │   ├── fibonacci(1)      &lt;-- 4th call to fibonacci(1)
    │   └── fibonacci(0)      &lt;-- 3rd call to fibonacci(0)
    └── fibonacci(1)          &lt;-- 5th call to fibonacci(1)
</code></pre>
		
		<p><code>fibonacci(0)</code> is called \(3\) times and <code>fibonacci(1)</code> is called \(5\) times.</p>
		
		<p>The number of calls to <code>fibonacci(1)</code> is the Fibonacci number \(F_{n}\) and the number of calls to <code>fibonacci(0)</code> is the Fibonacci number \(F_{n-1}\).</p>
		
		<p>The total number of function calls can be represented by the recurrence relation:</p>
		
		\[ T(n) = T(n - 1) + T(n - 2) + 1 \]
		
		<p>Where:</p>
		
		<ul>
			<li>\(T(n)\) is the total call count for <code>fibonacci(n)</code></li>
			<li>The \(+1\) accounts for the current call itself</li>
		</ul>
		
        <p>Let's break down the operations inside the <code>fibonacci</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>The comparison <code>n &lt;= 1</code> takes \(1\) unit of time, repeated \(T(n)\) times recursively.</li>
            <li>The return statement <code>return n</code> in the if block takes \(1\) unit of time, repeated \(F_{n}+F_{n-1}\) times recursively.</li>
            <li>The addition <code>fibonacci(n - 1) + fibonacci(n - 2)</code> take \(1\) unit of time, repeated \(\frac{T(n)-1}{2}\) times recursively.</li>
            <li>The return statement <code>return fibonacci(n - 1) + fibonacci(n - 2)</code> in the else block takes \(1\) unit of time, repeated \(\frac{T(n)-1}{2}\) times recursively.</li>
        </ul>

        <p>Totally it takes \(2T(n)+F_{n}+F_{n-1}-1\) units of time to complete its execution and it is Exponential Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases exponentially.</p>
				
		<p>The Fibonacci function can be analyzed using the recursion tree method to understand its time complexity more intuitively.</p>
		
		<ol>
			<li>Build the Recursion Tree<br>
				<ul>
					<li><b>Root Node</b>: The root of the tree is the initial call \(F(n)\).</li>
					<li><b>Child Nodes</b>: Each node splits into two child nodes:<br>
						<ul>
							<li>The left child is \(F(n-1)\)</li>
							<li>The right child is \(F(n-2)\)</li>
						</ul>
					</li>
					<li>For \(n = 6\), the recursion tree looks like this:<br>
						<pre><code class="language-bash hljs">					 F(5)                   
                   /     \
               F(4)       F(3)
              /   \       /   \
          F(3)   F(2)  F(2)  F(1)
         /   \   /  \   / \
     F(2)  F(1) F(1) F(0) F(1)
     / \
  F(1) F(0)</code></pre>
					</li>
				</ul>
			</li>
			<li>Calculate the Height of the Tree<br>
				<ul>
					<li>The height of the tree corresponds to how many levels we need to reach the base case \(F(0)\) or \(F(1)\).</li>
					<li>The maximum height for Fibonacci \(F(n)\) is \(n\) because we keep decrementing \(n\) until it reaches \(0\) or \(1\).</li>
				</ul>
			</li>
			<li>Count the Number of Nodes at Each Level<br>
				<ul>
					<li><b>Level 0</b>: 1 node (the root node, \(F(n)\))</li>
					<li><b>Level 1</b>: 2 nodes (\(F(n−1)\), \(F(n−2)\))</li>
					<li><b>Level 2</b>: 4 nodes (\(F(n−2)\), \(F(n−3)\), \(F(n−3)\), \(F(n−4)\))</li>
					<li><b>Level 3</b>: 8 nodes (\(F(n−3)\), \(F(n−4)\), \(F(n−4)\), \(F(n−5)\), \(F(n−4)\), \(F(n−5)\), \(F(n−5)\), \(F(n−6)\))</li>
					<li><b>Level k</b>: The number of nodes at level \(k\) is approximately \(2^{k}\)</li>
				</ul>
			</li>
			<li>Calculate Total Work at Each Level<br>
				<ul>
					<li><b>Level 0</b>: \(1 \times O(1) = O(1)\)</li>
					<li><b>Level 1</b>: \(2 \times O(1) = O(2)\)</li>
					<li><b>Level 2</b>: \(4 \times O(1) = O(4)\)</li>
					<li><b>Level 3</b>: \(8 \times O(1) = O(8)\)</li>
					<li><b>Level k</b>: \(2^{k} \times O(1) = O(2^{k})\)</li>
				</ul>
			</li>
			<li>The total work done can be calculated by summing the work done at each level of the tree until we reach the maximum height \(n\):<br>
				\[ T(n) = O(1) + O(2) + O(4) + O(8) + ... + O(2n) \]
				
				This series can be simplified using the formula for the sum of a geometric series. The sum of a geometric series where the first term is \(a\) and the common ratio is \(r\) is given by:<br>
				
				\[ S = a\frac{(r^{n}-1)}{r-1} \]
				
				Calculating the series gives:<br>
				
				\[ T(n) = O(2^{n+1}-1) = O(2^n) \]
			</li>
		</ol>
		
        <h5 class="post-subtitle">Linearithmic Time Complexity</h5>

        <p>Linearithmic time complexity is a common complexity class for algorithms that are more efficient than quadratic time complexity but less efficient than linear time complexity. This complexity typically arises in divide-and-conquer algorithms, where a problem is divided into smaller subproblems that are solved independently and then combined.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

void fft(double* xRe, double* xIm, int n) {
    if (n &lt;= 1) return;

    // Divide
    double* evenRe = malloc(n / 2 * sizeof(double));
    double* evenIm = malloc(n / 2 * sizeof(double));
    double* oddRe = malloc(n / 2 * sizeof(double));
    double* oddIm = malloc(n / 2 * sizeof(double));

    for (int i = 0; i &lt; n / 2; i++) {
        evenRe[i] = xRe[i * 2];
        evenIm[i] = xIm[i * 2];
        oddRe[i] = xRe[i * 2 + 1];
        oddIm[i] = xIm[i * 2 + 1];
    }

    // Conquer
    fft(evenRe, evenIm, n / 2);
    fft(oddRe, oddIm, n / 2);

    // Combine
    for (int k = 0; k &lt; n / 2; k++) {
        double tRe = cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k];
        double tIm = sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k];

        xRe[k] = evenRe[k] + tRe;
        xIm[k] = evenIm[k] + tIm;
        xRe[k + n / 2] = evenRe[k] - tRe;
        xIm[k + n / 2] = evenIm[k] - tIm;
    }

    free(evenRe);
    free(evenIm);
    free(oddRe);
    free(oddIm);
}

int main() {
    // Example input
    int n = 8; // Size of input (must be a power of 2)
    double xRe[] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0}; // Real part
    double xIm[] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; // Imaginary part

    // Perform FFT
    fft(xRe, xIm, n);

    // Print the results
    printf("FFT Results:\n");
    for (int i = 0; i &lt; n; i++) {
        printf("x[%d] = %.2f + %.2fi\n", i, xRe[i], xIm[i]);
    }

    return 0;
}</code></pre>
        
        <p>The size of the input \(n\) is required to be a power of \(2\). This allows the algorithm to recursively divide the input into two halves until it reaches a single element.</p>

        <p>The recursive nature of the Fast Fourier Transform (FFT) algorithm leads to the division of the input array in half at each recursive step. This process creates a series where each subsequent level of recursion processes half the elements of the previous level.</p>

        <p>Breakdown of Recursive Division:</p>

        <ul>
            <li>Level \(0\) (Initial Input of Size \(n\)):<br>
                <ul>
                    <li>This is the first level, where the input array of size \(n\) is processed.</li>
                    <li>The array is split into two subarrays, each of size \(\frac{n}{2}\).</li>
                    <li>The total work done at this level is to process all \(n\) elements (dividing them into even and odd parts), but no recursive calls have been made yet.</li>
                </ul>   
            </li>
            <li>Level \(1\) (Subarrays of Size \(\frac{n}{2}\)):<br>
                <ul>
                    <li>After splitting the array into two subarrays, each of size \(\frac{n}{2}\), we recursively process both subarrays.</li>
                    <li>There are two subarrays, each with \(\frac{n}{2}\) elements.</li>
                    <li>The total work done at this level is:<br>
                        \[ \frac{n}{2} + \frac{n}{2} = n \]
                    </li>
                    <li>Even though each subarray is smaller, we still process a total of \(n\) elements.</li>
                </ul>   
            </li>
            <li>Level \(2\) (Subarrays of Size \(\frac{n}{4}\)):<br>
                <ul>
                    <li>Each of the \(\frac{n}{2}\)-sized subarrays is split further into two subarrays of size \(\frac{n}{4}\), making a total of four subarrays.</li>
                    <li>Each subarray has \(\frac{n}{4}\) elements.</li>
                    <li>The total work done at this level is:<br>
                        \[ \frac{n}{4} + \frac{n}{4} + \frac{n}{4} + \frac{n}{4} = n \]
                    </li>   
                    <li>Again, we process \(n\) elements in total.</li>
                </ul>
            </li>
            <li>Level \(3\) (Subarrays of Size \(\frac{n}{8}\)):<br>
                <ul>
                    <li>Each of the \(\frac{n}{4}\)-sized subarrays is split further into two subarrays of size \(\frac{n}{8}\), making a total of eight subarrays.</li>
                    <li>Each subarray has \(\frac{n}{8}\) elements.</li>
                    <li>The total work done at this level is:<br>
                        \[ \frac{n}{8} + \frac{n}{8} + \frac{n}{8} + \frac{n}{8} + ... + \frac{n}{8} = n \]
                    </li>   
                    <li>The total work at this level is still \(n\).</li>
                </ul>
            </li>
            <li>Level \(k\) (Subarrays of Size \(\frac{n}{2^{k}}\)):<br>
                <ul>
                    <li>At each level, the array is split into more subarrays, but the total number of elements processed at that level always remains \(n\).</li>
                    <li>At level \(k\), there are \(2^k\) subarrays, each of size \(\frac{n}{2^k}\).</li>
                    <li>The total work at level \(k\) is:<br>
                        \[ 2^k \times \frac{n}{2^k} = n \]
                    </li>
                </ul>
            </li>
        </ul>

        <p>The total number of levels in the recursion is \(\log_{2}(n)\), since the input size is divided by \(2\) at each level. At each level, the work done is \(n\), and there are \(\log_{2}(n)\) levels. Therefore, the total work done by the algorithm is:</p>

        \[ n \times \log_{2}(n) \]

        <p>Let's break down the operations inside the <code>fft</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>Level \(0\) (function call with size \(n\)):<br>
                <ul>
                    <li>The comparison <code>n &lt;= 1</code> takes \(1\) unit of time</li>
                    <li>The initialization <code>int i = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(\frac{n}{2}\) times, and each iteration involves:<br> 
                        <ul>
                            <li>The comparison <code>i &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{2} + 1\) times (including the last comparison when \(i = \frac{n}{2}\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>evenRe[i] = xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>evenIm[i] = xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>oddRe[i] = xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>oddIm[i] = xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                        </ul>
                    </li>
					<li>The initialization <code>int k = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(\frac{n}{2}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>k &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{2} + 1\) times (including the last comparison when \(k = \frac{n}{2}\)).</li>
                            <li>The increment <code>k++</code> takes \(1\) unit of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The substraction <code>cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>double tRe = cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The addition <code>sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>double tIm = sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The addition <code>evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>xRe[k] = evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The addition <code>evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>xIm[k] = evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The substraction <code>evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>xRe[k + n / 2] = evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The substraction <code>evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{2}\) times.</li>
                            <li>The assigment <code>xIm[k + n / 2] = evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{2}\) times.</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level \(1\) (There are \(2\) recursive calls with size \(\frac{n}{2}\)):<br>
                <ul>
                    <li>In each of recursive calls, the comparison <code>n &lt;= 1</code> takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the initialization <code>int i = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the for loop runs \(\frac{n}{4}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>i &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{4} + 1\) times (including the last comparison when \(i = \frac{n}{4}\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>evenRe[i] = xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>evenIm[i] = xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>oddRe[i] = xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>oddIm[i] = xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                        </ul>
                    </li>
					<li>In each of recursive calls, the initialization <code>int k = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the for loop runs \(\frac{n}{4}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>k &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{4} + 1\) times (including the last comparison when \(k = \frac{n}{4}\)).</li>
                            <li>The increment <code>k++</code> takes \(1\) unit of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The substraction <code>cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>double tRe = cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The addition <code>sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>double tIm = sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The addition <code>evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>xRe[k] = evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The addition <code>evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>xIm[k] = evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The substraction <code>evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>xRe[k + n / 2] = evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The substraction <code>evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{4}\) times.</li>
                            <li>The assigment <code>xIm[k + n / 2] = evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{4}\) times.</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level \(2\) (There are \(4\) recursive calls with size \(\frac{n}{4}\)):<br>
                <ul>
                    <li>In each of recursive calls, the comparison <code>n &lt;= 1</code> takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the initialization <code>int i = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the for loop runs \(\frac{n}{8}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>i &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{8} + 1\) times (including the last comparison when \(i = \frac{n}{8}\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>evenRe[i] = xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>evenIm[i] = xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>oddRe[i] = xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>oddIm[i] = xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                        </ul>
                    </li>
					<li>In each of recursive calls, the initialization <code>int k = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the for loop runs \(\frac{n}{8}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>k &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{8} + 1\) times (including the last comparison when \(k = \frac{n}{8}\)).</li>
                            <li>The increment <code>k++</code> takes \(1\) unit of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The substraction <code>cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>double tRe = cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The addition <code>sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>double tIm = sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The addition <code>evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>xRe[k] = evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The addition <code>evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>xIm[k] = evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The substraction <code>evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>xRe[k + n / 2] = evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The substraction <code>evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{8}\) times.</li>
                            <li>The assigment <code>xIm[k + n / 2] = evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{8}\) times.</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level \(k\) (There are \(2^{k}\) recursive calls with size \(\frac{n}{2^{k}}\)):<br>
                <ul>
                    <li>In each of recursive calls, the comparison <code>n &lt;= 1</code> takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the initialization <code>int i = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the for loop runs \(\frac{n}{2^{k+1}}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>i &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{2^{k+1}} + 1\) times (including the last comparison when \(i = \frac{n}{2^{k+1}}\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>evenRe[i] = xRe[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The multiplication <code>i * 2</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>evenIm[i] = xIm[i * 2]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>oddRe[i] = xRe[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The multiplication and addition <code>i * 2 + 1</code> take \(2\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>oddIm[i] = xIm[i * 2 + 1]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                        </ul>
                    </li>
					<li>In each of recursive calls, the initialization <code>int k = 0</code> in the for loop takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the for loop runs \(\frac{n}{2^{k+1}}\) times, and each iteration involves:<br>
                        <ul>
                            <li>The comparison <code>k &lt; n / 2</code> takes \(1\) unit of time, repeated \(\frac{n}{2^{k+1}} + 1\) times (including the last comparison when \(k = \frac{n}{2^{k+1}}\)).</li>
                            <li>The increment <code>k++</code> takes \(1\) unit of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The substraction <code>cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>double tRe = cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The sin function <code>sin(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The multiplication <code>sin(-2 * M_PI * k / n) * oddRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The multiplication and division <code>-2 * M_PI * k / n</code> take \(3\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The cos function <code>cos(-2 * M_PI * k / n)</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The array access <code>oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The multiplication <code>cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The addition <code>sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>double tIm = sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The addition <code>evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>xRe[k] = evenRe[k] + tRe</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The addition <code>evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>xIm[k] = evenIm[k] + tIm</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The array access <code>evenRe[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The substraction <code>evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>xRe[k + n / 2] = evenRe[k] - tRe</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>

                            <li>The array access <code>evenIm[k]</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The substraction <code>evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The division and addition <code>k + n / 2</code> take \(2\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                            <li>The assigment <code>xIm[k + n / 2] = evenIm[k] - tIm</code> take \(1\) units of time, repeated \(\frac{n}{2^{k+1}}\) times.</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level final (There are \(2^{\log_{2}(n)}\) recursive calls with size \(\frac{n}{2^{\log_{2}(n)}}\) or \(1\)):<br>
                <ul>
                    <li>In each of recursive calls, the comparison <code>n &lt;= 1</code> takes \(1\) unit of time</li>
                    <li>In each of recursive calls, the return statement <code>return</code> takes \(1\) unit of time</li>
                </ul>
            </li>
        </ul>
		
		<p>Thus, the total number of operations is:</p>
		
		<ul>
			<li>The comparison <code>n &lt;= 1</code> takes \(2^{0} + 2^{1} + 2^{2} + ... + 2^{\log_{2}(n)} = 2^{\log_{2}(n) + 1} - 1\) units of time.</li>
			<li>The return statement <code>return</code> takes \(2^{\log_{2}(n)}\) unit of time.</li>
			<li>The initialization <code>int i = 0</code> in the first for loop takes \(2^{0} + 2^{1} + 2^{2} + ... + 2^{\log_{2}(n)-1} = 2^{\log_{2}(n)} - 1\) units of time.</li>
			<li>The first for loop takes \(\frac{n}{2} \times \log(n) \times 16\) units of time.</li>
			<li>The initialization <code>int k = 0</code> in the second for loop takes \(2^{0} + 2^{1} + 2^{2} + ... + 2^{\log_{2}(n)-1} = 2^{\log_{2}(n)} - 1\) units of time.</li>
			<li>The second for loop takes \(\frac{n}{2} \times \log(n) \times 46\) units of time.</li>
		</ul>
		
        <p>Totally it takes \(31n \log(n) + 4n - 3\) units of time to complete its execution and it is Linearithmic Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases linearithmically.</p>

        <h5 class="post-subtitle">Factorial Time Complexity</h5>

        <p>Factorial time complexity describes algorithms whose running time grows factorially with the size of the input \(n\). This complexity arises in scenarios where the algorithm generates all possible arrangements (permutations) or combinations of \(n\) items.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Function to generate permutations recursively and store them in a 2D array
void generatePermutations(int *digits, int start, int n, int **permutations, int *index) {
    if (start == n - 1) {
        // Store the current permutation in the 2D array
        for (int i = 0; i &lt; n; i++) {
            permutations[*index][i] = digits[i];
        }
        (*index)++;  // Move to the next row
        return;
    } else {
        for (int i = start; i &lt; n; i++) {
            // Swap the current element with the start
            swap(&digits[start], &digits[i]);

            // Recursively generate permutations for the remaining elements
            generatePermutations(digits, start + 1, n, permutations, index);

            // Backtrack: restore the original order
            swap(&digits[start], &digits[i]);
        }
    }
}

int main() {
    // Try to crack a lock with 3 dials
    printf("Cracking the lock with 3 dials:\n");
    // Calculate the total number of permutations (n!)
    int num_permutations = 1;
    for (int i = 1; i &lt;= n; i++) {
        num_permutations *= i;
    }

    // Allocate memory for the 2D array to store the permutations
    int **permutations = malloc(num_permutations * sizeof(int *));
    for (int i = 0; i &lt; num_permutations; i++) {
        permutations[i] = malloc(n * sizeof(int));
    }

    // Initialize the array with digits [0, 1, 2, ..., n-1]
    int digits[n];
    for (int i = 0; i &lt; n; i++) {
        digits[i] = i;
    }

    // Initialize the index to track the current permutation
    int index = 0;

    // Generate all permutations and store them in the 2D array
    generatePermutations(digits, 0, n, permutations, &index);

    // Print the stored permutations
    printf("All generated permutations:\n");
    for (int i = 0; i &lt; num_permutations; i++) {
        printf("Permutation %d: ", i + 1);
        for (int j = 0; j &lt; n; j++) {
            printf("%d ", permutations[i][j]);
        }
        printf("\n");
    }

    // Free the allocated memory
    for (int i = 0; i &lt; num_permutations; i++) {
        free(permutations[i]);
    }
    free(permutations);

    return 0;
}</code></pre>
        
		<p>Consider the array <code>digits[] = {0, 1, 2, 3}</code> with \(n = 4\). The detailed Steps with \(n = 4\):</p>
		
		<ul>
			<li>Initial Call <code>generatePermutations(digits, 0, 4, permutations, index)</code></li>
			<li>There is no swap since <code>i == start</code></li>
			<li><code>start = 0</code> and the current permutation is not stored since <code>start != n - 1</code>.</li>
			<li>The loop runs from <code>i = 0</code> to <code>i = 4</code>.</li>
			<li>For <code>i = 0</code>:<br>
				<ul>
					<li>There is no swap since <code>i == start</code></li>
					<li>Recursively call <code>generatePermutations(digits, 1, 4, permutations, index)</code></li>
					<li><code>start = 1</code> and the current permutation is not stored since <code>start != n - 1</code></li>
					<li>The loop runs from <code>i = 1</code> to <code>i = 4</code>.</li>
					<li>For <code>i = 1</code>:<br>
						<ul>
							<li>There is no swap since <code>i == start</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{0, 1, 2, 3}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 1, 3, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{0, 1, 3, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 1, 2, 3}</code></li>
								</ul>
							</li>
							<li>There is no swap since <code>i == start</code></li>
						</ul>
					</li>
					<li>For <code>i = 2</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {0, 2, 1, 3}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{0, 2, 1, 3}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 1, 3, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{0, 1, 3, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 1, 2, 3}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {0, 1, 2, 3}</code></li>
						</ul>
					</li>
					<li>For <code>i = 3</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 3, 2, 1}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{0, 3, 2, 1}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 3, 1, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{0, 3, 1, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 3, 2, 1}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 1, 2, 3}</code></li>
						</ul>
					</li>
					<li>There is no swap since <code>i == start</code></li>
				</ul>
			</li>
			<li>For <code>i = 1</code>:<br>
				<ul>
					<li>Swap <code>digits[0]</code> with <code>digits[1]</code>, thus <code>digits[] = {1, 0, 2, 3}</code></li>
					<li>Recursively call <code>generatePermutations(digits, 1, 4, permutations, index)</code></li>
					<li><code>start = 1</code> and the current permutation is not stored since <code>start != n - 1</code></li>
					<li>The loop runs from <code>i = 1</code> to <code>i = 4</code>.</li>
					<li>For <code>i = 1</code>:<br>
						<ul>
							<li>There is no swap since <code>i == start</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{1, 0, 2, 3}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 0, 3, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{1, 0, 3, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 0, 2, 3}</code></li>
								</ul>
							</li>
							<li>There is no swap since <code>i == start</code></li>
						</ul>
					</li>
					<li>For <code>i = 2</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {1, 2, 0, 3}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{1, 2, 0, 3}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>	
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 2, 3, 0}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{1, 2, 3, 0}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 2, 0, 3}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {1, 0, 2, 3}</code></li>
						</ul>
					</li>
					<li>For <code>i = 3</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 3, 2, 0}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{1, 3, 2, 0}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 3, 0, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{1, 3, 0, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 3, 2, 0}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {1, 0, 2, 3}</code></li>
						</ul>
					</li>
					<li>There is no swap since <code>i == start</code></li>
				</ul>
			</li>
			
			<li>For <code>i = 2</code>:<br>
				<ul>
					<li>Swap <code>digits[0]</code> with <code>digits[2]</code>, thus <code>digits[] = {2, 1, 0, 3}</code></li>
					<li>Recursively call <code>generatePermutations(digits, 1, 4, permutations, index)</code></li>
					<li><code>start = 1</code> and the current permutation is not stored since <code>start != n - 1</code></li>
					<li>The loop runs from <code>i = 1</code> to <code>i = 4</code>.</li>
					<li>For <code>i = 1</code>:<br>
						<ul>
							<li>There is no swap since <code>i == start</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{2, 1, 0, 3}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 1, 3, 0}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{2, 1, 3, 0}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 1, 0, 3}</code></li>
								</ul>
							</li>
							<li>There is no swap since <code>i == start</code></li>
						</ul>
					</li>
					<li>For <code>i = 2</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {2, 0, 1, 3}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{2, 0, 1, 3}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 0, 3, 1}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{2, 0, 3, 1}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 0, 1, 3}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {2, 1, 0, 3}</code></li>
						</ul>
					</li>
					<li>For <code>i = 3</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 3, 0, 1}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{2, 3, 0, 1}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 3, 1, 0}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{2, 3, 1, 0}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 3, 0, 1}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {2, 1, 0, 3}</code></li>
						</ul>
					</li>
					<li>Swap back <code>digits[0]</code> with <code>digits[2]</code>, thus <code>digits[] = {0, 1, 2, 3}</code></li>
				</ul>
			</li>			
			<li>For <code>i = 3</code>:<br>
				<ul>
					<li>Swap <code>digits[0]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 1, 2, 0}</code></li>
					<li>Recursively call <code>generatePermutations(digits, 1, 4, permutations, index)</code></li>
					<li><code>start = 1</code> and the current permutation is not stored since <code>start != n - 1</code></li>
					<li>The loop runs from <code>i = 1</code> to <code>i = 4</code>.</li>
					<li>For <code>i = 1</code>:<br>
						<ul>
							<li>There is no swap since <code>i == start</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{3, 1, 2, 0}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 1, 0, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{3, 1, 0, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 1, 2, 0}</code></li>
								</ul>
							</li>
							<li>There is no swap since <code>i == start</code></li>
						</ul>
					</li>
					<li>For <code>i = 2</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {3, 2, 1, 0}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{3, 2, 1, 0}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 2, 0, 1}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{3, 2, 0, 1}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 2, 1, 0}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[2]</code>, thus <code>digits[] = {3, 1, 2, 0}</code></li>
						</ul>
					</li>
					<li>For <code>i = 3</code>:<br>
						<ul>
							<li>Swap <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 0, 2, 1}</code></li>
							<li>Recursively call <code>generatePermutations(digits, 2, 4, permutations, index)</code></li>
							<li><code>start = 2</code> and the current permutation is not stored since <code>start != n - 1</code></li>
							<li>The loop runs from <code>i = 2</code> to <code>i = 4</code>.</li>
							<li>For <code>i = 2</code>:<br>
								<ul>
									<li>There is no swap since <code>i == start</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{3, 0, 2, 1}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>There is no swap since <code>i == start</code></li>
								</ul>
							</li>
							<li>For <code>i = 3</code>:<br>
								<ul>
									<li>Swap <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 0, 1, 2}</code></li>
									<li>Recursively call <code>generatePermutations(digits, 3, 4, permutations, index)</code></li>
									<li><code>start = 3</code> and the current permutation <code>{3, 0, 1, 2}</code> is stored since <code>start == n - 1</code></li>
									<li>Increment index and return to the previous call.</li>
									<li>Swap back <code>digits[2]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 0, 2, 1}</code></li>
								</ul>
							</li>
							<li>Swap back <code>digits[1]</code> with <code>digits[3]</code>, thus <code>digits[] = {3, 1, 2, 0}</code></li>
						</ul>
					</li>
					<li>Swap back <code>digits[0]</code> with <code>digits[3]</code>, thus <code>digits[] = {0, 1, 2, 3}</code></li>
				</ul>
			</li>
			<li>There is no swap since <code>i == start</code></li>
		</ul>
		
		<p>Let's break down the operations inside the <code>generatePermutations</code> function above and calculate the total time complexity:</p>
		
        <ul>
            <li>Level \(0\) (initial call):<br>
                <ul>
                    <li>The comparison <code>start == n - 1</code> takes \(1\) unit of time</li>
                    <li>The initialization <code>int i = 0</code> in the second for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(n\) times, and each iteration involves:<br> 
                        <ul>
							<li>The comparison <code>i &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(i = n\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n\) times.</li>
                            <li>The swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n\) times</li>
                            <li>The second swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n\) times</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level \(1\) (There are \(n\) recursive calls):<br>
                <ul>
                    <li>The comparison <code>start == n - 1</code> takes \(1\) unit of time</li>
                    <li>The initialization <code>int i = 0</code> in the second for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(n-1\) times, and each iteration involves:<br> 
                        <ul>
                            <li>The comparison <code>i &lt; n</code> takes \(1\) unit of time, repeated \(n - 1 + 1\) times (including the last comparison when \(i = n-1\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n - 1\) times.</li>
                            <li>The swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n - 1\) times</li>
                            <li>The second swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n - 1\) times</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level \(2\) (There are \(n \cdot (n-1)\) recursive calls):<br>
                <ul>
                    <li>The comparison <code>start == n - 1</code> takes \(1\) unit of time</li>
                    <li>The initialization <code>int i = 0</code> in the second for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(n-2\) times, and each iteration involves:<br> 
                        <ul>
                            <li>The comparison <code>i &lt; n</code> takes \(1\) unit of time, repeated \(n - 2 + 1\) times (including the last comparison when \(i = n-2\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n - 2\) times.</li>
                            <li>The swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n - 2\) times</li>
                            <li>The second swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n - 2\) times</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level \(k\) (There are \(n \cdot (n-1) \cdot ... \cdot (n-k+1)\) recursive calls):<br>
                <ul>
                    <li>The comparison <code>start == n - 1</code> takes \(1\) unit of time</li>
                    <li>The initialization <code>int i = 0</code> in the second for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(n-k\) times, and each iteration involves:<br> 
                        <ul>
							<li>The comparison <code>i &lt; n</code> takes \(1\) unit of time, repeated \(n - k + 1\) times (including the last comparison when \(i = n-k\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n - k\) times.</li>
                            <li>The swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n - k\) times.</li>
                            <li>The second swap function <code>swap(&digits[start], &digits[i])</code> takes \(5\) unit of time, repeated \(n - k\) times.</li>
                        </ul>
                    </li>
                </ul>
            </li>

            <li>Level final (There is \(n \cdot (n-1) \cdot ... \cdot (n-k+1) \cdot 1\) recursive call):<br>
                <ul>
                    <li>The comparison <code>start == n - 1</code> takes \(1\) unit of time</li>
                    <li>The initialization <code>int i = 0</code> in the first for loop takes \(1\) unit of time</li>
                    <li>The for loop runs \(n\) times, and each iteration involves:<br> 
                        <ul>
							<li>The comparison <code>k &lt; n</code> takes \(1\) unit of time, repeated \(n + 1\) times (including the last comparison when \(i = n\)).</li>
                            <li>The increment <code>i++</code> takes \(1\) unit of time, repeated \(n\) times.</li>
							<li>The array access <code>digits[i]</code> takes \(1\) unit of time, repeated \(n\) times.</li>
                            <li>The assignment function <code>permutations[*index][i] = digits[i]</code> takes \(1\) unit of time, repeated \(n\) times.</li>
                        </ul>
                    </li>
					<li>The increment <code>(*index)++</code> takes \(1\) unit of time</li>
					<li>The return statement <code>return</code> takes \(1\) unit of time</li>
                </ul>
            </li>
        </ul>
		
		<p>Thus, the total number of operations is:</p>
		
		<ul>
			<li>The comparison <code>start == n - 1</code> takes \(n + n \cdot (n-1) + n \cdot (n-1) \cdot (n-2) + ... + n! + 1\) units of time.</li>
			<li>The initialization <code>int i = 0</code> in the first for loop takes \(n + n \cdot (n-1) + n \cdot (n-1) \cdot (n-2) + ... + n \cdot (n-1) \cdot (n-2) \cdot ... \cdot (n-k+1) \cdot 2 + 1\) unit of time</li>
			<li>The first for loop takes \(n! \times (4n + 1)\) units of time.</li>
			<li>The increment <code>(*index)++</code> takes \(n!\) units of time</li>
			<li>The return statement <code>return</code> takes \(n!\) units of time</li>
			<li>The second for loop takes \((12 \cdot n + 1) + (12 \cdot n \cdot (n-1) + 1) + (12 \cdot n \cdot (n-1) \cdot (n-2) + 1) + ... + (12 \cdot n \cdot (n-1) \cdot (n-2) \cdot ... \cdot (n-k+1) + 1)\) units of time.</li>
		</ul>
		
        <p>Totally it takes \(15 \cdot n + 14 \cdot n \cdot (n-1) + 14 \cdot n \cdot (n-1) \cdot (n-2) + ... + 14 \cdot n \cdot (n-1) \cdot (n-2) \cdot ... \cdot (n-k+1) \cdot 2 + (4n + 4) \cdot n! + 1\) units of time to complete its execution and it is Factorial Time Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the time required also increases factorially.</p>

        <h4 class="post-subtitle">Space Complexity</h4>

        <p>Space complexity measures the total amount of memory space required by an algorithm to execute, including both the space needed for the input data and any auxiliary space needed for computations.</p>

        <p>When a program is executing, it utilizes memory primarily for these three reasons:</p>

        <ol>
            <li><b>Instruction Space</b>: To store the compiled code of the program, which includes all the instructions the CPU will execute.</li>
            <li><b>Environmental Stack</b>: To manage function calls and local variables. This includes information about active functions, their parameters, and where to return after a function execution.</li>
            <li><b>Data Space</b>: To hold all the variables, constants, and data structures that the program uses during its execution.</li>
        </ol>

        <p>When analyzing an algorithm's space complexity, we typically focus on the data space, which includes the memory required for variables, constants, data structures, and any additional memory needed during the execution of the algorithm. Instruction space (the code itself) and environmental stack (such as function call stacks) are generally not included in this analysis. This helps in understanding how much memory an algorithm will require as the input size increases.</p>

        <p>To calculate the space complexity, we must know the memory required to store different datatype values (according to the compiler).</p>

        <p>In C, the memory required for different data types can vary based on the compiler and the architecture, but here are some common sizes:</p>

        <ol>
            <li><code>char</code>: Typically \(1\) byte (8 bits).</li>
            <li><code>int</code>: Usually \(4\) bytes (32 bits) on most platforms, but can be 2 bytes (16 bits) on older systems.</li>
            <li><code>float</code>: Generally \(4\) bytes (32 bits).</li>
            <li><code>double</code>: Usually \(8\) bytes (64 bits).</li>
            <li><code>long</code>: Typically \(4\) bytes (32 bits) on 32-bit systems and \(8\) bytes (64 bits) on 64-bit systems.</li>
            <li><code>long long</code>: Generally \(8\) bytes (64 bits).</li>
			<li>memory address: Generally \(8\) bytes (64 bits) for a 64-bit computer machine or \(4\) bytes for 32-bit computer machine.</li>
        </ol>

        <h5 class="post-subtitle">Constant Space Complexity</h5>

        <p>Constant space complexity refers to an algorithm that requires a fixed amount of memory space regardless of the input size. In other words, the memory needed does not increase as the size of the input grows.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int sum(int a, int b)
{
   return a + b;
}</code></pre>

        <p>Let's break down the operations inside the sum function above and calculate the total space complexity:</p>

        <ul>
            <li>The first parameter <code>a</code> requires \(4\) bytes.</li>
            <li>The second parameter <code>b</code> requires \(4\) bytes.</li>
            <li>The return value requires another \(4\) bytes.</li>
        </ul>
        
        <p>Totally it requires \(12\) bytes of memory to complete its execution and it is Constant Space Complexity. It does not change based on the input values of <code>a</code> and <code>b</code>. That means for all input values, it requires the same amount of memory i.e. \(12\) bytes.</p>


        <h5 class="post-subtitle">Linear Space Complexity</h5>

        <p>Linear space complexity refers to an algorithm where the amount of memory required grows linearly with the size of the input. In other words, if the input size doubles, the memory usage also roughly doubles.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int sum(int arr[], int n)
{
    int sum = 0;
    for(int i = 0; i &lt; n; i++)
        sum = sum + arr[i];
    return sum;
}</code></pre>

        <p>Let's break down the operations inside the sum function above and calculate the total space complexity:</p>

        <ul>
            <li>The first parameter <code>int arr[]</code> requires \(n \cdot 4\) bytes.</li>
            <li>The second parameter <code>int n</code> requires \(4\) bytes.</li>
            <li>The local variable <code>int sum</code> requires \(4\) bytes.</li>
            <li>The local variable <code>int i</code> within the for loop requires \(4\) bytes.</li>
            <li>The return value requires another \(4\) bytes.</li>
        </ul>
        
        <p>Totally it requires \(4n + 16\) bytes of memory to complete its execution and it is Linear Space Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the memory required also increases linearly.</p>


        <h5 class="post-subtitle">Logarithmic Space Complexity</h5>

        <p>Logarithmic space complexity refers to algorithms where the amount of memory used grows logarithmically with the size of the input. This means that the space required increases very slowly as the input size grows, typically as the logarithm of the input size in some base (commonly base \(2\)).</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;

// Function to compute GCD using recursion
int gcd(int a, int b) {
    if (b == 0) // Base case: GCD(a, 0) = a
        return a;
    return gcd(b, a % b); // Recursive call
}

int main() {
    int a, b;
    
    // Input two integers
    printf("Enter two integers: ");
    scanf("%d %d", &a, &b);
    
    // Calculate GCD
    int result = gcd(a, b);
    
    // Display the result
    printf("GCD of %d and %d is %d\n", a, b, result);
    
    return 0; // Exit program
}</code></pre>
        
        <p>Let's break down the operations inside the <code>gcd</code> function above and calculate the total space complexity:</p>

        <ul>
            <li>The first parameter <code>int a</code> requires \(4\) bytes.</li>
			<li>The second parameter <code>int b</code> requires \(4\) bytes.</li>
			<li>The return value <code>return a</code> requires another \(4\) bytes.</li>
            <li>The return address <code>return gcd(b, a % b)</code> requires \(8\) bytes.</li>
        </ul>
		
		<p>So, each recursive call adds \(4 + 4 + 4 + 8 = 20\) bytes. The number of recursive calls is \(\log(min(a, b))\). Therefore, the total space complexity is \(20 \cdot \log(min(a, b))\).</p>
		
		<p>Totally it requires \(20 \cdot \log(min(a, b))\) bytes of memory to complete its execution and it is Logarithmic Space Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the memory required also increases logarithmically.</p>
		
        <h5 class="post-subtitle">Quadratic Space Complexity</h5>
		
        <p>Quadratic space complexity refers to an algorithm or process where the amount of memory (or storage) required grows quadratically with respect to the size of the input.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">void fillSquareMatrix(int** matrix, int n) {
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            matrix[i][j] = i + j;
        }
    }
}</code></pre>
        
        <p>Let's break down the operations inside the fillSquareMatrix function above and calculate the total time complexity:</p>

        <ul>
            <li>The first parameter <code>int** matrix</code> requires \(8 \times n\) bytes for the pointer and \(4 \cdot n^{2}\) bytes for the array of integers.</li>
			<li>The second parameter <code>int n</code> requires \(4\) bytes.</li>
			<li>The local variable <code>int i</code> requires another \(4\) bytes.</li>
			<li>The local variable <code>int j</code> requires another \(4\) bytes.</li>
        </ul>
		
		<p>Totally it requires \(4n^{2} + 8n + 12\) bytes of memory to complete its execution and it is Quadratic Space Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the memory required also increases quadratically.</p>
		
        <h5 class="post-subtitle">Cubic Space Complexity</h5>
		
		<p>Cubic space complexity refers to an algorithm or process where the amount of memory (or storage) required grows cubically with respect to the size of the input.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">void fillCubeMatrix(int*** matrix, int n) {

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            for (int k = 0; k &lt; n; k++) {
                matrix[i][j][k] = i + j + k;
            }
        }
    }
}</code></pre>
        
        <p>Let's break down the operations inside the <code>fillCubeMatrix</code> function above and calculate the total time complexity:</p>

        <ul>
            <li>The first parameter <code>int*** matrix</code> requires \(8 \times n^{2}\) bytes for the pointer and \(4 \cdot n^{3}\) bytes for the array of integers.</li>
			<li>The second parameter <code>int n</code> requires \(4\) bytes.</li>
			<li>The local variable <code>int i</code> requires another \(4\) bytes.</li>
			<li>The local variable <code>int j</code> requires another \(4\) bytes.</li>
			<li>The local variable <code>int k</code> requires another \(4\) bytes.</li>
        </ul>

        <p>Totally it takes \(4n^{3} + 8n^{2} + 16\) bytes of memory to complete its execution and it is cubic space Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the amount of memory required also increases cubically.</p>

        <h5 class="post-subtitle">Exponential Space Complexity</h5>

        <p>Exponential space complexity refers to an algorithm whose growth rate doubles with each additional input. In exponential space algorithms, the amount of memory (or storage) required grows extremely fast as the size of the input increases.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">int fibonacci(int n) {
    if (n &lt;= 1)
        return n;
    else
        return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>
        
		<p>The total number of function calls can be represented by the recurrence relation:</p>
		
		\[ T(n) = T(n - 1) + T(n - 2) + 1 \]
		
		<p>Where:</p>
		
		<ul>
			<li>\(T(n)\) is the total call count for <code>fibonacci(n)</code></li>
			<li>The \(+1\) accounts for the current call itself</li>
		</ul>
		
        <p>Let's break down the operations inside the fibonacci function above and calculate the total space complexity:</p>

        <ul>
            <li>The parameter <code>int n</code> requires \(4\) bytes.</li>
			<li>The return value <code>return n</code> or <code>return fibonacci(n - 1) + fibonacci(n - 2)</code> requires \(4\) bytes.</li>
			<li>The return address <code>fibonacci(n - 1)</code> requires \(8\) bytes.</li>
			<li>The return address <code>fibonacci(n - 2)</code> requires \(8\) bytes.</li>
        </ul>
		
		<p>So, each recursive call adds \(4 + 4 + 8 + 8 = 24\) bytes. The number of recursive calls is \(T(n)\). Therefore, the total space complexity is \(24 \cdot T(n)\).</p>
		
		<p>Totally it requires \(24 \cdot T(n)\) bytes of memory to complete its execution and it is exponential Space Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the memory required also increases exponentially.</p>
		

        <h5 class="post-subtitle">Linearithmic Space Complexity</h5>

        <p>Linearithmic complexity refers to the amount of space an algorithm requires in terms of both a linear and logarithmic relationship to the size of the input. This means that as the input size grows, the memory usage grows slightly faster than linear but much slower than quadratic or cubic space complexities.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

void fft(double* xRe, double* xIm, int n) {
    if (n &lt;= 1) return;

    // Divide
    double* evenRe = malloc(n / 2 * sizeof(double));
    double* evenIm = malloc(n / 2 * sizeof(double));
    double* oddRe = malloc(n / 2 * sizeof(double));
    double* oddIm = malloc(n / 2 * sizeof(double));

    for (int i = 0; i &lt; n / 2; i++) {
        evenRe[i] = xRe[i * 2];
        evenIm[i] = xIm[i * 2];
        oddRe[i] = xRe[i * 2 + 1];
        oddIm[i] = xIm[i * 2 + 1];
    }

    // Conquer
    fft(evenRe, evenIm, n / 2);
    fft(oddRe, oddIm, n / 2);

    // Combine
    for (int k = 0; k &lt; n / 2; k++) {
        double tRe = cos(-2 * M_PI * k / n) * oddRe[k] - sin(-2 * M_PI * k / n) * oddIm[k];
        double tIm = sin(-2 * M_PI * k / n) * oddRe[k] + cos(-2 * M_PI * k / n) * oddIm[k];

        xRe[k] = evenRe[k] + tRe;
        xIm[k] = evenIm[k] + tIm;
        xRe[k + n / 2] = evenRe[k] - tRe;
        xIm[k + n / 2] = evenIm[k] - tIm;
    }

    free(evenRe);
    free(evenIm);
    free(oddRe);
    free(oddIm);
}

int main() {
    // Example input
    int n = 8; // Size of input (must be a power of 2)
    double xRe[] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0}; // Real part
    double xIm[] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; // Imaginary part

    // Perform FFT
    fft(xRe, xIm, n);

    // Print the results
    printf("FFT Results:\n");
    for (int i = 0; i &lt; n; i++) {
        printf("x[%d] = %.2f + %.2fi\n", i, xRe[i], xIm[i]);
    }

    return 0;
}</code></pre>
        
        <p>Let's break down the operations inside the fft function above and calculate the total space complexity:</p>
		
        <ul>
            <li>The parameter <code>double* xRe</code> requires \(8\) bytes for the pointer and \(8 \times \frac{n}{2^{k}}\) bytes for the array of doubles. For each level of recursion \(k\), the array size is dynamically allocated.</li>
			<li>The parameter <code>double* xIm</code> requires \(8\) bytes for the pointer and \(8 \times \frac{n}{2^{k}}\)bytes for the array of doubles. For each level of recursion \(k\), the array size is dynamically allocated.</li>
			<li>The parameter <code>int n</code> requires \(4\)bytes.</li>
			<li>The local array <code>double* evenRe</code> requires \(8\) bytes for the pointer and \(8 \times \frac{1}{2} \times \frac{n}{2^{k}}\) bytes for the array of doubles. For each level of recursion \(k\), the array size is dynamically allocated.</li>
			<li>The local array <code>double* evenIm</code> requires \(8\) bytes for the pointer and \(8 \times \frac{1}{2} \times \frac{n}{2^{k}}\) bytes for the array of doubles. For each level of recursion \(k\), the array size is dynamically allocated.</li>
			<li>The local array <code>double* oddRe</code> requires \(8\) bytes for the pointer and \(8 \times \frac{1}{2} \times \frac{n}{2^{k}}\) bytes for the array of doubles. For each level of recursion \(k\), the array size is dynamically allocated.</li>
			<li>The local array <code>double* oddIm</code> requires \(8\) bytes for the pointer and \(8 \times \frac{1}{2} \times \frac{n}{2^{k}}\) bytes for the array of doubles. For each level of recursion \(k\), the array size is dynamically allocated.</li>
			<li>The return address <code>fft(evenRe, evenIm, n / 2)</code> requires \(8\) bytes.</li>
			<li>The return address <code>fft(oddRe, oddIm, n / 2)</code> requires \(8\) bytes.</li>
			<li>The local variable <code>double tRe</code> requires \(8\) bytes.</li>
			<li>The local variable <code>double tIm</code> requires \(8\) bytes.</li>
        </ul>
		
		<p>So, each recursive call adds \(8 \times \frac{n}{2^{k}} + 8 + 8 \times \frac{n}{2^{k}} + 8 + 4 \times \frac{n}{2^{k}} + 8 + 4 \times \frac{n}{2^{k}} + 8 + 4 \times \frac{n}{2^{k}} + 8 + 4 \times \frac{n}{2^{k}} + 8 + 8 + 8 + 8 + 8 = \frac{32n}{2^{k}} + 56\) bytes. The total number of recursive calls is \(2^{0} + 2^{1} + 2^{2} + ... + 2^{\log_{2}(n)} = 2^{\log_{2}(n) + 1} - 1\). Therefore, the total space complexity is \(2^{0} \times (\frac{32n}{2^{0}} + 56) + 2^{1} \times (\frac{32n}{2^{1}} + 56) + 2^{2} \times (\frac{32n}{2^{2}} + 56) + ... + 2^{\log_{2}(n)} \times (\frac{32n}{2^{\log_{2}(n)}} + 56) = 32n \log(n) + 108n - 56\).</p>
		
		<p>Totally it requires \(32n \log(n) + 108n - 56\) bytes of memory to complete its execution and it is linearithmic space complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the memory required also increases linearithmically.</p>

        <h5 class="post-subtitle">Factorial Space Complexity</h5>
		
        <p>Factorial space complexity arises in algorithms where the amount of memory used grows factorially with the size of the input. This is typical in problems involving permutations or combinations of a set of elements, where you need to store all possible arrangements or selections.</p>

        <p>Consider the following piece of code</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Function to generate permutations recursively and store them in a 2D array
void generatePermutations(int *digits, int start, int n, int **permutations, int *index) {
    if (start == n - 1) {
        // Store the current permutation in the 2D array
        for (int i = 0; i &lt; n; i++) {
            permutations[*index][i] = digits[i];
        }
        (*index)++;  // Move to the next row
        return;
    } else {
        for (int i = start; i &lt; n; i++) {
            // Swap the current element with the start
            swap(&digits[start], &digits[i]);

            // Recursively generate permutations for the remaining elements
            generatePermutations(digits, start + 1, n, permutations, index);

            // Backtrack: restore the original order
            swap(&digits[start], &digits[i]);
        }
    }
}

int main() {
    // Try to crack a lock with 3 dials
    printf("Cracking the lock with 3 dials:\n");
    // Calculate the total number of permutations (n!)
    int num_permutations = 1;
    for (int i = 1; i &lt;= n; i++) {
        num_permutations *= i;
    }

    // Allocate memory for the 2D array to store the permutations
    int **permutations = malloc(num_permutations * sizeof(int *));
    for (int i = 0; i &lt; num_permutations; i++) {
        permutations[i] = malloc(n * sizeof(int));
    }

    // Initialize the array with digits [0, 1, 2, ..., n-1]
    int digits[n];
    for (int i = 0; i &lt; n; i++) {
        digits[i] = i;
    }

    // Initialize the index to track the current permutation
    int index = 0;

    // Generate all permutations and store them in the 2D array
    generatePermutations(digits, 0, n, permutations, &index);

    // Print the stored permutations
    printf("All generated permutations:\n");
    for (int i = 0; i &lt; num_permutations; i++) {
        printf("Permutation %d: ", i + 1);
        for (int j = 0; j &lt; n; j++) {
            printf("%d ", permutations[i][j]);
        }
        printf("\n");
    }

    // Free the allocated memory
    for (int i = 0; i &lt; num_permutations; i++) {
        free(permutations[i]);
    }
    free(permutations);

    return 0;
}</code></pre>
        
        <p>Let's break down the operations inside the <code>generatePermutations</code> function above and calculate the total space complexity:</p>

        <ul>
            <li>The parameter <code>int *digits</code> requires \(8\) bytes for the pointer and \(4 \times n\) for the array of integers.</li>
			<li>The parameter <code>int start</code> requires \(4\) bytes.</li>
			<li>The parameter <code>int n</code> requires \(4\) bytes.</li>
			<li>The parameter <code>int **permutations</code> requires \(8 \times n!\) bytes for the pointer and \(4 \times n \times n!\) bytes for the array of integers.</li>
			<li>The parameter <code>int *index</code> requires requires \(8\) bytes for the pointer and \(4\) for the array of integers.</li>
			<li>The local variable <code>int i</code> in the first for loop requires \(4\) bytes.</li>
			<li>The local variable <code>int i</code> in the second for loop requires \(4\) bytes.</li>
			<li>The return address <code>swap(&digits[start], &digits[i])</code> requires \(8\) bytes.</li>
			<li>The return address <code>generatePermutations(digits, start + 1, n, permutations, index)</code> requires \(8\) bytes.</li>
			<li>The return address <code>swap(&digits[start], &digits[i])</code> requires \(8\) bytes.</li>
        </ul>
		
		<p>So, each recursive call adds \(8 + 4n + 4 + 4 + 8n! + 4n \cdot n! + 8 + 4 + 4 + 4 + 8 + 8 + 8 = 4n \cdot n!+ 8n! + 4n + 60\) bytes. The number of recursive calls is \(n!\). Therefore, the total space complexity is \(n! \times (4n \cdot n! + 8n! + 4n + 60)\).</p>
		
		<p>Totally it requires \(n! \times (4n \cdot n!+8n!+4n+62)\) bytes of memory to complete its execution and it is factorial Space Complexity. It changes based on the \(n\) value. If we increase the \(n\) value then the memory required also increases factorially.</p>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/algorithm" class="tag">algorithm</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/time-complexity" class="tag">time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/space-complexity" class="tag">space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/constant-time-complexity" class="tag">constant time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/logarithmic-time-complexity" class="tag">logarithmic time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linear-time-complexity" class="tag">linear time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linearithmic-time-complexity" class="tag">linearithmic time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/quadratic-time-complexity" class="tag">quadratic time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/cubic-time-complexity" class="tag">cubic time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/exponential-time-complexity" class="tag">exponential time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/factorial-time-complexity" class="tag">factorial time complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/constant-space-complexity" class="tag">constant space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/logarithmic-space-complexity" class="tag">logarithmic space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linear-space-complexity" class="tag">linear space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linearithmic-space-complexity" class="tag">linearithmic space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/quadratic-space-complexity" class="tag">quadratic space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/cubic-space-complexity" class="tag">cubic space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/exponential-space-complexity" class="tag">exponential space complexity</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/factorial-space-complexity" class="tag">factorial space complexity</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/10/07/time-and-space-complexity-in-algorithm/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/10/07/time-and-space-complexity-in-algorithm/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/10/07/time-and-space-complexity-in-algorithm/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-10" /><category term="day-07" /><category term="algorithm" /><category term="time complexity" /><category term="space complexity" /><category term="constant time complexity" /><category term="logarithmic time complexity" /><category term="linear time complexity" /><category term="linearithmic time complexity" /><category term="quadratic time complexity" /><category term="cubic time complexity" /><category term="exponential time complexity" /><category term="factorial time complexity" /><category term="constant space complexity" /><category term="logarithmic space complexity" /><category term="linear space complexity" /><category term="linearithmic space complexity" /><category term="quadratic space complexity" /><category term="cubic space complexity" /><category term="exponential space complexity" /><category term="factorial space complexity" /><summary type="html"><![CDATA[Time and Space Complexity in Algorithm explores the foundational concepts of time and space complexity in algorithms, providing insight into various complexity classes. This page covers key topics such as constant, logarithmic, linear, linearithmic, quadratic, cubic, exponential, and factorial time complexities, alongside their corresponding space complexities.]]></summary></entry><entry xml:lang="en"><title type="html">Linear Stack Data Structure</title><link href="https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/" rel="alternate" type="text/html" title="Linear Stack Data Structure" /><published>2024-09-26T16:21:00+00:00</published><updated>2024-09-26T16:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure</id><content type="html" xml:base="https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Linear Stack Data Structure</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published September 26, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/linearstack.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
		
		<h3 class="post-subtitle">Linear Stack</h3>
		
        <p>A Stack is a fundamental data structure in computer science that follows the Last In, First Out (LIFO) principle. This means that the last element added to the stack is the first one to be removed. A stack is used in scenarios where you need to manage data in a reverse or nested order, such as function call management in programming, undo/redo features, and expression evaluation.</p>
		
		<p>A stack has several key characteristics that make it unique and useful in various computational scenarios. Here are its main characteristics:</p>

        <ul>
            <li><b>LIFO Principle</b>: Stacks operate based on the Last In, First Out (LIFO) principle, where the most recently added element is the first one to be removed.</li>
            <li><b>Single Access Point</b>: Stacks have a single access point, typically referred to as the top of the stack, where all push and pop operations occur.</li>
            <li><b>Efficient Operations</b>: Push, pop, and peek operations on stacks typically have a time complexity of \(O(1)\), making them efficient for certain applications.</li>
            <li><b>Limited Access</b>: Stacks support limited access to elements. In most cases, only the top element of the stack is accessible for modification or removal.</li>
        </ul>
		
        <p>Suppose we want to store the elements in a stack and let's assume that stack is empty. We have taken the stack of size 3 in which we are pushing the elements one by one until the stack becomes full.</p>

        <p>Since our stack is full as the size of the stack is 3. In the above cases, we can observe that it goes from the top to the bottom when we were entering the new element in the stack. The stack gets filled up from the bottom to the top.</p>
    
        <p>When we perform the delete operation on the stack, there is only one way for entry and exit as the other end is closed. It follows the LIFO pattern, which means that the value entered first will be removed last. In the above case, the value 3 is entered first, so it will be removed only after the deletion of all the other elements.</p>

        <p>When classifying Linear Stacks based on their implementation, there are two main types:</p>
		
        <ul>
            <li><b>Fixed Size Linear Stack</b>: A fixed size linear stack has a fixed size and cannot grow or shrink dynamically. If the stack is full and an attempt is made to add an element to it, an overflow error occurs. If the stack is empty and an attempt is made to remove an element from it, an underflow error occurs. This type of stack is implemented using an array. The array size is fixed, so elements are added sequentially in the array.</li>
            <li><b>Dynamic Size Linear Stack</b>: A dynamic size linear stack can grow or shrink dynamically. When the stack is full, it automatically increases its size to accommodate the new element, and when the stack is empty, it decreases its size. This type of stack is implemented using a linked list, as it allows for easy resizing of the stack.</li>
        </ul>
		
		<p>When classifying Linear Stacks based on the types of data they handle, they can be categorized into:</p>

        <ul>
            <li><b>Homogeneous Stack</b>: A stack where all the elements are of the same data type.</li>
            <li><b>Heterogeneous Stack (Generic Stack)</b>:  A stack that can handle different data types, allowing elements of various types (e.g., integers, floats, strings, or custom objects) to coexist.</li>
        </ul>
		
        <h3 class="post-subtitle">Array-based Linear Stack</h3>
		
		<p>An Array-based Linear Stack is a stack implementation that uses an array to store elements in a linear order.</p>
		
		<p>Here's a detailed breakdown of common stack operations implemented using an array-based stack:</p>

        <ul>
            <li><code>push()</code>:<br> 
				<ul>
					<li><b>Description</b>: Adds an element to the top of the stack. If the stack is full then the overflow condition occurs.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply adds an element to the top of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>pop()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes the element from the top of the stack and returns it. If the stack is empty means that no element exists in the stack, this state is known as an underflow state.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply remove an element from the top of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether the stack is empty.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply checks the index of the top pointer is empty.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>isFull()</code>:<br> 
				<ul>
					<li><b>Description</b>: Checks if the stack has reached its maximum capacity.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply checks the index of the top pointer is at the maximum capacity of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>peek()</code>:<br>
				<ul>
					<li><b>Description</b>: Returns the element at the top of the stack without removing it.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply accesses the top of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Returns the number of elements currently in the stack.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply gets the number of elements in the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>clear()</code>:<br> 
				<ul>
					<li><b>Description</b>: Resets the stack to its initial empty state.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply decrements the top pointer of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>display()</code>:<br>
				<ul>
					<li><b>Description</b>: Prints all the elements available in the stack.</li>
					<li><b>Time complexity</b>: linear time i.e. \(O(n)\), it performs loop through the elements in the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
        </ul>
		
		<h4 class="post-subtitle">Array-based Homogeneous Linear Stack Implementation</h4>
		
        <p>Here is the Array-based Homogeneous Linear Stack implementation in C:</p>
  
        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Stack {
    int* stack;
    int top;
    int maxSize;
}

struct Stack* createStack(int size) {
    struct Stack* s = (struct Stack*)malloc(sizeof(struct Stack));
    s-&gt;maxSize = size;
    s-&gt;stack = (int*)malloc(s-&gt;maxSize * sizeof(int));
    s-&gt;top = -1;
    return s;
}

void push(struct Stack* s, int element) {
    if (s-&gt;top == s-&gt;maxSize - 1) {
        printf("Stack Overflow\n");
        return;
    }
    printf("Pushed %d to stack\n", element);
    s-&gt;stack[++(s-&gt;top)] = element;
}

int pop(struct Stack* s) {
    if (s-&gt;top == -1) {
        printf("Stack Underflow\n");
        return -1;
    }
    printf("Popped %d from stack\n", s-&gt;stack[s-&gt;top]);
    return s-&gt;stack[(s-&gt;top)--];
}

int isFull(struct Stack* s) {
    return s-&gt;top == s-&gt;maxSize - 1;
}

int isEmpty(struct Stack* s) {
    return s-&gt;top == -1;
}

int peek(struct Stack* s) {
    if (isEmpty(s)) {
        return -1;
    }
    return s-&gt;stack[s-&gt;top];
}

int size(struct Stack* s) {
    return s-&gt;top + 1;
}

void clear(struct Stack* s) {
    s-&gt;top = -1;
    printf("Stack is cleared!\n");
}

void display(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty!\n");
    } else {
        for (int i = 0; i &lt;= s-&gt;top; i++) {
            if (i == s-&gt;top)
                printf("%d", s-&gt;stack[i]);
            else
                printf("%d, ", s-&gt;stack[i]);
        }
        printf("\n");
    }
}

void freeStack(struct Stack* s) {
    free(s-&gt;stack);
    free(s);
}</code></pre>
		
		<p>Here is the Array-based Homogeneous Linear Stack implementation in C++:</p>
        
        <pre><code class="language-cpp hljs">#include &lt;iostream&gt;
using namespace std;

class Stack {
    private:
        int* stack;
        int top;
        int maxSize;

    public:
        Stack(int size) {
            maxSize = size;
            stack = new int[maxSize];
            top = -1;
        }

        ~Stack() {
            delete[] stack;
        }

        void push(int element) {
            if (top == maxSize - 1) {
                cout &lt;&lt; "Stack Overflow" &lt;&lt; endl;
                return;
            }
            cout &lt;&lt; "Pushed " &lt;&lt; element &lt;&lt; " to stack" &lt;&lt; endl;
            stack[++top] = element;
        }

        int pop() {
            if (IsEmpty()) {
                cout &lt;&lt; "Stack Underflow" &lt;&lt; endl;
                return -1;
            }
            cout &lt;&lt; "Popped " &lt;&lt; stack[top] &lt;&lt; " from stack" &lt;&lt; endl;
            return stack[top--];
        }

        bool isFull() {
            return top == maxSize - 1;
        }

        bool isEmpty() {
            return top == -1;
        }

        int peek() {
            if (IsEmpty()) {
                return -1;
            }
            return stack[top];
        }

        int size() {
            return top + 1;
        }

        void clear() {
            top = -1;
            cout &lt;&lt; "Stack is cleared!" &lt;&lt; endl;
        }

        void display() {
            if (IsEmpty()) {
                cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
            } else {
                for (int i = 0; i &lt;= top; i++) {
                    if (i == top)
                        cout &lt;&lt; stack[i];
                    else
                        cout &lt;&lt; stack[i] &lt;&lt; ", ";
                }
                cout &lt;&lt; endl;
            }
        }
}</code></pre>
		
        <p>Here is the Array-based Homogeneous Linear Stack implementation in Java:</p>
        
        <pre><code class="language-java hljs">import java.lang;

public class Stack {
    private int[] stack;
    private int top;
    private int maxSize;

    public Stack(int size) {
        maxSize = size;
        stack = new int[maxSize];
        top = -1;
    }

    public void push(int element) {
        if (top == maxSize - 1) {
            System.out.println("Stack Overflow");
            return;
        }
        System.out.println("Pushed " + element + " to stack");
        stack[++top] = element;
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack Underflow");
            return -1;
        }
        System.out.println("Popped " + stack[top] + " from stack");
        return stack[top--];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return stack[top];
    }

    public int size() {
        return top + 1;
    }

    public void clear() {
        top = -1;
        System.out.println("Stack is cleared!");
    }

    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
        } else {
            for (int i = 0; i &lt;= top; i++) {
                if (i == top)
                    System.out.print(stack[i]);
                else
                    System.out.print(stack[i] + ", ");
            }
            System.out.println();
        }
    }
}</code></pre>
		
	
        <p>Here is the Array-based Homogeneous Linear Stack implementation in C#:</p>

        <pre><code class="language-csharp hljs">using System;

class Stack {
    private int[] stack;
    private int top;
    private int maxSize;

    public Stack(int size) {
        maxSize = size;
        stack = new int[maxSize];
        top = -1;
    }

    public void Push(int element) {
        if (top == maxSize - 1) {
            Console.WriteLine("Stack Overflow");
            return;
        }
        Console.WriteLine($"Pushed {element} to stack");
        stack[++top] = element;
    }

    public int Pop() {
        if (isEmpty()) {
            Console.WriteLine("Stack Underflow");
            return -1;
        }
        Console.WriteLine($"Popped {stack[top]} from stack");
        return stack[top--];
    }

    public bool IsFull() {
        return top == maxSize - 1;
    }

    public bool IsEmpty() {
        return top == -1;
    }

    public int Peek() {
        if (isEmpty()) {
            return -1;
        }
        return stack[top];
    }

    public int Size()
    {
        return top + 1;
    }

    public void Clear()
    {
        top = -1; // Reset the stack to its initial empty state
        Console.WriteLine("Stack is cleared!");
    }

    public void Display()
    {
        if (IsEmpty())
        {
            Console.WriteLine("Stack is empty!");
        }
        else
        {
            for (int i = 0; i &lt;= top; i++)
            {
                if (i == top)
                    Console.Write(stack[i]);
                else
                    Console.Write(stack[i] + ", ");
            }
            Console.WriteLine();
        }
    }
}</code></pre>

        <h4 class="post-subtitle">Array-based Heterogeneous/Generic Linear Stack Implementation</h4>
		
		<p>C does not support generics directly, unlike languages such as C++ or Java. However, you can still implement generic-like behavior in C by using <code>void*</code> pointers and other techniques, like function pointers, to achieve flexibility with different data types.</p>
		
		<p>Here is the Array-based Generic Linear Stack implementation in C:</p>
		
		<pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct StackElement {
    void* data;
    char* toString;
};

struct Stack {
    struct StackElement* stack;
    int top;
    int maxSize;
};

struct Stack* createStack(int size) {
    struct Stack* s = (struct Stack*)malloc(sizeof(struct Stack));
    s-&gt;maxSize = size;
    s-&gt;stack = (struct StackElement*)malloc(s-&gt;maxSize * sizeof(struct StackElement));
    s-&gt;top = -1;
    return s;
}

void push(struct Stack* s, struct StackElement element) {
    if (s-&gt;top == s-&gt;maxSize - 1) {
        printf("Stack Overflow\n");
        return;
    }
    printf("Pushed %s to stack\n", (char*)element.toString);
    s-&gt;stack[++(s-&gt;top)] = element;
}

struct StackElement pop(struct Stack* s) {
    if (s-&gt;top == -1) {
        printf("Stack Underflow\n");
        
        struct StackElement emptyElement;
        emptyElement.data = NULL;
        emptyElement.toString = "";
        return emptyElement;
    }
	
	printf("Popped %s from stack\n", (char*)s-&gt;stack[s-&gt;top].toString);

    return s->stack[s->top--];
}

int isFull(struct Stack* s) {
    return s-&gt;top == s-&gt;maxSize - 1;
}

int isEmpty(struct Stack* s) {
    return s-&gt;top == -1;
}

struct StackElement peek(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty!\n");
        
        struct StackElement emptyElement;
        emptyElement.data = NULL;
        emptyElement.toString = "";
        return emptyElement;
    }
    return s-&gt;stack[s-&gt;top];
}

int size(struct Stack* s) {
    return s-&gt;top + 1;
}

void clear(struct Stack* s) {
    s-&gt;top = -1;
    printf("Stack is cleared!\n");
}

void display(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty!\n");
    } else {
        for (int i = 0; i &lt;= s-&gt;top; i++) {
            printf("%s", (char*)s-&gt;stack[s-&gt;top].toString);
            if (i &lt; s-&gt;top) printf(", ");
        }
        printf("\n");
    }
}

void freeStack(struct Stack* s) {
    free(s-&gt;stack);
    free(s);
}


struct Car {
    char model[20];
    int year;
};

struct Person {
    char name[20];
    int age;
};

int main() {
    struct Car tesla = {"Tesla", 2020};
	struct Car toyota = {"Toyota", 2019};
	struct Car honda = {"Honda", 2020};
	
	struct StackElement carElement;
	struct Stack* carStack = createStack(5);
	
    carElement.data = &tesla;
    carElement.toString = "Car{model:\"Tesla\",year:2020}";
	push(carStack, carElement);
	
	carElement.data = &toyota;
    carElement.toString = "Car{model:\"Toyota\",year:2019}";
    push(carStack, carElement);
	
	carElement.data = &honda;
    carElement.toString = "Car{model:\"Honda\",year:2020}";
    push(carStack, carElement);
	
    pop(carStack);
	display(carStack);
	freeStack(carStack);
	
    struct Person alice = {"Alice", 30};
	struct Person john = {"John", 19};
	struct Person albert = {"Albert", 28};
	struct Person robert = {"Robert", 20};
	
	struct StackElement personElement;
	struct Stack* personStack = createStack(5);
	
	personElement.data = &alice;
    personElement.toString = "Person{name:\"Alice\",age:30}";
	push(personStack, personElement);
	
	personElement.data = &john;
    personElement.toString = "Person{name:\"John\",age:19}";
    push(personStack, personElement);
	
	personElement.data = &albert;
    personElement.toString = "Person{name:\"Albert\",age:28}";
    push(personStack, personElement);
	
	personElement.data = &robert;
    personElement.toString = "Person{name:\"Robert\",age:20}";
	push(personStack, personElement);
    pop(personStack);
	display(personStack);
	freeStack(personStack);
	
    return 0;
}</code></pre>
		
		<p>In C++, you can easily implement a generic stack using templates. Templates allow the creation of classes, functions, and even member functions that can work with any data type, specified when the object or function is instantiated. Templates in C++ allow you to define generic classes and functions that can work with any data type.</p>
		
		<p>Here is the Array-based Generic Linear Stack implementation in C++:</p>
		
		<pre><code class="language-csharp hljs">#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
class Stack {
    private:
        T* stack;
        int top;
        int maxSize;

    public:
        Stack(int size) {
            maxSize = size;
            stack = new T[maxSize];
            top = -1;
        }

        ~Stack() {
            delete[] stack;
        }

        void push(T element) {
            if (top == maxSize - 1) {
                cout &lt;&lt; "Stack Overflow" &lt;&lt; endl;
                return;
            }
            stack[++top] = element;
            cout &lt;&lt; "Pushed " &lt;&lt; element &lt;&lt; " to stack" &lt;&lt; endl;
        }

        T pop() {
            if (isEmpty()) {
                cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
                return T();
            }
            cout &lt;&lt; "Popped " &lt;&lt; stack[top] &lt;&lt; " from stack" &lt;&lt; endl;
            return stack[top--];
        }

        bool isFull() {
            return top == maxSize - 1;
        }

        bool isEmpty() {
            return top == -1;
        }
        
        T peek() {
            if (isEmpty()) {
                cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
                return T();
            }
            return stack[top];
        }

        int size() {
            return top + 1;
        }

        void clear() {
            top = -1;
            cout &lt;&lt; "Stack is cleared!" &lt;&lt; endl;
        }

        void display() {
            if (isEmpty()) {
                cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
            } else {
                for (int i = 0; i &lt;= top; i++) {
                    if (i == top)
                        cout &lt;&lt; stack[i];
                    else
                        cout &lt;&lt; stack[i] &lt;&lt; ", ";
                }
                cout &lt;&lt; endl;
            }
        }
};

int main() {
    // Integer stack
    Stack&lt;int&gt; intStack(5);
    intStack.push(10);
    intStack.push(20);
    intStack.display();
    intStack.pop();
    intStack.display();

    // String stack
    Stack&lt;string&gt; stringStack(3);
    stringStack.push("Hello");
    stringStack.push("World");
    stringStack.display();
    stringStack.pop();
    stringStack.display();

    // Double stack
    Stack&lt;double&gt; doubleStack(4);
    doubleStack.push(99.9);
    doubleStack.push(123.45);
    doubleStack.display();
    doubleStack.pop();
    doubleStack.display();

    return 0;
}</code></pre>
		
		<p>In Java, you can create a generic stack using Generics, which allows you to define a stack that can hold elements of any type.</p>
		
		<p>Here is the Array-based Generic Linear Stack implementation in Java:</p>
		
		<pre><code class="language-java hljs">import java.lang;

public class Stack&lt;T&gt; {
    private T[] stack;
    private int top;
    private int maxSize;

    public Stack(int size) {
        maxSize = size;
        stack = (T[]) new Object[maxSize];
        top = -1;
    }

    public void push(T element) {
        if (top == maxSize - 1) {
            System.out.println("Stack Overflow");
            return;
        }
        stack[++top] = element;
        System.out.println("Pushed " + element + " to stack");
    }

    public T pop() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return;
        }
        System.out.println("Popped " + stack[top] + " from stack");
        return stack[top--];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public T peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return;
        }
        return stack[top];
    }

    public int size() {
        return top + 1;
    }

    public void clear() {
        top = -1;
        System.out.println("Stack is cleared!");
    }

    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
        } else {
            for (int i = 0; i &lt;= top; i++) {
                if (i == top)
                    System.out.print(stack[i]);
                else
                    System.out.print(stack[i] + ", ");
            }
            System.out.println();
        }
    }
}

class Program {
    static void Main() {
        Stack&lt;Person&gt; personStack = new Stack&lt;Person&gt;(5);
        Person p1 = new Person("Alice", 30);
        Person p2 = new Person("Bob", 25);

        personStack.Push(p1);
        personStack.Push(p2);
    }
}</code></pre>
		
		<p>In C#, you can implement a generic stack using generics, which allows the stack to hold elements of any data type.</p>
		
		<p>Here is the Array-based Generic Linear Stack implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Stack&lt;T&gt;
{
    private T[] stack;
    private int top;
    private int maxSize;

    public Stack(int size)
    {
        maxSize = size;
        stack = new T[maxSize];
        top = -1;
    }

    public void Push(T element)
    {
        if (top == maxSize - 1)
        {
            Console.WriteLine("Stack Overflow");
            return;
        }
        Console.WriteLine($"Pushed {element} to stack");
        stack[++top] = element;
    }

    public T Pop()
    {
        if (IsEmpty())
        {
            Console.WriteLine("Stack Underflow");
            return default(T);
        }
        Console.WriteLine($"Popped {stack[top]} from stack");
        return stack[top--];
    }

    public bool IsFull() {
        return top == maxSize - 1;
    }

    public bool IsEmpty()
    {
        return top == -1;
    }

    public T Peek()
    {
        if (IsEmpty())
        {
            return default(T);
        }
        return stack[top];
    }

    public int Size()
    {
        return top + 1;
    }

    public void Clear()
    {
        top = -1;
        Console.WriteLine("Stack is cleared!");
    }

    public void Display()
    {
        if (IsEmpty())
        {
            Console.WriteLine("Stack is empty!");
        }
        else
        {
            for (int i = 0; i &lt;= top; i++)
            {
                if (i == top)
                    Console.Write(stack[i]);
                else
                    Console.Write(stack[i] + ", ");
            }
            Console.WriteLine();
        }
    }
}

class Program
{
    static void Main()
    {
        Stack&lt;int&gt; intStack = new Stack&lt;int&gt;(5);
        intStack.Push(10);
        intStack.Push(20);
        intStack.Pop(); 
        intStack.Pop();
        intStack.Pop();

        Stack&lt;string&gt; stringStack = new Stack&lt;string&gt;(5);
        stringStack.Push("Hello");
        stringStack.Push("World");
        stringStack.Pop();
        stringStack.Pop(); 
        stringStack.Pop(); 
    }
}</code></pre>
		
		<h3 class="post-subtitle">Linked list-based Linear Stack</h3>
		
		<p>A linked list-based linear stack is a stack implementation that uses a linked list to store elements instead of an array. This type of stack offers dynamic memory allocation, meaning the size of the stack can grow or shrink dynamically as elements are pushed and popped, unlike array-based stacks which have a fixed size.</p>
		
		<p>Here's a detailed breakdown of common stack operations implemented using an array-based stack:</p>

        <ul>
            <li><code>push()</code>:<br> 
				<ul>
					<li><b>Description</b>: Adds an element to the top of the stack. If the stack is full then the overflow condition occurs.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply adds an element to the top of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>pop()</code>:<br>
				<ul>
					<li><b>Description</b>: Removes the element from the top of the stack and returns it. If the stack is empty means that no element exists in the stack, this state is known as an underflow state.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply remove an element from the top of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>isEmpty()</code>:<br>
				<ul>
					<li><b>Description</b>: Checks whether the stack is empty.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply checks the index of the top pointer is empty.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>peek()</code>:<br>
				<ul>
					<li><b>Description</b>: Returns the element at the top of the stack without removing it.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply accesses the top of the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>size()</code>:<br>
				<ul>
					<li><b>Description</b>: Returns the number of elements currently in the stack.</li>
					<li><b>Time complexity</b>: constant time i.e. \(O(1)\), it simply gets the number of elements in the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>clear()</code>:<br> 
				<ul>
					<li><b>Description</b>: Resets the stack to its initial empty state.</li>
					<li><b>Time complexity</b>: linear time i.e. \(O(n)\), it performs loop through the elements in the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
            <li><code>display()</code>:<br>
				<ul>
					<li><b>Description</b>: Prints all the elements available in the stack.</li>
					<li><b>Time complexity</b>: linear time i.e. \(O(n)\), it performs loop through the elements in the stack.</li>
					<li><b>Space complexity</b>: constant space i.e. \(O(1)\), no extra space is required.</li>
				</ul>
			</li>
        </ul>
		
		<h4 class="post-subtitle">Linked list-based Homogeneous Linear Stack Implementation</h4>

        <p>Here is the Linked list-based Homogeneous Linear Stack implementation in C:</p>

        <pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    struct Node* top;
    int size;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack-&gt;top = NULL;
    stack-&gt;size = 0;
    return stack;
}

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    return newNode;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = createNode(data);
    newNode-&gt;next = stack-&gt;top;
    stack-&gt;top = newNode;
    stack-&gt;size++;
    printf("Pushed %d to stack\n", data);
}

int pop(struct Stack* stack) {
    if (stack-&gt;top == NULL) {
        printf("Stack Underflow\n");
        return -1;
    }
    struct Node* temp = stack-&gt;top;
    int poppedData = temp-&gt;data;
    stack-&gt;top = temp-&gt;next;
    free(temp);
    stack-&gt;size--;
    printf("Popped %d from stack\n", poppedData);
    return poppedData;
}

int peek(struct Stack* stack) {
    if (stack-&gt;top == NULL) {
        printf("Stack is empty\n");
        return -1;
    }
    return stack-&gt;top-&gt;data;
}

int isEmpty(struct Stack* stack) {
    return stack-&gt;top == NULL;
}

int size(struct Stack* stack) {
    return stack-&gt;size;
}

void clear(struct Stack* stack) {
    while (!isEmpty(stack)) {
        pop(stack);
    }
    printf("Stack is cleared!\n");
}

void display(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty!\n");
        return;
    }
    struct Node* temp = stack-&gt;top;
    while (temp != NULL) {
        printf("%d", temp-&gt;data);
        if (temp-&gt;next != NULL) {
            printf(" -&gt; ");
        }
        temp = temp-&gt;next;
    }
    printf("\n");
}

void freeStack(struct Stack* stack) {
    clear(stack);
    free(stack);
}

int main() {
    struct Stack* stack = createStack();

    push(stack, 10);
    push(stack, 20);
    push(stack, 30);
    display(stack);

    pop(stack);
    display(stack);

    printf("Top element is: %d\n", peek(stack));
    printf("Size of stack: %d\n", size(stack));

    clear(stack);
    display(stack);

    freeStack(stack);
    return 0;
}</code></pre>
		
		<p>Here is the Linked list-based Homogeneous Linear Stack implementation in C++:</p>

        <pre><code class="language-cpp hljs">#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
};

class Stack {
    private:
        Node* top;
        int size;

    public:
        Stack() {
            top = nullptr;
            size = 0;
        }

        ~Stack() {
            while (top != nullptr) {
                pop();
            }
        }

        void push(int element) {
            Node* newNode = new Node();
            newNode-&gt;data = element;
            newNode-&gt;next = top;
            top = newNode;
            size++;
            cout &lt;&lt; "Pushed " &lt;&lt; element &lt;&lt; " to stack" &lt;&lt; endl;
        }

        int pop() {
            if (isEmpty()) {
                cout &lt;&lt; "Stack Underflow" &lt;&lt; endl;
                return -1;
            }

            Node* temp = top;
            int poppedData = temp-&gt;data;
            top = top-&gt;next;
            delete temp;
            size--;
            cout &lt;&lt; "Popped " &lt;&lt; poppedData &lt;&lt; " from stack" &lt;&lt; endl;
            return poppedData;
        }

        int peek() {
            if (isEmpty()) {
                cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
                return -1;
            }
            return top-&gt;data;
        }

        bool isEmpty() {
            return top == nullptr;
        }

        void clear() {
            while (!isEmpty()) {
                pop();
            }
            cout &lt;&lt; "Stack is cleared!" &lt;&lt; endl;
        }

        void display() {
            if (isEmpty()) {
                cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
            } else {
                Node* current = top;
                while (current != nullptr) {
                    cout &lt;&lt; current-&gt;data;
                    if (current-&gt;next != nullptr)
                        cout &lt;&lt; ", ";
                    current = current-&gt;next;
                }
                cout &lt;&lt; endl;
            }
        }

        int getSize() {
            return size;
        }
};

int main() {
    Stack stack;

    stack.push(10);
    stack.push(20);
    stack.push(30);
    stack.display();  // Outputs: 30, 20, 10

    stack.pop();      // Outputs: Popped 30 from stack
    stack.display();  // Outputs: 20, 10

    cout &lt;&lt; "Top element is: " &lt;&lt; stack.peek() &lt;&lt; endl;  // Outputs: 20
    cout &lt;&lt; "Stack size is: " &lt;&lt; stack.getSize() &lt;&lt; endl;   // Outputs: 2

    stack.clear();
    stack.display();  // Outputs: Stack is empty!

    return 0;
}</code></pre>
        
		<p>Here is the Linked list-based Homogeneous Linear Stack implementation in C#:</p>

        <pre><code class="language-cs hljs">using System;

class Node {
    public int data;
    public Node next;
}

class Stack {
    private Node top;
    private int size;

    public Stack() {
        top = null;
        size = 0;
    }

    public void Push(int element) {
        Node newNode = new Node();
        newNode.data = element;
        newNode.next = top;
        top = newNode;
        size++;
        Console.WriteLine($"Pushed {element} to stack");
    }

    public int Pop() {
        if (IsEmpty()) {
            Console.WriteLine("Stack Underflow");
            return -1;
        }

        int poppedData = top.data;
        top = top.next;
        size--;
        Console.WriteLine($"Popped {poppedData} from stack");
        return poppedData;
    }

    public int Peek() {
        if (IsEmpty()) {
            Console.WriteLine("Stack is empty!");
            return -1;
        }
        return top.data;
    }

    public bool IsEmpty() {
        return top == null;
    }

    public int Size() {
        return size;
    }

    public void Clear() {
        top = null;
        size = 0;
        Console.WriteLine("Stack is cleared!");
    }

    public void Display() {
        if (IsEmpty()) {
            Console.WriteLine("Stack is empty!");
        } else {
            Node current = top;
            while (current != null) {
                Console.Write(current.data);
                if (current.next != null) {
                    Console.Write(", ");
                }
                current = current.next;
            }
            Console.WriteLine();
        }
    }
}

class Program {
    static void Main() {
        Stack stack = new Stack();

        stack.Push(10);
        stack.Push(20);
        stack.Push(30);
        stack.Display();  // Outputs: 30, 20, 10

        stack.Pop();      // Outputs: Popped 30 from stack
        stack.Display();  // Outputs: 20, 10

        Console.WriteLine("Top element is: " + stack.Peek());  // Outputs: 20
        Console.WriteLine("Stack size is: " + stack.Size());   // Outputs: 2

        stack.Clear();
        stack.Display();  // Outputs: Stack is empty!
    }
}</code></pre>
		
        <p>Here is the Linked list-based Homogeneous Linear Stack implementation in Java:</p>
        
        <pre><code class="language-java hljs">import java.lang;

public class Node {
    public int data;
    public Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Stack {
    private Node top;
    private int size;

    public Stack() {
        top = null;
        size = 0;
    }

    public void push(int element) {
        Node newNode = new Node(element);
        newNode.next = top;
        top = newNode;
        size++; 
        System.out.println("Pushed " + element + " to stack");
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack Underflow");
            return -1;  // Return -1 if the stack is empty
        }

        int poppedData = top.data;
        top = top.next;
        size--;
        System.out.println("Popped " + poppedData + " from stack");
        return poppedData;
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return -1;
        }
        return top.data;
    }

    public boolean isEmpty() {
        return top == null;
    }

    public int size() {
        return size;
    }

    public void clear() {
        top = null;
        size = 0;
        System.out.println("Stack is cleared!");
    }

    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
        } else {
            Node current = top;
            while (current != null) {
                System.out.print(current.data);
                if (current.next != null) {
                    System.out.print(", ");
                }
                current = current.next;
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Stack stack = new Stack();

        stack.push(10);
        stack.push(20);
        stack.push(30);
        stack.display();  // Outputs: 30, 20, 10

        stack.pop();      // Outputs: Popped 30 from stack
        stack.display();  // Outputs: 20, 10

        System.out.println("Top element is: " + stack.peek());  // Outputs: 20
        System.out.println("Stack size is: " + stack.size());   // Outputs: 2

        stack.clear();
        stack.display();  // Outputs: Stack is empty!
    }
}</code></pre>
        
		
		<h4 class="post-subtitle">Linked list-based Heterogeneous/Generic Linear Stack Implementation</h4>

        <p>Here is the Linked list-based Heterogeneous/Generic Linear Stack implementation in C:</p>
		
		<pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct StackElement {
    void* data;
    char* toString;
};

struct Node {
    struct StackElement element;
    struct Node* next;
};

struct Stack {
    struct Node* top;
    int size;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack-&gt;top = NULL;
    stack-&gt;size = 0;
    return stack;
}

struct Node* createNode(struct StackElement element) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode-&gt;element = element;
    newNode-&gt;next = NULL;
    return newNode;
}

void push(struct Stack* stack, struct StackElement element) {
    struct Node* newNode = createNode(element);
    newNode-&gt;next = stack-&gt;top;
    stack-&gt;top = newNode;
    stack-&gt;size++;
    printf("Pushed %s to stack\n", element.toString);
}

struct StackElement pop(struct Stack* stack) {
    if (stack-&gt;top == NULL) {
        printf("Stack Underflow\n");
        struct StackElement emptyElement = {NULL, ""};
        return emptyElement;
    }

    struct Node* temp = stack-&gt;top;
    struct StackElement poppedElement = temp-&gt;element;
    stack-&gt;top = temp-&gt;next;
    free(temp);
    stack-&gt;size--;
    printf("Popped %s from stack\n", poppedElement.toString);
    return poppedElement;
}

int isEmpty(struct Stack* stack) {
    return stack-&gt;top == NULL;
}

struct StackElement peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty!\n");
        struct StackElement emptyElement = {NULL, ""};
        return emptyElement;
    }
    return stack-&gt;top-&gt;element;
}

int size(struct Stack* stack) {
    return stack-&gt;size;
}

void clear(struct Stack* stack) {
    while (!isEmpty(stack)) {
        pop(stack);
    }
    printf("Stack is cleared!\n");
}

void display(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty!\n");
        return;
    }
    struct Node* temp = stack-&gt;top;
    while (temp != NULL) {
        printf("%s", temp-&gt;element.toString);
        if (temp-&gt;next != NULL) {
            printf(" -&gt; ");
        }
        temp = temp-&gt;next;
    }
    printf("\n");
}

void freeStack(struct Stack* stack) {
    clear(stack);
    free(stack);
}

struct Car {
    char model[20];
    int year;
};

struct Person {
    char name[20];
    int age;
};

int main() {
    struct Car tesla = {"Tesla", 2020};
	struct Car toyota = {"Toyota", 2019};
	struct Car honda = {"Honda", 2020};
	
	struct StackElement carElement;
	struct Stack* carStack = createStack(5);
	
    carElement.data = &tesla;
    carElement.toString = "Car{model:\"Tesla\",year:2020}";
	push(carStack, carElement);
	
	carElement.data = &toyota;
    carElement.toString = "Car{model:\"Toyota\",year:2019}";
    push(carStack, carElement);
	
	carElement.data = &honda;
    carElement.toString = "Car{model:\"Honda\",year:2020}";
    push(carStack, carElement);
	
    pop(carStack);
	display(carStack);
	freeStack(carStack);
	
    struct Person alice = {"Alice", 30};
	struct Person john = {"John", 19};
	struct Person albert = {"Albert", 28};
	struct Person robert = {"Robert", 20};
	
	struct StackElement personElement;
	struct Stack* personStack = createStack(5);
	
	personElement.data = &alice;
    personElement.toString = "Person{name:\"Alice\",age:30}";
	push(personStack, personElement);
	
	personElement.data = &john;
    personElement.toString = "Person{name:\"John\",age:19}";
    push(personStack, personElement);
	
	personElement.data = &albert;
    personElement.toString = "Person{name:\"Albert\",age:28}";
    push(personStack, personElement);
	
	personElement.data = &robert;
    personElement.toString = "Person{name:\"Robert\",age:20}";
	push(personStack, personElement);
    pop(personStack);
	display(personStack);
	freeStack(personStack);
	
    return 0;
}</code></pre>

		<p>Here is the Linked list-based Heterogeneous/Generic Linear Stack implementation in C++:</p>
		
		<pre><code class="language-cpp hljs">#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
class Node {
public:
    T data;
    Node* next;

    Node(T data) {
        this-&gt;data = data;
        this-&gt;next = nullptr;
    }
};

template &lt;typename T&gt;
class Stack {
private:
    Node&lt;T&gt;* top;
    int size;

public:
    Stack() {
        top = nullptr;
        size = 0;
    }

    ~Stack() {
        clear();
    }

    void push(T element) {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(element);
        newNode-&gt;next = top;
        top = newNode;
        size++;
        cout &lt;&lt; "Pushed " &lt;&lt; element &lt;&lt; " to stack" &lt;&lt; endl;
    }

    T pop() {
        if (isEmpty()) {
            cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
            return T();
        }
        Node&lt;T&gt;* temp = top;
        T poppedElement = top-&gt;data;
        top = top-&gt;next;
        delete temp;
        size--;
        cout &lt;&lt; "Popped " &lt;&lt; poppedElement &lt;&lt; " from stack" &lt;&lt; endl;
        return poppedElement;
    }

    bool isEmpty() {
        return top == nullptr;
    }

    T peek() {
        if (isEmpty()) {
            cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
            return T();
        }
        return top-&gt;data;
    }

    int getSize() {
        return size;
    }

    void clear() {
        while (!isEmpty()) {
            pop();
        }
        cout &lt;&lt; "Stack is cleared!" &lt;&lt; endl;
    }

    void display() {
        if (isEmpty()) {
            cout &lt;&lt; "Stack is empty!" &lt;&lt; endl;
            return;
        }
        Node&lt;T&gt;* temp = top;
        while (temp != nullptr) {
            cout &lt;&lt; temp-&gt;data;
            if (temp-&gt;next != nullptr)
                cout &lt;&lt; " -&gt; ";
            temp = temp-&gt;next;
        }
        cout &lt;&lt; endl;
    }
};

int main() {
    // Integer stack
    Stack&lt;int&gt; intStack;
    intStack.push(10);
    intStack.push(20);
    intStack.display();
    intStack.pop();
    intStack.display();

    // String stack
    Stack&lt;string&gt; stringStack;
    stringStack.push("Hello");
    stringStack.push("World");
    stringStack.display();
    stringStack.pop();
    stringStack.display();

    // Double stack
    Stack&lt;double&gt; doubleStack;
    doubleStack.push(99.9);
    doubleStack.push(123.45);
    doubleStack.display();
    doubleStack.pop();
    doubleStack.display();

    return 0;
}</code></pre>

		<p>Here is the Linked list-based Heterogeneous/Generic Linear Stack implementation in C#:</p>
		
		<pre><code class="language-csharp hljs">using System;

class Node&lt;T&gt;
{
    public T data { get; set; }
    public Node&lt;T&gt; next { get; set; }

    public Node(T data)
    {
        data = data;
        next = null;
    }
}

class Stack&lt;T&gt;
{
    private Node&lt;T&gt; top;
    private int size;

    public Stack()
    {
        top = null;
        size = 0;
    }

    public void Push(T element)
    {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(element);
        newNode.next = top;
        top = newNode;
        size++;
        Console.WriteLine($"Pushed {element} to stack");
    }

    public T Pop()
    {
        if (IsEmpty())
        {
            Console.WriteLine("Stack Underflow");
            return default(T);
        }

        T poppedElement = top.data;
        top = top.next;
        size--;
        Console.WriteLine($"Popped {poppedElement} from stack");
        return poppedElement;
    }

    public bool IsEmpty()
    {
        return top == null;
    }

    public T Peek()
    {
        if (IsEmpty())
        {
            Console.WriteLine("Stack is empty!");
            return default(T);
        }
        return top.data;
    }

    public int Size()
    {
        return size;
    }

    public void Clear()
    {
        top = null;
        size = 0;
        Console.WriteLine("Stack is cleared!");
    }

    public void Display()
    {
        if (IsEmpty())
        {
            Console.WriteLine("Stack is empty!");
        }
        else
        {
            Node&lt;T&gt; current = top;
            while (current != null)
            {
                Console.Write(current.data);
                if (current.next != null)
                    Console.Write(" -> ");
                current = current.next;
            }
            Console.WriteLine();
        }
    }
}

class Program
{
    static void Main()
    {
        // Integer stack
        Stack&lt;int&gt; intStack = new Stack&lt;int&gt;();
        intStack.Push(10);
        intStack.Push(20);
        intStack.Pop(); 
        intStack.Pop();
        intStack.Pop();  // This will print "Stack Underflow"

        // String stack
        Stack&lt;string&gt; stringStack = new Stack&lt;string&gt;();
        stringStack.Push("Hello");
        stringStack.Push("World");
        stringStack.Display();
        stringStack.Pop();
        stringStack.Display();
        stringStack.Pop(); 
        stringStack.Pop();  // This will print "Stack Underflow"
    }
}</code></pre>

		<p>Here is the Linked list-based Heterogeneous/Generic Linear Stack implementation in Java:</p>
		
		<pre><code class="language-java hljs">import java.lang;

public class Node&lt;T&gt; {
    public T data;
    public Node&lt;T&gt; next;

    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class Stack&lt;T&gt; {
    private Node&lt;T&gt; top;
    private int size;

    public Stack() {
        top = null;
        size = 0;
    }

    public void push(T element) {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(element);
        newNode.next = top;
        top = newNode;
        size++;
        System.out.println("Pushed " + element + " to stack");
    }

    public T pop() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return null;
        }
        T poppedElement = top.data;
        top = top.next;
        size--;
        System.out.println("Popped " + poppedElement + " from stack");
        return poppedElement;
    }

    public boolean isEmpty() {
        return top == null;
    }

    public T peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return null;
        }
        return top.data;
    }

    public int size() {
        return size;
    }

    public void clear() {
        top = null;
        size = 0;
        System.out.println("Stack is cleared!");
    }

    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return;
        }

        Node&lt;T&gt; current = top;
        while (current != null) {
            System.out.print(current.data);
            if (current.next != null) {
                System.out.print(" -> ");
            }
            current = current.next;
        }
        System.out.println();
    }
}

public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }
}

public class Program {
    public static void main(String[] args) {
        Stack&lt;Person&gt; personStack = new Stack&lt;Person&gt;();
        Person p1 = new Person("Alice", 30);
        Person p2 = new Person("Bob", 25);

        personStack.push(p1);
        personStack.push(p2);

        personStack.display();  // Displays all elements in the stack

        personStack.pop();  // Removes the top element from the stack
        personStack.display();  // Displays the stack after pop
    }
}</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/data-structure" class="tag">data structure</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/stack" class="tag">stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/linear-stack" class="tag">linear stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/fixed-sized-linear-stack" class="tag">fixed sized linear stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/dynamic-sized-linear-stack" class="tag">dynamic sized linear stack</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/09/26/linear-stack-data-structure/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-09" /><category term="day-26" /><category term="data structure" /><category term="stack" /><category term="linear stack" /><category term="fixed sized linear stack" /><category term="dynamic sized linear stack" /><summary type="html"><![CDATA[Explore the concepts of linear stack data structures, including both fixed-sized and dynamic-sized variations, in this comprehensive guide. A stack is a fundamental data structure that operates on the Last In, First Out (LIFO) principle, meaning the most recently added element is the first to be removed. Fixed-sized stacks are typically implemented using arrays, where the maximum size is predefined, while dynamic-sized stacks, often implemented using linked lists or dynamic memory allocation, can grow or shrink as needed. This guide provides detailed explanations of stack operations such as push (inserting elements), pop (removing elements), and peek (accessing the top element).]]></summary></entry><entry xml:lang="en"><title type="html">Asymptotic Notation</title><link href="https://hemimorphite.github.io/2024/09/19/asymptotic-notation/" rel="alternate" type="text/html" title="Asymptotic Notation" /><published>2024-09-19T07:21:00+00:00</published><updated>2024-09-19T07:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/09/19/asymptotic-notation</id><content type="html" xml:base="https://hemimorphite.github.io/2024/09/19/asymptotic-notation/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Asymptotic Notation</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published September 19, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/asymptotic.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>The efficiency of an algorithm depends on the amount of time, storage and other resources required to execute the algorithm. The efficiency is measured with the help of asymptotic notations.</p>

        <p>An algorithm may not have the same performance for different types of inputs. With the increase in the input size, the performance will change.</p>

        <p>The study of change in performance of the algorithm with the change in the order of the input size is defined as asymptotic analysis.</p>

        <p>There are five types of asymptotic notation: \(O\) (Big O), \(\Omega\) (Big omega), \(\Theta\) (Big theta), \(o\) (Little o) and \(\omega\) (Little Omega).</p>

        <h5 class="post-subtitle">Big-O Notation</h5>

        <p>Big O notation represents the upper bound or worst-case scenario of the growth rate of a function. It describes an algorithm’s maximum time or space complexity.</p>

        <p class="definition">Let \(f(n)\) and \(g(n)\) be functions that map positive integers to positive real numbers. We say that \(f(n)\) is \(O(g(n))\) (or \(f(n) \in O(g(n))\)) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that \(f(n) \leq c \cdot g(n)\) for every integer \(n \geq n_0\).</p>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n + 8\) and \(g(n) = n\). Is \(f(n) \in O(g(n))\)?</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) belongs to \(O(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 7n + 8 \leq c \cdot n \]
                </div>

                <p>Subtract both sides by \(c \cdot n\):</p>

                <div class="equation-container">
                \[ (7 - c)n + 8 \leq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((7 - c)n\) must be negative. Therefore:</p>

                <div class="equation-container">
                \[ 7 - c \lt 0 \implies c \gt 7 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(7\).</p>

                <p>Choose \(c = 8\):</p>

                <div class="equation-container">
                \[ 7n + 8 \leq 8n \implies n \geq 8 \]
                </div>

                <p>Therefore, we can pick \(c = 8\) and \(n_0 = 8\):</p>

                <div class="equation-container">
                \[ 8 \geq 8 \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 8\) and \(n_0 = 8\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n^{2} + 8\) and \(g(n) = n\). Is \(f(n) \in O(g(n))\)?</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = 7n^{2} + 8\) belongs to \(O(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 7n^{2} + 8 \leq c \cdot n \]
                </div>

                <p>Subtract both sides by \(c \cdot n\):</p>

                <div class="equation-container">
                \[ 7n^{2} - c \cdot n + 8 \leq 0 \]
                </div>

                <p>For large \(n\), the term \(7n^{2}\) will grow faster than \(c \cdot n\). Hence, the inequality \(7n^{2} + 8 \leq c \cdot n\) will not hold for any large \(n\).</p>

                <p>Hence, we have shown that there do not exist constants \(c \gt 0\) and \(n_0\) such that \(7n^{2} + 8 \leq c \cdot n\) for all \(n \geq n_0\). Thus, \(f(n) \notin O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = n^{3} + 20n + 1\) is \(O(n^{3})\)</p>
                
                <p>Solution</p>

                <p>To determine whether \(f(n) = n^{3} + 20n + 1\) belongs to \(O(g(n))\) where \(g(n) = n^{3}\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ n^{3} + 20n + 1 \leq c \cdot n^{3} \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c - 1)n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c - 1)n^{3}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ c - 1 \gt 0 \implies c \gt 1 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(1\).</p>

                <p>Choose \(c = 2\):</p>

                <div class="equation-container">
                \[ n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>We want to find \(n_0\) such that:</p>

                <div class="equation-container">
                \[ n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n^{3} - 20n - 1 \geq 0\) holds, we need to find the point where the positive terms (\(n^{3}\)) become dominant over the negative terms (\(20n\) and \(1\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(n^{3}\) is the highest-degree positive term and \(20n\) is the highest-degree negative term. We compare \(n^{3}\) with \(20n\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ n^{3} \gt 20n \implies n \gt \sqrt{20} \approx 4.4721 \]
                </div>

                <p>So, \(n^{3}\) starts to dominate \(20n\) when \(n\) is \(5\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{3} - 20n - 1 \geq 0\) holds.</p>

                <p>For \(n = 5\):</p>

                <div class="equation-container">
                \[ 5^{3} - 20(5) - 1 = 125 - 20 - 1 = 24 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 2\) and \(n_0 = 5\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = n^{3} + 20n + 1\) is not \(O(n^{2})\)</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = n^{3} + 20n + 1\) belongs to \(O(g(n))\) where \(g(n) = n^{2}\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Assume, for contradiction, that \(f(n) = n^{3} + 20n + 1\) is \(O(n^{2})\). Then there exist constants \(c \gt 0\) and \(n_0 \geq 1\) such that for all \(n \geq n_0\):</p>

                <div class="equation-container">
                \[ n^{3} + 20n + 1 \leq c \cdot n^{2} \]
                </div>

                <p>Subtract by \(c \cdot n^{2}\) from both sides:</p>

                <div class="equation-container">
                \[ n^{3} - c \cdot n^{2} + 20n + 1 \leq 0 \]
                </div>

                <p>For large \(n\), the term \(n^{3}\) will grow faster than \(c \cdot n^{2}\). Hence, the inequality \(n^{3} + 20n + 1 \leq c \cdot n^{2}\) will not hold for any large \(n\).</p>

                <p>Hence, we have shown that there do not exist constants \(c \gt 0\) and \(n_0\) such that \(n^{3} + 20n + 1 \leq c \cdot n^{2}\) for all \(n \geq n_0\). Thus, \(f(n) \notin O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 100n^{3} + 20n + 1\) is \(O(n^{4})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 100n^{3} + 20n + 1\) belongs to \(O(g(n))\) where \(g(n) = n^{4}\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 100n^{3} + 20n + 1 \leq c \cdot n^{4} \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ c \cdot n^{4} - 100n^{3} - 20n - 1 \geq 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \(c \cdot n^{4}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ c \gt 0 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(0\).</p>

                <p>Choose \(c = 1\):</p>

                <div class="equation-container">
                \[ n^{4} - 100n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>We want to find \(n_0\) such that:</p>

                <div class="equation-container">
                \[ n^{4} - 100n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n^{4} - 100n^{3} - 20n - 1 \geq 0\) holds, we need to find the point where the positive terms (\(n^{4}\)) become dominant over the negative terms (\(100n^{3}\), \(20n\) and \(1\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(n^{4}\) is the highest-degree positive term and \(100n^{3}\) is the highest-degree negative term. We compare \(n^{4}\) with \(100n^{3}\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ n^{4} \gt 100n^{3} \implies n \gt 100 \]
                </div>

                <p>So, \(n^{4}\) starts to dominate \(100n^{3}\) when \(n\) is larger than \(100\).</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{4} - 100n^{3} - 20n - 1 \geq 0\) holds.</p>

                <p>For \(n = 101\):</p>

                <div class="equation-container">
                \[ 101^{4} - 100(101^{3}) - 20(101) - 1 = 104060401 -103030100 - 2020 - 1 = 1028280 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 100\):</p>

                <div class="equation-container">
                \[ 100^{4} - 100(100^{3}) - 20(100) - 1 = 100000000 -100000000 - 2000 - 1 = -2001 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 1\) and \(n_0 = 101\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 2^{n+1}\) is \(O(2^{n})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 2^{n+1}\) belongs to \(O(g(n))\) where \(g(n) = 2^{n}\), we need to check if f(n) grows at most as fast as g(n) asymptotically. A function f(n) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 2^{n+1} \leq c \cdot 2^{n} \]
                </div>

                <p>Divide by \(2^{n}\) from both sides:</p>

                <div class="equation-container">
                \[ c \geq 2 \]
                </div>

                <p>This means that for large enough \(n\), the inequality will hold as long as \(c \geq 2\).</p>

                <p>Choose \(c = 2\):</p>

                <div class="equation-container">
                \[ 2^{n+1} \leq 2 \cdot 2^{n} \implies 2^{n+1} \leq 2^{n+1} \]
                </div>

                <p>Therefore, we can pick \(c = 2\) and \(n_0 = 1\):</p>

                <div class="equation-container">
                \[ 2^{2} \leq 2^{2} \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 2\) and \(n_0 = 1\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 10^{80}\) is \(O(1)\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 10^{80}\) belongs to \(O(g(n))\) where \(g(n) = 1\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>The function \(f(n) = 10^{80}\) is a constant value, meaning that it does not depend on \(n\). It remains \(10^{80}\) regardless of the input \(n\).</p>

                <div class="equation-container">
                \[ 10^{80} \leq c \cdot 1 \]
                </div>

                <p>We need to find a constant \(c\) such that:</p>

                <div class="equation-container">
                \[ 10^{80} \leq c \]
                </div>

                <p>This inequality is true for any constant \(c \geq 10^{80}\). Therefore, we can choose \(c = 10^{80}\).</p>

                <p>Thus, we can conclude that \(f(n) \in O(g(n))\) with \(c = 10^{80}\) and \(n_0 = 1\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) is \(O(\log(\log(n)))\)</p>

                <p>Solution</p>

                <p>The function \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) can be rewritten using the change of base formula:</p>

                <div class="equation-container">
                \[ f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log (\log^{\log(100)}(n))}{\log(\ln(5))} \]
                </div>

                <p>Next, simplify the expression:</p>

                <div class="equation-container">
                \[ f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log(100)}{\log (\ln(5))} \cdot \log(\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) belongs to \(O(g(n))\) where \(g(n) = \log(\log(n))\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) \leq c \cdot \log(\log(n)) \]
                </div>

                <p>Simplify the function \(f(n)\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\log (\ln(5))} \cdot \log(\log(n)) \leq c \cdot \log(\log(n)) \]
                </div>

                <p>Divide by \(\log(\log(n))\) from both sides:</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\log (\ln(5))} \leq c \]
                </div>

                <p>This means that for large enough \(n\), the inequality will hold as long as \(c \geq \frac{\log(100)}{\log (\ln(5))}\).</p>

                <p>Thus, we can conclude that \(f(n) \in O(g(n))\) with \(c = \frac{\log(100)}{\log(\ln(5))}\) and \(n_0 = 1\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 5^{log(3)} n^{3} + 10^{80} n^{2} + log(3) n^{3.1} + 6006\) is \(O(n^{3.1})\).</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 5^{log(3)} n^{3} + 10^{80} n^{2} + log(3) n^{3.1} + 6006\) belongs to \(O(g(n))\) where \(g(n) = n^{3.1}\), we need to check if f(n) grows at most as fast as g(n) asymptotically. A function f(n) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 5^{log(3)} n^{3} + 10^{80} n^{2} + log(3) n^{3.1} + 6006 \leq c \cdot n^{3.1} \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c - log(3))n^{3.1} - 5^{log(3)}n^{3} - 10^{80}n^{2} - 6006 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c - log(3))n^{3.1}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ c - log(3) \gt 0 \implies c \gt log(3) \approx 0.4771 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(0.4771\).</p>

                <p>Choose \(c = 1\):</p>

                <div class="equation-container">
                \[ (1 - log(3))n^{3.1} - 5^{log(3)}n^{3} - 10^{80}n^{2} - 6006 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \((1 - log(3))n^{3.1} - 5^{log(3)}n^{3} - 10^{80}n^{2} - 6006 \geq 0\) holds, we need to find the point where the positive terms (\((1 - log(3))n^{3.1}\)) become dominant over the negative terms (\(5^{log(3)}n^{3}\), \(10^{80}n^{2}\) and \(6006\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \((1 - log(3))n^{3.1}\) which is the highest-degree positive term with \(5^{log(3)}n^{3}\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ (1 - log(3))n^{3.1} \gt 5^{log(3)}n^{3} \]
                </div>

                <p>Divide both sides by \((1 - log(3))n^{3}\):</p>

                <div class="equation-container">
                \[ n^{0.1} \gt \frac{5^{log(3)}}{1 - log(3)} \approx 8.85 \]
                </div>

                <p>Raise both sides to the power of \(10\):</p>

                <div class="equation-container">
                \[ n \gt 4.94 \cdot 10^{9} \]
                </div>

                <p>Next, we compare \((1 - log(3))n^{3.1}\) which is the highest-degree positive term with \(10^{80}n^{2}\) which is the term with the largest constant magnitude to estimate \(n\).</p>

                <div class="equation-container">
                \[ (1 - log(3))n^{3.1} \gt 10^{80}n^{2} \]
                </div>

                <p>Divide both sides of the inequality by n^{2}</p>

                <div class="equation-container">
                \[ (1 - log(3))n^{1.1} \gt 10^{80} \]
                </div>

                <p>Divide both sides by \(1−\log(3)\):</p>

                <div class="equation-container">
                \[ n^{1.1} \gt \frac{10^{80}}{1 - log(3)} \approx 10^{80} \]
                </div>

                <p>Now, take the 1.11-th root of both sides to isolate \(n\):</p>

                <div class="equation-container">
                \[ n \gt 10^{72.73} \]
                </div>

                <p>This is a much larger threshold than \(4.94 \cdot 10^{9}\).</p>

                <p>Let's approach it by testing positive values for \(n\) such that \((1 - log(3))n^{3.1} - 5^{log(3)}n^{3} - 10^{80}n^{2} - 6006 \geq 0\) holds.</p>

                <p>For \(n = 10^{73}\):</p>

                <div class="equation-container">
                \[ (1 - log(3)) (10^{73})^{3.1} - 5^{log(3)} (10^{73})^{3} - 10^{80} (10^{73})^{2} - 6006 \approx -10^{226} \quad (\text{which} \: \lt 0) \]
                </div>

                <p>For \(n = 10^{74}\):</p>

                <div class="equation-container">
                \[ (1 - log(3)) (10^{74})^{3.1} - 5^{log(3)} (10^{74})^{3} - 10^{80} (10^{74})^{2} - 6006 \approx 5.23 \cdot 10^{228.4} \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 1\) and \(n_0 = 10^{74}\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \binom{n}{\frac{n}{2}}\) is \(O(\frac{2^{n}}{\sqrt{n}})\).</p>

                <p>Solution</p>
				
				<p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) belongs to \(O(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \leq c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>From the above approximation:</p>
                
                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \leq c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Divide by \(\frac{2^{n}}{\sqrt{n}}\) from both sides:</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \leq c \]
                </div>

                <p>This means that for large enough \(n\), the inequality will hold as long as \(c \geq \frac{\sqrt{2}}{\sqrt{\pi}}\).</p>

                <p>Thus, we can conclude that \(f(n) \in O(g(n))\) with \(c = \frac{\sqrt{2}}{\sqrt{\pi}}\) and \(n_0 = 1\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{3} − 11n^{2} + 12}\) is \(O(n)\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) belongs to \(O(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \leq c \cdot n \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \leq c \cdot n \cdot (2n^{2} − 11n + 12) \]
                </div>

                <p>Expand the expression:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \leq 2c \cdot n^{3} − 11c \cdot n^{2} + 12c \cdot n \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (2c - 4)n^{3} + (28 - 11c)n^{2} + (12c - 56)n + 35 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((2c - 4)n^{3}\) must be positive or zero. If the dominant term \((2c - 4)n^{3}\) becomes zero, the term \((28 - 11c)n^{2}\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 2c - 4 \geq 0 \implies c \geq 2 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than or equal to \(2\).</p>

                <p>Choose \(c = 2\):</p>

                <div class="equation-container">
                \[ 6n^{2} - 32n + 35 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(6n^{2} - 32n + 35 \geq 0\) holds, we need to find the point where the positive terms (\(6n^{2}\) and \(35\)) become dominant over the negative terms (\(32n\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \(6n^{2}\) which is the highest-degree positive term with \(32n\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ 6n^{2} \geq 32n \]
                </div>

                <p>Divide both sides by \(6n\):</p>

                <div class="equation-container">
                \[ n \geq 5.4 \]
                </div>

                <p>So, \(6n^{2}\) starts to dominate \(32n\) when \(n\) is \(6\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(6n^{2} - 32n + 35 \geq 0\) holds.</p>

                <p>For \(n = 6\):</p>

                <div class="equation-container">
                \[ 6(6^{2}) - 32(6) + 35 = 216 - 192 + 35 = 59 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 5\):</p>

                <div class="equation-container">
                \[ 6(5^{2}) - 32(5) + 35 = 150 - 160 + 35 = 25 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 4\):</p>

                <div class="equation-container">
                \[ 6(4^{2}) - 32(4) + 35 = 96 - 128 + 35 = 3 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 3\):</p>

                <div class="equation-container">
                \[ 6(3^{2}) - 32(3) + 35 = 54 - 96 + 35 = -7 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 2\) and \(n_0 = 4\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) is \(O(\frac{1}{n^{2}})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) belongs to \(O(g(n))\) where \(g(n) = \frac{1}{n^{2}}\), we need to check if \(f(n)\) grows at most as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \leq c \cdot \frac{1}{n^{2}} \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ n^{2} \cdot (5n^{2} − 2n − 35) \leq c \cdot (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45) \]
                </div>

                <p>Expand the expression:</p>

                <div class="equation-container">
                \[ 5n^{4} − 2n^{3} − 35n^{2} \leq 2c \cdot n^{4} − 11c \cdot n^{3} + 12c \cdot n^{2} + 4c \cdot n + 45c \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (2c - 5)n^{4} + (2 - 11c)n^{3} + (12c + 35)n^{2} + (4c)n + 45c \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((2c - 5)n^{4}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 2c - 5 \gt 0 \implies c \gt 2.5 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than or equal to \(2.5\).</p>

                <p>Choose \(c = 2.6\):</p>

                <div class="equation-container">
                \[ 0.2n^{4} - 26.6n^{3} + 66.2n^{2} + 10.4n + 117 \geq 0 \]
                </div>

                <p>Multiply both sides by \(5\):</p>

                <div class="equation-container">
                \[ n^{4} - 133n^{3} + 331n^{2} + 52n + 585 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n^{4} - 133n^{3} + 331n^{2} + 52n + 585 \geq 0\) holds, we need to find the point where the positive terms (\(n^{4}\), \(331n^{2}\), \(52n\) and \(585\)) become dominant over the negative terms (\(133n^{3}\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \(n^{4}\) which is the highest-degree positive term with \(133n^{2}\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ n^{4} \geq 133n^{3} \]
                </div>

                <p>Solving for \(n\):</p>

                <div class="equation-container">
                \[ n \geq 133 \]
                </div>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{4} - 133n^{3} + 331n^{2} + 52n + 585 \geq 0\) holds.</p>

                <p>For \(n = 133\):</p>

                <div class="equation-container">
                \[ (133)^{4} - 133(133^{3}) + 331(133^{2}) + 52(133) + 585 = 312900721 - 312900721 + 5855059 + 6916 + 585 = 5862560 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 132\):</p>

                <div class="equation-container">
                \[ (132)^{4} - 133(132^{3}) + 331(132^{2}) + 52(132) + 585 = 303180864 - 306789024 + 5763054 + 6864 + 585 = 2168343 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 131\):</p>

                <div class="equation-container">
                \[ (131)^{4} - 133(131^{3}) + 331(131^{2}) + 52(131) + 585 = 294616321 - 299674083 + 5688511 + 6792 + 585 = 642126 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 130\):</p>

                <div class="equation-container">
                \[ (130)^{4} - 133(130^{3}) + 331(130^{2}) + 52(130) + 585 = 285610000 - 292321000 + 5596900 + 6760 + 585 = -1106755 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 2.6\) and \(n_0 = 131\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \log(n!)\) is \(O(n \log(n))\).</p>

                <p>Solution</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) belongs to \(O(g(n))\) where \(g(n) = n \log(n)\), we need to check if f(n) grows at most as fast as g(n) asymptotically. A function f(n) is in \(O(g(n))\) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \leq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to determine if there exist constants \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \log(n!) \leq c \cdot n \log(n) \]
                </div>

                <p>From the approximation above:</p>

                <div class="equation-container">
                \[ \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \leq c \cdot n \log(n) \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c - 1)n \log(n) + n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c - 1)n \log(n)\) must be positive or zero. If the dominant term \((c - 1)n \log(n)\) becomes zero, the term \(n \log(e)\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ c - 1 \geq 0 \implies c \geq 1 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than or equal to \(1\).</p>

                <p>Choose \(c = 1\):</p>

                <div class="equation-container">
                \[ n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \geq 0\) holds, we need to find the point where the positive terms (\(n \log(e)\)) become dominant over the negative terms (\(\frac{1}{2} \log(n)\) and \(\frac{1}{2} \log(2\pi)\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \(n \log(e)\) which is the highest-degree positive term with \(\frac{1}{2} \log(n)\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ n \log(e) \gt \frac{1}{2} \log(n) \]
                </div>

                <p>The inequality \(n \log(e) \gt \frac{1}{2} \log(n)\) holds for all positive \(n\)</p>

                <div class="equation-container">
                \[ n \gt 0 \]
                </div>

                <p>Let's approach it by testing positive values for \(n\) such that \(n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \geq 0\) holds.</p>

                <p>For \(n = 1\):</p>

                <div class="equation-container">
                \[ 1 \cdot log(e) - \frac{1}{2} \log(1) - \frac{1}{2} \log(2\pi) \geq 0 \approx 0.434 - 0 - 0.399 \approx 0.035 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 1\) and \(n_0 = 1\) such that \(f(n) \leq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in O(g(n))\).</p>
            </div>
        </div>

        <h5 class="post-subtitle">Little-o Notation</h5>

        <p>Let \(f(n)\) and \(g(n)\) be functions that map positive integers to positive real numbers. We say that \(f(n)\) is \(o(g(n))\) (or \(f(n) \in o(g(n))\)) if for any real constant \(c \gt 0\), there exists an integer constant \(n_0 \geq 1\) such that \(f(n) \lt c \cdot g(n)\) for every integer \(n \geq n_0\).</p>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n + 8\) and \(g(n) = n\). Is \(f(n) \in o(g(n))\)?</p>
                
                <p>Solution 1</p>

                <p>To determine whether \(f(n) = 7n + 8\) belongs to \(o(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ 7n + 8 \lt c \cdot n \]
                </div>

                <p>Subtract both sides by \(c \cdot n\):</p>

                <div class="equation-container">
                \[ (7 - c)n + 8 \lt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((7 - c)n\) must be negative. Therefore:</p>

                <div class="equation-container">
                \[ 7 - c \lt 0 \implies c \gt 7 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(7\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt 7\) requires \(c\) to be at least \(7\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(7\)).</p>

                <p>Hence, \(f(n) = 7n + 8 \notin o(g(n))\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) is in \(o(g(n))\) where \(g(n) = n\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = 7n + 8\) and \(g(n) = n\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n + 8}{n} \]
                </div>

                <p>Simplify the expression:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n + 8}{n} = \lim_{n \to \infty} (7 + \frac{8}{n}) \]
                </div>

                <p>As \(n\) approaches infinity, the term \(\frac{8}{n}\) approaches \(0\). Thus, the limit becomes:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} (7 + \frac{8}{n}) = 7 \]
                </div>

                <p>Since the limit is \(7\) (and not \(0\)), the function \(f(n) = 7n + 8\) does not grow faster than \(g(n) = n\). Therefore, \(f(n) \notin o(g(n))\).</p>

            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n + 8\) and \(g(n) = n^{2}\). Is \(f(n) \in o(g(n))\)?</p>
                
                <p>Solution 1</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) belongs to \(o(g(n))\) where \(g(n) = n^{2}\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ 7n + 8 \lt c \cdot n^{2} \]
                </div>

                <p>Subtract both sides by \(c \cdot n^{2}\):</p>

                <div class="equation-container">
                \[ (-c)n^{2} + 7n + 8 \lt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((-c)n^{2}\) must be negative. Therefore:</p>

                <div class="equation-container">
                \[ -c \lt 0 \implies c \gt 0 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(0\).</p>

                <p>Since the inequality holds for any positive \(c\), \(f(n)\) satisfy the condition for \(o(g(n))\). Therefore, \(f(n) = 7n + 8 \in o(g(n) = n^{2})\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) is in \(o(g(n))\) where \(g(n) = n^{2}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = 7n + 8\) and \(g(n) = n^{2}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n + 8}{n^{2}} \]
                </div>

                <p>Simplify the expression:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n + 8}{n^{2}} = \lim_{n \to \infty} (\frac{7}{n} + \frac{8}{n^{2}}) \]
                </div>

                <p>As \(n\) approaches infinity, the terms \(\frac{7}{n}\) and \(\frac{8}{n^{2}}\) approach \(0\). Thus, the limit becomes:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} (\frac{7}{n} + \frac{8}{n^{2}}) = 0 \]
                </div>

                <p>Since the limit is \(0\), then \(f(n) = 7n + 8 \in o(g(n) = n^{2})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 2^{n+1}\) and \(g(n) = 2^{n}\). Is \(f(n) \in o(g(n))\)?</p>
                
                <p>Solution 1</p>
                
                <p>To determine whether \(f(n) = 2^{n+1}\) belongs to \(o(g(n))\) where \(g(n) = 2^{n}\), we need to see if for any given positive value of \(c\), we can find a point \(n_0\) beyond which the function \(f(n) = 2^{n+1}\) grows strictly slower than \(c\) times \(g(n) = 2^{n}\):</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ 2^{n+1} \lt c \cdot 2^{n} \]
                </div>

                <p>Divide both sides by \(2^{n}\):</p>

                <div class="equation-container">
                \[ 2 \lt c \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(2\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt 2\) requires \(c\) to be at least \(2\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(2\)).</p>

                <p>Hence, \(f(n) = 2^{n+1} \notin o(g(n) = 2^{n})\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = 2^{n+1}\) belongs to \(o(g(n))\) where \(g(n) = 2^{n}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = 2^{n+1}\) and \(g(n) = 2^{n}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{2^{n+1}}{2^{n}} \]
                </div>

                <p>Simplify the expression and evaluate the limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{2^{n+1}}{2^{n}} = \lim_{n \to \infty} 2 = 2 \]
                </div>

                <p>Since the limit is \(2\) (and not \(0\)), the function \(f(n) = 2^{n+1}\) does not grow faster than \(g(n) = 2^{n}\). Therefore, \(f(n) \notin o(g(n))\).</p>

            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) and \(g(n) = \log(\log(n))\). Is \(f(n) \in o(g(n))\)</p>

                <p>Solution 1</p>
                
                <p>Let's simplify the expression \(\log_{\ln(5)}(\log^{\log(100)}(n))\).</p>

                <p>The change of base formula states:</p>

                <div class="equation-container">
                \[ \log_{a}(x) = \frac{\log_{b}(x)}{\log_{b}(a)} \]
                </div>

                <p>Applying this to the expression:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log (\log^{\log(100)}(n))}{\ln(5)} \]
                </div>

                <p>The expression inside the logarithm can be simplified using the logarithm power rule, \(\log⁡ (x^{y}) = y \cdot \log⁡ (x)\):</p>

                <div class="equation-container">
                \[ \log (\log^{\log(100)}(n)) = \log(100) \cdot \log (\log(n)) \]
                </div>

                <p>So, the original expression becomes:</p>

                <div class="equation-container">
                \[ \frac{\log (\log^{\log(100)}(n))}{\ln(5)} = \frac{\log(100)}{\ln(5)} \cdot \log (\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) belongs to \(o(g(n))\) where \(g(n) = \log(\log(n))\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>


                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) \lt c \cdot \log(\log(n)) \]
                </div>

                <p>Simplify the expression \(\log_{\ln(5)}(\log^{\log(100)}(n))\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \cdot \log (\log(n)) \lt c \cdot \log(\log(n)) \]
                </div>

                <p>Divide both sides by \(\log(\log(n))\) (which is positive for all \(n\)):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \lt c \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(\frac{\log(100)}{\ln(5)}\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt \frac{\log(100)}{\ln(5)}\) requires \(c\) to be at least \(\frac{\log(100)}{\ln(5)}\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(\frac{\log(100)}{\ln(5)}\)).</p>

                <p>Hence, \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) \notin o(g(n) = \log(\log(n)))\).</p>

                <p>Solution 2</p>
                
                <p>Let's simplify the expression \(\log_{\ln(5)}(\log^{\log(100)}(n))\).</p>

                <p>The change of base formula states:</p>

                <div class="equation-container">
                \[ \log_{a}(x) = \frac{\log_{b}(x)}{\log_{b}(a)} \]
                </div>

                <p>Applying this to the expression:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log (\log^{\log(100)}(n))}{\ln(5)} \]
                </div>

                <p>The expression inside the logarithm can be simplified using the logarithm power rule, \(\log⁡ (x^{y}) = y \cdot \log⁡ (x)\):</p>

                <div class="equation-container">
                \[ \log (\log^{\log(100)}(n)) = \log(100) \cdot \log (\log(n)) \]
                </div>

                <p>So, the original expression becomes:</p>

                <div class="equation-container">
                \[ \frac{\log (\log^{\log(100)}(n))}{\ln(5)} = \frac{\log(100)}{\ln(5)} \cdot \log (\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) belongs to \(o(g(n))\) where \(g(n) = \log(\log(n))\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) and \(g(n) = \log(\log(n))\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\log_{\ln(5)}(\log^{\log(100)}(n))}{\log(\log(n))} \]
                </div>

                <p>Simplify the expression and evaluate the limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\log_{\ln(5)}(\log^{\log(100)}(n))}{\log(\log(n))} = \lim_{n \to \infty} \frac{\frac{\log(100)}{\ln(5)} \cdot \log (\log(n))}{\log(\log(n))} = \frac{\log(100)}{\ln(5)} \]
                </div>

                <p>Since the limit is \(\frac{\log(100)}{\ln(5)}\) (and not \(0\)), the function \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) does not grow faster than \(g(n) = \log(\log(n))\). Therefore, \(f(n) \notin o(g(n))\).</p>

            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \binom{n}{\frac{n}{2}}\) and \(g(n) = \frac{2^{n}}{\sqrt{n}}\). Is \(f(n)\) in \(o(g(n))\).</p>

                <p>Solution 1</p>
                
                <p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) belongs to \(o(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substitute the given functions:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \lt c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\binom{n}{\frac{n}{2}}\):</p>

                <div class="equation-container">
                \[ \sqrt{\frac{2}{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \lt c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Divide both sides by \(\frac{2^{n}}{\sqrt{n}}\) (which is positive for all \(n\)):</p>

                <div class="equation-container">
                \[ \sqrt{\frac{2}{\pi}} \lt c \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(\sqrt{\frac{2}{\pi}}\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt \sqrt{\frac{2}{\pi}}\) requires \(c\) to be at least \(\sqrt{\frac{2}{\pi}}\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(\sqrt{\frac{2}{\pi}}\)).</p>

                <p>Hence, \(f(n) = \binom{n}{\frac{n}{2}} \notin o(g(n) = \frac{2^{n}}{\sqrt{n}})\).</p>

                <p>Solution 2</p>
                
                <p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) belongs to \(o(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = \binom{n}{\frac{n}{2}}\) and \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\binom{n}{\frac{n}{2}}}{\frac{2^{n}}{\sqrt{n}}} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\binom{n}{\frac{n}{2}}\):</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\binom{n}{\frac{n}{2}}}{\frac{2^{n}}{\sqrt{n}}} = \lim_{n \to \infty} \frac{\sqrt{\frac{2}{\pi}} \cdot \frac{2^{n}}{\sqrt{n}}}{\frac{2^{n}}{\sqrt{n}}} = \lim_{n \to \infty} \sqrt{\frac{2}{\pi}} = \sqrt{\frac{2}{\pi}} \]
                </div>

                <p>Since the limit is \(\sqrt{\frac{2}{\pi}}\) (and not \(0\)), the function \(f(n) = \binom{n}{\frac{n}{2}}\) does not grow faster than \(g(n) = \frac{2^{n}}{\sqrt{n}}\). Therefore, \(f(n) \notin o(g(n))\).</p>
                
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \log(n!)\) and \(g(n) = n \log(n)\). Is \(f(n)\) in \(o(g(n))\).</p>

                <p>Solution 1</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) belongs to \(o(g(n))\) where \(g(n) = n \log(n)\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad \quad n \geq n_0 \]
                </div>

                <p>Substitute the given functions:</p>

                <div class="equation-container">
                \[ \log(n!) \lt c \cdot n \log(n) \]
                </div>

				<p>Substitute the approximation above into the expression for \(\log(n!)\):</p>
				
                <div class="equation-container">
                \[ \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \lt c \cdot n \log(n) \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c - 1)n \log(n) + n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \gt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c - 1)n \log(n)\) must be positive or zero. If the dominant term \((c - 1)n \log(n)\) becomes zero, the term \(n \log(e)\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ c - 1 \geq 0 \implies c \geq 1 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than or equal to \(1\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \geq 1\) requires \(c\) to be at least \(1\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(1\)).</p>

                <p>Hence, \(f(n) = \log(n!) \notin o(g(n) = n \log(n))\).</p>

                <p>Solution 2</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) is in \(o(g(n))\) where \(g(n) = n \log(n)\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = \log(n!)\) and \(g(n) = n \log(n)\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\log(n!)}{n \log(n)} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\log(n!)\):</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e)}{n \log(n)} = \lim_{n \to \infty} (\frac{\log(2\pi)}{2n \log(n)} + \frac{1}{2n} + 1 - \frac{\log(e)}{\log(n)}) \]
                </div>

                <p>As \(n\) approaches infinity, the term \(\frac{\log(2\pi)}{2n \log(n)}\), \(\frac{1}{2n}\) and \(\frac{\log(e)}{\log(n)}\) approach \(0\). Thus, the limit becomes:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} (\frac{\log(2\pi)}{2n \log(n)} + \frac{1}{2n} + 1 - \frac{\log(e)}{\log(n)}) = 0 + 0 + 1 - 0 = 1 \]
                </div>

                <p>Since the limit is \(1\) (and not \(0\)), the function \(f(n) = \log(n!)\) does not grow faster than \(g(n) = n \log(n)\). Therefore, \(f(n) \notin o(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) and \(g(n) = n\). Is \(f(n)\) in \(o(g(n))\).</p>

                <p>Solution 1</p>

                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) belongs to \(o(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \lt c \cdot n \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{2} − 11n + 12\):</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \lt c \cdot n \cdot (2n^{2} − 11n + 12) \]
                </div>

                <p>Expand the right-hand side, the inequality becomes:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \lt 2c \cdot n^{3} - 11c \cdot n^{2} + 12c \cdot n \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (2c - 4)n^{3} + (28 - 11c)n^{2} + (12c - 56)n + 35 \gt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((2c - 4)n^{3}\) must be positive or zero. If the dominant term \((2c - 4)n^{3}\) becomes zero, the term \((28 - 11c)n^{2}\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 2c - 4 \geq 0 \implies c \geq 2 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than or equal to \(2\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \geq 2\) requires \(c\) to be at least \(2\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(2\)).</p>

                <p>Hence, \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \notin o(g(n) = n)\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) belongs to \(o(g(n))\) where \(g(n) = n\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) =  \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) and \(g(n) = n\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}}{n} \]
                </div>

                <p>Simplify the fraction:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{3} − 11n^{2} + 12n} \]
                </div>

                <p>Applying L'Hôpital's rule:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (4n^{3} − 28n^{2} + 56n − 35)}{\frac{d}{dn} \, (2n^{3} − 11n^{2} + 12n)} = \lim_{n \to \infty} \frac{12n^{2} − 56n + 56}{6n^{2} − 22n + 12} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (12n^{2} − 56n + 56)}{\frac{d}{dn} \, (6n^{2} − 22n + 12)} = \lim_{n \to \infty} \frac{24n − 56}{12n − 22} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (24n − 56)}{\frac{d}{dn} \, (12n − 22)} = \lim_{n \to \infty} \frac{24}{12} = 2 \]
                </div>

                <p>Since the limit is \(2\) (and not \(0\)), the function \(f(n) = \frac{5n^{4} − 2n^{3} − 35n^{2}}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) does not grow faster than \(g(n) = n\). Therefore, \(f(n) \notin o(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) and \(g(n) = \frac{1}{n^{2}}\). Is \(f(n)\) in \(o(g(n))\).</p>

                <p>Solution 1</p>

                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) belongs to \(o(g(n))\) where \(g(n) = \frac{1}{n^{2}}\), we need to check if \(f(n)\) grows strictly slower than \(g(n)\) asymptotically. A function \(f(n)\) is in \(o(g(n))\) if for any given positive real constant \(c\), there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \lt c \cdot \frac{1}{n^{2}} \]
                </div>

                <p>Multiply both sides by the denominators \(2n^{4} − 11n^{3} + 12n^{2} + 4n + 45\) and \(n^{2}\):</p>

                <div class="equation-container">
                \[ n^{2} (5n^{2} − 2n − 35) \lt c \cdot (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45) \]
                </div>

                <p>Expand the expression, the inequality becomes:</p>

                <div class="equation-container">
                \[ 5n^{4} − 2n^{3} − 35n^{2} \lt 2c \cdot n^{4} - 11c \cdot n^{3} + 12c \cdot n^{2} + 4c \cdot n + 45c \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (2c - 5)n^{4} + (2 - 11c)n^{3} + (35 + 12c)n^{2} + (4c)n + 45c \gt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((2c - 5)n^{4}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 2c - 5 \gt 0 \implies c \gt 2.5 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(2.5\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt 2.5\) requires \(c\) to be at least \(2.5\), \(f(n)\) cannot be less than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(2.5\)).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) belongs to \(o(g(n))\) where \(g(n) = \frac{1}{n^{2}}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(0\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) and \(g(n) = \frac{1}{n^{2}}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}}{\frac{1}{n^{2}}} \]
                </div>

                <p>Simplify the fraction:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{5n^{4} − 2n^{3} − 35n^{2}}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \]
                </div>

                <p>Applying L'Hôpital's rule:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (5n^{4} − 2n^{3} − 35n^{2})}{\frac{d}{dn} \, (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45)} = \lim_{n \to \infty} \frac{20n^{3} − 6n^{2} − 70n}{8n^{3} − 33n^{2} + 24n + 4} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (20n^{3} − 6n^{2} − 70n)}{\frac{d}{dn} \, (8n^{3} − 33n^{2} + 24n + 4)} = \lim_{n \to \infty} \frac{60n^{2} − 12n − 70}{24n^{2} − 66n + 24} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (60n^{2} − 12n − 70)}{\frac{d}{dn} \, (24n^{2} − 66n + 24)} = \lim_{n \to \infty} \frac{120n − 12}{48n − 66} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (120n − 12)}{\frac{d}{dn} \, (48n − 66)} = \lim_{n \to \infty} \frac{120}{48} = \frac{5}{2} \]
                </div>

                <p>Since the limit is \(2.5\) (and not \(0\)), the function \(f(n) = \frac{5n^{4} − 2n^{3} − 35n^{2}}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) does not grow faster than \(g(n) = \frac{1}{n^{2}}\). Therefore, \(f(n) \notin o(g(n))\).</p>
            </div>
        </div>

        <h5 class="post-subtitle">Big–Omega Notation</h5>

        <p>Big Omega notation represents the lower bound or best-case scenario of the growth rate of a function. It describes an algorithm’s minimum time or space complexity.</p>

        <p>Let \(f(n)\) and \(g(n)\) be functions that map positive integers to positive real numbers. We say that \(f(n)\) is \(\Omega(g(n))\) (or \(f(n) \in \Omega(g(n))\)) if there exists a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that \(f(n) \geq c \cdot g(n)\) for every integer \(n \geq n_0\).</p>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n + 8\) and \(g(n) = n\). Is \(f(n) \in \Omega(g(n))\)?</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) belongs to \(\Omega(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>


                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 7n + 8 \geq c \cdot n \]
                </div>

                <p>Subtract \(c \cdot n\) from both sides:</p>

                <div class="equation-container">
                \[ (7 - c)n + 8 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((7 - c)n\) must be positive or zero. If the dominant term \((7 - c)n\) becomes zero, the term \(8\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 7 - c  \geq 0 \implies c \leq 7 \]
                </div>

                <p>We can choose \(c = 7\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ 7n + 8 \geq 7n \]
                </div>

                <p>Subtract both sides by \(7n\):</p>

                <div class="equation-container">
                \[ 8 \geq 0 \]
                </div>

                <p>This is true for all \(n \geq 1\) (or any positive \(n_0\)).</p>

                <p>We have shown that for \(c = 7\) and \(n_0 = 1\), the inequality holds. Hence, \(f(n) = 7n + 8 \in \Omega(g(n) = n)\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = n^{3} + 20n + 1\) and \(g(n) = n^{3}\). Is \(f(n) \in \Omega(g(n))\)?</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = n^{3} + 20n + 1\) belongs to \(\Omega(g(n))\) where \(g(n) = n^{3}\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ n^{3} + 20n + 1 \geq c \cdot n^{3} \]
                </div>

                <p>Subtract \(c \cdot n^{3}\) from both sides:</p>

                <div class="equation-container">
                \[ (1 - c)n^{3} + 20n + 1 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((1 - c)n^{3}\) must be positive or zero. If the dominant term \((1 - c)n^{3}\) becomes zero, the term \(20n\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 1 - c \geq 0 \implies c \leq 1 \]
                </div>

                <p>We can choose \(c = 1\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ 20n + 1 \geq 0 \]
                </div>

                <p>This is true for all \(n \geq 1\), so we can set \(n_0 = 1\).</p>

                <p>We have shown that for \(c = 1\) and \(n_0 = 1\), the inequality holds. Hence, \(f(n) = n^{3} + 20n + 1 \in \Omega(g(n) = n^{3})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 2^{n+1} is \Omega(2^{n})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 2^{n+1}\) belongs to \(\Omega(g(n))\) where \(g(n) = 2^{n}\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 2^{n+1} \geq c \cdot 2^{n} \]
                </div>


                <p>Cancel \(2^{n}\) from both sides of the inequality:</p>

                <div class="equation-container">
                \[ 2 \geq c \]
                </div>

                <p>We can choose \(c = 2\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ 2^{n+1} \geq 2 \cdot 2^{n} \]
                </div>

                <p>Divide both sides by \(2^{n+1}\):</p>

                <div class="equation-container">
                \[ 1 \geq 1 \]
                </div>

                <p>This is true for all \(n \geq 1\), so we can set \(n_0 = 1\).</p>

                <p>We have shown that for \(c = 1\) and \(n_0 = 1\), the inequality holds. Hence, \(f(n) = 2^{n+1} \in \Omega(g(n) = 2^{n})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 10^{80}\) is \(\Omega(1)\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 10^{80}\) belongs to \(\Omega(g(n))\) where \(g(n) = 1\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ 10^{80} \geq c \cdot 1 \]
                </div>

                <p>We can choose \(c = 10^{80}\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ 10^{80} \geq 10^{80} \]
                </div>

                <p>This is true for all \(n \geq 1\), so we can set \(n_0 = 1\).</p>

                <p>We have shown that for \(c = 1\) and \(n_0 = 1\), the inequality holds. Hence, \(f(n) = 10^{80} \in \Omega(g(n) = 1)\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) is \(\Omega(\log(\log(n)))\)</p>

                <p>Solution</p>

                <p>The function \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) can be rewritten using the change of base formula:</p>

                <div class="equation-container">
                \[ f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log (\log^{\log(100)}(n))}{\log (\ln(5))} \]
                </div>

                <p>Next, simplify the expression \(\log (\log^{\log(100)}(n))\):</p>

                <div class="equation-container">
                \[ \log (\log^{\log(100)}(n)) = \log(100) \cdot \log(\log(n)) \]
                </div>

                <p>Substituting this back into \(f(n)\), we get:</p>

                <div class="equation-container">
                \[ f(n) = \frac{\log(100)}{\log (\ln(5))} \cdot \log(\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) belongs to \(\Omega(g(n))\) where \(g(n) = \log(\log(n))\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) \geq c \cdot \log(\log(n)) \]
                </div>

                <p>From the simplified form of \(f(n)\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\log (\ln(5))} \cdot \log(\log(n)) \geq c \cdot \log(\log(n)) \]
                </div>

                <p>Cancel \(\log(\log(n))\) from both sides of the inequality:</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\log (\ln(5))} \geq c \]
                </div>

                <p>We can choose \(c = \frac{\log(100)}{\log (\ln(5))}\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\log (\ln(5))}  \cdot \log(\log(n)) \geq \frac{\log(100)}{\log (\ln(5))} \cdot \log(\log(n)) \]
                </div>

                <p>Divide both sides by \(\frac{\log(100)}{\log (\ln(5))} \cdot \log(\log(n))\):</p>

                <div class="equation-container">
                \[ 1 \geq 1 \]
                </div>

                <p>This is true for all \(n \geq 1\), so we can set \(n_0 = 1\).</p>

                <p>We have shown that for \(c = \frac{\log(100)}{\log (\ln(5))}\) and \(n_0 = 1\), the inequality holds. Hence, \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) \in \Omega(g(n) = \log(\log(n)))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \binom{n}{\frac{n}{2}} is \Omega(\frac{2^{n}}{\sqrt{n}})\).</p>

                <p>Solution</p>

                <p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) belongs to \(\Omega(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \geq c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\binom{n}{\frac{n}{2}}\):</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \geq c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Cancel \(\frac{2^{n}}{\sqrt{n}}\) from both sides of the inequality:</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \geq c \]
                </div>

                <p>We can choose \(c = \frac{\sqrt{2}}{\sqrt{\pi}}\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \geq \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>This is true for all \(n \geq 1\), so we can set \(n_0 = 1\).</p>

                <p>We have shown that for \(c = \frac{\sqrt{2}}{\sqrt{\pi}}\) and \(n_0 = 1\), the inequality holds. Hence, \(f(n) = \binom{n}{\frac{n}{2}} \in \Omega(g(n) = \frac{2^{n}}{\sqrt{n}})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) is \(\Omega(n)\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) belongs to \(\Omega(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \geq c \cdot n \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{2} − 11n + 12\):</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \geq c \cdot n \cdot (2n^{2} − 11n + 12) \]
                </div>

                <p>Expand the right-hand side, the inequality becomes:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \geq 2c \cdot n^{3} − 11c \cdot n^{2} + 12c \cdot n \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (4 - 2c)n^{3} + (11c - 28)n^{2} + (56 - 12c)n - 35 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((4 - 2c)n^{3}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 4 - 2c \gt 0 \implies c \lt 2 \]
                </div>

                <p>Choose \(c = 1.9\):</p>

                <div class="equation-container">
                \[ 0.2n^{3} - 7.1n^{2} + 33.2n - 35 \geq 0 \]
                </div>

                <p>Multiply both sides by \(10\):</p>

                <div class="equation-container">
                \[ 2n^{3} - 71n^{2} + 332n - 350 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(2n^{3} - 71n^{2} + 332n - 350 \geq 0\) holds, we need to find the point where the positive terms (\(2n^{3}\) and \(332n\)) become dominant over the negative terms (\(71n^{2}\) and \(350\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \(2n^{3}\) which is the highest-degree positive term with \(71n^{2}\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ 2n^{3} \gt 71n^{2} \]
                </div>

                <p>Divide both sides by \(2n^{2}\):</p>

                <div class="equation-container">
                \[ n \gt 30.5 \]
                </div>

                <p>Let's approach it by testing positive values for \(n\) such that \(2n^{3} - 71n^{2} + 332n - 350 \geq 0\) holds.</p>

                <p>For \(n = 31\):</p>

                <div class="equation-container">
                \[ 2(31^{3}) - 71(31^{2}) + 332(31) - 350 = 59582 - 68131 + 10292 - 350 = 1393 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 30\):</p>

                <div class="equation-container">
                \[ 2(30^{3}) - 71(30^{2}) + 332(30) - 350 = 54000 - 63900 + 9960 - 350 = -290 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 1.9\) and \(n_0 = 31\) such that \(f(n) \geq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in \Omega(g(n))\).</p>

            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) is \(\Omega(\frac{1}{n^{2}})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) belongs to \(\Omega(g(n))\) where \(g(n) = \frac{1}{n^{2}}\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \geq c \cdot \frac{1}{n^{2}} \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{2} − 11n + 12\) and \(n^{2}\):</p>

                <div class="equation-container">
                \[ n^{2}(5n^{2} − 2n − 35) \geq c \cdot (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45) \]
                </div>

                <p>Expand the expression, the inequality becomes:</p>

                <div class="equation-container">
                \[ 5n^{4} − 2n^{3} − 35n^{2} \geq 2c \cdot n^{4} − 11c \cdot n^{3} + 12c \cdot n^{2} + 4c \cdot n + 45c \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (5 - 2c)n^{4} + (11c - 2)n^{3} - (35 + 12c)n^{2} - (4c)n - 45c \geq 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((5 - 2c)n^{4}\) must be positive or zero. If the dominant term \((5 - 2c)n^{4}\) becomes zero, the term \((11c - 2)n^{3}\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 5 - 2c \geq 0 \implies c \leq 2.5 \]
                </div>

                <p>Choose \(c = 2.5\):</p>

                <div class="equation-container">
                \[ (5 - 2(2.5))n^{4} + (11(2.5) - 2)n^{3} - (35 + 12(2.5))n^{2} - (4(2.5))n - 45(2.5) \geq 0 \]
                </div>

                <p>Calculate each coefficient:</p>

                <div class="equation-container">
                \[ 51n^{3} - 130n^{2} - 20n - 225 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(51n^{3} - 130n^{2} - 20n - 225 \geq 0\) holds, we need to find the point where the positive terms (\(51n^{3}\)) become dominant over the negative terms (\(130n^{2}\), \(20n\) and \(225\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \(51n^{3}\) which is the highest-degree positive term with \(130n^{2}\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ 51n^{3} \geq 130n^{2} \]
                </div>

                <p>Divide both sides by \(51n^{2}\):</p>

                <div class="equation-container">
                \[ n \geq 2.549 \]
                </div>

                <p>Let's approach it by testing positive values for \(n\) such that \(51n^{3} - 130n^{2} - 20n - 225 \geq 0\) holds.</p>

                <p>For \(n = 3\):</p>

                <div class="equation-container">
                \[ 51(3)^{3} - 130(3)^{2} - 20(3) - 225 = 1377 - 1170 - 60 - 225 = -78 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>For \(n = 4\):</p>

                <div class="equation-container">
                \[ 51(4)^{3} - 130(4)^{2} - 20(4) - 225 = 3264 - 2080 - 80- 225 = 879 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 2.5\) and \(n_0 = 4\) such that \(f(n) \geq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in \Omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \log(n!)\) and \(g(n) = n \log(n)\). Is \(f(n)\) in \(\Omega(g(n))\).</p>

                <p>Solution</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) belongs to \(\Omega(g(n))\) where \(g(n) = n \log(n)\), we need to check if \(f(n)\) grows at least as fast as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Omega(g(n))\) if there exist a real constant \(c \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \geq c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c\) and \(n_0\) such that:</p>

                <div class="equation-container">
                \[ \log(n!) \geq c \cdot n \log(n) \]
                </div>

                <p>Substitute the approximation above into the expression for \(\log(n!)\):</p>

                <div class="equation-container">
                \[ \frac{1}{2} \log (2\pi) + \frac{1}{2} \log (n) + n \log (n) - n log (e) \geq c \cdot n \log(n) \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (1 - c) n \log(n) - n \log (e) + \frac{1}{2} \log (n) + \frac{1}{2} \log (2\pi) \geq 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((1 - c)n \log(n)\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 1 - c \gt 0 \implies c \lt 1 \]
                </div>

                <p>Choose \(c = 0.9\):</p>

                <div class="equation-container">
                \[ \frac{1}{10} n \log(n) - n \log (e) + \frac{1}{2} \log (n) + \frac{1}{2} \log (2\pi) \geq 0 \]
                </div>

                <p>Multiply both sides by \(10\):</p>

                <div class="equation-container">
                \[ n \log(n) - 10n \log (e) + 5 \log (n) + 5 \log (2\pi) \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n \log(n) - 10n \log (e) + 5 \log (n) + 5 \log (2\pi) \geq 0\) holds, we need to find the point where the positive terms (\(n \log(n)\), \(5 \log (n)\), and \(5 \log (2\pi)\)) become dominant over the negative terms (\(10n \log (e)\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>We compare \(n \log(n)\) which is the highest-degree positive term with \(10n \log (e)\) which is the highest-degree negative term to estimate \(n\).</p>

                <div class="equation-container">
                \[ n \log(n) \geq 10n \log (e) \]
                </div>

                <p>Divide both sides by \(n\):</p>

                <div class="equation-container">
                \[ \log(n) \geq 10 \log (e) \approx 4.34 \]
                </div>

                <p>Rewrite it in its exponential form:</p>

                <div class="equation-container">
                \[ n \geq 10^{4.34} \]
                </div>

                <p>Let's approach it by testing positive values for \(n\) such that \(n \log(n) - 10n \log (e) + 5 \log (n) + 5 \log (2\pi) \geq 0\) holds.</p>

                <p>For \(n = 10^{5}\):</p>

                <div class="equation-container">
                \[ 10^{5} \cdot \log(10^{5}) - 10 \cdot 10^{5} \cdot \log (e) + 5 \log (10^{5}) + 5 \log (2\pi) = 5 \cdot 10^{5} - 4.34 \cdot 10^{5} + 25 + 3.99 \approx 66029 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Hence, we have shown that there exist constants \(c = 0.9\) and \(n_0 = 66029\) such that \(f(n) \geq c \cdot g(n)\) for all \(n \geq n_0\). Thus, \(f(n) \in \Omega(g(n))\).</p>
            </div>
        </div>

        <h5 class="post-subtitle">Little–Omega Notation</h5>

        <p>Let f(n) and g(n) be functions that map positive integers to positive real numbers. We say that f(n) is \omega(g(n)) (or f(n) \in \omega(g(n))) if for any real constant c \gt 0, there exists an integer constant n_0 \geq 1 such that f(n) \gt c \cdot g(n) for every integer n \geq n_0.</p>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n + 8\) and \(g(n) = n\). Is \(f(n)\) in \(\omega(g(n))\)?</p>
                
                <p>Solution 1</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) belongs to \(\omega(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ 7n + 8 \gt c \cdot n \]
                </div>

                <p>Subtract both sides by \(c \cdot n\):</p>

                <div class="equation-container">
                \[ (7 - c)n + 8 \gt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((7 - c)n\) must be positive or zero. If the dominant term \((7 - c)n\) becomes zero, the term 8 can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 7 - c \geq 0 \implies c \leq 7 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), c must be less than or equal to \(1\). However, \(\omega(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \leq 7\) requires \(c\) to be at most \(7\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary large values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(\omega(g(n))\) because there exists a upper bound on \(c\) (namely \(7\)).</p>

                <p>Hence, \(f(n) = 7n + 8 \notin \omega(g(n) = n)\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) is in \(\omega(g(n))\) where \(g(n) = n\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) = 7n + 8\) and \(g(n) = n\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n + 8}{n} \]
                </div>

                <p>Simplify the expression:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n + 8}{n} = \lim_{n \to \infty} (7 + \frac{8}{n}) \]
                </div>

                <p>As \(n\) approaches infinity, the term \(\frac{8}{n}\) approaches \(0\). Thus, the limit becomes:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} (7 + \frac{8}{n}) = 7 \]
                </div>

                <p>Since the limit is \(7\) (and not \(\infty\)), the function \(f(n) = 7n + 8\) does not grow faster than \(g(n) = n\). Therefore, \(f(n) \notin \omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n^{2} + 8\) and \(g(n) = n\). Is \(f(n)\) in \(\omega(g(n))\)?</p>
                
                <p>Solution 1</p>
                
                <p>To determine whether \(f(n) = 7n^{2} + 8\) belongs to \(\omega(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ 7n^{2} + 8 \gt c \cdot n \]
                </div>

                <p>Subtract both sides by \(c \cdot n\):</p>

                <div class="equation-container">
                \[ 7n^{2} + (-c)n + 8 \gt 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the coefficient of the dominant term \(n^{2}\), must be positive and it does not depend on \(c\). Therefore:</p>

                <div class="equation-container">
                \[ c \gt 0 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(0\).</p>

                <p>Since the inequality holds for any positive \(c\), \(f(n)\) satisfy the condition for \(\omega(g(n))\). Therefore, \(f(n) = 7n + 8 \in \omega(g(n) = n^{2})\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = 7n^{2} + 8\) is in \(\omega(g(n))\) where \(g(n) = n\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) = 7n^{2} + 8\) and \(g(n) = n\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n^{2} + 8}{n} \]
                </div>

                <p>Simplify the expression:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{7n^{2} + 8}{n} = \lim_{n \to \infty} (7n + \frac{8}{n^{2}}) \]
                </div>

                <p>As \(n\) approaches infinity, the terms \(\frac{8}{n^{2}}\) approach \(0\). Thus, the limit becomes:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} 7n = \infty \]
                </div>

                <p>Since the limit is \(\infty\), the function \(f(n) = 7n^{2} + 8\) always grows faster than \(g(n) = n\). Therefore, \(f(n) \in \omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 2^{n+1}\) and \(g(n) = 2^{n}\). Is \(f(n)\) in \(\omega(g(n))\)?</p>
                
                <p>Solution 1</p>
                
                <p>To determine whether \(f(n) = 2^{n+1}\) belongs to \(\omega(g(n))\) where \(g(n) = 2^{n}\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \lt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ 2^{n+1} \lt c \cdot 2^{n} \]
                </div>

                <p>Divide both sides by \(2^{n}\):</p>

                <div class="equation-container">
                \[ 2 \lt c \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than \(2\). However, \(\omega(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt 2\) requires \(c\) to be at least \(2\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a lower bound on \(c\) (namely \(2\)).</p>

                <p>Hence, \(f(n) = 2^{n+1} \notin \omega(g(n) = 2^{n})\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = 2^{n+1}\) belongs to \(\omega(g(n))\) where \(g(n) = 2^{n}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) = 2^{n+1}\) and \(g(n) = 2^{n}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{2^{n+1}}{2^{n}} \]
                </div>

                <p>Simplify the expression and evaluate the limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{2^{n+1}}{2^{n}} = \lim_{n \to \infty} 2 = 2 \]
                </div>

                <p>Since the limit is \(2\) (and not \(\infty\)), the function \(f(n) = 2^{n+1}\) does not grow faster than \(g(n) = 2^{n}\). Therefore, \(f(n) \notin \omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) and \(g(n) = \log(\log(n))\). Is \(f(n)\) in \(\omega(g(n))\)</p>

                <p>Solution 1</p>
                
                <p>Simplify the expression using the change of base formula, \(\log_{a}(x) = \frac{\log_{b}(x)}{\log_{b}(a)}\):</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log(\log^{\log(100)}(n))}{\ln(5)} \]
                </div>

                <p>The expression inside the logarithm can be simplified using the logarithm power rule, \(\log⁡ (x^{y}) = y \cdot \log⁡(x)\):</p>

                <div class="equation-container">
                \[ \log(\log^{\log(100)}(n)) = \log(100) \cdot \log(\log(n)) \]
                </div>

                <p>So, the original expression becomes:</p>

                <div class="equation-container">
                \[ \frac{\log(\log^{\log(100)}(n))}{\ln(5)} = \frac{\log(100)}{\ln(5)} \cdot \log(\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) belongs to \(\omega(g(n))\) where \(g(n) = \log(\log(n))\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) \gt c \cdot \log(\log(n)) \]
                </div>

                <p>Simplify the expression \log_{\ln(5)}(\log^{\log(100)}(n)):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \cdot \log (\log(n)) \gt c \cdot \log(\log(n)) \]
                </div>

                <p>Divide both sides by \(\log(\log(n))\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \gt c \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be less than \(\frac{\log(100)}{\ln(5)}\). However, \(o(g(n))\) requires the inequality to hold for any positive \(c\), no matter how large.</p>

                <p>Since \(c \lt \frac{\log(100)}{\ln(5)}\) requires \(c\) to be at most \(\frac{\log(100)}{\ln(5)}\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary big values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(o(g(n))\) because there exists a upper bound on \(c\) (namely \(\frac{\log(100)}{\ln(5)}\)).</p>

                <p>Hence, \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) \notin \omega(g(n) = \log(\log(n)))\).</p>

                <p>Solution 2</p>
                
                <p>Let's simplify the expression \(\log_{\ln(5)}(\log^{\log(100)}(n))\).</p>

                <p>The change of base formula states:</p>

                <div class="equation-container">
                \[ \log_{a}(x) = \frac{\log_{b}(x)}{\log_{b}(a)} \]
                </div>

                <p>Applying this to the expression:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log (\log^{\log(100)}(n))}{\ln(5)} \]
                </div>

                <p>The expression inside the logarithm can be simplified using the logarithm power rule, \(\log⁡ (x^{y}) = y \cdot \log⁡ (x)\):</p>

                <div class="equation-container">
                \[ \log (\log^{\log(100)}(n)) = \log(100) \cdot \log (\log(n)) \]
                </div>

                <p>So, the original expression becomes:</p>

                <div class="equation-container">
                \[ \frac{\log (\log^{\log(100)}(n))}{\ln(5)} = \frac{\log(100)}{\ln(5)} \cdot \log (\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) belongs to \(\omega(g(n))\) where \(g(n) = \log(\log(n))\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) and \(g(n) = \log(\log(n))\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\log_{\ln(5)}(\log^{\log(100)}(n))}{\log(\log(n))} \]
                </div>

                <p>Simplify the expression and evaluate the limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\log_{\ln(5)}(\log^{\log(100)}(n))}{\log(\log(n))} = \lim_{n \to \infty} \frac{\frac{\log(100)}{\ln(5)} \cdot \log (\log(n))}{\log(\log(n))} = \frac{\log(100)}{\ln(5)} \]
                </div>

                <p>Since the limit is \(\frac{\log(100)}{\ln(5)}\) (and not \(\infty\)), the function \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) does not grow faster than \(g(n) = \log(\log(n))\). Therefore, \(f(n) \notin \omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \binom{n}{\frac{n}{2}}\) and \(g(n) = \frac{2^{n}}{\sqrt{n}}\). Is \(f(n)\) in \(\omega(g(n))\).</p>

                <p>Solution 1</p>
                
                <p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) belongs to \(\omega(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \gt c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\binom{n}{\frac{n}{2}}\):</p>

                <div class="equation-container">
                \[ \sqrt{\frac{2}{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \gt c \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Divide both sides by \(\frac{2^{n}}{\sqrt{n}}\):</p>

                <div class="equation-container">
                \[ \sqrt{\frac{2}{\pi}} \lt c \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be larger than \(\sqrt{\frac{2}{\pi}}\). However, \(\omega(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \gt \sqrt{\frac{2}{\pi}}\) requires \(c\) to be at least \(\sqrt{\frac{2}{\pi}}\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary small values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(\omega(g(n))\) because there exists a lower bound on \(c\) (namely \(\sqrt{\frac{2}{\pi}}\)).</p>

                <p>Hence, \(f(n) = \binom{n}{\frac{n}{2}} \notin \omega(g(n) = \frac{2^{n}}{\sqrt{n}})\).</p>

                <p>Solution 2</p>
                
                <p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) belongs to \(\omega(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) = \binom{n}{\frac{n}{2}}\) and \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\binom{n}{\frac{n}{2}}}{\frac{2^{n}}{\sqrt{n}}} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\binom{n}{\frac{n}{2}}\):</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\binom{n}{\frac{n}{2}}}{\frac{2^{n}}{\sqrt{n}}} = \lim_{n \to \infty} \frac{\sqrt{\frac{2}{\pi}} \cdot \frac{2^{n}}{\sqrt{n}}}{\frac{2^{n}}{\sqrt{n}}} = \lim_{n \to \infty} \sqrt{\frac{2}{\pi}} = \sqrt{\frac{2}{\pi}} \]
                </div>

                <p>Since the limit is \(\sqrt{\frac{2}{\pi}}\) (and not \(\infty\)), the function \(f(n) = \binom{n}{\frac{n}{2}}\) does not grow faster than \(g(n) = \frac{2^{n}}{\sqrt{n}} \log(n)\). Therefore, \(f(n) \notin \omega(g(n))\).</p>

            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \log(n!)\) and \(g(n) = n \log(n)\). Is \(f(n)\) in \(\omega(g(n))\).</p>

                <p>Solution 1</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) belongs to \(\omega(g(n))\) where \(g(n) = n \log(n)\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>


                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substite the given functions:</p>

                <div class="equation-container">
                \[ \log(n!) \gt c \cdot n \log(n) \]
                </div>

                <p>Substitute the approximation above into the expression for \(\log(n!)\):</p>

                <div class="equation-container">
                \[ \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n log (e) \gt c \cdot n \log(n) \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (1 - c)n \log(n) - n \log(e) + \frac{1}{2} \log(n) + \frac{1}{2} \log(2\pi) \gt 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((1 - c)n \log(n)\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 1 - c \gt 0 \implies c \lt 1 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be smaller than \(1\). However, \(\omega(g(n))\) requires the inequality to hold for any positive \(c\), no matter how big.</p>

                <p>Since \(c \lt 1\) requires \(c\) to be at most \(1\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary large values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(\omega(g(n))\) because there exists a upper bound on \(c\) (namely \(1\)).</p>

                <p>Hence, \(f(n) = \log(n!) \notin \omega(g(n) = n \log(n))\).</p>

                <p>Solution 2</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) is in \(\omega(g(n))\) where \(g(n) = n \log(n)\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin o(g(n))\).</p>

                <p>Given \(f(n) = \log(n!)\) and \(g(n) = n \log(n)\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\log(n!)}{n \log(n)} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\log(n!)\):</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e)}{n \log(n)} = \lim_{n \to \infty} (\frac{\log (2\pi)}{2n \log(n)} + \frac{1}{2n} + 1 - \frac{log(e)}{log(n)}) \]
                </div>

                <p>As \(n\) approaches infinity, the term \(\frac{\log (2\pi)}{2n \log(n)}\), \(\frac{1}{2n}\) and \(\frac{log(e)}{log(n)}\) approach \(0\). Thus, the limit becomes:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} (\frac{\log(2\pi)}{2n \log(n)} + \frac{1}{2n} + 1 - \frac{log(e)}{log(n)}) = 1 \]
                </div>

                <p>Since the limit is \(1\) (and not \(\infty\)), the function \(f(n) = \log(n!)\) does not grow faster than \(g(n) = n \log(n)\). Therefore, \(f(n) \notin \omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) and \(g(n) = n\). Is \(f(n)\) in \(\omega(g(n))\).</p>

                <p>Solution 1</p>

                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) belongs to \(\omega(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \gt c \cdot n \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{2} − 11n + 12\):</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \gt c \cdot n \cdot (2n^{2} − 11n + 12) \]
                </div>

                <p>Expand the right-hand side, the inequality becomes:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \gt 2c \cdot n^{3} - 11c \cdot n^{2} + 12c \cdot n \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (4 - 2c)n^{3} + (11c − 28)n^{2} + (56 - 12c)n − 35 \gt 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((4 - 2c)n^{3}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 4 - 2c \gt 0 \implies c \lt 2 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be smaller than \(2\). However, \(\omega(g(n))\) requires the inequality to hold for any positive \(c\), no matter how big.</p>

                <p>Since \(c \lt 2\) requires \(c\) to be at most \(2\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary large values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(\omega(g(n))\) because there exists a upper bound on \(c\) (namely \(2\)).</p>

                <p>Hence, \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \notin \omega(g(n) = n)\).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) belongs to \(\omega(g(n))\) where \(g(n) = n\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in o(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) =  \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) and \(g(n) = n\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}}{n} \]
                </div>

                <p>Simplify the fraction:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{3} − 11n^{2} + 12n} \]
                </div>

                <p>Applying L'Hôpital's rule:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (4n^{3} − 28n^{2} + 56n − 35)}{\frac{d}{dn} \, (2n^{3} − 11n^{2} + 12n)} = \lim_{n \to \infty} \frac{12n^{2} − 56n + 56}{6n^{2} − 22n + 12} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (12n^{2} − 56n + 56)}{\frac{d}{dn} \, (6n^{2} − 22n + 12)} = \lim_{n \to \infty} \frac{24n − 56}{12n − 22} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (24n − 56)}{\frac{d}{dn} \, (12n − 22)} = \lim_{n \to \infty} \frac{24}{12} = 2 \]
                </div>

                <p>Since the limit is \(2\) (and not \(\infty\)), the function \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) does not grow faster than \(g(n) = n\). Therefore, \(f(n) \notin \omega(g(n))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) and \(g(n) = \frac{1}{n^{2}}\). Is \(f(n)\) in \(\omega(g(n))\).</p>

                <p>Solution 1</p>

                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) belongs to \(\omega(g(n))\) where \(g(n) = \frac{1}{n^{2}}\), we need to check if \(f(n)\) grows strictly faster than \(g(n)\) asymptotically. A function \(f(n)\) is in \(\omega(g(n))\) if for any given positive constant \(c\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ f(n) \gt c \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>Substituting the given functions:</p>

                <div class="equation-container">
                \[ \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \gt c \cdot \frac{1}{n^{2}} \]
                </div>

                <p>Multiply both sides by the denominators \(2n^{4} − 11n^{3} + 12n^{2} + 4n + 45\) and \(n^{2}\):</p>

                <div class="equation-container">
                \[ n^{2} (5n^{2} − 2n − 35) \gt c \cdot (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45) \]
                </div>

                <p>Expand the expression, the inequality becomes:</p>

                <div class="equation-container">
                \[ 5n^{4} − 2n^{3} − 35n^{2} \gt 2c \cdot n^{4} - 11c \cdot n^{3} + 12c \cdot n^{2} + 4c \cdot n + 45c \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (5 - 2c)n^{4} + (11c − 2)n^{3} - (12c + 35)n^{2} - 4c \cdot n - 45c \gt 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((5 - 2c)n^{4}\) must be positive or zero. If the dominant term \((5 - 2c)n^{4}\) becomes zero, the term \((11c − 2)n^{3}\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 5 - 2c \geq 0 \implies c \geq 2.5 \]
                </div>

                <p>This means that for the inequality to hold for large enough \(n\), \(c\) must be greater than or equal to \(2.5\). However, \(\omega(g(n))\) requires the inequality to hold for any positive \(c\), no matter how small.</p>

                <p>Since \(c \geq 2.5\) requires \(c\) to be at least \(2.5\), \(f(n)\) cannot grow faster than \(c \cdot n\) for arbitrary large values of \(c\). Therefore, \(f(n)\) does not satisfy the condition for \(\omega(g(n))\) because there exists a lower bound on \(c\) (namely \(2.5\)).</p>

                <p>Solution 2</p>
                
                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) belongs to \(\omega(g(n))\) where \(g(n) = \frac{1}{n^{2}}\) using limits, we need to evaluate the following limit:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{f(n)}{g(n)} \]
                </div>

                <p>If the limit is \(\infty\), then \(f(n) \in \omega(g(n))\). Otherwise, \(f(n) \notin \omega(g(n))\).</p>

                <p>Given \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) and \(g(n) = \frac{1}{n^{2}}\), we need to evaluate:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}}{\frac{1}{n^{2}}} \]
                </div>

                <p>Simplify the fraction:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{5n^{4} − 2n^{3} − 35n^{2}}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \]
                </div>

                <p>Applying L'Hôpital's rule:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (5n^{4} − 2n^{3} − 35n^{2})}{\frac{d}{dn} \, (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45)} = \lim_{n \to \infty} \frac{20n^{3} − 6n^{2} − 70n}{8n^{3} − 33n^{2} + 24n + 4} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (20n^{3} − 6n^{2} − 70n)}{\frac{d}{dn} \, (8n^{3} − 33n^{2} + 24n + 4)} = \lim_{n \to \infty} \frac{60n^{2} − 12n − 70}{24n^{2} − 66n + 24} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (60n^{2} − 12n − 70)}{\frac{d}{dn} \, (24n^{2} − 66n + 24)} = \lim_{n \to \infty} \frac{120n − 12}{48n − 66} \]
                </div>

                <p>Applying L'Hôpital's rule again:</p>

                <div class="equation-container">
                \[ \lim_{n \to \infty} \frac{\frac{d}{dn} \, (120n − 12)}{\frac{d}{dn} \, (48n − 66)} = \lim_{n \to \infty} \frac{120}{48} = \frac{5}{2} \]
                </div>

                <p>Since the limit is \(\frac{5}{2}\) (and not \(\infty\)), the function \(f(n) = \frac{5n^{4} − 2n^{3} − 35n^{2}}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) does not grow faster than \(g(n) = \frac{1}{n^{2}}\). Therefore, \(f(n) \notin \omega(g(n))\).</p>
            </div>
        </div>

        <h5 class="post-subtitle">Big–Theta Notation</h5>

        <p>Big Theta notation represents both the upper and lower bounds of the growth rate of a function. It provides a tight bound on the time or space complexity of an algorithm.</p>

        <p>Let \(f(n)\) and \(g(n)\) be functions that map positive integers to positive real numbers. We say that \(f(n)\) is \(\Theta(g(n))\) (or \(f(n) \in \Theta(g(n))\)) if and only if \(f(n) \in O(g(n))\) and \(f(n) \in \Omega(g(n))\).</p>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = 7n + 8\) and \(g(n) = n\). Is \(f(n)\) in \(\Theta(g(n))\)?</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = 7n + 8\) is in \(\Theta(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot n \leq 7n + 8 \leq c_2 \cdot n \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ 7n + 8 \leq c_2 \cdot n \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c_2 - 7)n - 8 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c_2 - 7)n\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ c_2 - 7 \gt 0 \implies c_2 \gt 7 \]
                </div>

                <p>We can choose \(c_2 = 8\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (8 - 7)n - 8 \geq 0 \]
                </div>

                <p>Solve for \(n\):</p>

                <div class="equation-container">
                \[ n \geq 8 \]
                </div>

                <p>Thus, we can choose \(c_2 = 8\) and it holds for \(n \geq 8\).</p>


                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ 7n + 8 \geq c_1 \cdot n \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (7 - c_1)n + 8 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((7 - c_1)n\) must be positive or zero. If the dominant term \((7 - c_1)n\) becomes zero, the term \(8\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 7 - c_1 \geq 0 \implies c_1 \lt 7 \]
                </div>

                <p>We can choose \(c_1 = 7\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (7 - 7)n + 8 \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 8 \geq 0 \]
                </div>

                <p>Thus, we can choose \(c_1 = 7\) and it holds for all \(n \geq 1\).</p>

                <p>To satisfy both conditions for \(n \geq n_0\), we can choose \(c_1 = 7\), \(c_2 = 8\), \(n_0 = 8\).</p>

                <p>Hence, \(f(n) = 7n + 8 \in \Theta(g(n) = n)\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = n^{3} + 20n + 1\) and \(g(n) = n^{3}\). Is \(f(n)\) in \(\Theta(g(n))\)?</p>
                
                <p>Solution</p>
                
                <p>To determine whether \(f(n) = n^{3} + 20n + 1\) is in \(\Theta(g(n))\) where \(g(n) = n^{3}\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot n^{3} \leq n^{3} + 20n + 1 \leq c_2 \cdot n^{3} \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ n^{3} + 20n + 1 \leq c_2 \cdot n^{3} \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c_2 - 1)n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c_2 - 1)n^{3}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ c_2 - 1 \gt 0 \implies c_2 \gt 1 \]
                </div>

                <p>We can choose \(c_2 = 2\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (2 - 1)n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ n^{3} - 20n - 1 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n^{3} - 20n - 1 \geq 0\) holds, we need to find the point where the positive terms (\(n^{3}\)) become dominant over the negative terms (\(20n\) and \(1\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(n^{3}\) is the highest-degree positive term and \(20n\) is the highest-degree negatiive term. We compare \(n^{3}\) with \(20n\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ n^{3} \gt 20n \implies n \gt \sqrt{20} \approx 4.4721 \]
                </div>

                <p>So, \(n^{3}\) starts to dominate \(20n\) when \(n\) is \(5\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{3} - 20n  1 \geq 0\) holds.</p>

                <p>For \(n = 5\):</p>

                <div class="equation-container">
                \[ 5^{3} - 20(5) - 1 = 125 - 20 - 1 = 24 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Thus, we can choose \(c_2 = 2\) and it holds for \(n \geq 5\).</p>


                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ n^{3} + 20n + 1 \geq c_1 \cdot n^{3} \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (1 - c_1)n^{3} + 20n + 1 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((1 - c_1)n^{3}\) must be positive or zero. If the dominant term \((1 - c_1)n^{3}\) becomes zero, the term \(20n\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 1 - c_1 \geq 0 \implies c_1 \leq 1 \]
                </div>

                <p>We can choose \(c_1 = 1\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (1 - 1)n^{3} + 20n + 1 \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 20n + 1 \geq 0 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>Thus, we can choose \(c_1 = 1\) and it holds for all \(n \geq 1\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = 1\), \(c_2 = 2\), \(n_0 = 5\)</p>

                <p>Hence, \(f(n) = n^{3} + 20n + 1 \in \Theta(g(n) = n^{3})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 2^{n+1}\) is \(\Theta(2^{n})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 2^{n+1}\) is in \(\Theta(g(n))\) where \(g(n) = 2^{n}\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot 2^{n} \leq 2^{n+1} \leq c_2 \cdot 2^{n} \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ 2^{n+1} \leq c_2 \cdot 2^{n} \]
                </div>

                <p>Divide both sides by \(2^{n}\):</p>

                <div class="equation-container">
                \[ 2 \leq c_2 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_2 = 2\) and it holds for all \(n \geq 1\).</p>

                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ 2^{n+1} \geq c_1 \cdot 2^{n} \]
                </div>

                <p>Divide both sides by \(2^{n}\):</p>

                <div class="equation-container">
                \[ 2 \geq c_1 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_1 = 2\) and it holds for all \(n \geq 1\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = 2\), \(c_2 = 2\), \(n_0 = 1\).</p>

                <p>Hence, \(f(n) = 2^{n+1} \in \Theta(g(n) = 2^{n})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = 10^{80}\) is \(\Theta(1)\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = 10^{80}\) is in \(\Theta(g(n))\) where \(g(n) = 1\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot 1 \leq 10^{80} \leq c_2 \cdot 1 \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ 10^{80} \leq c_2 \cdot 1 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 10^{80} \leq c_2 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_2 = 10^{80}\) and it holds for all \(n \geq 1\).</p>

                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ 10^{80} \geq c_1 \cdot 1 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 10^{80} \geq c_1 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_1 = 10^{80}\) and it holds for all \(n \geq 1\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = 10^{80}\), \(c_2 = 10^{80}\), and for all \(n \geq 1\).</p>

                <p>Hence, \(f(n) = 10^{80} \in \Theta(g(n) = 1)\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) is \(\Theta(\log(\log(n)))\)</p>

                <p>Solution</p>

                <p>Simplify the expression using the change of base formula, \(\log_{a}(x) = \frac{\log_{b}(x)}{\log_{b}(a)}\):</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) = \frac{\log(\log^{\log(100)}(n))}{\ln(5)} \]
                </div>

                <p>The expression inside the logarithm can be simplified using the logarithm power rule, \(\log⁡ (x^{y}) = y \cdot \log⁡(x)\):</p>

                <div class="equation-container">
                \[ \log(\log^{\log(100)}(n)) = \log(100) \cdot \log(\log(n)) \]
                </div>

                <p>So, the original expression becomes:</p>

                <div class="equation-container">
                \[ \frac{\log(\log^{\log(100)}(n))}{\ln(5)} = \frac{\log(100)}{\ln(5)} \cdot \log(\log(n)) \]
                </div>

                <p>To determine whether \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n))\) is in \(\Theta(g(n))\) where \(g(n) = \log(\log(n))\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot \log(\log(n)) \leq \log_{\ln(5)}(\log^{\log(100)}(n)) \leq c_2 \cdot \log(\log(n)) \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) \leq c_2 \cdot \log(\log(n)) \]
                </div>

                <p>Simplify the expression \(\log_{\ln(5)}(\log^{\log(100)}(n))\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \cdot \log(\log(n)) \leq c_2 \cdot \log(\log(n)) \]
                </div>

                <p>Divide both sides by \(\log(\log(n))\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \leq c_2 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_2 = \frac{\log(100)}{\ln(5)}\) and it holds for all \(n \geq 1\).</p>

                <p>To show \(f(n)\) is in \(\Theta(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ \log_{\ln(5)}(\log^{\log(100)}(n)) \geq c_1 \cdot \log(\log(n)) \]
                </div>

                <p>Simplify the expression \(\log_{\ln(5)}(\log^{\log(100)}(n))\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \cdot \log(\log(n)) \geq c_1 \cdot \log(\log(n)) \]
                </div>

                <p>Divide both sides by \(\log(\log(n))\):</p>

                <div class="equation-container">
                \[ \frac{\log(100)}{\ln(5)} \geq c_1 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_1 = \frac{\log(100)}{\ln(5)}\) and it holds for all \(n \geq 1\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = \frac{\log(100)}{\ln(5)}\), \(c_2 = \frac{\log(100)}{\ln(5)}\), and for all \(n \geq 1\).</p>

                <p>Hence, \(f(n) = \log_{\ln(5)}(\log^{\log(100)}(n)) \in \Theta(g(n) = \log(\log(n)))\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \binom{n}{\frac{n}{2}}\) is \(\Theta(\frac{2^{n}}{\sqrt{n}})\).</p>

                <p>Solution</p>

                <p>The binomial coefficient can be written as:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} = \frac{n!}{\left(\frac{n}{2}\right)!\left(\frac{n}{2}\right)!} \]
                </div>
				
                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Substituting Stirling's approximation for both \(n!\) and \(\left(\frac{n}{2}\right)!\), we get</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <div class="equation-container">
                \[ \left(\frac{n}{2}\right)! \approx \sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}} \]
                </div>

                <p>Substituting these approximations into the expression for \(\binom{n}{\frac{n}{2}}\), we obtain:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{(\sqrt{\pi n} (\frac{\frac{n}{2}}{e})^{\frac{n}{2}})^{2}} \]
                </div>

                <p>Simplifying the expression:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2\pi n} (\frac{n}{e})^{n}}{\pi n (\frac{\frac{n}{2}}{e})^{n}} \]
                </div>

                <p>Simplifying further:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \approx \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To determine whether \(f(n) = \binom{n}{\frac{n}{2}}\) is in \(\Theta(g(n))\) where \(g(n) = \frac{2^{n}}{\sqrt{n}}\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot \frac{2^{n}}{\sqrt{n}} \leq \binom{n}{\frac{n}{2}} \leq c_2 \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \leq c_2 \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Simplify the expression \(\binom{n}{\frac{n}{2}}\) using Stirling's approximation:</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \leq c_2 \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Divide both sides by \(\frac{2^{n}}{\sqrt{n}}\):</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \leq c_2 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_2 = \frac{\sqrt{2}}{\sqrt{\pi}}\) and it holds for all \(n \geq 1\).</p>

                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ \binom{n}{\frac{n}{2}} \geq c_1 \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Substitute the approximation above into the expression for \(\binom{n}{\frac{n}{2}}\):</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \cdot \frac{2^{n}}{\sqrt{n}} \geq c_1 \cdot \frac{2^{n}}{\sqrt{n}} \]
                </div>

                <p>Divide both sides by \(\frac{2^{n}}{\sqrt{n}}\):</p>

                <div class="equation-container">
                \[ \frac{\sqrt{2}}{\sqrt{\pi}} \geq c_1 \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>

                <p>We can choose \(c_1 = \frac{\sqrt{2}}{\sqrt{\pi}}\) and it holds for all \(n \geq 1\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = \frac{\sqrt{2}}{\sqrt{\pi}}\), \(c_2 = \frac{\sqrt{2}}{\sqrt{\pi}}\), and for all \(n \geq 1\).</p>

                <p>Hence, \(f(n) = \binom{n}{\frac{n}{2}} \in \Theta(g(n) = \frac{2^{n}}{\sqrt{n}})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) is \(\Theta(n)\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12}\) is in \(\Theta(g(n))\) where \(g(n) = n\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot n \leq \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \leq c_2 \cdot n \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \leq c_2 \cdot n \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{2} − 11n + 12\):</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \leq c_2 \cdot n \cdot (2n^{2} − 11n + 12) \]
                </div>

                <p>Expand the right-hand side, the inequality becomes:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \leq 2c_2 \cdot n^{3} - 11c_2 \cdot n^{2} + 12c_2 \cdot n \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (2c_2 - 4)n^{3} + (28 - 11c_2)n^{2} + (12c_2 - 56)n + 35 \geq 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large n, the dominant term \((2c_2 - 4)n^{3}\) must be positive or zero. If the dominant term \((2c_2 - 4)n^{3}\) becomes zero, the term \((28 - 11c_2)n^{2}\) can still satisfy the inequality for large \(n\). Therefore:</p>

                <div class="equation-container">
                \[ 2c_2 - 4 \geq 0 \implies c_2 \geq 2 \]
                </div>

                <p>We can choose \(c_2 = 2\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (2(2) - 4)n^{3} + (28 - 11(2))n^{2} + (12(2) - 56)n + 35 \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 6n^{2} - 32n + 35 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(6n^{2} - 32n + 35 \geq 0\) holds, we need to find the point where the positive terms (\(6n^{2}\) and \(35\)) become dominant over the negative terms (\(32n\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(6n^{2}\) is the highest-degree positive term and \(32n\) is the highest-degree negatiive term. We compare \(6n^{2}\) with \(32n\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ 6n^{2} \geq 32n \implies n \geq 5.4 \]
                </div>

                <p>So, \(6n^{2}\) starts to dominate \(32n\) when \(n\) is \(6\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(6n^{2} - 32n + 35 \geq 0\) holds.</p>

                <p>For \(n = 6\):</p>

                <div class="equation-container">
                \[ 6(6^{2}) - 32(6) + 35 = 216 - 192 + 35 = 59 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 5\):</p>

                <div class="equation-container">
                \[ 6(5^{2}) - 32(5) + 35 = 150 - 160 + 35 = 25 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 4\):</p>

                <div class="equation-container">
                \[ 6(4^{2}) - 32(4) + 35 = 96 - 128 + 35 = 3 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 3\):</p>

                <div class="equation-container">
                \[ 6(3^{2}) - 32(3) + 35 = 54 - 96 + 35 = -7 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Thus, we can choose \(c_2 = 2\) and \(n \geq 4\).</p>


                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \geq c_1 \cdot n \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{2} − 11n + 12\):</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \geq c_1 \cdot n \cdot (2n^{2} − 11n + 12) \]
                </div>

                <p>Expand the left-hand side, the inequality becomes:</p>

                <div class="equation-container">
                \[ 4n^{3} − 28n^{2} + 56n − 35 \geq 2c_1 \cdot n^{3} - 11c_1 \cdot n^{2} + 12c_1 \cdot n \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (4 - 2c_1)n^{3} + (11c_1 - 28)n^{2} + (56 - 12c_1)n - 35 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((4 - 2c_1)n^{3}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 4 - 2c_1 \gt 0 \implies c_1 \lt 2 \]
                </div>

                <p>We can choose \(c_1 = 1\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (4 - 2(1))n^{3} + (11(1) - 28)n^{2} + (56 - 12(1))n - 35 \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 2n^{3} - 17n^{2} + 44n - 35 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(2n^{3} - 17n^{2} + 44n - 35 \geq 0\) holds, we need to find the point where the positive terms (\(2n^{3}\) and \(44n\)) become dominant over the negative terms (\(17n^{2}\) and \(35\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(2n^{3}\) is the highest-degree positive term and \(17n^{2}\) is the highest-degree negative term. We compare \(2n^{3}\) with \(17n^{2}\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ 2n^{3} \geq 17n^{2} \implies n \geq 8.5 \]
                </div>

                <p>So, \(2n^{3}\) starts to dominate \(17n^{2}\) when \(n\) is \(9\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(2n^{3} - 17n^{2} + 44n - 35 \geq 0\) holds.</p>

                <p>For \(n = 9\):</p>

                <div class="equation-container">
                \[ 2(9^{3}) - 17(9^{2}) + 44(9) - 35 = 1458 - 1377 + 396 - 35 = 442 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 8\):</p>

                <div class="equation-container">
                \[ 2(8^{3}) - 17(8^{2}) + 44(8) - 35 = 1024 - 1088 + 352 - 35 = 253 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 6\):</p>

                <div class="equation-container">
                \[ 2(6^{3}) - 17(6^{2}) + 44(6) - 35 = 432 - 612 + 264 - 35 = 49 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 4\):</p>

                <div class="equation-container">
                \[ 2(4^{3}) - 17(4^{2}) + 44(4) - 35 = 128 - 272 + 176 - 35 = -3 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>For \(n = 5\):</p>

                <div class="equation-container">
                \[ 2(5^{3}) - 17(5^{2}) + 44(5) - 35 = 250 - 425 + 220 - 35 = 10 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>Thus, we can choose \(c_1 = 1\) and \(n \geq 5\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = 1\), \(c_2 = 2\), and \(n_0 = 5\).</p>

                <p>Hence, \(f(n) = \frac{4n^{3} − 28n^{2} + 56n − 35}{2n^{2} − 11n + 12} \in \Theta(g(n) = n)\).</p>

            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Prove that running time \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) is \(\Theta(\frac{1}{n^{2}})\)</p>

                <p>Solution</p>

                <p>To determine whether \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45}\) is in \(\Theta(g(n))\) where \(g(n) = \frac{1}{n^{2}}\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot \frac{1}{n^{2}} \leq \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \leq c_2 \cdot \frac{1}{n^{2}} \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \leq c_2 \cdot \frac{1}{n^{2}} \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{4} − 11n^{3} + 12n^{2} + 4n + 45\) and \(n^{2}\):</p>

                <div class="equation-container">
                \[ (5n^{2} − 2n − 35) \cdot n^{2} \leq c_2 \cdot (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45) \]
                </div>

                <p>Expand the expression, the inequality becomes:</p>

                <div class="equation-container">
                \[ 5n^{4} − 2n^{3} − 35n^{2} \leq 2c_2 \cdot n^{4} − 11c_2 \cdot n^{3} + 12c_2 \cdot n^{2} + 4c_2 \cdot n + 45c_2 \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (2c_2 - 5)n^{4} − (11c_2 - 2)n^{3} + (12c_2 + 35)n^{2} + (4c_2)n + 45c_2 \geq 0 \]
                </div>
                
                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((2c_2 - 5)n^{4}\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 2c_2 - 5 \gt 0 \implies c_2 \gt 2.5 \]
                </div>

                <p>We can choose \(c_2 = 3\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (2(3) - 5)n^{4} − (11(3) - 2)n^{3} + (12(3) + 35)n^{2} + (4(3))n + 45(3) \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ n^{4} − 31n^{3} + 71n^{2} + 12n + 135 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n^{4} − 31n^{3} + 71n^{2} + 12n + 135 \geq 0\) holds, we need to find the point where the positive terms (\(n^{4}\), \(71n^{2}\), \(12n\) and \(135\)) become dominant over the negative terms (\(31n^{3}\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(n^{4}\) is the highest-degree positive term and \(31n^{3}\) is the highest-degree negative term. We compare \(n^{4}\) with \(31n^{3}\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ n^{4} \geq 31n^{3} \implies n \geq 31 \]
                </div>

                <p>So, \(n^{4}\) starts to dominate \(31n^{3}\) when \(n\) is \(31\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{4} − 31n^{3} + 71n^{2} + 12n + 135 \geq 0\) holds.</p>

                <p>For \(n = 31\):</p>

                <div class="equation-container">
                \[ 31^{4} − 31(31^{3}) + 71(31^{2}) + 12(31) + 135 = 923521 - 923521 + 68131 + 372 + 135 = 68638 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 29\):</p>

                <div class="equation-container">
                \[ 29^{4} − 31(29^{3}) + 71(29^{2}) + 12(29) + 135 = 707281 - 756059 + 59711 + 348 + 135 = 11416 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 27\):</p>

                <div class="equation-container">
                \[ 27^{4} − 31(27^{3}) + 71(27^{2}) + 12(27) + 135 = 531441 - 610173 + 51759 + 324 + 135 = -26514 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>For \(n = 28\):</p>

                <div class="equation-container">
                \[ 28^{4} − 31(28^{3}) + 71(28^{2}) + 12(28) + 135 = 614656 - 680512 + 55664 + 336 + 135 = -9721 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Thus, we can choose \(c_2 = 3\) and \(n \geq 29\).</p>


                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \geq c_1 \cdot \frac{1}{n^{2}} \]
                </div>

                <p>Multiply both sides by the denominator \(2n^{4} − 11n^{3} + 12n^{2} + 4n + 45\) and \(n^{2}\):</p>

                <div class="equation-container">
                \[ (5n^{2} − 2n − 35) \cdot n^{2} \geq c_1 \cdot (2n^{4} − 11n^{3} + 12n^{2} + 4n + 45) \]
                </div>

                <p>Expand the expression, the inequality becomes:</p>

                <div class="equation-container">
                \[ 5n^{4} − 2n^{3} − 35n^{2} \geq 2c_1 \cdot n^{4} − 11c_1 \cdot n^{3} + 12c_1 \cdot n^{2} + 4c_1 \cdot n + 45c_1 \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (5 - 2c_1)n^{4} + (11c_1 - 2)n^{3} - (35 + 12c_1)n^{2} - (4c_1)n - 45c_1 \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((5 - 2c_1)n^{4}\) must be positive or zero. If the dominant term \((5 - 2c_1)n^{4}\) becomes zero, the term \((11c_1 - 2)n^{3}\) can still satisfy the inequality for large \(n\).  Therefore:</p>

                <div class="equation-container">
                \[ 5 - 2c_1 \geq 0 \implies c_1 \leq 2.5 \]
                </div>

                <p>We can choose \(c_1 = 2\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (5 - 2(2))n^{4} + (11(2) - 2)n^{3} - (35 + 12(2))n^{2} - (4(2))n - 45(2) \geq 0 \]
                </div>
                

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ n^{4} + 20n^{3} - 59n^{2} - 8n - 90 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(n^{4} + 20n^{3} - 59n^{2} - 8n - 90 \geq 0\) holds, we need to find the point where the positive terms (\(n^{4}\) and \(20n^{3}\)) become dominant over the negative terms (\(59n^{2}\), \(8n\) and \(90\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(n^{4}\) is the highest-degree positive term and \(59n^{2}\) is the highest-degree negative term. We compare \(n^{4}\) with \(59n^{2}\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ n^{4} \geq 59n^{2} \implies n \geq 7.68 \]
                </div>

                <p>So, \(n^{4}\) starts to dominate \(59n^{2}\) when \(n\) is \(8\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{4} + 20n^{3} - 59n^{2} - 8n - 90 \geq 0\) holds.</p>

                <p>For \(n = 8\):</p>

                <div class="equation-container">
                \[ 8^{4} + 20(8^{3}) - 59(8^{2}) - 8(8) - 90 = 4096 + 10240 - 3776 - 64 - 90 = 10506 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 6\):</p>

                <div class="equation-container">
                \[ 6^{4} + 20(6^{3}) - 59(6^{2}) - 8(6) - 90 = 1296 + 4320 - 2124 - 48 - 90 = 3354 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 4\):</p>

                <div class="equation-container">
                \[ 4^{4} + 20(4^{3}) - 59(4^{2}) - 8(4) - 90 = 256 + 1280 - 944 - 32 - 90 = 470 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 3\):</p>

                <div class="equation-container">
                \[ 3^{4} + 20(3^{3}) - 59(3^{2}) - 8(3) - 90 = 81 + 540 - 531 - 24 - 90 = -24 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>Thus, we can choose \(c_1 = 2\) and \(n \geq 3\).</p>

                <p>To satisfy both conditions, we can choose \(c_1 = 2\), \(c_2 = 3\), and \(n_0 = 29\).</p>

                <p>Hence, \(f(n) = \frac{5n^{2} − 2n − 35}{2n^{4} − 11n^{3} + 12n^{2} + 4n + 45} \in \Theta(g(n) = \frac{1}{n^{2}})\).</p>
            </div>
        </div>

        <div class="textbox">
            <p class="title">Example</p>
            <div class="content">
                <p>Let \(f(n) = \log(n!)\) and \(g(n) = n \log(n)\). Is \(f(n)\) in \(\Theta(g(n))\).</p>

                <p>Solution</p>

                <p>The factorials can be approximated using Stirling's approximation. Stirling's approximation states:</p>

                <div class="equation-container">
                \[ n! \approx \sqrt{2\pi n} (\frac{n}{e})^{n} \]
                </div>

                <p>Taking the logarithm of both sides:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n} (\frac{n}{e})^{n}) \]
                </div>

                <p>Using the properties of logarithms, we can simplify the expression:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \log (\sqrt{2\pi n}) + n \log (\frac{n}{e}) \]
                </div>

                <p>Simplify further:</p>

                <div class="equation-container">
                \[ \log(n!) \approx \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \]
                </div>

                <p>To determine whether \(f(n) = \log(n!)\) is in \(\Theta(g(n))\) where \(g(n) = n \log(n)\), we need to check if \(f(n)\) grows at the same rate as \(g(n)\) asymptotically. A function \(f(n)\) is in \(\Theta(g(n))\) if there exist positive real constants \(c_1 \gt 0\), \(c_2 \gt 0\) and there exists an integer constant \(n_0 \geq 1\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all} \quad n \geq n_0 \]
                </div>

                <p>We need to find \(c_1\), \(c_2\) such that:</p>

                <div class="equation-container">
                \[ c_1 \cdot n \log(n) \leq \log(n!) \leq c_2 \cdot n \log(n) \]
                </div>

                <p>To show \(f(n)\) is in \(O(g(n))\), we need to find \(c_2\) such that:</p>

                <div class="equation-container">
                \[ \log(n!) \leq c_2 \cdot n \log(n) \]
                </div>

                <p>Substitute the approximation above into the expression for \(\log(n!)\):</p>

                <div class="equation-container">
                \[ \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \leq c_2 \cdot n \log(n) \]
                </div>

                <p>Move all terms to right side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (c_2 - 1)n \log(n) + n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((c_2 - 1)n \log(n)\) must be positive or zero. If the dominant term \((c_2 - 1)n \log(n)\) becomes zero, the term \(n \log(e)\) can still satisfy the inequality for large \(n\).  Therefore:</p>

                <div class="equation-container">
                \[ c_2 - 1 \geq 0 \implies c_2 \geq 1 \]
                </div>

                <p>We can choose \(c_2 = 1\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ n \log(e) - \frac{1}{2} \log(n) - \frac{1}{2} \log(2\pi) \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 0.4343n - 0.5 \log(n) - 0.39905 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(0.4343n - 0.5 \log(n) - 0.39905 \geq 0\) holds, we need to find the point where the positive terms (\(0.4343n\)) become dominant over the negative terms (\(0.5 \log(n)\) and \(0.39905\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(0.4343n\) is the highest-degree positive term and  \(0.5 \log(n)\) is the highest-degree negative term. We compare \(0.4343n\) with \(0.5 \log(n)\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ 0.4343n \gt 0.5 \log(n) \]
                </div>

                <p>Divide both sides by \(0.5\)</p>

                <div class="equation-container">
                \[ 0.8686n \gt \log(n) \]
                </div>

                <p>The inequality holds for all \(n \geq 1\).</p>


                <p>To show \(f(n)\) is in \(\Omega(g(n))\), we need to find \(c_1\) such that:</p>

                <div class="equation-container">
                \[ \log(n!) \geq c_1 \cdot n \log(n) \]
                </div>

                <p>Substitute the approximation above into the expression for \(\log(n!)\):</p>

                <div class="equation-container">
                \[ \frac{1}{2} \log(2\pi) + \frac{1}{2} \log(n) + n \log(n) - n \log(e) \geq c_1 \cdot n \log(n) \]
                </div>

                <p>Move all terms to left side of the inequality and combine like terms:</p>

                <div class="equation-container">
                \[ (1 - c_1)n \log(n) - n \log(e) + \frac{1}{2} \log(n) + \frac{1}{2} \log(2\pi) \geq 0 \]
                </div>

                <p>For the inequality to hold for sufficiently large \(n\), the dominant term \((1 - c_1)n \log(n)\) must be positive. Therefore:</p>

                <div class="equation-container">
                \[ 1 - c_1 \gt 0 \implies c_1 \lt 1 \]
                </div>

                <p>We can choose \(c_1 = 0.5\). Then, the inequality becomes:</p>

                <div class="equation-container">
                \[ (1 - 0.5)n \log(n) - n \log(e) + \frac{1}{2} \log(n) + \frac{1}{2} \log(2\pi) \geq 0 \]
                </div>

                <p>Simplify the inequality:</p>

                <div class="equation-container">
                \[ 0.5n \log(n) - 0.4343n + 0.5 \log(n) + 0.39905 \geq 0 \]
                </div>

                <p>To estimate \(n\) for which \(0.5n \log(n) - 0.4343n + 0.5 \log(n) + 0.39905 \geq 0\) holds, we need to find the point where the positive terms (\(0.5n \log(n)\), \(0.5 \log(n)\), and \(0.39905\)) become dominant over the negative terms (\(0.4343n\)). We can compare terms based on their degree and the magnitude of their coefficients.</p>

                <p>\(0.5n \log(n)\) is the highest-degree positive term and \(0.4343n\) is the highest-degree negative term. We compare \(0.5n \log(n)\) with \(0.4343n\) to estimate \(n\).</p>

                <div class="equation-container">
                \[ 0.5n \log(n) \geq 0.4343n \]
                </div>

                <p>Divide both sides by \(0.5n\)</p>

                <div class="equation-container">
                \[ \log(n) \geq 0.8686 \]
                </div>

                <p>Exponentiate both sides to remove the logarithm:</p>

                <div class="equation-container">
                \[ n \geq 10^{0.8686} \approx 7.35 \]
                </div>

                <p>So, \(0.5n \log(n)\) starts to dominate \(0.4343n\) when \(n\) is \(8\) or larger.</p>

                <p>Let's approach it by testing positive values for \(n\) such that \(n^{4} + 20n^{3} - 59n^{2} - 8n - 90 \geq 0\) holds.</p>

                <p>For \(n = 8\):</p>

                <div class="equation-container">
                \[ 0.5(8) \log(8) - 0.4343(8) + 0.5 \log(8) + 0.39905 = 3.6124 - 3.4744 + 0.45155 + 0.39905 = 0.9886 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 7\):</p>

                <div class="equation-container">
                \[ 0.5(7) \log(7) - 0.4343(7) + 0.5 \log(7) + 0.39905 = 2.95835 - 3.0431 + 0.42255 + 0.39905 = 0.73685 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 5\):</p>

                <div class="equation-container">
                \[ 0.5(5) \log(5) - 0.4343(5) + 0.5 \log(5) + 0.39905 = 1.744925 - 2.1715 + 0.349485 + 0.39905 = 0.32196 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 3\):</p>

                <div class="equation-container">
                \[ 0.5(3) \log(3) - 0.4343(3) + 0.5 \log(3) + 0.39905 = 0.71165 - 1.3029 + 0.23855 + 0.39905 = 0.04635 \quad (\text{which} \: \gt 0) \]
                </div>

                <p>For \(n = 2\):</p>

                <div class="equation-container">
                \[ 0.5(2) \log(2) - 0.4343(2) + 0.5 \log(2) + 0.39905 = 0.3010 - 0.8686 + 0.1505 + 0.39905 = -0.01805 \quad (\text{which} \: \lt 0) \]
                </div>

                <p>To satisfy both conditions, we can choose \(c_1 = 0.5\), \(c_2 = 1\), and for all \(n \geq 2\).</p>

                <p>Hence, \(f(n) = \log(n!) \in \Theta(g(n) = n \log(n))\).</p>
            </div>
        </div>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/mathematics" class="tag">mathematics</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/algorithm" class="tag">algorithm</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/asymptotic-analysis" class="tag">asymptotic analysis</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/big-o" class="tag">big O</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/little-o" class="tag">little o</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/big-omega" class="tag">big omega</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/little-omega" class="tag">little omega</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/big-theta" class="tag">big theta</a></li>
		
	</ul>
</div>


    <div class="post-share">
	
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2024/09/19/asymptotic-notation/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2024/09/19/asymptotic-notation/" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2024/09/19/asymptotic-notation/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-09" /><category term="day-19" /><category term="mathematics" /><category term="algorithm" /><category term="asymptotic analysis" /><category term="big O" /><category term="little o" /><category term="big omega" /><category term="little omega" /><category term="big theta" /><summary type="html"><![CDATA[Explore the fundamentals of Asymptotic Notation, a crucial concept in algorithm analysis and mathematics. This page provides an in-depth look at different notations like Big O, Little o, Big Omega, Little Omega, and Big Theta. Learn how these notations are used to describe the efficiency and performance of algorithms as input sizes grow, helping you to understand and compare algorithms more effectively. Whether you're a student or a professional, this guide will enhance your understanding of algorithmic efficiency and complexity analysis.]]></summary></entry></feed>