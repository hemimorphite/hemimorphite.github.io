<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hemimorphite.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hemimorphite.github.io/" rel="alternate" type="text/html" /><updated>2024-07-15T08:18:50+00:00</updated><id>https://hemimorphite.github.io/feed.xml</id><title type="html">Hemimorphite</title><subtitle>Gain a better understanding of mathematics, chemistry, physics, and computer science. Our tutorials provide clear explanations and practical examples to help you learn and master these subjects. Helping learners of all levels to grasp fundamental concepts and hone their skills.</subtitle><entry xml:lang="en"><title type="html">Event Loop in Javascript</title><link href="https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript/" rel="alternate" type="text/html" title="Event Loop in Javascript" /><published>2024-07-15T06:21:00+00:00</published><updated>2024-07-15T06:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/15/event-loop-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Event Loop in Javascript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 15, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a single-threaded programming language. This means that JavaScript can do only one thing at a single point in time.</p>

        <p>The main thread is responsible for executing JavaScript code, performing rendering tasks, and handling user interactions. Since JavaScript is single-threaded, it can perform only one task at a time on the main thread.</p>

        <p>The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, and pushes, and pops functions onto and off the call stack in the execution phase.</p>

        <p>If a function takes a long time to execute, you cannot interact with the web browser during the function's execution because the page hangs.</p>

        <p>A function that takes a long time to complete is called a blocking function. Technically, a blocking function blocks all the interactions on the webpage, such as mouse clicks.</p>

        <p>The following example uses a big loop to simulate a blocking function:</p>

        <pre><code class="language-bash hljs">function task(message) {
    // emulate time consuming task
    let n = 10000000000;
    while (n > 0){
        n--;
    }
    console.log(message);
}

console.log('Start script...');
task('Doing a task');
console.log('Done!');</code></pre>

        <p>The script hangs for a few seconds (depending on how fast the computer is) and issues the following output:</p>

        <pre><code class="language-bash hljs">Start script...
Doing a task
Done!</code></pre>
        
        <p>The JavaScript Event Loop is a mechanism that enables JavaScript to perform non-blocking I/O operations despite being single-threaded. It allows asynchronous operations, such as handling user inputs, network requests, and timers, to be executed without blocking the main execution thread.</p>

        <p>The Event Loop is a continuous process that coordinates the execution of tasks in JavaScript. It is composed of several components that work together to facilitate asynchronous programming:</p>

        <ul>
            <li>Call Stack</li>
            <li>Web APIs</li>
            <li>Macrotask Queue</li>
            <li>Microtask Queue</li>
        </ul>

        <h5 class="post-subtitle">Call Stack</h5>

        <p>The call stack is a fundamental concept in JavaScript and plays a key role in understanding the language's asynchronous behavior. It is a data structure known as a Last In, First Out (LIFO) stack, which is responsible for keeping track of the function calls and their execution order. Whenever a function is called, it gets added to the call stack, and once it finishes executing, it is removed from the stack (sort of).</p>
        
        <p>JavaScript is single-threaded, meaning it has only one call stack that can handle one task at a time. This is why blocking operations, such as time-consuming calculations or network requests, can freeze the browser's UI until the task is completed.</p>
        
        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">function fifth() { 
    console.log("fifth")
}

function fourth() { 
    console.log("fourth")
    fifth() 
}

function third() { 
    console.log("third")
    fourth() 
}

function second() { 
    console.log("second")
    third() 
}

function first() {
    console.log("first") 
    second() 
}

first();</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>first</code> function call, a function execution context for <code>first</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-01.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>first</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"first"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>second</code> function call, a function execution context for  <code>second</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-02.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>second</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"second"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>third</code> function call, a function execution context for  <code>third</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-03.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>third</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"third"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>fourth</code> function call, a function execution context for  <code>fourth</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-04.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>fourth</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"fourth"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <code>fifth</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-05.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>fifth</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"fifth"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes function execution context for <code>fifth</code>, <code>fourth</code>, <code>third</code>, <code>second</code> and <code>first</code> consecutively from the call stack.</li>
            <li>The main thread removes the global execution context from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Web APIs</h5>

        <p>Web APIs are provided by the browser environment to extend JavaScript's functionality beyond its single-threaded nature. These APIs allow developers to access features like the DOM, timers, and network requests, enabling JavaScript to perform tasks asynchronously without blocking the call stack.</p>

        <p>When a function utilizing a Web API is called, the API handles the task in the background and returns a callback function. This callback is then placed into a queue, waiting to be executed once the call stack is empty.</p>

        <p>Here are some common examples of Web APIs: DOM (Document Object Model) API, Fetch API, Geolocation API, Canvas API, Web Storage API, etc.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 1000);

console.log('End');</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Start"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function call.</li>
            <li>The main thread creates a new function execution context and places it on the call stack.</li>
            <li>The main thread registers the callback function and the delay with the Web API.</li>
            <li>The Web API (e.g., the browser's timer system) sets up a timer that counts down in the background within the Web API environment from the specified delay (1000 milliseconds in this case).</li>
            <li>The main thread removes the function execution context from the call stack.</li>
            <li>When the timers expires after the specified delays, the Web API moves the callback function to the callback queue (or task queue).</li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"End"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>If the call stack is clear, the event loop pushes the first task from the callback queue onto the call stack and creates a new function execution context for the callback function.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Timeout"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context from the call stack.</li>
            <li>The main thread removes the global execution context from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Tasks and the Task Queue</h5>
        
        <p>Tasks are scheduled, synchronous blocks of code. While executing, they have exclusive access to the Call Stack and can also enqueue other tasks. Between Tasks, the browser can perform rendering updates. Tasks are stored in the Task Queue, waiting to be executed by their associated functions. These tasks come from:</p>

        <ul>
            <li>Timers (via setTimeout or setInterval)</li>
            <li>Event listeners (when an event is triggered)</li>
            <li>Network operations (when a response is received)</li>
        </ul>

        <p>The Task Queue is a FIFO (First In, First Out) data structure.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">setTimeout(function a() {
    console.log("task A")            
}, 1000);

setTimeout(function b() {
    console.log("task B")
}, 500);

setTimeout(function c() {
    console.log("task C")
}, 0);

function d() {
    console.log("task D")
}

d();</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function calls.</li>
            <li>The main thread creates new function execution contexts and places it on the call stack.</li>
            <li>The main thread registers the callback functions and the delays with the Web API.</li>
            <li>The Web API (e.g., the browser's timer system) sets up timers that count down in the background within the Web API environment from the specified delays.</li>
            <li>The main thread removes the function execution contexts for the <code>setTimeout</code> functions from the call stack.</li>
            <li>When the timers expires after the specified delays, the Web API moves the callback function to the callback queue (or task queue).<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-06.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>d</code> function call, a function execution context for <code>d</code> (or frame) is added to the call stack.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-07.jpg" alt="call stack">
                </figure>
            </li>
            <li>The <code>d</code> function's code is executed line-by-line.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task D"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes function execution context for <code>d</code> from the call stack.</li>
            <li>If the call stack is clear, the event loop pushes the first task from the callback queue onto the call stack and creates a new function execution context for the callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-08.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task C"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the callback function from the call stack.</li>
            <li>The event loop pushes the next task from the callback queue onto the call stack and creates a new function execution context for the callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-09.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task B"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context from the call stack.</li>
            <li>The event loop pushes the next task from the callback queue onto the call stack and creates a new function execution context for the callback function.<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-10.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task A"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
            <li>The main thread removes the global execution context from the call stack.</li>
        </ul>

        <h5 class="post-subtitle">Microtasks and the Microtask Queue</h5>

        <p>Microtasks are similar to Tasks in that they're scheduled, synchronous blocks of code with exclusive access to the Call Stack while executing. Additionally, they are stored in their own FIFO (First In, First Out) data structure, the Microtask Queue. Microtasks differ from Tasks, however, in that the Microtask Queue must be emptied out after a Task completes and before re-rendering.</p>

        <p>Microtasks and the Microtask Queue are also referred to as Jobs and the Job Queue.</p>
        
        <p>The microtask queue holds tasks that are prioritized over tasks in the task queue. Microtasks include promises and mutation observer callbacks. When the call stack is empty and before fetching tasks from the task queue, the event loop first processes all tasks in the microtask queue. This ensures that microtasks are executed as soon as possible.</p>

        <p>Here's an example:</p>

        <pre><code class="language-bash hljs">console.log("Start");

const promise = new Promise((resolve, reject) => {
    console.log("Promise executor function started");
    resolve("Promise resolved successfully");
});

promise.then((result) => {
    console.log(result);
});

setTimeout(function d() {
    console.log("task D");
}, 0);

function e() {
    console.log("task E");
}

e();

console.log("End");</code></pre>

        <p>The execution flow is as follows:</p>

        <ul>
            <li>The main thread starts by creating the global execution context.</li>
            <li>The main thread pushes the global execution context onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Start"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes Promise constructor call, and its execution context is created and pushed onto the call stack.</li>
            <li>The executor function within the Promise constructor initializes the promise.</li>
            <li>The main thread executes executor function call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Promise executor function started"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread executes resolve function call, and its execution context is created and pushed onto the call stack.</li>
            <li>Calling resolve transitions the promise from the pending state to the fulfilled (or resolved) state.</li>
            <li>The value "Promise resolved successfully" is set as the value of the promise.</li>
            <li>The main thread removes function execution context for <code>resolve</code> from the call stack.</li>
            <li>The executor function finishes its synchronous execution, and its execution context is popped off the call stack.</li>
            <li>Once the executor function completes its synchronous execution, the promise constructor itself has no more code to run.</li>
            <li>The Promise constructor completes, and its execution context is popped off the call stack.</li>
            <li>The main thread executes <code>.then()</code> method call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread moves the resolve callback function to the microtask queue (or job queue).<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-11.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread removes the execution context for <code>then()</code> from the call stack.</li>
            <li>The main thread executes <code>setTimeout</code> function calls.</li>
            <li>The main thread creates new function execution contexts and places it on the call stack.</li>
            <li>The main thread registers the callback functions and the delays with the Web API.</li>
            <li>The Web API (e.g., the browser's timer system) sets up timers that count down in the background within the Web API environment from the specified delays.</li>
            <li>The main thread removes the function execution contexts for <code>setTimeout</code> from the call stack.</li>
            <li>When the timer expires after the specified delay, the Web API moves the callback function to the callback queue (or task queue).<br>
                <figure class="post-figure">
                    <img src="/assets/images/callstack-12.jpg" alt="call stack">
                </figure>
            </li>
            <li>The main thread continues to execute any synchronous code that follows.</li>
            <li>The main thread executes <code>e</code> function call, and its execution context is created and pushed onto the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task E"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the execution context for <code>e</code> from the call stack.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"End"</code> to the console.</li>
            <li>The main thread removes function execution context for <code>console.log</code> from the call stack.</li>
            <li>After the current synchronous code finishes, the event loop proceeds to handle the microtask queue before handling any macrotasks.</li>
            <li>If there are microtasks in the microtask queue, the event loop moves the first microtask callback from the microtask queue to the call stack and creates a new function execution context for the resolve callback function.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"Promise resolved successfully"</code> to the console.</li>
            <li>The main thread removes the function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the resolve callback function from the call stack.</li>
            <li>After all microtasks have been processed, the event loop proceeds to handle macrotasks.</li>
            <li>The event loop moves the first macrotask callback from the macrotask queue to the call stack  and creates a new function execution context for the <code>setTimeout</code> callback function.</li>
            <li>The main thread executes <code>console.log</code> function call, a function execution context for <code>console.log</code> (or frame) is added to the call stack.</li>
            <li>The main thread logs <code>"task D"</code> to the console.</li>
            <li>The main thread removes the function execution context for <code>console.log</code> from the call stack.</li>
            <li>The main thread removes the function execution context for the <code>setTimeout</code> callback function from the call stack.</li>
            <li>The main thread removes the global execution context from the call stack.</li>
        </ul>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/event-loop" class="tag">event loop</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/call-stack" class="tag">call stack</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/web-api" class="tag">web api</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/macrotask" class="tag">macrotask</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/macrotask-queue" class="tag">macrotask queue</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/microtask" class="tag">microtask</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/microtask-queue" class="tag">microtask queue</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-15" /><category term="javascript" /><category term="event loop" /><category term="call stack" /><category term="web api" /><category term="macrotask" /><category term="macrotask queue" /><category term="microtask" /><category term="microtask queue" /><summary type="html"><![CDATA[The event loop is a fundamental concept in JavaScript that governs the asynchronous execution of code. It manages the order in which various tasks are processed, ensuring smooth and efficient operation of JavaScript programs. The event loop involves the interaction of the call stack, web API, macrotasks, microtasks, and their respective queues. Understanding the event loop is essential for developing responsive and high-performance JavaScript applications. This concept is particularly important for handling asynchronous operations, such as fetching data from servers or responding to user interactions.]]></summary></entry><entry xml:lang="en"><title type="html">Execution Context in JavaScript</title><link href="https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript/" rel="alternate" type="text/html" title="Execution Context in JavaScript" /><published>2024-07-13T08:30:00+00:00</published><updated>2024-07-13T08:30:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/13/execution-context-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Execution Context in JavaScript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 13, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a single-threaded programming language. This means that JavaScript can do only one thing at a single point in time.</p>

        <p>The JavaScript engine executes a script from the top of the file and works its way down. It creates the execution contexts, and pushes, and pops functions onto and off the call stack in the execution phase.</p>

        <p>When the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code.</p>
        
        <p>JavaScript Execution Context is the environment in which JavaScript code is executed. It contains information about the variables, functions, and objects that are available to the code being executed, as well as the scope chain and the value of the <code>this</code> keyword.</p>
        
        <p>Execution stack, also known as “calling stack” in other programming languages, is a stack with a LIFO (Last in, First out) structure, which is used to store all the execution context created during the code execution.</p>
        <p>There are two types of execution contexts:</p>

        <ul>
            <li><b>Global Execution Context (GEC)</b>: The Global Execution Context is also called the base/default execution. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. Each JavaScript file has only one GEC.</li>
            <li><b>Function Execution Context (FEC)</b>: When a function is called, the JavaScript engine creates a Function Execution Context within the GEC to execute the code within that function. Multiple FECs can exist during script runtime, as each function call has its own FEC. FEC can access the entire code of the GEC, but it is not possible for GEC to access all the code of the FEC. During the GEC code execution.</li>
        </ul>

        <p>When Global Execution Context or Function Execution Context is created. Execution of code is happening in two phases:</p>

        <ul>
            <li><b>Creation Phase</b>, the JavaScript engine sets up the environment for the code to be executed. During this phase, the JavaScript engine creates the following:<br>
                <ul>
                    <li><b>Variable Environment</b>: an Environment Record that holds bindings created by <code>var</code> declarations within this execution context.</li>
                    <li><b>Lexical Environment</b>: an Environment Record
                    used to resolve identifier references, ie. <code>let</code> or <code>const</code>, made by code within this execution context.<br><br>
                    An Environment Record is used to define the association of identifiers to specific variables and functions based upon the lexical nesting structure of the code. Each Environment Record has a reference to the outer environment, which could either point to the Global environment or an outer function environment, enabling the scope chain.<br><br>
                    The <b>Scope Chain</b> is a list of Variable Objects that are accessible in the current scope. Each Variable Object in the Scope Chain represents a higher level of scope.<br><br>
                    There are a few different types of environment records: Global Environment Record, Declarative Environment Record and Object Environment Record.<br><br>
                    The Global Environment Record is a composite environment record, made up of a Declarative Environment Record and an Object Environment Record.<br><br>
                    The Declarative Environment Record is associated with a scope containing variable, <code>const</code>, <code>let</code>, <code>class</code>, <code>module</code>, <code>import</code>, and/or <code>function</code> declarations. A Declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.<br><br>
                    The Object Environment Record is associated with an object called its binding object. Its binding object is the global object, which is window in the case of browsers.<br><br>
                    For every function declaration, a property is added to the record, pointing to that function, and that property is stored in memory. But function expressions are not included. This means all the function declarations will be stored and made accessible inside the execution context, even before the code starts running. This process of storing variables and function declaration in memory prior to the execution of the code is known as Hoisting.</li>
                    <li><b>Determining the value of the <code>this</code> keyword</b>: The value of <code>this</code> is determined and stored in the Execution Context. The value of <code>this</code> depends on how the function is called, and can refer to the global context, the current instance of an object (in the case of methods), or be set explicitly using functions like <code>call</code>, <code>apply</code>, or <code>bind</code>.</li>
                </ul><br>

                In the below code, <code>letter</code> is a binding identifier and the value the variable or binding contains is <code>"a"</code>. Note that variables or bindings contain values, they aren't the values themselves. This is important to understand, variables are containers for values.<br><br>

                <pre><code class="language-bash hljs">const letter = "a"
var number = 1

function greeting() {
    console.log('Welcome to Javascript')
}

const person = {
    name: "John Doe"
}</code></pre><br>
                The below snippet is a pseudo-code representation of execution context.<br><br>
                <pre><code class="language-bash hljs">GlobalExecutionContext = {
    LexicalEnvironment: {
        DeclarativeEnvironmentRecord: {
            letter: "a",
            greeting: &lt;ref. to greeting function object&gt;,
            outer: null
        },
        ObjectEnvironmentRecord: {
            window: &lt;ref.to Global object&gt;,
            this: &lt;ref.to window Object&gt;,
            person: {
                name: "John Doe"
            }
        }
    },
    VariableEnvironment: {
        DeclarativeEnvironmentRecord: {
            number: 1,
            outer: null
        }
    }
}</code></pre>
            </li>
            <li><b>Execution Phase</b>, the JavaScript engine executes the code line by line. The JavaScript engine reads the code and executes it one line at a time. This phase involves the following steps:<br>
                <ul>
                    <li><b>Assigning Values to Variables</b>: JavaScript engine assigns values to variables. If a variable is not initialized, it has the value of <code>undefined</code>.</li>
                    <li><b>Executing Functions and Code Blocks</b>: JavaScript engine executes functions and code blocks as it encounters them in the code. If a function is called, the engine creates a new execution context for that function and adds it to the call stack.</li>
                    <li><b>Managing the Call Stack</b>:  When a function is called, its execution context is added to the top of the call stack. When the function returns, its execution context is removed from the stack.</li>
                </ul>
            </li>
        </ul>

        <p>The two main components of an execution context in JavaScript are</p>

        <ul>
            <li><b>Memory Component</b> — This refers to the memory space that is allocated for the code and data components within the context. This includes variables, objects, arrays, and other data structures that are used or manipulated by the code. The memory component is also responsible for maintaining the scope chain, which is a list of variable objects that a function has access to, starting with its own variable object and continuing with the variable objects of its parent functions, all the way up to the global variable object.</li>
            <li><b>Code Component</b> — This refers to the actual code that is being executed within the context. It includes any function and variable declarations, as well as any other instructions that make up the code. During the creation phase of the execution context, the JavaScript engine sets up memory space for all variables and function declarations through a process known as hoisting.</li>
        </ul>

        <p>These two components enable the JavaScript engine to execute code and manage data within the program.</p>

        <p>Let's understand the Execution Context with the following code example below:</p>

        <pre><code class="language-bash hljs">function greeting() {
    console.log("Welcome to the JS world!");
}

greeting();

var number1 = 10;
var number2 = 5;

function add(number1, number2) {
    return number1 + number2;
}

function addExtra(number1, number2) {
    var extra = 15;
    return number1 + number2 + extra;
}

var result1 = add(number1, number2);
var result2 = addExtra(number1, number2);

console.log(result1);
console.log(result2);</code></pre>
        
        <p>Using the example code above, let's walk through each stage of what happens during the Memory Creation Phase:</p>

        <ul>
            <li>Javascript engine will create and push a global execution context into the call stack.</li>
            <li>Javascript engine will create the this object and bind it to the global object i.e., <code>window</code> in the web browser or <code>global</code> in Node.js.</li>
            <li>Javascript engine will create a new object called <code>this</code>, which is a reference to the current execution context.</li>
            <li>Javascript engine will set the value of this to the global object, which is the top-most object in the scope chain. In a browser, the global object is the window object, while in a Node.js environment, it's the global object.</li>
            <li>Javascript engine will allocate memory for variables <code>number1</code>, <code>number2</code>, <code>result1</code>, <code>result2</code> and assign undefined to them</li>
            <li>Javascript engine also allocates memory for function <code>greeting</code>, <code>add</code>, <code>addExtra</code> which includes space for the function's code, its name, and its scope.</li>
            <li>The below snippet is a pseudo-code representation of global execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">GlobalExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        greeting: &lt;ref. to greeting function object&gt;,
                        add: &lt;ref. to add function object&gt;,
                        addExtra: &lt;ref. to addExtra function object&gt;,
                        outer: null
                    },
                    ObjectEnvironmentRecord: {
                        window: &lt;ref.to Global object&gt;,
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        number1: undefined,
                        number2: undefined,
                        outer: null
                    }
                }
            }</code></pre>
            </li>
        </ul>

        <p>After the memory creation phase is completed, the Javascript engine moves on to the execution phase. The JS engines scan over the function in the code one more time, updating the variable object with the values of the variables and then running the code, which is known as an execution phase.</p>

        <p>Let's look at what happens during the execution phase:</p>

        <ul>
            <li><code>greeting</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>greeting</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 0 as its starting value.</li>
            <li>Javascript engine will create <code>this</code> object and bind to the global object.</li>
            <li>Here is a pseudo-code representation of <code>greeting</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">GreetingFunctionExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    },
                    ObjectEnvironmentRecord: {
                        arguments: {
                            length: 0
                        },
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    }
                }
            }</code></pre></li>
            <li>The <code>greeting</code> function execution context enters the Execution Phase.</li>
            <li>Javascript engine will display <code>"Welcome to the JS world!"</code> to the console.</li>
            <li>Here is a pseudo-code representation of <code>greeting</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">GreetingFunctionExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    },
                    ObjectEnvironmentRecord: {
                        arguments: {
                            length: 0
                        },
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    }
                }
            }</code></pre></li>
            <li>The <code>greeting</code> function execution context is returned and the call stack is popped off.</li>
            <li>Control returns to the global execution context.</li>
            <li>Javascript engine will assign 10 to <code>number1</code>.</li>
            <li>Javascript engine will assign 5 to<code>number2</code>.</li>
            <li><code>add</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>add</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 2 as its starting value.</li>
            <li>Assign the value of <code>number1</code> to the first index of the arguments object.</li>
            <li>Assign the value of <code>number2</code> to the second index of the arguments object.</li>
            <li>Javascript engine will create <code>number1</code> and <code>number2</code> variable in the function's local memory and assignthe corresponding values from the arguments object.</li>
            <li>Javascript engine will create <code>this</code> object and bind to the window object.</li>
            <li>Here is a pseudo-code representation of <code>add</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">AddFunctionExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        number1: 10,
                        number2: 5,
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    },
                    ObjectEnvironmentRecord: {
                        arguments: {
                            0: 10,
                            1: 5,
                            length: 2
                        },
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    }
                }
            }</code></pre></li>
            <li>The <code>add</code> function execution context enters the Execution Phase.</li>
            <li>The return statement is evaluated.</li>
            <li>Javascript engine will look up <code>number1</code>, <code>number2</code> variables in the function's local memory.</li>
            <li>Javascript engine locates the <code>number1</code>, <code>number2</code> variables in local memory, then swaps the values to the variable references.</li>
            <li>The evaluated result of the <code>add</code> function execution context is returned and the call stack is popped off.</li>
            <li>Here is a pseudo-code representation of <code>add</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">AddFunctionExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        number1: 10,
                        number2: 5,
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    },
                    ObjectEnvironmentRecord: {
                        arguments: {
                            0: 10,
                            1: 5,
                            length: 2
                        },
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    }
                }
            }</code></pre></li>
            <li>The control returns to its caller context (the global execution context) with the returned value of 15.</li>
            <li>Javascript engine will assign 15 to <code>result1</code>.</li>
            <li><code>addExtra</code> function is called, Javascript engine will create a new local execution context for it and push it to the top of the call stack.</li>
            <li>The <code>addExtra</code> function execution context enters the Creation Phase.</li>
            <li>Javascript engine will create arguments object in the function's local memory with a length of 2 as its starting value.</li>
            <li>Assign the value of <code>number1</code> to the first index of the arguments object.</li>
            <li>Assign the value of <code>number2</code> to the second index of the arguments object.</li>
            <li>Javascript engine will create <code>number1</code> and <code>number2</code> variables in the function's local memory and assign the corresponding values from the arguments object.</li>
            <li>Javascript engine will create <code>extra</code> variable in the function's local memory and assign undefined to it</li>
            <li>Javascript engine will create <code>this</code> object and bind to the window object.</li>
            <li>Here is a pseudo-code representation of <code>addExtra</code> function execution context during the creation phase:<br>
            <pre><code class="language-bash hljs">AddExtraFunctionExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        number1: 10,
                        number2: 5,
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    },
                    ObjectEnvironmentRecord: {
                        arguments: {
                            0: 10,
                            1: 5,
                            length: 2
                        },
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        extra: undefined,
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    }
                }
            }</code></pre></li>
            <li>The <code>addExtra</code> function execution context enters the Execution Phase.</li>
            <li>Javascript engine will assign 15 to <code>extra</code>.</li>
            <li>The return statement is evaluated.</li>
            <li>Javascript engine will look up <code>number1</code>, <code>number2</code>, <code>extra</code> variables in the function's local memory.</li>
            <li>Javascript engine locates the <code>number1</code>, <code>number2</code>, <code>extra</code> variables in local memory, then swaps the values to the variable references.</li>
            <li>The evaluated result of the <code>addExtra</code> function execution context is returned and the call stack is popped off.</li>
            <li>Here is a pseudo-code representation of <code>addExtra</code> function execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">AddExtraFunctionExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        number1: 10,
                        number2: 5,
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    },
                    ObjectEnvironmentRecord: {
                        arguments: {
                            0: 10,
                            1: 5,
                            length: 2
                        },
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        extra: 15,
                        outer: &lt;ref. to GlobalExecutionContext Lexical Environment&gt;
                    }
                }
            }</code></pre></li>
            <li>The control returns to its caller context (the global execution context) with the returned value of 30.</li>
            <li>Javascript engine will assign 30 to <code>result2</code>.</li>
            <li>Javascript engine will display <code>15</code> and <code>30</code> to the console.</li>
            <li>The below snippet is a pseudo-code representation of global execution context during the execution phase:<br>
            <pre><code class="language-bash hljs">GlobalExecutionContext = {
                LexicalEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        greeting: &lt;ref. to greeting function object&gt;,
                        add: &lt;ref. to add function object&gt;,
                        addExtra: &lt;ref. to addExtra function object&gt;,
                        outer: null
                    },
                    ObjectEnvironmentRecord: {
                        window: &lt;ref.to Global object&gt;,
                        this: &lt;ref.to window Object&gt;
                    }
                },
                VariableEnvironment: {
                    DeclarativeEnvironmentRecord: {
                        number1: 10,
                        number2: 5,
                        result1: 10,
                        result2: 30,
                        outer: null
                    }
                }
            }</code></pre>
            </li>
            <li>The global execution context is removed from the call stack or the call stack is popped off.</li>
        </ul>
        
        <figure class="post-figure">
            <img src="/assets/images/callstack-01.jpg" alt="Global Execution Context into the call stack">
        </figure>

        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/global-execution-context" class="tag">global execution context</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/function-execution-context" class="tag">function execution context</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/creation-phase" class="tag">creation phase</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/execution-phase" class="tag">execution phase</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-13" /><category term="javascript" /><category term="global execution context" /><category term="function execution context" /><category term="creation phase" /><category term="execution phase" /><summary type="html"><![CDATA[Execution context in JavaScript refers to the environment in which code is executed. This includes the global execution context, which encompasses code not within any function, and function execution contexts, which are created when functions are invoked. The execution context goes through two phases: the creation phase, where the JavaScript engine sets up the environment, and the execution phase, where the code is run. Understanding these concepts is crucial for effectively scoping variables and functions and comprehending how JavaScript code is processed.]]></summary></entry><entry xml:lang="en"><title type="html">Handling Asynchronous Operations in Node.js</title><link href="https://hemimorphite.github.io/2024/07/09/handling-asynchronous-operations-in-nodejs/" rel="alternate" type="text/html" title="Handling Asynchronous Operations in Node.js" /><published>2024-07-09T05:21:00+00:00</published><updated>2024-07-09T05:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/09/handling-asynchronous-operations-in-nodejs</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/09/handling-asynchronous-operations-in-nodejs/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Handling Asynchronous Operations in Node.js</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 09, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/nodejs.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>In Node JS, asynchronous operations allow us to perform tasks without blocking the main thread, enabling the application to handle multiple requests concurrently. These operations include reading/writing files, making HTTP requests, querying databases, and more.</p>

        <h5>Callbacks</h5>

        <p>A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.</p>

        <p>Synchronous callback functions execute instantly, but asynchronous callback functions execute at a later time.</p>

        <p>In this example, we have two functions: <code>greet</code> and <code>sayGoodbye</code>. The greet function takes two arguments: <code>name</code> (a string) and <code>callback</code> (a function).</p>

        <pre><code class="language-bash hljs">function greet(name, callback) {
    console.log(`Hello, ${name}!`);
    callback();
}

function sayGoodbye() {
    console.log("Goodbye!");
}; 

greet("Alice", sayGoodbye);</code></pre>

        <p>It will output:</p>

        <pre><code class="language-bash hljs">Hello, Alice!
Goodbye!</code></pre>

        <p>The <code>sayGoodbye</code> function is called immediately following the <code>greet</code> function's completion, making it an example of a synchronous callback function.</p>

        <p>In the next example, the <code>asyncOperation</code> function uses <code>setTimeout</code> to simulate an asynchronous task. The callback is executed after a delay of 1 second.</p>
        
        <p><code>setTimeout()</code> takes a callback function as an argument and executes the callback function after a specified amount of time.</p>

        <pre><code class="language-bash hljs">function asyncOperation(callback) {
    console.log("Start operation");
    setTimeout(function() {
        callback();
    }, 1000);
    console.log("End operation");
};

function callback() {
    console.log("Callback executed");
}

asyncOperation(callback);</code></pre>

        <p>It will output:</p>

        <pre><code class="language-bash hljs">Start operation
End operation
Callback executed</code></pre>

        <p>Callbacks can lead to callback hell or pyramid of doom, where multiple nested callbacks can make code hard to read and maintain.</p>
        
        <p>Here is a example of nested callbacks:</p>

        <pre><code class="language-bash hljs">function pyramidOfDoom() {
    setTimeout(() => {
        console.log(1);
        setTimeout(() => {
            console.log(2);
            setTimeout(() => {
                console.log(3);
                setTimeout(() => {
                    console.log(4);
                    setTimeout(() => {
                        console.log(5);
                    }, 3500);
                }, 1500);
            }, 500);
        }, 2000);
    }, 1000);
}</code></pre>

        <p>In the above code, each new <code>setTimeout</code> is nested inside a higher order function, creating a pyramid shape of deeper and deeper callbacks.</p>

        <p>Let's look at another example, say we have a list of users, their posts and their respective comments, like this:</p>

        <pre><code class="language-bash hljs">const users = [
    { id: 1, name: 'Luther Hargreeves' },
    { id: 2, name: 'Diego Hargreeves' },
    { id: 3, name: 'Allison Hargreeves' },
];
const posts = [
    { id: 1, title: 'First Post', user_id: 2 },
    { id: 2, title: 'Second Post', user_id: 1 },
    { id: 3, title: 'Third Post', user_id: 2 },
    { id: 4, title: 'Fourth Post', user_id: 2 },
    { id: 5, title: 'Fifth Post', user_id: 3 },
];

const comments = [
    { user_id: 2, post_id: 2, text: 'Great!'},
    { user_id: 3, post_id: 2, text: 'Nice Post!'},
    { user_id: 1, post_id: 3, text: 'Awesome Post!'},
];</code></pre>
        
        <p>Now, we will write a function to get a post by passing the post id. If the post is found, we will retrieve the comments related to that post.</p>

        <pre><code class="language-bash hljs">const getPost = (post_id, callback) => {
    const post = posts.find( post => post.id === post_id);
    setTimeout(() => {
        if(post) {
            callback(null, post);
        } else {
            callback("No such post found", undefined);
        }
    }, 1000);
};

const getUser = (user_id, callback) => {
    const user = users.find( user => user.id === user_id);
    setTimeout(() => {
        if(user) {
            callback(null, user);
        } else {
            callback("No such user found", undefined);
        }
    }, 500);
};

const getComments = (post_id, callback) => {
    const result = comments.filter( comment => comment.post_id === post_id);
    setTimeout(() => {
        if(result) {
            callback(null, result);
        } else {
            callback("No comments found", undefined);
        }
    }, 100);
}

getPost(2, (err, post) => {
    if (err) {
        console.error('Error getting post:', err);
    } else {
        getUser(post.user_id, (err, user) => {
            if (err) {
                console.error('Error getting user:', err);
            } else {
                console.log(`${user.name} created a post with title ${post.title}`);
                getComments(post.id, (err, comments) => {
                    if (err) {
                        console.error('Error getting comment:', err);
                    } else {
                        comments.forEach((comment) => {
                            getUser(comment.user_id, (err, user) => {
                                if(err) {
                                    console.error('Error getting user:', err);
                                }
                                else {
                                    console.log(`${user.name} comments: ${comment.text}`);
                                }
                            });
                        });
                    }
                });
            }
        });
    }
});</code></pre>

        <p>After executing the above code, you will see the following output:</p>

        <pre><code class="language-bash hljs">Luther Hargreeves created a post with title Second Post
Luther Hargreeves comment: Great! 
Allison Hargreeves comment: Nice Post!</code></pre>

        <h5>Promises</h5>

        <p>Promises help in solving the callback hell problem. A promise represents a value that may not be available yet but will be resolved in the future, either successfully with a value or unsuccessfully with an error.</p>

        <p>You can initialize a promise with the <code>new Promise</code> syntax, and you must initialize it with a function. The function that gets passed to a promise has <code>resolve</code> and <code>reject</code> parameters. The <code>resolve</code> and <code>reject</code> functions handle the success and failure of an operation, respectively.</p>
        
        <p>When we initialize a promise, it has a <code>pending</code> state and <code>undefined</code> value:</p>

        <pre><code class="language-bash hljs">// Initialize a promise
const promise = new Promise((resolve, reject) => {})
console.log(promise);
// Promise { &lt;state&gt;: "pending" }</code></pre>
        
        <p>When we call the <code>resolve</code> function and pass a value, it has a <code>fulfilled</code> state and a value.</p>
        
        <pre><code class="language-bash hljs">const promise = new Promise((resolve, reject) => {
    resolve('result value');
});
console.log(promise);
// Promise { &lt;state&gt;: "fulfilled", &lt;value&gt;: "result value" }</code></pre>
        
        <p>If we call <code>reject</code> function and pass a value, it will has a <code>rejected</code> state and a value.</p>

        <pre><code class="language-bash hljs">const promise = new Promise((resolve, reject) => {
    reject('error value');
});
console.log(promise);
// Promise { &lt;state&gt;: "rejected", &lt;value&gt;: "error value" }</code></pre>

        <p>A promise can have three possible states: pending, fulfilled, and rejected.</p>

        <ul>
            <li>Pending - Initial state before being resolved or rejected</li>
            <li>Fulfilled - Successful operation, promise has resolved</li>
            <li>Rejected - Failed operation, promise has rejected</li>
        </ul>

        <p>To get the result of the successful promise execution, we need to register a callback handler using <code>.then</code> like this:</p>

        <pre><code class="language-bash hljs">promise.then(function(result) {
    console.log(result); // result value
});</code></pre>

        <p>To catch the error, we need to register another callback using <code>.catch</code> like this:</p>

        <pre><code class="language-bash hljs">promise.then(function(result) {
    console.log(result); // result value
}).catch(function(error) {
    console.log(error);  // error value
});</code></pre>

        <p>For reference, here is a table with the handler methods on <code>Promise</code> objects:</p>

        <table>
            <thead>
                <tr>
                    <th>Method</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>then()</code>
                    </td>
                    <td>Handles a <code>resolve</code>. Returns a promise, and calls <code>onFulfilled</code> function asynchronously </td>
                </tr>
                <tr>
                    <td>
                        <code>catch()</code>
                    </td>
                    <td>Handles a <code>reject</code>. Returns a promise, and calls <code>onRejected</code> function asynchronously </td>
                </tr>
                <tr>
                    <td>
                        <code>finally()</code>
                    </td>
                    <td>Called when a promise is settled. Returns a promise, and calls <code>onFinally</code> function asynchronously </td>
                </tr>
            </tbody>
        </table>


        <p>One of the most useful and frequently used Web APIs that returns a promise is the Fetch API, which allows you to make an asynchronous resource request over a network. fetch is a two-part process, and therefore requires chaining then. This example demonstrates hitting the GitHub API to fetch a user's data, while also handling any potential error:</p>

        <pre><code class="language-bash hljs">// Fetch a user from the GitHub API
fetch('https://api.github.com/users/octocat')
    .then((response) => {
    return response.json()
    })
    .then((data) => {
    console.log(data)
    })
    .catch((error) => {
    console.error(error)
    });</code></pre>

        <p>The fetch request is sent to the <code>https://api.github.com/users/octocat</code> URL, which asynchronously waits for a response. The first then passes the response to an anonymous function that formats the response as JSON data, then passes the JSON to a second then that logs the data to the console. The catch statement logs any error to the console.</p>

        <p>Sometimes, you want to execute two or more related asynchronous operations, where the next operation starts with the result from the previous one. For example:</p>

        <pre><code class="language-bash hljs">let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 1000);
});

p.then((result) => {
    console.log(result); // 10
    return result * 2;
}).then((result) => {
    console.log(result); // 20
    return result * 3;
}).then((result) => {
    console.log(result); // 60
    return result * 4;
});</code></pre>

        <p>In the above example, the return value in the first <code>then()</code> method is passed to the second <code>then()</code> method and the return value in the second <code>then()</code> method is passed the third <code>then()</code>. Because the <code>then()</code> method returns a new <code>Promise</code> with a value resolved to a value, you can call the <code>then()</code> method on the return <code>Promise</code>.</p>

        <p>The way we call the <code>then()</code> method like this is often referred to as a promise chain.</p>

        <p>When you call the <code>then()</code> method multiple times on a promise, it is not the promise chaining. For example:</p>

        <pre><code class="language-bash hljs">let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 1000);
});
        
p.then((result) => {
    console.log(result); // 10
    return result * 2;
})

p.then((result) => {
    console.log(result); // 10
    return result * 3;
})

p.then((result) => {
    console.log(result); // 10
    return result * 4;
});</code></pre>

        <p>Here is the modified code of callback function example that uses Promises instead of callbacks:</p>

        <pre><code class="language-bash hljs">const users = [  
    { id: 1, name: 'Luther Hargreeves' },  
    { id: 2, name: 'Diego Hargreeves' },  
    { id: 3, name: 'Allison Hargreeves' },  
];  

const posts = [  
    { id: 1, title: 'First Post', user_id: 2 },  
    { id: 2, title: 'Second Post', user_id: 1 },  
    { id: 3, title: 'Third Post', user_id: 2 },  
    { id: 4, title: 'Fourth Post', user_id: 2 },  
    { id: 5, title: 'Fifth Post', user_id: 3 },  
];  

const comments = [  
    { user_id: 2, post_id: 2, text: 'Great!'},  
    { user_id: 3, post_id: 2, text: 'Nice Post!'},  
    { user_id: 1, post_id: 3, text: 'Awesome Post!'},  
];  

const getPost = (post_id) => {  
    return new Promise((resolve, reject) => {  
        const post = posts.find(post => post.id === post_id);  
        setTimeout(() => {  
            if (post) {  
                resolve(post);  
            } else {  
                reject("No such post found");  
            }  
        }, 1000);  
    });  
};  

const getUser = (user_id) => {  
    return new Promise((resolve, reject) => {  
        const user = users.find(user => user.id === user_id);  
        setTimeout(() => {  
            if (user) {  
                resolve(user);  
            } else {  
                reject("No such user found");  
            }  
        }, 500);  
    });  
};  

const getComments = (post_id) => {  
    return new Promise((resolve, reject) => {  
        const result = comments.filter(comment => comment.post_id === post_id);  
        setTimeout(() => {  
            if (result) {  
                resolve(result);  
            } else {  
                reject("No comments found");  
            }  
        }, 100);  
    });  
};  

getPost(2)  
    .then(post => {  
        return getUser(post.user_id)  
            .then(user => {  
                console.log(`${user.name} created a post with title ${post.title}`);  
                return getComments(post.id);  
            });  
    })  
    .then(comments => {  
        comments.forEach(comment => {  
            getUser(comment.user_id)  
                .then(user => {  
                    console.log(`${user.name} comments: ${comment.text}`);  
                })  
                .catch(err => {  
                    console.error('Error getting user:', err);  
                });  
        });  
    })  
    .catch(err => {  
        console.error('Error:', err);  
    }); </code></pre>

        <h5>Async/Await</h5>

        <p>An <code>async</code> function allows you to handle asynchronous code in a manner that appears synchronous. <code>async</code> functions still use promises under the hood, but have a more traditional JavaScript syntax.</p>

        <p>The <code>async</code> keyword allows you to define a function that handles asynchronous operations.</p>

        <p>To define an <code>async</code> function, you place the <code>async</code> keyword in front of the function as follows:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return `Hello, ${name}`;
}</code></pre>

        <p>Since <code>async</code> functions always returns a <code>Promise</code>, you can use <code>then()</code> method to consume it, like this:</p>

        <pre><code class="language-bash hljs">greet('Alison').then(console.log);</code></pre>

        <p>You can also explicitly return a <code>Promise</code> from the <code>greet()</code> function as shown in the following code:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.resolve(`Hello, ${name}`);
}</code></pre>

        <p>Besides the regular functions, you can use the <code>async</code> keyword in the function expressions:</p>

        <pre><code class="language-bash hljs">let greet = async function (name) {
    return `Hello, ${name}`;
}</code></pre>

        <p>Or in arrow functions:</p>

        <pre><code class="language-bash hljs">let greet = async (name) => `Hello, ${name}`;</code></pre>

        <p>Or in methods of classes:</p>

        <pre><code class="language-bash hljs">class person {
    async greet(name) {
        return `Hello, ${name}`;
    }
}</code></pre>

        <p>You use the <code>await</code> keyword to wait for a <code>Promise</code> to settle either in a resolved or rejected state.</p>
        
        <p>You cannot use the <code>await</code> keyword inside a sync function:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.resolve(`Hello, ${name}`);
}
function print() {
    let result = await greet('Alison');
    console.log(result);
}
print();
// SyntaxError: await is only valid in async functions, async generators and modules</code></pre>

        <p>You use the <code>await</code> keyword only inside an <code>async</code> function:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.resolve(`Hello, ${name}`);
}
async function print() {
    let result = await greet('Alison');
    console.log(result);
}

print(); // Hello, Alison</code></pre>

        <p>You cannot use the <code>await</code> keyword at the top level of a script:</p>

        <pre><code class="language-bash hljs">&lt;script&gt;
    async function greet(name) {
        return Promise.resolve(`Hello, ${name}`);
    }
    
    let result = await greet('Alison');
    // SyntaxError: await is only valid in async functions, async generators and modules
&lt;/script&gt;</code></pre>
        
        <p>Instead, make the script a module:</p>

        <pre><code class="language-bash hljs">&lt;script type="module"&gt;
    async function greet(name) {
        return Promise.resolve(`Hello, ${name}`);
    }
    
    let result = await greet('Alison');
    // SyntaxError: await is only valid in async functions, async generators and modules
&lt;/script&gt;</code></pre>

        <p>If a promise resolves normally, then <code>await promise</code> returns the result. But in case of a promise is rejected, it throws the error, just as if there were a <code>throw</code> statement at that line.</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.reject(new Error('Invalid name'));
}
async function print() {
    let result = await greet('Alison');
    console.log(result);
}

print(); // Uncaught (in promise) Error: Invalid name</code></pre>

        <p>The above code is the same as this:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    throw new Error('Invalid name');
}
async function print() {
    let result = await greet('Alison');
    console.log(result);
}

print(); // Uncaught (in promise) Error: Invalid name</code></pre>

        <p>You can catch the error by using the <code>try...catch</code> statement, the same way as a regular <code>throw</code> statement:</p>

        <pre><code class="language-bash hljs">async function greet(name) {
    return Promise.reject(new Error('Invalid name'));
}
async function print() {
    try {
        let result = await greet('Alison');
        console.log(result);
    } catch(error) {
        console.log(error);
    }
}

print(); // Uncaught (in promise) Error: Invalid name</code></pre>

        <p>Here is the modified code of callback function example that uses async/await instead of callbacks:</p>

        <pre><code class="language-bash hljs">const users = [  
    { id: 1, name: 'Luther Hargreeves' },  
    { id: 2, name: 'Diego Hargreeves' },  
    { id: 3, name: 'Allison Hargreeves' },  
];  

const posts = [  
    { id: 1, title: 'First Post', user_id: 2 },  
    { id: 2, title: 'Second Post', user_id: 1 },  
    { id: 3, title: 'Third Post', user_id: 2 },  
    { id: 4, title: 'Fourth Post', user_id: 2 },  
    { id: 5, title: 'Fifth Post', user_id: 3 },  
];  

const comments = [  
    { user_id: 2, post_id: 2, text: 'Great!'},  
    { user_id: 3, post_id: 2, text: 'Nice Post!'},  
    { user_id: 1, post_id: 3, text: 'Awesome Post!'},  
];  
  
const getPost = async (post_id) => {  
    return new Promise((resolve, reject) => {  
        const post = posts.find(post => post.id === post_id);  
        setTimeout(() => {  
            if (post) {  
            resolve(post);  
            } else {  
            reject("No such post found");  
            }  
        }, 1000);  
    });  
};  
  
const getUser = async (user_id) => {  
    return new Promise((resolve, reject) => {  
        const user = users.find(user => user.id === user_id);  
        setTimeout(() => {  
            if (user) {  
            resolve(user);  
            } else {  
            reject("No such user found");  
            }  
        }, 500);  
    });  
};  
  
const getComments = async (post_id) => {  
    return new Promise((resolve, reject) => {  
        const result = comments.filter(comment => comment.post_id === post_id);  
        setTimeout(() => {  
            if (result) {  
                resolve(result);  
            } else {  
                reject("No comments found");  
            }  
        }, 100);  
    });  
};  
  
async function main() {  
    try {  
        const post = await getPost(2);  
        const user = await getUser(post.user_id);  
        console.log(`${user.name} created a post with title ${post.title}`);  
        const comments = await getComments(post.id);  
        comments.forEach(async (comment) => {  
            const user = await getUser(comment.user_id);  
            console.log(`${user.name} comments: ${comment.text}`);  
        });  
    } catch (err) {  
        console.error('Error:', err);  
    }  
}  
  
main();</code></pre>
        </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/nodejs" class="tag">nodejs</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/async" class="tag">async</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/await" class="tag">await</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/promise" class="tag">promise</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/callback" class="tag">callback</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-09" /><category term="javascript" /><category term="nodejs" /><category term="async" /><category term="await" /><category term="promise" /><category term="callback" /><summary type="html"><![CDATA[Learn how to handle asynchronous operations in Node.js using callback functions, async/await, and promises. Get detailed explanations and examples to enhance your understanding.]]></summary></entry><entry xml:lang="en"><title type="html">__proto__ VS Prototype in Javascript</title><link href="https://hemimorphite.github.io/2024/07/07/proto-vs-prototype-in-javascript/" rel="alternate" type="text/html" title="__proto__ VS Prototype in Javascript" /><published>2024-07-07T11:21:00+00:00</published><updated>2024-07-07T11:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/07/proto-vs-prototype-in-javascript</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/07/proto-vs-prototype-in-javascript/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">__proto__ VS Prototype in Javascript</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 07, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, <code>null</code> has no prototype and acts as the final link in this prototype chain.</p>

        <p>Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has <code>null</code> for its own prototype.</p>

        <p>When you try to access a property of an object: if the property can't be found in the object itself, the prototype is searched for the property. If the property still can't be found, then the prototype's prototype is searched, and so on until either the property is found, or the end of the chain is reached, in which case <code>undefined</code> is returned.</p>

        <p>So when we call <code>myObject.toString()</code>, the Javascript engine follows the prototype chain to resolve the method:</p>

        <ul>
            <li>looks for <code>toString()</code> method in <code>myObject</code></li>
            <li>if the Javascript engine can't find it there, the Javascript engine looks into the prototype object of <code>myObject</code> for <code>toString()</code> method</li>
            <li>if the Javascript engine finds it there, the Javascript engine calls the <code>toString()</code> method.</li>
        </ul>

        <p>In JavaScript, <code>__proto__</code> and <code>prototype</code> are two related but distinct concepts that are often confused with each other.</p>

        <p><code>__proto__</code> (also called the Dunder Proto or Double Underscore Prototype) is a property of an object that points to its prototype. This property is used internally by the JavaScript engine to search for properties and methods on an object's prototype chain.</p>

        <p>The <code>__proto__</code> is not part of the ECMAScript standard, but is supported by browsers.</p>

        <p><code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> are the modern ways of getting access to and setting an object's prototype.</p>

        <p>Let's create an object literal:</p>

        <pre><code class="language-bash hljs">const myObject = {
    name: "John Doe",
    greet() {
        console.log(`Hello ${this.name}`);
    },
};
myObject.greet(); // Hello John Doe
myObject.__proto__ // Object { }
Object.getPrototypeOf(myObject); // Object { }</code></pre>

        <p><code>Object.prototype</code> is the most basic prototype, that all objects have by default. The prototype of <code>Object.prototype</code> is <code>null</code>, so it's at the end of the prototype chain.</p>

        <p>The prototype of an object is not always <code>Object.prototype</code>. For example:</p>

        <pre><code class="language-bash hljs">const myDate = new Date();
let object = myDate;

do {
    object = Object.getPrototypeOf(object);
    console.log(object);
} while (object);

// Date.prototype
// Object { }
// null</code></pre>

        <p><code>prototype</code> is a built-in property when you create an object from a constructor function. This is like a blueprint for all the objects created from that constructor function. It defines the shared properties and methods that all instances of that object will have.</p>

        <p>Let's create a constructor function:</p>

        <pre><code class="language-bash hljs">function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.getArea = function() {
    return Math.PI * Math.pow(this.radius, 2);
};

const circle1 = new Circle(5);
circle1.getArea();   // 78.53981633974483
const circle2 = new Circle(6);
circle2.getArea();   // 113.09733552923255
console.log(circle1.__proto__ === Circle.prototype); // true
console.log(circle2.__proto__ === Circle.prototype); // true</code></pre>

        <p>In the code above, the <code>getArea</code> method is contained in an object called <code>Circle.prototype</code>. When a new <code>Circle</code> instance is created, its <code>__proto__</code> property is set to <code>Circle.prototype</code>.</p>

        <pre><code class="language-bash hljs">circle1.getCircumference = function () {
    return Math.PI * 2 * this.radius;
}
circle1.getCircumference(); // 31.41592653589793
circle2.getCircumference(); // Uncaught TypeError: circle2.getCircumference is not a function</code></pre>

        <p>In the code above, the <code>getCircumference()</code> method is added to only <code>circle1</code> object and not on <code>Circle.prototype</code> or <code>circle2</code>.</p>

        <p>Here we are comparing the <code>__proto__</code> (which is the prototype from which the object was created), with the <code>prototype</code> (a property that only exists in constructor functions).</p>

        <pre><code class="language-bash hljs">const fn = () => {};
fn.__proto__ === Function.prototype;   // Output: true</code></pre>

        <p>Every function has a prototype property that points to the <code>Function.prototype</code> object. <code>fn</code> is an anonymous function created using the arrow function syntax. This means that <code>fn</code> inherits properties and methods from <code>Function.prototype</code>. For example, <code>fn</code> can use methods like <code>call()</code>, <code>apply()</code>, and <code>bind()</code> because they are defined on <code>Function.prototype</code>.</p>

        <pre><code class="language-bash hljs">const fn = () => {};
fn.__proto__ === new Function().__proto__ // Output: true</code></pre>
        
        <p><code>fn</code> is an anonymous function created using the arrow function syntax. <code>new Function()</code> creates a new function object using the Function constructor. The <code>__proto__</code> property of <code>fn</code> points to the same object as the <code>__proto__</code> property of the newly created function object using <code>new Function()</code>.</p>

        <pre><code class="language-bash hljs">const arr = [];
arr.__proto__ === Array.prototype;     // Output: true</code></pre>

        <p>Every array in JavaScript has a prototype property that points to the <code>Array.prototype</code> object. <code>arr</code> is an array created using the array literal syntax <code>[]</code>. This means that <code>arr</code> inherits properties and methods from <code>Array.prototype</code>, such as <code>push()</code>, <code>pop()</code>, and <code>forEach()</code>.</p>
        
        <pre><code class="language-bash hljs">const arr = [];
arr.__proto__ === new Array().__proto__;     // Output: true</code></pre>

        <p><code>arr</code> is an array created using the array literal syntax <code>[]</code>. <code>new Array()</code> creates a new array object using the Array constructor. The <code>__proto__</code> property of <code>arr</code> points to the same object as the <code>__proto__</code> property of the newly created array object using <code>new Array()</code>.</p>

        <pre><code class="language-bash hljs">const obj = {};
obj.__proto__ === Object.prototype;     // Output: true</code></pre>

        <p>Every object in JavaScript has a prototype property that points to the <code>Object.prototype</code> object. <code>obj</code> is an object created using the object literal syntax <code>{}</code>. This means that <code>obj</code> inherits properties and methods from <code>Object.prototype</code>, such as <code>toString()</code> and <code>hasOwnProperty()</code>.</p>
        
        <pre><code class="language-bash hljs">const obj = {};
obj.__proto__ === new Object().__proto__;     // Output: true</code></pre>
        
        <p><code>obj</code> is an object created using the object literal syntax <code>{}</code>. <code>new Object()</code> creates a new object using the Object constructor. The <code>__proto__</code> property of <code>obj</code> points to the same object as the <code>__proto__</code> property of the newly created object using <code>new Object()</code>.</p>

        <pre><code class="language-bash hljs">const str = 'Hello';
str.__proto__ === String.prototype;     // Output: true</code></pre>

        <p>Strings in Javascript have a prototype property that points to the <code>String.prototype</code> object. <code>str</code> is a string created using the string literal syntax <code>'Hello'</code>. This means that <code>str</code> inherits properties and methods from <code>String.prototype</code>, such as <code>toUpperCase()</code> and <code>substr()</code>.</p>
        
        <pre><code class="language-bash hljs">const str = 'Hello';
str.__proto__ === String.prototype;     // Output: true</code></pre>
        
        <p><code>str</code> is a string created using the string literal syntax <code>'Hello'</code>. <code>new String()</code> creates a new string object using the String constructor. The <code>__proto__</code> property of <code>str</code> points to the same object as the <code>__proto__</code> property of the newly created string object using <code>new String()</code>.</p>

        <pre><code class="language-bash hljs">const num = 123;
num.__proto__ === Number.prototype;     // Output: true</code></pre>
        
        <p>Numbers in JavaScript have a prototype property that points to the <code>Number.prototype</code> object. <code>num</code> is a number created using the number literal syntax 123. This means that <code>num</code> inherits properties and methods from <code>Number.prototype</code>, such as <code>toFixed()</code> and <code>toExponential()</code>.</p>
        
        <pre><code class="language-bash hljs">const num = 123;
num.__proto__ === new Number().__proto__;     // Output: true</code></pre>

        <p><code>num</code> is a number created using the number literal syntax 123. <code>new Number()</code> creates a new number object using the Number constructor. The <code>__proto__</code> property of <code>num</code> points to the same object as the <code>__proto__</code> property of the newly created number object using <code>new Number()</code>.</p>

        <pre><code class="language-bash hljs">const bool = true;
bool.__proto__ === Boolean.prototype;     // Output: true</code></pre>
        
        <p>Booleans in JavaScript have a prototype property that points to the <code>Boolean.prototype</code> object. <code>bool</code> is a boolean created using the boolean literal syntax <code>true</code>. This means that <code>bool</code> inherits properties and methods from <code>Boolean.prototype</code>, such as <code>toString()</code> and <code>valueOf()</code>.</p>
        
        <pre><code class="language-bash hljs">const bool = true;
bool.__proto__ === new Boolean().__proto__;     // Output: true</code></pre>

        <p><code>bool</code> is a boolean created using the boolean literal syntax <code>true</code>. <code>new Boolean()</code> creates a new boolean object using the Boolean constructor. The <code>__proto__</code> property of <code>bool</code> points to the same object as the <code>__proto__</code> property of the newly created boolean object using <code>new Boolean()</code>.</p>

</article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/prototype" class="tag">prototype</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/proto" class="tag">__proto__</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/inheritance" class="tag">inheritance</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/prototype-chain" class="tag">prototype chain</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-07" /><category term="day-07" /><category term="javascript" /><category term="prototype" /><category term="__proto__" /><category term="inheritance" /><category term="prototype chain" /><summary type="html"><![CDATA[Understanding the difference between __proto__ and prototype in JavaScript is crucial for grasping prototype-based inheritance. Learn the distinction, see examples, and gain clarity on these concepts.]]></summary></entry><entry xml:lang="en"><title type="html">Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations</title><link href="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-bigint-type-binary-and-arithmetic-operations/" rel="alternate" type="text/html" title="Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations" /><published>2024-07-05T11:21:00+00:00</published><updated>2024-07-05T11:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-bigint-type-binary-and-arithmetic-operations</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-bigint-type-binary-and-arithmetic-operations/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Javascript Language Specification: Abstract Operations of BigIInt Type Binary and Arithmetic Operations</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 05, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>An abstract operation is a conceptual operation that is not an actual operation in the language but is used to aid in the specification and understanding of a programming concept or system.</p>

        <p>The following abstract operations are defined over the BigInt type:</p>

        <table>
            <tbody>
                <tr>
                    <th>Operation</th>
                    <th>Example</th>
                    <th>Invoked by</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::unaryMinus</code>
                    </td>
                    <td>
                        <code>-x</code>
                    </td>
                    <td>
                        Unary <code>-</code> Operator
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseNOT</code>
                    </td>
                    <td>
                        <code>~x</code>
                    </td>
                    <td>
                        Bitwise NOT Operator (<code>~</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::exponentiate</code>
                    </td>
                    <td>
                        <code>x&nbsp;**&nbsp;y</code>
                    </td>
                    <td>
                        Exponentiation Operator (<code>**</code>)
                        and <code>Math.pow(base, exponent)</code>
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::multiply</code>
                    </td>
                    <td>
                        <code>x&nbsp;*&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::divide</code>
                    </td>
                    <td>
                        <code>x&nbsp;/&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                
                <tr>
                    <td>
                        <code>BigInt::remainder</code>
                    </td>
                    <td>
                        <code>x&nbsp;%&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> either a normal completion containing a BigInt or a throw completion </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::add</code>
                    </td>
                    <td>
                        <code>x ++</code>
                        <br>
                        <code>++ x</code>
                        <br>
                        <code>x&nbsp;+&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Increment Operator, Prefix Increment Operator, and The Addition Operator (<code>+</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                
                <tr>
                    <td>
                        <code>BigInt::subtract</code>
                    </td>
                    <td>
                        <code>x --</code>
                        <br>
                        <code>-- x</code>
                        <br>
                        <code>x&nbsp;-&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Decrement Operator, Prefix Decrement Operator, and The Subtraction Operator (<code>-</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::leftShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&lt;&nbsp;y</code>
                    </td>
                    <td>
                        The Left Shift Operator(<code>&lt;&lt;</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::signedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Signed Right Shift Operator(<code>&gt;&gt;</code>)
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td>  a throw completion  </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::lessThan</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&lt;=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;=&nbsp;y</code>
                    </td>
                    <td>
                        Relational Operators, via <code>IsLessThan (x, y, LeftFirst)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::equal</code>
                    </td>
                    <td>
                        <code>x&nbsp;==&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;===&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!==&nbsp;y</code>
                    </td>
                    <td>
                        Equality Operators, via <code>IsStrictlyEqual (x, y)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::sameValue</code>
                    </td>
                    <td>
                        <code>Object.is(x, y)</code>
                    </td>
                    <td> 
                        Object internal methods, via <code>SameValue (x, y)</code>, to test exact value equality 
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::sameValueZero</code>
                    </td>
                    <td>
                        <code>[x].includes(y)</code>
                    </td>
                    <td> 
                        Array, Map, and Set methods, via <code>SameValueZero (x, y)</code>, to test value equality, ignoring the difference between +0 and -0
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseAND</code>
                    </td>
                    <td>
                        <code>x&nbsp;&amp;&nbsp;y</code>
                    </td>
                    <td rowspan="3">
                        Binary Bitwise Operators
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseXOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;^&nbsp;y</code>
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::bitwiseOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;|&nbsp;y</code>
                    </td>
                    <td> BigInt </td>
                </tr>
                <tr>
                    <td>
                        <code>BigInt::toString</code>
                    </td>
                    <td>
                        <code>String(x)</code>
                    </td>
                    <td> Many expressions and built-in functions, via <code>ToString (argument)</code> 
                    </td>
                    <td> String </td>
                </tr>
            </tbody>
        </table>

        <h6>BigInt::unaryMinus (x)</h6>

        <p>The abstract operation <code>BigInt::unaryMinus</code> takes argument <code>x</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is 0, return 0.</li>
            <li>Return the BigInt value that represents the negation of <code>x</code>.</li>
        </ol>

        <pre><code class="language-bash hljs">BigInt.unaryMinus = function (x) {
    if(x === 0n) {
        return BigInt(x);
    }
    return -BigInt(x);
}
BigInt.unaryMinus(100n);</code></pre>
        
        <h6>BigInt::bitwiseNOT (x)</h6>

        <p>The abstract operation <code>BigInt::bitwiseNOT</code> takes argument <code>x</code> (a BigInt) and returns a BigInt. It returns the one's complement of x. It performs the following steps when called:</p>

        <ol>
            <li>Return -x - 1.</li>
            <li>Return the BigInt value that represents the negation of <code>x</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.bitwiseNOT = function (x) {
    return -BigInt(x) - 1;
}
BigInt.bitwiseNOT(100n);</code></pre>

        <h6>BigInt::exponentiate (base, exponent)</h6>

        <p>The abstract operation <code>BigInt::exponentiate</code> takes arguments <code>base</code> (a BigInt) and <code>exponent</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>exponent</code> < 0, throw a <code>RangeError</code> exception.</li>
            <li>If <code>base</code> is 0 and <code>exponent</code> is 0, return 1.</li>
            <li>Return the BigInt value that represents <code>base</code> raised to the power <code>exponent</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.exponentiate = function (base, exponent) {
    if(BigInt(exponent) < 0n) {
        // If exponent < 0, throw a RangeError exception
        throw new RangeError("The exponent must be greater than 0.");
    }
    if(BigInt(base) === 0n && BigInt(exponent) === 0n) {
        // If base is 0 and exponent is 0, return 1
        return BigInt(1);
    }

    // Return the BigInt value that represents base raised to the power exponent
    return BigInt(base) ** BigInt(exponent);
}
BigInt.exponentiate(100n, 100n);</code></pre>

        <h6>BigInt::multiply  (x, y)</h6>

        <p>The abstract operation <code>BigInt::multiply</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the product of <code>x</code> and <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.multiply = function (x, y) {
    // Return the BigInt value that represents the product of x and y
    return BigInt(x) * BigInt(y);
}
BigInt.multiply(100n, 100n);</code></pre>

        <h6>BigInt::divide (x, y)</h6>

        <p>The abstract operation <code>BigInt::divide</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>y</code> is 0, throw a <code>RangeError</code> exception.</li>
            <li>Let <code>quotient</code> be <code>x</code> / <code>y</code>.</li>
            <li>Return <code>truncate(quotient)</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.divide = function (x, y) {
    // If y is 0, throw a RangeError exception.
    if(BigInt(y) === 0n) {
        throw new RangeError("The divisor must be greater than 0.");
    }

    // Let quotient be x / y
    let quotient = BigInt(x) / BigInt(y);

    // Return truncate(quotient)
    return BigInt(quotient);
}
BigInt.divide(100n, 2n);</code></pre>

        <h6>BigInt::remainder (n, d)</h6>

        <p>The abstract operation <code>BigInt::remainder</code> takes arguments <code>n</code> (a BigInt) and <code>d</code> (a BigInt) and returns either a normal completion containing a BigInt or a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>If <code>d</code> is 0, throw a <code>RangeError</code> exception.</li>
            <li>If <code>n</code> is 0, return 0.</li>
            <li>Let <code>quotient</code> be <code>n</code> / <code>d</code>.</li>
            <li>Let <code>q</code> be <code>truncate(quotient)</code>.</li>
            <li>Return <code>n</code> - (<code>d</code> × <code>q</code>).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.remainder = function (n, d) {
    // If d is 0, throw a RangeError exception
    if(BigInt(d) === 0n) {
        throw new RangeError("The divisor must be greater than 0.");
    }

    // If n is 0, return 0
    if(BigInt(n) === 0n) {
        return BigInt(0);
    }

    // Let quotient be n / d
    let quotient = BigInt(n) / BigInt(d);

    // Let q be truncate(quotient)
    let q = quotient;

    // Return n - (d × q)
    return BigInt(n) - (BigInt(d) * BigInt(q));
}
BigInt.remainder(13n, 3n);</code></pre>

        <h6>BigInt::add (x, y)</h6>

        <p>The abstract operation <code>BigInt::add</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the sum of <code>x</code> and <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.add = function (x, y) {
    // Return the BigInt value that represents the sum of x and y
    return BigInt(x) + BigInt(y);
}
BigInt.add(13n, 3n);</code></pre>

        <h6>BigInt::subtract (x, y)</h6>

        <p>The abstract operation <code>BigInt::subtract</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return the BigInt value that represents the difference <code>x</code> minus <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.subtract = function (x, y) {
    // Return the BigInt value that represents the difference x minus y
    return BigInt(x) - BigInt(y);
}
BigInt.add(13n, 3n);</code></pre>

        <h6>BigInt::leftShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::leftShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>If <code>y</code> < 0, then<br>
                <ol>
                    <li>Return the BigInt value that represents $$x / 2^-y$$, rounding down to the nearest integer, including for negative numbers.</li>
                </ol>
            </li>
            <li>Return the BigInt value that represents $$x × 2^y$$.</li>
        </ol>
        
        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.leftShift = function (x, y) {
    if(y < 0) {
        // If y < 0, then return the BigInt value that represents x / 2^-y, rounding down to the nearest integer, including for negative numbers.
        return BigInt(x) / BigInt(2) ** BigInt(-y);
    }

    // Return the BigInt value that represents x × 2^y.
    return BigInt(x) * BigInt(2) ** BigInt(y);
}
BigInt.leftShift(13n, -3n);</code></pre>

        <h6>BigInt::signedRightShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::signedRightShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return <code>BigInt::leftShift(x, -y)</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.leftShift = function (x, y) {
    if(y < 0) {
        // If y < 0, then return the BigInt value that represents x / 2^-y, rounding down to the nearest integer, including for negative numbers.
        return BigInt(x) / BigInt(2) ** BigInt(-y);
    }

    // Return the BigInt value that represents x × 2^y.
    return BigInt(x) * BigInt(2) ** BigInt(y);
};
BigInt.signedRightShift = function (x, y) {
    // Return BigInt::leftShift(x, -y).
    return BigInt.leftShift(x, -y);
};
BigInt.signedRightShift(13n, -3n);</code></pre>


        <h6>BigInt::unsignedRightShift (x, y)</h6>

        <p>The abstract operation <code>BigInt::unsignedRightShift</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a throw completion. It performs the following steps when called:</p>

        <ol>
            <li>Throw a <code>TypeError</code> exception.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.unsignedRightShift = function (x, y) {
    throw new TypeError("Invalid operator") 
};
BigInt.unsignedRightShift(13n, -3n);</code></pre>

        <h6>BigInt::lessThan (x, y)</h6>

        <p>The abstract operation <code>BigInt::lessThan</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> < <code>y</code>, return <code>true</code>; otherwise return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.lessThan = function (x, y) {
    if(BigInt(x) < BigInt(y)) {
        // If x < y, return true; 
        return true;
    }else {
        // otherwise return false
        return false;
    }
};
BigInt.lessThan(13n, -13n);</code></pre>

        <h6>BigInt::equal (x, y)</h6>

        <p>The abstract operation <code>BigInt::equal</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> = <code>y</code>, return <code>true</code>; otherwise return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.lessThan = function (x, y) {
    if(BigInt(x) === BigInt(y)) {
        // If x = y, return true; 
        return true;
    }else {
        // otherwise return false
        return false;
    }
};
BigInt.lessThan(13n, -13n);</code></pre>

        <h6>BinaryAnd (x, y)</h6>

        <p>The abstract operation <code>BinaryAnd</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 and y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryAnd(x, y) {
    if(x === BigInt(1) && y === BigInt(1)) {
        // If x = 1 and y = 1, return 1;
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
BinaryAnd(1n, 0n);</code></pre>

        <h6>BinaryOr (x, y)</h6>

        <p>The abstract operation <code>BinaryOr</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 or y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryOr(x, y) {
    if(x === BigInt(1) || y === BigInt(1)) {
        // If x = 1 or y = 1, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
BinaryOr(1n, 0n);</code></pre>

        <h6>BinaryXor (x, y)</h6>

        <p>The abstract operation <code>BinaryXor</code> takes arguments <code>x</code> (0 or 1) and <code>y</code> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>

        <ol>
            <li>If x = 1 and y = 0, return 1.</li>
            <li>Else if x = 0 and y = 1, return 1.</li>
            <li>Else, return 0.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryXor(x, y) {
    if(x === BigInt(1) && y === BigInt(0)) {
        // If x = 1 and y = 0, return 1 
        return BigInt(1);
    } else if(x === BigInt(0) && y === BigInt(1)) {
        // Else if x = 0 and y = 1, return 1
        return BigInt(1);
    } else {
        // Else, return 0
        return BigInt(0);
    }
};
BinaryXor(1n, 0n);</code></pre>


        <h6>BigIntBitwiseOp (op, x, y)</h6>

        <p>The abstract operation <code>BigIntBitwiseOp</code> takes arguments <code>op</code> (<code>&</code>, <code>^</code>, or <code>|</code>), <code>x</code> (a BigInt), and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Set <code>x</code> to <code>x</code>.</li>
            <li>Set <code>y</code> to <code>y</code>.</li>
            <li>Let <code>result</code> be 0.</li>
            <li>Let <code>shift</code> be 0.</li>
            <li>Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1),<br>
                <ol>
                    <li>Let <code>xDigit</code> be <code>x</code> modulo 2.</li>
                    <li>Let <code>yDigit</code> be <code>y</code> modulo 2.</li>
                    <li>If <code>op</code> is <code>&</code>, set <code>result</code> to $$result + 2^shift × BinaryAnd(xDigit, yDigit)$$.</li>
                    <li>Else if <code>op</code> is <code>|</code>, set <code>result</code> to $$result + 2^shift × BinaryOr(xDigit, yDigit)$$.</li>
                    <li>Else<br>
                        <ol>
                            <li>Assert: <code>op</code> is <code>^</code>.</li>
                            <li>Set <code>result</code> to $$result + 2^shift × BinaryXor(xDigit, yDigit)$$.</li>
                        </ol>
                    </li>
                    <li>Set <code>shift</code> to <code>shift</code> + 1.</li>
                    <li>Set <code>x</code> to $$(x - xDigit) / 2$$.</li>
                    <li>Set <code>y</code> to $$(y - yDigit) / 2$$.</li>
                </ol>
            </li>
            <li>If <code>op</code> is <code>&</code>, let <code>tmp</code> be <code>BinaryAnd(x modulo 2, y modulo 2)</code>.</li>
            <li>Else if <code>op</code> is <code>|</code>, let <code>tmp</code> be <code>BinaryOr(x modulo 2, y modulo 2)</code>.</li>
            <li>Else,<br>
                <ol>
                    <li>Assert: <code>op</code> is <code>^</code>.</li>
                    <li>Let <code>tmp</code> be <code>BinaryXor(x modulo 2, y modulo 2)</code>.</li>
                </ol>
            </li>
            <li>If <code>tmp</code> ≠ 0, then<br>
                <ol>
                    <li>Set <code>result</code> to $$result - 2^shift$$.</li>
                    <li>NOTE: This extends the sign.</li>
                </ol>
            </li>
            <li>Return the BigInt value for <code>result</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};</code></pre>

        <h6>BigInt::bitwiseAND (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseAND</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(&, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryAnd(x, y) {
    if(x === BigInt(1) && y === BigInt(1)) {
        // If x = y, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseAND = function (x, y) {
    return BigIntBitwiseOp('&', x, y);
}
BigInt.bitwiseAND(102n, 875n);</code></pre>

        <h6>BigInt::bitwiseXOR (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseXOR</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(^, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryXor(x, y) {
    if(x === BigInt(1) && y === BigInt(0)) {
        // If x = 1 and y = 0, return 1 
        return BigInt(1);
    } else if(x === BigInt(0) && y === BigInt(1)) {
        // Else if x = 0 and y = 1, return 1
        return BigInt(1);
    } else {
        // Else, return 0
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseXOR = function (x, y) {
    return BigIntBitwiseOp('^', x, y);
}
BigInt.bitwiseXOR(102n, 875n);</code></pre>

        <h6>BigInt::bitwiseOR (x, y)</h6>

        <p>The abstract operation <code>BigInt::bitwiseOR</code> takes arguments <code>x</code> (a BigInt) and <code>y</code> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>

        <ol>
            <li>Return BigIntBitwiseOp(|, x, y).</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function BinaryOr(x, y) {
    if(x === BigInt(1) || y === BigInt(1)) {
        // If x = 1 or y = 1, return true; 
        return BigInt(1);
    }else {
        // otherwise return false
        return BigInt(0);
    }
};
function BigIntBitwiseOp(op, x, y) {
    // Set x to x
    x = BigInt(x);
    // Set y to y
    y = BigInt(y);
    // Let result be 0
    let result = BigInt(0);
    // Let shift be 0
    let shift = BigInt(0);
    // Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1)
    do {
        // Let xDigit be x modulo 2
        let xDigit = x % BigInt(2);
        // Let yDigit be y modulo 2
        let yDigit = y % BigInt(2);
        
        if(op === '&') {
            // If op is &, set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
            result = result + (BigInt(2) ** shift) * BinaryAnd(xDigit, yDigit);
            
        } else if(op === '|') {
            // Else if op is |, set result to result + 2^shift × BinaryOr(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryOr(xDigit, yDigit);
        } else {
            // Else op is ^.
            // Set result to result + 2^shift × BinaryXor(xDigit, yDigit)
            result = result + BigInt(2) ** shift * BinaryXor(xDigit, yDigit);
        }
        // Set shift to shift + 1
        shift = shift + BigInt(1);
        // Set x to (x - xDigit) / 2
        x = (x - xDigit) / BigInt(2);
        // Set y to (y - yDigit) / 2
        y = (y - yDigit) / BigInt(2);
        
        if((x === BigInt(0) || x === BigInt(-1)) && (y === BigInt(0) || y === BigInt(-1))) {
            break;
        }
    }
    while (true);

    if(op === '&') {
        // If op is &, let tmp be BinaryAnd(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryAnd(x % BigInt(2), y % BigInt(2)));
        
    } else if(op === '|') {
        // Else if op is |, let tmp be BinaryOr(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryOr(x % BigInt(2), y % BigInt(2)));
    } else {
        // Else
        // Assert: op is ^
        // Let tmp be BinaryXor(x modulo 2, y modulo 2)
        tmp = BigInt(BinaryXor(x % BigInt(2), y % BigInt(2)));
    }

    if(tmp !== BigInt(0)) {
        result = result - BigInt(2) ** shift;
    }
    
    return BigInt(result);
};
BigInt.bitwiseOR = function (x, y) {
    return BigIntBitwiseOp('|', x, y);
}
BigInt.bitwiseOR(102n, 875n);</code></pre>

        <h6>BigInt::toString (x, radix)</h6>

        <p>The abstract operation <code>BigInt::toString</code> takes arguments <code>x</code> (a BigInt) and <code>radix</code> (an integer in the inclusive interval from 2 to 36) and returns a String. It represents <code>x</code> as a String using a positional numeral system with radix <code>radix</code>. The digits used in the representation of a BigInt using radix <code>r</code> are taken from the first <code>r</code> code units of <b>"0123456789abcdefghijklmnopqrstuvwxyz"</b> in order. The representation of BigInts other than 0 never includes leading zeroes. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> < 0, return the string-concatenation of <code>"-"</code> and <code>BigInt::toString(-x, radix)</code>.</li>
            <li>Return the String value consisting of the representation of <code>x</code> using radix <code>radix</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">BigInt.toString = function (x, radix) {
    if(x < BigInt(0)) {
        return "-" + BigInt.toString(-x, radix);
    }

    let result = "";
    let number = BigInt(x);

    while(number > BigInt(0n)) {    
        let remainder = number % BigInt(radix);
            
        if (remainder === BigInt(10n)) {
            result = "A" + result;
        } else if (remainder === BigInt(11n)) {
            result = "B" + result;
        } else if (remainder === BigInt(12n)) {
            result = "C" + result;
        } else if (remainder === BigInt(13n)) {
            result = "D" + result;
        } else if (remainder === BigInt(14n)) {
            result = "E" + result;
        } else if (remainder === BigInt(15n)) {
            result = "F" + result;
        } else if (remainder === BigInt(16n)) {
            result = "G" + result;
        } else if (remainder === BigInt(17n)) {
            result = "H" + result;
        } else if (remainder === BigInt(18n)) {
            result = "I" + result;
        } else if (remainder === BigInt(19n)) {
            result = "J" + result;
        } else if (remainder === BigInt(20n)) {
            result = "K" + result;
        } else if (remainder === BigInt(21n)) {
            result = "L" + result;
        } else if (remainder === BigInt(22n)) {
            result = "M" + result;
        } else if (remainder === BigInt(23n)) {
            result = "N" + result;
        } else if (remainder === BigInt(24n)) {
            result = "O" + result;
        } else if (remainder === BigInt(25n)) {
            result = "P" + result;
        } else if (remainder === BigInt(26n)) {
            result = "Q" + result;
        } else if (remainder === BigInt(27n)) {
            result = "R" + result;
        } else if (remainder === BigInt(28n)) {
            result = "S" + result;
        } else if (remainder === BigInt(29n)) {
            result = "T" + result;
        } else if (remainder === BigInt(30n)) {
            result = "U" + result;
        } else if (remainder === BigInt(31n)) {
            result = "V" + result;
        } else if (remainder === BigInt(32n)) {
            result = "W" + result;
        } else if (remainder === BigInt(33n)) {
            result = "X" + result;
        } else if (remainder === BigInt(34n)) {
            result = "Y" + result;
        } else if (remainder === BigInt(35n)) {
            result = "Z" + result;
        } else {
            result = remainder + result;
        }    
        
        number = number / radix;
    }
    return result;
}
BigInt.toString(123456789012345678901234567890n, 16n);</code></pre>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/abstract-operation" class="tag">abstract operation</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Complete Reference" /><category term="year-2024" /><category term="month-07" /><category term="day-05" /><category term="javascript" /><category term="abstract operation" /><summary type="html"><![CDATA[Learn about the abstract operations of the BigInt type in JavaScript, focusing on binary and arithmetic operations. This article provides examples, algorithms, and explanations to help you understand these concepts better.]]></summary></entry><entry xml:lang="en"><title type="html">Javascript Language Specification: Abstract Operations of Number Type Binary and Arithmetic Operations</title><link href="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-number-type-binary-and-arithmetic-operations/" rel="alternate" type="text/html" title="Javascript Language Specification: Abstract Operations of Number Type Binary and Arithmetic Operations" /><published>2024-07-05T11:00:00+00:00</published><updated>2024-07-05T11:00:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-number-type-binary-and-arithmetic-operations</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-abstract-operations-of-number-type-binary-and-arithmetic-operations/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Javascript Language Specification: Abstract Operations of Number Type Binary and Arithmetic Operations</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 05, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>An abstract operation is a conceptual operation that is not an actual operation in the language but is used to aid in the specification and understanding of a programming concept or system.</p>

        <p>The following abstract operations are defined over the Number object:</p>

        <table>
            <tbody>
                <tr>
                    <th>Operation</th>
                    <th>Example</th>
                    <th>Invoked by</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td>
                        <code>Number::unaryMinus</code>
                    </td>
                    <td>
                        <code>-x</code>
                    </td>
                    <td>
                        Unary <code>-</code> Operator
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseNOT</code>
                    </td>
                    <td>
                        <code>~x</code>
                    </td>
                    <td>
                        Bitwise NOT Operator (<code>~</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::exponentiate</code>
                    </td>
                    <td>
                        <code>x&nbsp;**&nbsp;y</code>
                    </td>
                    <td>
                        Exponentiation Operator (<code>**</code>)
                        and <code>Math.pow(base, exponent)</code>
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::multiply</code>
                    </td>
                    <td>
                        <code>x&nbsp;*&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::divide</code>
                    </td>
                    <td>
                        <code>x&nbsp;/&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> Number </td>
                </tr>
                
                <tr>
                    <td>
                        <code>Number::remainder</code>
                    </td>
                    <td>
                        <code>x&nbsp;%&nbsp;y</code>
                    </td>
                    <td>
                        Multiplicative Operators
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::add</code>
                    </td>
                    <td>
                        <code>x ++</code>
                        <br>
                        <code>++ x</code>
                        <br>
                        <code>x&nbsp;+&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Increment Operator, Prefix Increment Operator, and The Addition Operator (<code>+</code>)
                    </td>
                    <td> Number </td>
                </tr>
                
                <tr>
                    <td>
                        <code>Number::subtract</code>
                    </td>
                    <td>
                        <code>x --</code>
                        <br>
                        <code>-- x</code>
                        <br>
                        <code>x&nbsp;-&nbsp;y</code>
                    </td>
                    <td>
                        Postfix Decrement Operator, Prefix Decrement Operator, and The Subtraction Operator (<code>-</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::leftShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&lt;&nbsp;y</code>
                    </td>
                    <td>
                        The Left Shift Operator(<code>&lt;&lt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::signedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Signed Right Shift Operator(<code>&gt;&gt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::unsignedRightShift</code>
                    </td>
                    <td>
                        <code>x&nbsp;&gt;&gt;&gt;&nbsp;y</code>
                    </td>
                    <td>
                        The Unsigned Right Shift Operator (<code>&gt;&gt;&gt;</code>)
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::lessThan</code>
                    </td>
                    <td>
                        <code>x&nbsp;&lt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&lt;=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;&gt;=&nbsp;y</code>
                    </td>
                    <td>
                        Relational Operators, via <code>IsLessThan (x, y, LeftFirst)</code>
                    </td>
                    <td> Boolean or <code>undefined</code> (for unordered inputs) </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::equal</code>
                    </td>
                    <td>
                        <code>x&nbsp;==&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!=&nbsp;y</code>
                        <br>
                        <code>x&nbsp;===&nbsp;y</code>
                        <br>
                        <code>x&nbsp;!==&nbsp;y</code>
                    </td>
                    <td>
                        Equality Operators, via <code>IsStrictlyEqual (x, y)</code>
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::sameValue</code>
                    </td>
                    <td>
                        <code>Object.is(x, y)</code>
                    </td>
                    <td> 
                        Object internal methods, via <code>SameValue (x, y)</code>, to test exact value equality 
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::sameValueZero</code>
                    </td>
                    <td>
                        <code>[x].includes(y)</code>
                    </td>
                    <td> 
                        Array, Map, and Set methods, via <code>SameValueZero (x, y)</code>, to test value equality, ignoring the difference between +0 and -0
                    </td>
                    <td> Boolean </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseAND</code>
                    </td>
                    <td>
                        <code>x&nbsp;&amp;&nbsp;y</code>
                    </td>
                    <td>
                        Binary Bitwise Operators
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseXOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;^&nbsp;y</code>
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::bitwiseOR</code>
                    </td>
                    <td>
                        <code>x&nbsp;|&nbsp;y</code>
                    </td>
                    <td> Number </td>
                </tr>
                <tr>
                    <td>
                        <code>Number::toString</code>
                    </td>
                    <td>
                        <code>String(x)</code>
                    </td>
                    <td> Many expressions and built-in functions, via <code>ToString (argument)</code> 
                    </td>
                    <td> String </td>
                </tr>
            </tbody>
        </table>

        <h5 class="post-subtitle">Number::unaryMinus(x)</h5>

        <p>The abstract operation <code>Number::unaryMinus</code> takes argument <code>x</code> (a Number) and returns a <code>Number</code>. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>Return the result of negating <code>x</code>; that is, compute a <code>Number</code> with the same magnitude but opposite sign.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.unaryMinus = function(x) {
            if (Number.isNaN(x)) {
                // if x is NaN, return NaN
                return Number.NaN;
            } else {
                // return the result of negating
                return Number(-x);
            }
        };
        Number.unaryMinus(Number(100));</code></pre>

        <h5 class="post-subtitle">Number::bitwiseNOT(x)</h5>

        <p>The abstract operation <code>Number::bitwiseNOT</code> takes argument <code>x</code> (a Number) and returns a Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>oldValue</code> be <code>!ToInt32(x)</code></li>
            <li>Return the result of applying bitwise complement to <code>oldValue</code>. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.</li>
        </ol>

        <p>The <code>!ToInt32(x)</code> just means that we are certain that this call to <code>ToInt32</code> will never return an exception</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.bitwiseNOT = function(x) {
    // return the result of applying bitwise complement to x
    return Number(~x);
};
Number.bitwiseNOT(Number(100));</code></pre>

        <h5 class="post-subtitle">Number::exponentiate (base, exponent)</h5>

        <p>The abstract operation <code>Number::exponentiate</code> takes arguments <code>base</code> (a Number) and <code>exponent</code> (a Number) and returns a Number. It returns an implementation-approximated value representing the result of raising base to the exponent power. It performs the following steps when called:</p>

        <ol>
            <li>If <code>exponent</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>exponent</code> is either +0 or -0, return <code>1</code>.</li>
            <li>If <code>base</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>base</code> is +∞, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, return +∞. Otherwise, return +0</li>
                </ol>
            </li>
            <li>If <code>base</code> is -∞, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, then<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -∞. Otherwise, return +∞.</li>
                        </ol>
                    </li>
                    <li>Else<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -0. Otherwise, return +0.</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>If <code>base</code> is +0, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, return +0. Otherwise, return +∞.</li>
                </ol>
            </li>
            <li>If <code>base</code> is -0, then<br>
                <ol>
                    <li>If <code>exponent</code> > +0, return +0. Otherwise, return +∞.<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -0. Otherwise, return +0.</li>
                        </ol>
                    </li>
                    <li>Else,<br>
                        <ol>
                            <li>If <code>exponent</code> is an odd integral Number, return -∞. Otherwise, return +∞.</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>
                Assert: <code>base</code> is finite and is neither +0 nor -0.
            </li>
            <li>If <code>exponent</code> is +∞, then<br>
                <ol>
                    <li>If <code>abs(base)</code> > 1, return +∞.</li>
                    <li>If <code>abs(base)</code> = 1, return <code>NaN</code>.</li>
                    <li>If <code>abs(base)</code> < 1, return +0.</li>
                </ol>
            </li>
            <li>If <code>exponent</code> is -∞, then<br>
                <ol>
                    <li>If <code>abs(base)</code> > 1, return +0.</li>
                    <li>If <code>abs(base)</code> = 1, return <code>NaN</code>.</li>
                    <li>If <code>abs(base)</code> < 1, return +∞.</li>
                </ol>
            </li>
            <li>Assert: <code>exponent</code> is finite and is neither +0 nor -0.</li>
            <li>If <code>base</code> < -0 and <code>exponent</code> is not an integral Number, return <code>NaN</code>.</li>
            <li>Return an implementation-approximated Number value representing the result of raising <code>base</code> to the <code>exponent</code> power.</li>
        </ol>

        <pre><code class="language-bash hljs">Number.exponentiate = function(base, exponent) {
    if(Number.isNaN(exponent)) {
        // if exponent is NaN, return NaN
        return Number.NaN;
    }
    if(Number(exponent) === 0) {
        // if exponent is either +0 or -0, return 1
        return 1;
    }
    if(Number.isNaN(base)) {
        // if base is NaN, return NaN
        return Number.NaN;
    }
    if(Number(base) === +Infinity) {
        // if base is +∞
        if(Number(exponent) > 0) {
            // if exponent > +0, return +∞
            return +Infinity;
        } else {
            // otherwise, return +0
            return Number(0);
        }
    }
    if(Number(base) === -Infinity) {
        // if base is -∞, then
        if(Number(exponent) > 0) {
            // if exponent > +0, then
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -∞
                return -Infinity;
            }
            else {
                // otherwise, return +∞
                return +Infinity;
            }
        } else {
            // else
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -0
                return Number(-0);
            }
            else {
                // otherwise, return +0.
                return Number(0);
            }
        }
    }
    if(Number(base) === Infinity) {
        // f base is +∞, then
        if(Number(exponent) > 0) {
            // If exponent > +0, return +∞
            return Infinity;
        }
        else {
            // Otherwise, return +0
            return Number(0);
        }
    }
    if(Number(base) === -Infinity) {
        // if base is -∞, then
        if(exponent > 0) {
            // if exponent > +0 then
            if(exponent % 2 === 1) {
                // if exponent is an odd integral Number, return -∞
                return -Infinity;
            }
            else {
                // otherwise, return +∞
                return Infinity;
            }
        }
        else {
            // else
            if(exponent % 2 === 1) {
                // if exponent is an odd integral Number, return -0
                return Number(-0);
            }
            else {
                // otherwise, return +0
                return Number(0);
            }
        }
    }
    if(1/Number(base) === Infinity) {
        // if base is +0, then
        if(Number(exponent) > 0) {
            // if exponent > +0, return +0
            return Number(0);
        }
        else {
            // otherwise, return +∞
            return Infinity;
        }
    }
    if(1/Number(base) === -Infinity) {
        // if base is -0, then
        if(Number(exponent) > 0) {
            // if exponent > +0 then
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -0
                return Number(-0);
            }
            else {
                // Otherwise, return +0
                return Number(0);
            }
        }
        else {
            // else
            if(Number(exponent) % 2 === 1) {
                // if exponent is an odd integral Number, return -∞
                return -Infinity;
            }
            else {
                // otherwise, return +∞
                return Infinity;
            }
        }
    }
    // base is finite and is neither +0 nor -0
    if(exponent === Infinity) {
        // if exponent is +∞, then
        if(Math.abs(base) > 1) {
            // if abs(base) > 1, return +∞
            return Infinity;
        }
        if(Math.abs(base) === 1) {
            // if abs(base) = 1, return NaN
            return Number.NaN;
        }
        if(Math.abs(base) <  1) {
            // If abs(base) < 1, return +0
            return Number(0);
        }
    }

    if(exponent === -Infinity) {
        // if exponent is -∞, then
        if(Math.abs(base) > 1) {
            // if abs(base) > 1, return +0
            return Number(0);
        }
        if(Math.abs(base) === 1) {
            // if abs(base) = 1, return NaN.
            return Number.NaN;
        }
        if(Math.abs(base) <  1) {
            // if abs(base) < 1, return +∞
            return Infinity;
        }
    }

    // exponent is finite and is neither +0 nor -0
    if(base < 0 && Math.isNaN(exponent)) {
        // if base < -0 and exponent is not an integral Number, return NaN.
        return Number.NaN;
    }
    // return an implementation-approximated Number value representing the result of raising base to the exponent power.
    return Number(base) ** Number(exponent);
};
Number.exponentiate(Number(2), Number(1.2));</code></pre>

        <h5 class="post-subtitle">Number::multiply (x, y)</h5>

        <p>The abstract operation <code>Number::multiply</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs multiplication according to the rules of IEEE 754-2019 binary double-precision arithmetic, producing the product of <code>x</code> and <code>y</code>. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> or <code>y</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>x</code> is either +∞ or -∞, then<br>
                <ol>
                    <li>If <code>y</code> is either +0 or -0, return <code>NaN</code>.</li>
                    <li>If <code>y</code> > +0, return <code>x</code>.</li>
                    <li>Return <code>-x</code>.</li>
                </ol>
            </li>
            <li>If <code>y</code> is either +∞ or -∞, then<br>
                <ol>
                    <li>If <code>x</code> is either +0 or -0, return <code>NaN</code>.</li>
                    <li>If <code>x</code> > +0, return <code>y</code>.</li>
                    <li>Return <code>-y</code>.</li>
                </ol>
            </li>
            <li>If x is -0, then<br>
                <ol>
                    <li>If <code>y</code> is -0 or <code>y</code> < -0, return +0.</li>
                    <li>Else, return -0.</li>
                </ol>
            </li>
            <li>If y is -0, then<br>
                <ol>
                    <li>If <code>x</code> < -0, return +0.</li>
                    <li>Else, return -0.</li>
                </ol>
            </li>
            <li>Return <code>x</code> × <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.multiply = function(x, y) {
    if(Number.isNaN(x) || Number.isNaN(y)) {
        // if x is NaN or y is NaN, return NaN
        return Number.NaN;
    }
    if(Number(x) === +Infinity || Number(x) === -Infinity) {
        // if x is either +∞ or -∞, then
        if(1/Number(y) === +Infinity || 1/Number(y) === -Infinity) {
            // If y is either +0 or -0, return NaN
            return Number.NaN;
        }

        if(Number(y) > 0) {
            // If y > +0, return x
            return Number(x);
        }
        // Return -x
        return Number(-x);
    }
    if(Number(y) === +Infinity || Number(y) === -Infinity) {
        // if y is either +∞ or -∞, then
        if(Number(x) === 0) {
            // if x is either +0 or -0, return NaN.
            return Number.NaN;
        }
        if(Number(x) > 0) {
            // if x > +0, return y.
            return Number(y);
        }
        // Return -y
        return Number(-y);
    }
    if(1/Number(x) === -Infinity) {
        // If x is -0, then
        if(1/Number(y) === -Infinity || y < 0) {
            // If y is -0 or y < -0, return +0
            return Number(0);
        } else {
            // Else, return -0
            return Number(-0);
        }
    }
    if(1/Number(-y) === -Infinity) {
        // If y is -0, then
        if(x < 0) {
            // If x < -0, return +0
            return Number(0);
        }
        else {
            // Else, return -0
            return Number(-0);
        }
    }
    // Return x × y
    return Number(x) * Number(y);
};
Number.multiply(Number(1.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::divide (x, y)</h5>

        <p>The abstract operation <code>Number::divide</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs division according to the rules of IEEE 754-2019 binary double-precision arithmetic, producing the quotient of <code>x</code> and <code>y</code> where <code>x</code> is the dividend and <code>y</code> is the divisor. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> or <code>y</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>x</code> is either +∞ or -∞, then<br>
                <ol>
                    <li>If <code>y</code> is either +∞ or -∞, return <code>NaN</code>.</li>
                    <li>If <code>y</code> is +0 or <code>y</code> > +0, return <code>x</code>.</li>
                    <li>Return <code>-x</code>.</li>
                </ol>
            </li>
            <li>If <code>y</code> is +∞, then<br>
                <ol>
                    <li>If <code>x</code> is +0 or <code>x</code> > +0, return +0. Otherwise, return -0.</li>
                </ol>
            </li>
            <li>If <code>y</code> is -∞, then<br>
                <ol>
                    <i>If <code>x</code> is +0 or <code>x</code> > +0, return -0. Otherwise, return +0.</i>
                </ol>
            </li>
            <li>If <code>x</code> is either +0 or -0, then<br>
                <ol>
                    <li>If <code>y</code> is either +0 or -0, return <code>NaN</code>.</li>
                    <li>If <code>y</code> > +0, return <code>x</code>.</li>
                    <li>Return <code>-x</code>.</li>
                </ol>
            </li>
            <li>If <code>y</code> is +0, then<br>
                <ol>
                    <li>If <code>x</code> > +0, return +∞. Otherwise, return -∞.</li>
                </ol>
            </li>
            <li>If <code>y</code> is -0, then<br>
                <li>If <code>x</code> > +0, return -∞. Otherwise, return +∞.</li>
            </li>
            <li>
                Return x / y.
            </li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.divide = function(x, y) {
    if(Number.isNaN(x) || Number.isNaN(y)) {
        // if x is NaN or y is NaN, return NaN
        return Number.NaN;
    }
    if(Number(x) === +Infinity || Number(x) === -Infinity) {
        // if x is either +∞ or -∞, then
        if(Number(y) === +Infinity || Number(y) === -Infinity) {
            // If y is either +∞ or -∞, return NaN
            return Number.NaN;
        }
        if(1/Number(y) === Infinity ||  Number(y) > 0) {
            // If y is +0 or y > +0, return x
            return Number(x);
        }
        // Return -x
        return Number(-x);
    }
    if(Number(y) === +Infinity) {
        // If y is +∞, then
        if(1/Number(x) === Infinity || Number(x) > 0) {
            // If x is +0 or x > +0, return +0
            return Number(0);
        }
        else {
            // Otherwise, return -0
            return Number(-0);
        }
    }
    if(Number(y) === -Infinity) {
        // If y is -∞, then
        if(1/Number(x) === Infinity || x > 0) {
            // If x is +0 or x > +0, return -0
            return Number(-0);
        } else {
            // Otherwise, return +0
            return Number(+0);
        }
    }
    if(Number(x) === 0) {
        // If x is either +0 or -0, then
        if(Number(y) === 0) {
            // If y is either +0 or -0, return NaN.
            return Number.NaN;
        }
        if(Number(y) > 0) {
            // If y > +0, return x
            return Number(x);
        }
        // Return -x
        return Number(-x);
    }
    if(1/Number(y) === Infinity) {
        // If y is +0, then
        if(Number(x) > 0) {
            // If x > +0, return +∞
            return Infinity;
        }
        else {
            // Otherwise, return -∞
            return -Infinity;
        }
    }
    if(1/Number(y) === -Infinity) {
        // If y is -0, then
        if(x > 0) {
            // If x > +0, return -∞
            return -Infinity;
        }
        else {
            // Otherwise, return +∞
            return Infinity;
        }
    }

    // Return x / y
    return Number(x) / Number(y);
};
Number.divide(Number(1.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::remainder (n, d)</h5>

        <p>The abstract operation <code>Number::remainder</code> takes arguments <code>n</code> (a Number) and <code>d</code> (a Number) and returns a Number. It yields the remainder from an implied division of its operands where <code>n</code> is the dividend and <code>d</code> is the divisor. It performs the following steps when called:</p>

        <ol>
            <li>If <code>n</code> is <code>NaN</code> or <code>d</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>n</code> is either +∞ or -∞, return <code>NaN</code>.</li>
            <li>If <code>d</code> is either +∞ or -∞, return <code>n</code>.</li>
            <li>If <code>d</code> is either +0 or -0, return <code>NaN</code>.</li>
            <li>If <code>n</code> is either +0 or -0, return <code>n</code>.</li>
            <li>Assert: <code>n</code> and <code>d</code> are finite and non-zero.</li>
            <li>Let <code>quotient</code> be <code>n / d</code>.</li>
            <li>Let <code>q</code> be <code>truncate(quotient)</code>.</li>
            <li>Let <code>r</code> be <code>n - (d × q)</code>.</li>
            <li>If <code>r</code> = 0 and <code>n</code> < -0, return -0.</li>
            <li>Return <code>r</code>.</li>
        </ol>

        <p>The mathematical function truncate(x) removes the fractional part of x by rounding towards zero, producing -floor(-x) if x < 0 and otherwise producing floor(x).</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.remainder = function(n, d) {
    if(Number.isNaN(n) || Number.isNaN(d)) {
        // If n is NaN or d is NaN, return NaN
        return Number.NaN;
    }
    if(Number(n) === +Infinity || Number(n) === -Infinity) {
        // If n is either +∞𝔽 or -∞𝔽, return NaN
        return Number.NaN;
    }
    if(Number(d) === +Infinity || Number(d) === -Infinity) {
        // If d is either +∞ or -∞, return n
        return Number(d);
    }
    if(Number(d) === 0) {
        // If d is either +0 or -0, return NaN
        return Number.NaN;
    }
    if(Number(n) === 0) {
        // If n is either +0 or -0, return n
        return Number(n);
    }

    // let quotient be n / d
    let quotient = n / d;
    
    // let q be truncate(quotient)
    let q = Math.floor(quotient);

    // let r be n - (d × q)
    let r = n - (d * q);

    if(r === 0 && n < 0) {
        // if r = 0 and n < -0, return -0
        return Number(-0);
    }
    
    // Return r
    return Number(r);
};
Number.remainder(Number(1.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::add (x, y)</h5>

        <p>The abstract operation <code>Number::add</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs addition according to the rules of IEEE 754-2019 binary double-precision arithmetic, producing the sum of its arguments. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> or <code>y</code> is <code>NaN</code>, return <code>NaN</code>.</li>
            <li>If <code>x</code> is +∞ and <code>y</code> is -∞, return <code>NaN</code>.</li>
            <li>If <code>x</code> is -∞ and <code>y</code> is +∞, return <code>NaN</code>.</li>
            <li>If <code>x</code> is either +∞ or -∞, return <code>x</code>.</li>
            <li>If <code>y</code> is either +∞ or -∞, return <code>y</code>.</li>
            <li>Assert: <code>x</code> and <code>y</code> are both finite.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is -0, return -0.</li>
            <li>Return <code>x</code> + <code>y</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.add = function(x, y) {
    if(Number.isNaN(x) || Number.isNaN(y)) {
        // If x is NaN or y is NaN, return NaN
        return Number.NaN;
    }
    if(Number(x) === +Infinity && Number(y) === -Infinity) {
        // If x is +∞ and y is -∞, return NaN
        return Number.NaN;
    }
    if(Number(x) === -Infinity && Number(y) === Infinity) {
        // If x is -∞ and y is +∞, return NaN.
        return Number.NaN;
    }
    if(Number(x) === Infinity || Number(x) === -Infinity) {
        // If x is either +∞ or -∞, return x
        return Number(x);
    }
    if(Number(y) === Infinity || Number(y) === -Infinity) {
        // If y is either +∞ or -∞, return y
        return Number(y);
    }
    // x and y are both finite
    if(1/Number(x) === -Infinity && 1/Number(y) === -Infinity) {
        // If x is -0 and y is -0, return -0
        return Number(-0);
    }
    
    // Return x + y
    return Number(x) + Number(y);
};
Number.add(Number(73.5), Number(23.76));</code></pre>

        <h5 class="post-subtitle">Number::subtract (x, y)</h5>

        <p>The abstract operation Number::subtract takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Number. It performs subtraction, producing the difference of its operands; <code>x</code> is the minuend and <code>y</code> is the subtrahend. It performs the following steps when called:</p>

        <ol>
            <li>Return <code>Number::add(x, Number::unaryMinus(y))</code></li>
        </ol>

        <h5 class="post-subtitle">Number::leftShift (x, y)</h5>

        <p>The abstract operation <code>Number::leftShift</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToInt32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToUint32(y)</code>.</li>
            <li>Let <code>shiftCount</code> be <code>rnum modulo 32</code>.</li>
            <li>Return the result of left shifting <code>lnum</code> by <code>shiftCount</code> bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.</li>
        </ol>

        <p>The <code>!ToInt32(x)</code> just means that we are certain that this call to <code>ToInt32</code> will never return an exception.</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.leftShift = function (x, y) {
    // lnum is the value of x converted to 32 bit integer
    // rnum is the value of y converted to 32 bit unsigned integer
    let lnum = x;
    let rnum = y;

    // Let shiftCount be rnum modulo 32
    let shiftCount = rnum % 32;

    // Return the result of left shifting lnum by shiftCount bits
    return lnum << shiftCount;
};
Number.leftShift(20, 5);</code></pre>

        <h5 class="post-subtitle">Number::signedRightShift (x, y)</h5>

        <p>The abstract operation <code>Number::signedRightShift</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToInt32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToUint32(y)</code>.</li>
            <li>Let <code>shiftCount</code> be <code>rnum modulo 32</code>.</li>
            <li>Return the result of performing a sign-extending right shift of <code>lnum</code> by <code>shiftCount</code> bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.</li>
        </ol>

        <p>When the most significant bit (MSB) is propagated, it means that the value of the MSB is copied and shifted into the vacant positions during a right shift operation. As a result, the sign of the original number is preserved, and the MSB, which indicates the sign of the number, is replicated and moved to the right. This process is also referred to as an arithmetic shift.</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.signedRightShift = function (x, y) {
    // lnum is the value of x converted to 32 bit integer
    // rnum is the value of y converted to 32 bit unsigned integer
    let lnum = x;
    let rnum = y;

    // Let shiftCount be rnum modulo 32
    let shiftCount = rnum % 32;

    // Return the result of performing a sign-extending right shift of lnum by shiftCount bits
    return lnum >> shiftCount;
};
Number.signedRightShift(320, 5);</code></pre>

        <h5 class="post-subtitle">Number::unsignedRightShift (x, y)</h5>

        <p>The abstract operation <code>Number::unsignedRightShift</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToUint32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToUint32(y)</code>.</li>
            <li>Let <code>shiftCount</code> be <code>rnum modulo 32</code>.</li>
            <li>Return the result of performing a zero-filling right shift of <code>lnum</code> by <code>shiftCount</code> bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.unsignedRightShift = function (x, y) {
    // lnum is the value of x converted to 32 bit unsigned integer
    // rnum is the value of y converted to 32 bit unsigned integer
    let lnum = x;
    let rnum = y;

    // Let shiftCount be rnum modulo 32
    let shiftCount = rnum % 32;

    // Return the result of performing a sign-extending right shift of lnum by shiftCount bits
    return lnum >>> shiftCount;
};
Number.unsignedRightShift(320, 5);</code></pre>

        <h5 class="post-subtitle">Number::lessThan (x, y)</h5>

        <p>The abstract operation <code>Number::lessThan</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean or undefined. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>undefined</code>.</li>
            <li>If <code>y</code> is <code>NaN</code>, return <code>undefined</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>false</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>false</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>false</code>.</li>
            <li>If <code>x</code> is +∞, return <code>false</code>.</li>
            <li>If <code>y</code> is +∞, return <code>true</code>.</li>
            <li>If <code>y</code> is -∞, return <code>false</code>.</li>
            <li>If <code>x</code> is -∞, return <code>true</code>.</li>
            <li>Assert: <code>x</code> and <code>y</code> are finite and non-zero.</li>
            <li>If <code>x</code> < <code>y</code>, return <code>true</code>. Otherwise, return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.lessThan = function (x, y) {
    if(Number.isNaN(x)) {
        // If x is NaN, return undefined
        return undefined;
    }
    if(Number.isNaN(y)) {
        // If y is NaN, return undefined
        return undefined;
    }
    if(x === y) {
        // If x is y, return false
        return false;
    }
    if(1/Number(x) === Infinity && 1/Number(y) === -Infinity) {
        // If x is +0 and y is -0, return false
        return false;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) === Infinity) {
        // If x is -0 and y is +0, return false
        return false;
    }
    if(x === Infinity) {
        // If x is +∞, return false
        return false;
    }
    if(y === Infinity) {
        // If y is +∞, return true
        return true;
    }
    if(y === -Infinity) {
        // If y is -∞, return false
        return false;
    }
    if(x === -Infinity) {
        // If x is -∞, return true.
        return true;
    }
    // x and y are finite and non-zero
    
    // If x < y, return true
    if(Number(x) < Number(y)) {
        return true;
    }
    else {
        return false;
    }
};
Number.lessThan(30, 50);</code></pre>

        <h5 class="post-subtitle">Number::equal(x, y)</h5>

        <p>The abstract operation <code>Number::equal</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>false</code>.</li>
            <li>If <code>y</code> is <code>NaN</code>, return <code>false</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>true</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>true</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>true</code>.</li>
            <li>Return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.equal = function (x, y) {
    if(Number.isNaN(x)) {
        // If x is NaN, return false
        return false;
    }
    if(Number.isNaN(y)) {
        // If y is NaN, return false.
        return false;
    }
    if(x === y) {
        // If x is y, return true
        return true;
    }
    if(1/Number(x) === Infinity && 1/Number(y) === -Infinity) {
        // If x is +0 and y is -0, return true.
        return true;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) === Infinity) {
        // If x is -0 and y is +0, return true
        return true;
    }
    
    // Return false
    return false;
};
Number.equal(30, 30);</code></pre>

        <h5 class="post-subtitle">Number::sameValue(x, y)</h5>

        <p>The abstract operation <code>Number::sameValue</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> and <code>y</code> is <code>NaN</code>, return <code>true</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>false</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>false</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>true</code>.</li>
            <li>Return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.sameValue = function (x, y) {
    if(Number.isNaN(x) && Number.isNaN(y)) {
        // If x is NaN and y is NaN, return true
        return true;
    }
    if(1/Number(x) === Infinity && 1/Number(y) ==== -Infinity) {
        // If x is +0 and y is -0, return false
        return false;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) ==== Infinity) {
        // If x is -0 and y is +0, return false
        return false;
    }
    if(Number(x) === Number(y)) {
        // If x is y, return true
        return true;
    }
    
    // Return false
    return false;
};
Number.sameValue(0, -0);</code></pre>

        <h5 class="post-subtitle">Number::sameValueZero(x, y)</h5>

        <p>The abstract operation <code>Number::sameValueZero</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns a Boolean. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code> and <code>y</code> is <code>NaN</code>, return <code>true</code>.</li>
            <li>If <code>x</code> is +0 and <code>y</code> is -0, return <code>true</code>.</li>
            <li>If <code>x</code> is -0 and <code>y</code> is +0, return <code>true</code>.</li>
            <li>If <code>x</code> is <code>y</code>, return <code>true</code>.</li>
            <li>Return <code>false</code>.</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.sameValueZero = function (x, y) {
    if(Number.isNaN(x) && Number.isNaN(y)) {
        // If x is NaN and y is NaN, return true.
        return true;
    }
    if(1/Number(x) === Infinity && 1/Number(y) ==== -Infinity) {
        // If x is +0 and y is -0, return true.
        return true;
    }
    if(1/Number(x) === -Infinity && 1/Number(y) ==== Infinity) {
        // If x is -0 and y is +0, return true.
        return true;
    }
    if(Number(x) === Number(y)) {
        // If x is y, return true
        return true;
    }
    
    // Return false
    return false;
};
Number.sameValueZero(0, -0);</code></pre>

        <h5 class="post-subtitle">NumberBitwiseOp (op, x, y)</h5>

        <p>The abstract operation <code>NumberBitwiseOp</code> takes arguments <code>op</code> (<code>&</code>, <code>^</code>, or <code>|</code>), <code>x</code> (a Number), and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Let <code>lnum</code> be <code>!ToInt32(x)</code>.</li>
            <li>Let <code>rnum</code> be <code>!ToInt32(y)</code>.</li>
            <li>Let <code>lbits</code> be the 32-bit two's complement bit string representing <code>lnum</code>.</li>
            <li>Let <code>rbits</code> be the 32-bit two's complement bit string representing <code>rnum</code>.</li>
            <li>If <code>op</code> is <code>&</code>, let <code>result</code> be the result of applying the bitwise AND operation to <code>lbits</code> and <code>rbits</code>.</li>
            <li>Else if <code>op</code> is <code>^</code>, let <code>result</code> be the result of applying the bitwise exclusive OR (XOR) operation to <code>lbits</code> and <code>rbits</code>.</li>
            <li>Else, <code>op</code> is <code>|</code>. Let <code>result</code> be the result of applying the bitwise inclusive OR operation to <code>lbits</code> and <code>rbits</code>.</li>
            <li>Return the Number value for the integer represented by the 32-bit two's complement bit string <code>result</code>.</li>
        </ol>

        <p>The <code>!ToInt32(x)</code> just means that we are certain that this call to <code>ToInt32</code> will never return an exception</p>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
    // Let lnum be ! ToInt32(x)
    let lnum = Number(x);

    // Let rnum be ! ToInt32(y)
    let rnum = Number(y);

    // Let lbits be the 32-bit two's complement bit string representing lnum
    let lbits = lnum;

    // Let rbits be the 32-bit two's complement bit string representing rnum
    let rbits = rnum;
    
    let result;

    if(op == '&') {
        // If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
        result = lbits & rbits;
    }
    else if(op == '&') {
        // Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
        result = lbits ^ rbits;
    }
    else {
        // Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
        result = lbits | rbits;
    }

    // Return the Number value for the integer represented by the 32-bit two's complement bit string result
    return result;
};</code></pre>

        <h5 class="post-subtitle">Number::bitwiseAND (x, y)</h5>

        <p>The abstract operation <code>Number::bitwiseAND</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Return NumberBitwiseOp(&, x, y)</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
    // Let lnum be ! ToInt32(x)
    let lnum = Number(x);

    // Let rnum be ! ToInt32(y)
    let rnum = Number(y);

    // Let lbits be the 32-bit two's complement bit string representing lnum
    let lbits = lnum;

    // Let rbits be the 32-bit two's complement bit string representing rnum
    let rbits = rnum;
    
    let result;

    if(op == '&') {
        // If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
        result = lbits & rbits;
    }
    else if(op == '&') {
        // Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
        result = lbits ^ rbits;
    }
    else {
        // Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
        result = lbits | rbits;
    }

    // Return the Number value for the integer represented by the 32-bit two's complement bit string result
    return result;
};
Number.bitwiseAND = function(x, y) {
    return NumberBitwiseOp('&', x, y);
}
Number.bitwiseAND(20, 30);</code></pre>

        <h5 class="post-subtitle">Number::bitwiseXOR (x, y)</h5>

        <p>The abstract operation <code>Number::bitwiseXOR</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Return NumberBitwiseOp(^, x, y)</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
// Let lnum be ! ToInt32(x)
let lnum = Number(x);

// Let rnum be ! ToInt32(y)
let rnum = Number(y);

// Let lbits be the 32-bit two's complement bit string representing lnum
let lbits = lnum;

// Let rbits be the 32-bit two's complement bit string representing rnum
let rbits = rnum;

let result;

if(op == '&') {
// If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
result = lbits & rbits;
}
else if(op == '&') {
// Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
result = lbits ^ rbits;
}
else {
// Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
result = lbits | rbits;
}

// Return the Number value for the integer represented by the 32-bit two's complement bit string result
return result;
};
Number.bitwiseXOR = function(x, y) {
    return NumberBitwiseOp('^', x, y);
}
Number.bitwiseXOR (20, 30);</code></pre>

        <h5 class="post-subtitle">Number::bitwiseOR (x, y)</h5>

        <p>The abstract operation <code>Number::bitwiseOR</code> takes arguments <code>x</code> (a Number) and <code>y</code> (a Number) and returns an integral Number. It performs the following steps when called:</p>

        <ol>
            <li>Return NumberBitwiseOp(|, x, y)</li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">function NumberBitwiseOp(op, x, y) {
    // Let lnum be ! ToInt32(x)
    let lnum = Number(x);

    // Let rnum be ! ToInt32(y)
    let rnum = Number(y);

    // Let lbits be the 32-bit two's complement bit string representing lnum
    let lbits = lnum;

    // Let rbits be the 32-bit two's complement bit string representing rnum
    let rbits = rnum;

    let result;

    if(op == '&') {
    // If op is &, let result be the result of applying the bitwise AND operation to lbits and rbits
    result = lbits & rbits;
    }
    else if(op == '&') {
    // Else if op is ^, let result be the result of applying the bitwise exclusive OR (XOR) operation to lbits
    result = lbits ^ rbits;
    }
    else {
    // Else, op is |. Let result be the result of applying the bitwise inclusive OR operation to lbits and rbits
    result = lbits | rbits;
    }

    // Return the Number value for the integer represented by the 32-bit two's complement bit string result
    return result;
};
Number.bitwiseOR = function(x, y) {
    return NumberBitwiseOp('|', x, y);
}
Number.bitwiseOR (20, 30);</code></pre>

        <h5 class="post-subtitle">Number::toString (x, radix)</h5>

        <p>The abstract operation <code>Number::toString</code> takes arguments <code>x</code> (a Number) and <code>radix</code> (an integer in the inclusive interval from 2 to 36) and returns a String. It represents <code>x</code> as a String using a positional numeral system with radix <code>radix</code>. The digits used in the representation of a number using radix <code>r</code> are taken from the first <code>r</code> code units of <b>0123456789abcdefghijklmnopqrstuvwxyz</b> in order. The representation of numbers with magnitude greater than or equal to 1 never includes leading zeroes. It performs the following steps when called:</p>

        <ol>
            <li>If <code>x</code> is <code>NaN</code>, return <code>"NaN"</code>.</li>
            <li>If <code>x</code> is either +0 or -0, return <code>"0"</code>.</li>
            <li>If <code>x</code> < -0, return the string-concatenation of <code>"-"</code> and <code>Number::toString(-x, radix)</code>.</li>
            <li>If <code>x</code> is +∞, return <code>"Infinity"</code>.</li>
            <li>Let <code>n</code>, <code>k</code>, and <code>s</code> be integers such that $$k ≥ 1$$, $$radix^{k - 1} ≤ s < radix^k$$, $$s × radix^{n - k}$$ is $$x$$, and $$k$$ is as small as possible. Note that <code>k</code> is the number of digits in the representation of <code>s</code> using radix <code>radix</code>, that <code>s</code> is not divisible by <code>radix</code>, and that the least significant digit of <code>s</code> is not necessarily uniquely determined by these criteria.<br><br>
            In simple words, <code>x</code> is an integer, <code>n</code> is the position of the leading digit of <code>x</code>, with n=0 being the first fraction (0.X), n=1 being the least significant integer position (X.0), n=2 being the "tens" position (X0.0) etc. <code>s</code> is the integer representation that results from stripping all trailing zeroes of <code>x</code>, and <code>k</code> is the number of digits in <code>s</code>.<br><br>

            Example 1:<br>
            <code>x</code> = 100000000000000000000, would yield <code>s</code> = 1, <code>k</code> = 1, <code>n</code> = 21. Therefore the <code>x</code> passes point 6a and will return "100000000000000000000"<br><br>
            Example 2:<br>
            <code>x</code> = 10000000000000000000000, would yield <code>s</code> = 1, <code>k</code> = 1, <code>n</code> = 23. Therefore the <code>x</code> passes point 11a and will return "1e+22"<br><br>
            Example 3:<br>
            <code>x</code> = 0.000003001, would yield <code>s</code> = 3001, <code>k</code> = 4, <code>n</code> = -5. Therefore the <code>x</code> passes point 6c and will return "0.000003001"<br><br>
            Example 4:<br>
            <code>x</code> = 0.0000003001, would yield <code>s</code> = 3001, <code>k</code> = 4, <code>n</code> = -6. Therefore the <code>x</code> passes point 12 and will return "3.001e-7"<br><br>
            Example 5:<br>
            <code>x</code> = 100000000.00000003001, would yield <code>s</code> = 10000000000000003001, <code>k</code> = 20, <code>n</code> = 9. Therefore the <code>x</code> passes point 6b and will return "100000000.00000003" since the floating-point numbers in JavaScript can only keep 16 decimal places of precision; beyond that, the value will be changed.<br><br>
            Example 6:<br>
            <code>x</code> = 1000000000.00000003001, would yield <code>s</code> = 100000000000000003001, <code>k</code> = 21, <code>n</code> = 10. Therefore the <code>x</code> passes point 6b and will return "100000000". It actually returned "100000000.0000000" since the floating-point numbers in JavaScript can only keep 16 decimal places of precision and since Javascript automatically removes the trailing zeros of a floating point number, it returned "100000000".<br><br>
            </li>
            <li>If radix ≠ 10 or n is in the inclusive interval from -5 to 21, then<br>
                <ol>
                    <li>If n ≥ k, then<br>
                        <ol>
                            <li>Return the string-concatenation of:<br>
                                <ol>
                                    <li>the code units of the k digits of the representation of s using radix radix</li>
                                    <li>n - k occurrences of the code unit 0x0030 (DIGIT ZERO)</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>Else if n > 0, then<br>
                        <ol>
                            <li>Return the string-concatenation of:<br>
                                <ol>
                                    <li>
                                        the code units of the most significant n digits of the representation of s using radix radix
                                    </li>
                                    <li>the code unit 0x002E (FULL STOP)</li>
                                    <li>the code units of the remaining k - n digits of the representation of s using radix radix</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>Else,<br>
                        <ol>
                            <li>Assert: n ≤ 0.</li>
                            <li>Return the string-concatenation of:<br>
                                <ol>
                                    <li>the code unit 0x0030 (DIGIT ZERO)</li>
                                    <li>the code unit 0x002E (FULL STOP)</li>
                                    <li>-n occurrences of the code unit 0x0030 (DIGIT ZERO)</li>
                                    <li>the code units of the k digits of the representation of s using radix radix</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>NOTE: In this case, the input will be represented using scientific E notation, such as 1.2e+3.</li>
            <li>Assert: radix is 10.</li>
            <li>If n < 0, then<br>
                <ol>
                    <li>Let exponentSign be the code unit 0x002D (HYPHEN-MINUS).</li>
                </ol>
            </li>
            <li>Else,<br>
                <ol>
                    <li>Let exponentSign be the code unit 0x002B (PLUS SIGN).</li>
                </ol>
            </li>
            <li>If k = 1, then<br>
                <ol>
                    <li>Return the string-concatenation of:<br>
                        <ol>
                            <li>the code unit of the single digit of s</li>
                            <li>the code unit 0x0065 (LATIN SMALL LETTER E)</li>
                            <li>exponentSign</li>
                            <li>the code units of the decimal representation of abs(n - 1)</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>Return the string-concatenation of:<br>
                <ol>
                    <li>the code unit of the most significant digit of the decimal representation of s</li>
                    <li>the code unit 0x002E (FULL STOP)</li>
                    <li>the code units of the remaining k - 1 digits of the decimal representation of s</li>
                    <li>the code unit 0x0065 (LATIN SMALL LETTER E)</li>
                    <li>exponentSign</li>
                    <li>the code units of the decimal representation of abs(n - 1)</li>
                </ol>
            </li>
        </ol>

        <p>If we translated the steps into Javascript codes, this is more or less it would look like:</p>

        <pre><code class="language-bash hljs">Number.toString = function (x, radix) {
    if(Number.isNaN(x)) {
        // If x is NaN, return "NaN"
        return "NaN";
    }

    if(x === 0) {
        // If x is either +0 or -0, return "0"
        return "0";
    }
    
    if(x < 0) {
        // If x < -0, return the string-concatenation of "-" and Number::toString(-x, radix)
        return "-" + Number.toString(-x, radix);
    }

    if(x === Infinity) {
        // If x is +∞, return "Infinity".
        return "Infinity";
    }

    let n = 0;
    let k = 0;
    let narray = [];
    let karray = [];
    let whole;
    let fraction;
    
    if(Math.floor(x) === Math.ceil(x)) {
        whole = x + "";
    } else {
        let str = x.toString().split(".");
        whole = str[0];
        fraction = str[1];
    }
    
    let temp = x;
    let numofzero = 0;
    let iszero = true;
    
    while(Math.floor(temp) > 0) {
        n = n + 1;
        narray.push(whole[whole.length - n]);
        
        k = k + 1;
        karray.push(whole[whole.length - n]);
        
        //console.log(whole[whole.length-n])
        if(Math.floor(x) === Math.ceil(x) && whole[whole.length - n] === "0" && iszero) {
            k = k - 1;
            
            karray.pop();
            
            numofzero = numofzero + 1;
        } else {
            iszero = false;
        }
        
        temp = temp / 10;
    }
    
    temp = x;
    iszero = true;
    let i = 0;
    while(Math.ceil(temp) !== Math.floor(temp)) {
        temp = temp * 10;
        
        if(n <= 0 && Math.floor(temp) === 0 && iszero) {
            n = n - 1;
            narray.push(fraction[i]);
        } else {
            k = k + 1;
            iszero = false;
            karray.unshift(fraction[i]);
        }
        i = i + 1;
    }
    
    function numbertobase(number, rad) {
        let wnum;
        let fnum;
        if(Math.floor(number) === Math.ceil(number)) {
            wnum = number;
        } else {
            let str = number.split(".");
            wnum = str[0];
            fnum = str[1];
        }
    
        let numberofdigits = Math.round(Math.log10(Math.pow(2,53)) / Math.log10(rad)) + 1;
        let result = "";
        let zeropads = "";

        while(wnum > 0) {
            let remainder = wnum - Math.floor(wnum / rad) * rad + "";
            
            if (remainder === "10") {
                result = "A" + result;
            } else if (remainder === "11") {
                result = "B" + result;
            } else if (remainder === "12") {
                result = "C" + result;
            } else if (remainder === "13") {
                result = "D" + result;
            } else if (remainder === "14") {
                result = "E" + result;
            } else if (remainder === "15") {
                result = "F" + result;
            } else if (remainder === "16") {
                result = "G" + result;
            } else if (remainder === "17") {
                result = "H" + result;
            } else if (remainder === "18") {
                result = "I" + result;
            } else if (remainder === "19") {
                result = "J" + result;
            } else if (remainder === "20") {
                result = "K" + result;
            } else if (remainder === "21") {
                result = "L" + result;
            } else if (remainder === "22") {
                result = "M" + result;
            } else if (remainder === "23") {
                result = "N" + result;
            } else if (remainder === "24") {
                result = "O" + result;
            } else if (remainder === "25") {
                result = "P" + result;
            } else if (remainder === "26") {
                result = "Q" + result;
            } else if (remainder === "27") {
                result = "R" + result;
            } else if (remainder === "28") {
                result = "S" + result;
            } else if (remainder === "29") {
                result = "T" + result;
            } else if (remainder === "30") {
                result = "U" + result;
            } else if (remainder === "31") {
                result = "V" + result;
            } else if (remainder === "32") {
                result = "W" + result;
            } else if (remainder === "33") {
                result = "X" + result;
            } else if (remainder === "34") {
                result = "Y" + result;
            } else if (remainder === "35") {
                result = "Z" + result;
            } else {
                result = remainder + result;
            }
            numberofdigits = numberofdigits - 1;
            
            wnum = Math.floor(wnum / rad);
        }
        
        if(Math.ceil(number) !== Math.floor(number)) {
            const factor = Math.pow(10, fnum.length)
            fnum = "1." + fnum;
            
            if(fnum > 0) {
                if(result === "") {
                    result = "0.";
                } else {
                    result = result + ".";
                }
            }
            
            while(fnum > 0) {
                fnum = (Math.round(fnum * rad * factor) / factor) + "";
                str = fnum.split(".");
                let num = str[0] - rad + "";
                fnum = "1." + str[1];
                
                if (num > 0) {
                    result = result + zeropads;
                    zeropads = "";
                }
                
                if (num === "10") {
                    result = result + "A";
                } else if (num === "11") {
                    result = result + "B";
                } else if (num === "12") {
                    result = result + "C";
                } else if (num === "13") {
                    result = result + "D";
                } else if (num === "14") {
                    result = result + "E";
                } else if (num === "15") {
                    result = result + "F";
                } else if (num === "16") {
                    result = result + "G";
                } else if (num === "17") {
                    result = result + "H";
                } else if (num === "18") {
                    result = result + "I";
                } else if (num === "19") {
                    result = result + "J";
                } else if (num === "20") {
                    result = result + "K";
                } else if (num === "21") {
                    result = result + "L";
                } else if (num === "22") {
                    result = result + "M";
                } else if (num === "23") {
                    result = result + "N";
                } else if (num === "24") {
                    result = result + "O";
                } else if (num === "25") {
                    result = result + "P";
                } else if (num === "26") {
                    result = result + "Q";
                } else if (num === "27") {
                    result = result + "R";
                } else if (num === "28") {
                    result = result + "S";
                } else if (num === "29") {
                    result = result + "T";
                } else if (num === "30") {
                    result = result + "U";
                } else if (num === "31") {
                    result = result + "V";
                } else if (num === "32") {
                    result = result + "W";
                } else if (num === "33") {
                    result = result + "X";
                } else if (num === "34") {
                    result = result + "Y";
                } else if (num === "35") {
                    result = result + "Z";
                } else if (num === "0") {
                    zeropads = zeropads + "0";
                } else {
                    result = result + num;
                }
                
                numberofdigits = numberofdigits - 1;
                
                if(numberofdigits === 0) {
                    break;
                }
                
            }
        } 
        
        return result;
    }
    //let s = x / 10 ** (n-k);

    if(radix !== 10 || (n >= -5 && n <= 21)) {
        // If radix ≠ 10 or n is in the inclusive interval from -5 to 21, then

        if(n >= k) {
            // If n ≥ k, then
            // Return the string-concatenation of: 
            // the code units of the k digits of the representation of s using radix radix
            // n - k occurrences of the code unit 0x0030 (DIGIT ZERO)
            
            return numbertobase(karray.reverse().join("") + narray.slice(0, n - k).reverse().join(""), radix);
        } else if(n > 0) {
            // Else if n > 0, then
            // Return the string-concatenation of:
            // the code units of the most significant n digits of the representation of s using radix radix
            // the code unit 0x002E (FULL STOP)
            // the code units of the remaining k - n digits of the representation of s using radix radix
            
            return numbertobase(narray.reverse().join("") + "." +  karray.slice(0, k - n).reverse().join(""), radix);
        } else {
            // Else n ≤ 0
            // Return the string-concatenation of:
            // the code unit 0x0030 (DIGIT ZERO)
            // the code unit 0x002E (FULL STOP)
            // -n occurrences of the code unit 0x0030 (DIGIT ZERO)
            // the code units of the k digits of the representation of s using radix radix
            
            return numbertobase("0" + "." + narray.reverse().join("") + karray.reverse().join(""), radix);
        }
    }

    let exponentSign;
    // radix is 10
    if(n < 0) {
        // If n < 0, then
        // Let exponentSign be the code unit 0x002D (HYPHEN-MINUS)
        exponentSign = "-";
    } else {
        // Else
        // Let exponentSign be the code unit 0x002B (PLUS SIGN)
        exponentSign = "+";
    }

    if(k === 1) {
        // If k = 1, then
        // the code unit of the single digit of s
        // the code unit 0x0065 (LATIN SMALL LETTER E)
        // exponentSign
        // the code units of the decimal representation of abs(n - 1)
        return karray.reverse().join("") + "e" + exponentSign + Math.abs(n - 1);
    }
    
    // Return the string-concatenation of:
    // the code unit of the most significant digit of the decimal representation of s
    // the code unit 0x002E (FULL STOP)
    // the code units of the remaining k - 1 digits of the decimal representation of s
    // the code unit 0x0065 (LATIN SMALL LETTER E)
    // exponentSign
    // the code units of the decimal representation of abs(n - 1)

    return karray[karray.length - 1] + "." + karray.slice(0, karray.length - 1).reverse().join("") + "e" + exponentSign + Math.abs(n - 1);
};
Number.toString(100000000000000000000, 10);
// "100000000000000000000"
Number.toString(100000000000000000000, 16);
// "56BC75E2D63100000"
Number.toString(0.000003001, 10);
// "0.000003001"
Number.toString(0.000003001, 16);
// "0.0000325932651B"
Number.toString(100000000.00000003001, 10);
// "100000000.00000003"
Number.toString(100000000.00000003001, 16);
// "5f5e100.0000008"</code></pre>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/abstract-operation" class="tag">abstract operation</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Complete Reference" /><category term="year-2024" /><category term="month-07" /><category term="day-05" /><category term="javascript" /><category term="abstract operation" /><summary type="html"><![CDATA[Learn about the abstract operations of the Number type in JavaScript, focusing on binary and arithmetic operations. This article provides examples, algorithms, and explanations to help you understand these concepts better.]]></summary></entry><entry xml:lang="en"><title type="html">Javascript Language Specification: Data Types and Values</title><link href="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-data-types-and-values/" rel="alternate" type="text/html" title="Javascript Language Specification: Data Types and Values" /><published>2024-07-05T10:21:00+00:00</published><updated>2024-07-05T10:21:00+00:00</updated><id>https://hemimorphite.github.io/2024/07/05/javascript-language-specification-data-types-and-values</id><content type="html" xml:base="https://hemimorphite.github.io/2024/07/05/javascript-language-specification-data-types-and-values/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">Javascript Language Specification: Data Types and Values</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published July 05, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/javascript.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>JavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:</p>

        <pre><code class="language-bash hljs">let foo = 42; // foo is now a number
foo = "bar"; // foo is now a string
foo = true; // foo is now a boolean</code></pre>
        
        <p>JavaScript is also a weakly typed language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.</p>
        
        <p>The Javascript data types are <b>Undefined</b>, <b>Null</b>, <b>Boolean</b>, <b>String</b>, <b>Symbol</b>, <b>Number</b>, <b>BigInt</b>, and <b>Object</b>.</p>

        <p>All types except <b>Object</b> define immutable values. We refer to values of these types as primitive values.</p>
        
        <p>In JavaScript, primitive values are immutable — once a primitive value is created, it cannot be changed, although the variable that holds it may be reassigned another value. By contrast, objects and arrays are mutable by default — their properties and elements can be changed without reassigning a new value.</p>

        <pre><code class="language-bash hljs">const foo = 42; // foo is a number
const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
console.log(result); // 421</code></pre>
        
        <p>Implicit coercions are very convenient, but can create subtle bugs when conversions happen where they are not expected, or where they are expected to happen in the other direction (for example, <b>string</b> to <b>number</b> instead of <b>number</b> to <b>string</b>). For <b>symbols</b> and <b>BigInts</b>, JavaScript has intentionally disallowed certain implicit type conversions.</p>
        
        <p>All primitive types, except <code>null</code>, can be tested by the <code>typeof</code> operator. <code>typeof null</code> returns <code>object</code>, so one has to use <code>=== null</code> to test for <code>null</code>.</p>

        <h5 class="post-subtitle">Null Type</h5>

        <p>The Null type has exactly one value, called <code>null</code>. The <code>null</code> value represents the intentional absence of any object value.</p>

        <pre><code class="language-bash hljs">function getVowels(str) {
    const m = str.match(/[aeiou]/gi);
    if (m === null) {
        return 0;
    }
    return m.length;
}
console.log(getVowels('sky'));
// 0</code></pre>

        <h5 class="post-subtitle">Undefined Type</h5>

        <p>The Undefined type has exactly one value, called <code>undefined</code>.</p>
        
        <p><code>undefined</code> indicates the absence of a value, while <code>null</code> indicates the absence of an object (which could also make up an excuse for <code>typeof null === "object"</code>).</p>
        
        <p>There are several situations where the value <code>undefined</code> is assigned:</p>

        <ul>
            <li>A <code>return</code> statement with no value (e.g. <code>return;</code>) implicitly returns <code>undefined</code>.</li>
            <li>Accessing a nonexistent object property (e.g. <code>obj.iDontExist</code>) returns <code>undefined</code>.</li>
            <li>A variable declaration without initialization (e.g. <code>let x;</code>) implicitly initializes the variable to <code>undefined</code>.</li>
            <li>Many methods, such as <code>Array.prototype.find()</code> and <code>Map.prototype.get()</code>, return <code>undefined</code> when no element is found.</li>
        </ul>

        <pre><code class="language-bash hljs">function getNothing() {
    return;
}
console.log(getNothing());
// undefined

let x;
console.log(x);
// undefined

let person = {};
console.log(person.name);
// undefined</code></pre>

        <p><code>null</code> is a keyword, but <code>undefined</code> is a normal <b>identifier</b> that happens to be a global property. <code>undefined</code> should not be redefined or shadowed.</p>

        <h5 class="post-subtitle">Boolean type</h5>

        <p>The Boolean type represents a logical entity and is inhabited by two values: <code>true</code> and <code>false</code>.</p>

        <pre><code class="language-bash hljs">let x = true;
let y = false;
console.log(x);
// true
console.log(y);
// false</code></pre>

        <h5 class="post-subtitle">Number type</h5>

        <p>The Number type is a double-precision 64-bit binary format IEEE 754 value. It is capable of storing positive floating-point numbers between \(2^{-1074}\) (<code>Number.MIN_VALUE</code>) and \(2^{1024}\) (<code>Number.MAX_VALUE</code>) as well as negative floating-point numbers between \(-2^{-1074}\) and \(-2^{1024}\), but it can only safely store integers in the range \(-(2^{53} − 1)\) (<code>Number.MIN_SAFE_INTEGER</code>) to \(2^{53} − 1\) (<code>Number.MAX_SAFE_INTEGER</code>). Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double-precision floating point approximation. You can check if a number is within the range of safe integers using <code>Number.isSafeInteger()</code>.</p>

        <p>Values outside the range ±(\(2^{-1074}\) to \(2^{1024}\)) are automatically converted:</p>

        <ul>
            <li>Positive values greater than <code>Number.MAX_VALUE</code> are converted to <code>+Infinity</code>.</li>
            <li>Positive values smaller than <code>Number.MIN_VALUE</code> are converted to <code>+0</code>.</li>
            <li>Negative values smaller than <code>-Number.MAX_VALUE</code> are converted to <code>-Infinity</code>.</li>
            <li>Negative values greater than <code>-Number.MIN_VALUE</code> are converted to <code>-0</code>.</li>
        </ul>

        <pre><code class="language-bash hljs">// With decimals:
let x1 = 34.00;

// Without decimals:
let x2 = 34; </code></pre>

        <p><code>NaN</code> (<b>Not a Number</b>) is a special kind of number value that's typically encountered when the result of an arithmetic operation cannot be expressed as a number.</p>

        <h5 class="post-subtitle">BigInt Type</h5>

        <p>The BigInt type represents an integer value. The value may be any size and is not limited to a particular bit-width. Generally, where not otherwise noted, operations are designed to return exact mathematically-based answers. For binary operations, BigInts act as two's complement binary strings, with negative numbers treated as having bits set infinitely to the left.</p>

        <p>The BigInt type in JavaScript only supports integers, not floating-point numbers. It is designed to represent integer values with arbitrary magnitude, allowing for safe storage of large integers that exceed the range supported by the Number data type.</p>
        
        <p>The BigInt type is created by appending n to the end of an integer or by calling the <code>BigInt()</code> function.</p>

        <pre><code class="language-bash hljs">let x = 123456789012345678901234567890n;
let y = BigInt("123456789012345678901234567890");</code></pre>
        
        <p>BigInt values are neither always more precise nor always less precise than numbers, since BigInts cannot represent fractional numbers, but can represent big integers more accurately. Neither type entails the other, and they are not mutually substitutable. A <code>TypeError</code> is thrown if BigInt values are mixed with regular numbers in arithmetic expressions, or if they are implicitly converted to each other.</p>

        <h5 class="post-subtitle">String Type</h5>

        <p>The String type represents textual data and is encoded as a sequence of 16-bit unsigned integer values representing UTF-16 code units. Each element in the string occupies a position in the string. The first element is at index <code>0</code>, the next at index <code>1</code>, and so on. The length of a string is the number of UTF-16 code units in it, which may not correspond to the actual number of Unicode characters</p>

        <p>JavaScript strings are immutable. This means that once a string is created, it is not possible to modify it. String methods create new strings based on the content of the current string — for example:</p>

        <ul>
            <li>A substring of the original using <code>substring()</code>.</li>
            <li>A concatenation of two strings using the concatenation operator (+) or <code>concat()</code>.</li>
        </ul>

        <pre><code class="language-bash hljs">const string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;</code></pre>
        
        <p>An empty string has both a legal value and a type.</p>

        <pre><code class="language-bash hljs">let str = "";    // The value is "", the typeof is "string"</code></pre>

        <h5 class="post-subtitle">Symbol type</h5>

        <p>The Symbol type is the set of all non-String values that may be used as the key of an Object property.</p>

        <p>Each possible Symbol value is unique and immutable.</p>

        <p>Each Symbol value immutably holds an associated value called <code>description</code> that is either undefined or a String value.</p>

        <p>To create a new primitive symbol, you write <code>Symbol()</code> with an optional <code>string</code> as its description:</p>

        <pre><code class="language-bash hljs">const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");</code></pre>

        <p>The above code creates three new symbols. Note that <code>Symbol("foo")</code> does not coerce the string <code>"foo"</code> into a symbol. It creates a new symbol each time:</p>

        <pre><code class="language-bash hljs">Symbol("foo") === Symbol("foo"); // false</code></pre>

        <h5 class="post-subtitle">Object Type</h5>

        <p>An Object is logically a collection of properties. Each property has corresponding attributes. Each attribute is accessed internally by the JavaScript engine, but you can set them through <code>Object.defineProperty()</code>, or read them through <code>Object.getOwnPropertyDescriptor()</code>. Each property is either a data property, or an accessor property:</p>

        <ul>
            <li>A data property associates a key with a value.</li>
            <li>An accessor property associates a key value with one or two accessor functions (get and set) to retrieve or store a value.</li>
        </ul>

        <p>Properties are identified using key values. A property key value is either a String value or a Symbol value. All String and Symbol values, including the empty String, are valid as property keys. A property name is a property key that is a String value.</p>

        <p>Property keys are used to access properties and their values. There are two kinds of access for properties: get and set, corresponding to value retrieval and assignment, respectively. The properties accessible via get and set access includes both own properties that are a direct part of an object and inherited properties which are provided by another associated object via a property inheritance relationship. Inherited properties may be either own or inherited properties of the associated object. Each own property of an object must each have a key value that is distinct from the key values of the other own properties of that object.</p>

        <p>Every object property has a set of invisible attributes containing metadata associated with that property, called property descriptors.</p>

        <p>There are two types of descriptors associated with any property: data descriptors and accessor descriptors. A data descriptor includes key and value pairs that contain a property's value, regardless of whether that value is writable, configurable, or enumerable. Accessor descriptors contain functions that execute when a property is set, changed, or accessed.</p>

        <p>The following table lists all object property attributes.</p>

        <table>
            <tbody>
                <tr>
                    <th>Attribute Name</th>
                    <th>Types of property</th>
                    <th>Data Type</th>
                    <th>Default Value</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td> <code>value</code> </td>
                    <td>
                        data property
                    </td>
                    <td> 
                        any data type
                    </td>
                    <td>
                        <code>undefined</code>
                    </td>
                    <td> The value retrieved by a get access of the property. </td>
                </tr>
                <tr>
                    <td> <code>writable</code> </td>
                    <td>
                        data property
                    </td>
                    <td> boolean </td>
                    <td>
                        <code>false</code>
                    </td>
                    <td> determines if the value of a data property can be changed. If <code>false</code>, attempts to change the property's <code>value</code> attribute using <code>set</code> will not succeed. </td>
                </tr>
                <tr>
                    <td> <code>get</code> </td>
                    <td>
                        accessor property
                    </td>
                    <td> object or <code>undefined</code>
                    </td>
                    <td>
                        <code>undefined</code>
                    </td>
                    <td> If the value is an object, it must be a function object. The function's <code>call</code> internal method is called with an empty arguments list to retrieve the property value each time a get access of the property is performed. </td>
                </tr>
                <tr>
                    <td> <code>set</code> </td>
                    <td>
                        accessor property
                    </td>
                    <td> object or <code>undefined</code>
                    </td>
                    <td>
                        <code>undefined</code>
                    </td>
                    <td> If the value is an object, it must be a function object. The function's <code>call</code> internal method is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's <code>set</code> internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's <code>get</code> internal method. </td>
                </tr>
                <tr>
                    <td> <code>enumerable</code> </td>
                    <td>
                        data property or accessor property
                    </td>
                    <td> boolean </td>
                    <td>
                        <code>false</code>
                    </td>
                    <td> If <code>true</code>, the property will be enumerated by a for-in enumeration. Otherwise, the property is said to be non-enumerable. </td>
                </tr>
                <tr>
                    <td> <code>configurable</code> </td>
                    <td>
                        data property or accessor property
                    </td>
                    <td> boolean </td>
                    <td>
                        <code>false</code>
                    </td>
                    <td> If <code>false</code>, attempts to delete the property, change it from a data property to an accessor property or from an accessor property to a data property, or make any changes to its attributes (other than replacing an existing <code>value</code> or setting <code>writable</code> to <code>false</code>) will fail. </td>
                </tr>
            </tbody>
        </table>

        <p>The following code retrieves the object descriptor for the data property <code>firstName</code>:</p>

        <pre><code class="language-bash hljs">const person = {
    firstName:"John", 
    lastName:"Doe", 
    age:50
};
console.log(Object.getOwnPropertyDescriptor(person, "firstName"));
// Object { value: "John", writable: true, enumerable: true, configurable: true }
</code></pre>

        <p>In the next example, we retrieve the property descriptor for the getter <code>fullName</code>:</p>

        <pre><code class="language-bash hljs">const person = {
    firstName:"John", 
    lastName:"Doe", 
    age:50,
    get fullName() {
        return this.firstName + " " + this.lastName;
    }
};
console.log(Object.getOwnPropertyDescriptor(person, "fullName"));
// Object { get: get fullName() {
//    return this.firstName + " " + this.lastName;
// }, set: undefined, enumerable: true, configurable: true }</code></pre>

    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/javascript" class="tag">javascript</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/null-type" class="tag">null type</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/undefined-type" class="tag">undefined type</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/number-type" class="tag">number type</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/bigint-type" class="tag">bigint type</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/string-type" class="tag">string type</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/object-type" class="tag">object type</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/symbol-type" class="tag">symbol type</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Complete Reference" /><category term="year-2024" /><category term="month-07" /><category term="day-05" /><category term="javascript" /><category term="null type" /><category term="undefined type" /><category term="number type" /><category term="bigint type" /><category term="string type" /><category term="object type" /><category term="symbol type" /><summary type="html"><![CDATA[The JavaScript language specification covering data types and values provides detailed explanations, examples, and references for developers looking to understand the intricacies of JavaScript programming.]]></summary></entry><entry xml:lang="en"><title type="html">The Math of UTF-8 Encoding and Decoding</title><link href="https://hemimorphite.github.io/2024/06/25/the-math-of-utf-8-encoding-and-decoding/" rel="alternate" type="text/html" title="The Math of UTF-8 Encoding and Decoding" /><published>2024-06-25T16:58:00+00:00</published><updated>2024-06-25T16:58:00+00:00</updated><id>https://hemimorphite.github.io/2024/06/25/the-math-of-utf-8-encoding-and-decoding</id><content type="html" xml:base="https://hemimorphite.github.io/2024/06/25/the-math-of-utf-8-encoding-and-decoding/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">The Math of UTF-8 Encoding and Decoding</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published June 25, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/computerscience.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>In computer systems, characters are transformed and stored as numbers (sequences of bits) that can be handled by the processor. A code page is an encoding scheme that maps a specific sequence of bits to its character representation. Before Unicode, there were hundreds of different encoding schemes that assigned a number to each letter or character. Many such schemes included code pages that contained only 256 characters – each character requiring 8 bits of storage. While this was relatively compact, it was insufficient to hold ideographic character sets containing thousands of characters such as Chinese and Japanese, and also did not allow the character sets of many languages to co-exist with each other.</p>

        <p>Unicode is an attempt to include all the different schemes into one universal text-encoding standard. As of version 15.0, it can represent 149,186 different characters.</p>

        <p>Unicode represents each individual character as a unique code point with a unique number. For example, the character A – Latin Capital Letter A – is represented as U+0041 and the Hiragana ふ is U+3075</p>

        <p>Unicode defines multiple encodings of its single character set: UTF-8, UTF-16, and UTF-32.</p>

        <p>UTF-8 is a character encoding that maps code points of Unicode character to a sequence of one, two, three or four 8-bit code units. UTF-8 uses 1, 2, 3 or 4 8-bit code units to represent a unicode character.</p>

        <p>Code unit is a value that encoded code point to 8/16/32 bits to store/transmit Unicode text efficiently on a computer.</p>

        <p>When representing characters in UTF-8, each code point is represented by a sequence of one or more bytes. The number of bytes used depends on the code point being represented by the character. Here's a breakdown of the usage range:</p>

        <ul>
            <li>code points in the ASCII range (0-127) are represented by a single byte</li>
            <li>code points in the range (128-2047) are represented by two bytes</li>
            <li>code points in the range (2048-65535) are represented by three bytes</li>
            <li>code points in the range (65536-1114111) are represented by four bytes</li>
        </ul>

        <p>The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point.</p>

        <table class="table table-bordered border-primary">
            <tbody>
                <tr>
                    <th>First code point </th>
                    <th>Last code point </th>
                    <th>Byte 1 </th>
                    <th>Byte 2 </th>
                    <th>Byte 3 </th>
                    <th>Byte 4 </th>
                </tr>
                <tr>
                    <td style="text-align: right;">
                        U+00<span style="color:red;">0</span><span style="color:purple;">0</span>
                    </td>
                    <td style="text-align: right;">
                        U+00<span style="color:red;">7</span><span style="color:purple;">F</span>
                    </td>
                    <td>
                        0<span style="color:red;">xxx</span><span style="color:purple;">xxxx</span>
                    </td>
                    <td style="background: darkgray;" colspan="3"></td>
                </tr>
                <tr>
                    <td style="text-align: right;">
                        U+0<span style="color:green;">0</span><span style="color:red;">8</span><span style="color:purple;">0</span>
                    </td>
                    <td style="text-align: right;">
                        U+0<span style="color:green;">7</span><span style="color:red;">F</span><span style="color:purple;">F</span>
                    </td>
                    <td>
                        110<span style="color:green;">xxx</span><span style="color:red;">xx</span>
                    </td>
                    <td>
                        10<span style="color:red;">xx</span><span style="color:purple;">xxxx</span>
                    </td>
                    <td style="background: darkgray;" colspan="2"></td>
                </tr>
                <tr>
                    <td style="text-align: right;">
                        U+<span style="color:blue;">0</span><span style="color:green;">8</span><span style="color:red;">0</span><span style="color:purple;">0</span>
                    </td>
                    <td style="text-align: right;">
                        U+<span style="color:blue;">F</span><span style="color:green;">F</span><span style="color:red;">F</span><span style="color:purple;">F</span>
                    </td>
                    <td>
                        1110<span style="color:blue;">xxxx</span>
                    </td>
                    <td>
                        10<span style="color:green;">xxxx</span><span style="color:red;">xx</span>
                    </td>
                    <td>
                        10<span style="color:red;">xx</span><span style="color:purple;">xxxx</span>
                    </td>
                    <td style="background: darkgray;"></td>
                </tr>
                <tr>
                    <td style="text-align: right;">
                        U+<span style="color:crimson;">0</span><span style="color:orange;">1</span><span style="color:blue;">0</span><span style="color:green;">0</span><span style="color:red;">0</span><span style="color:purple;">0</span>
                    </td>
                    <td style="text-align: right;">
                        U+<span style="color:crimson;">1</span><span style="color:orange;">0</span><span style="color:blue;">F</span><span style="color:green;">F</span><span style="color:red;">F</span><span style="color:purple;">F</span>
                    </td>
                    <td>
                        11110<span style="color:crimson;">x</span><span style="color:orange;">xx</span>
                    </td>
                    <td>
                        10<span style="color:orange;">xx</span><span style="color:blue;">xxxx</span>
                    </td>
                    <td>
                        10<span style="color:green;">xxxx</span><span style="color:red;">xx</span>
                    </td>
                    <td>
                        10<span style="color:red;">xx</span><span style="color:purple;">xxxx</span>
                    </td>
                </tr>
            </tbody>
        </table>

        <p>The calculation to convert a unicode code point to UTF-8 sequence is as follows:</p>

        <ol>
            <li>If the code point is between <b>U+0000</b> and <b>U+007F</b>, the UTF-8 encoded value is equal to the code point value.<br>

                For example, the character <b>$</b> with code point <b>U+0024</b>, the UTF-8 encoded value of the character <b>$</b> = the code point value of the character <b>$</b>, so the UTF-8 encoded value of the character <b>$</b> = 0x24.
            </li>
            <li>If the code point is between U+0080 and U+07FF, to find the UTF-8 encoded value:<br>
                <ul>
                    <li><b>Step 1</b>: find the first byte value, where the leading 3 bits of the first byte must be 110 and the trailing 5 bits of the first byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 6 bits of the code point value by dividing the code point value by 0x40</li>
                            <li><b>Substep 2</b>: ensure the leading 3 bits of the first byte is 110 by adding 0xC0 to the result of substep 1</li>
                            <li><b>Substep 3</b>: since the first byte is one byte away from the last byte so we multiply the result of substep 2 with 0x100</li>
                        </ul>  
                    </li>
                    <li><b>Step 2</b>: find the second byte value, where the leading 2 bits of the second byte must be 10 and the trailing 6 bits of the second byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: extract the trailing 6 bits of the code point value by finding the remainder of the code point value divided by 0x40</li>
                            <li><b>Substep 2</b>: ensure the leading 2 bits of the second byte is 10 by adding 0x80 to the result of substep 1</li>
                        </ul>
                    </li>
                    <li><b>Substep 3</b>: add the result of step 2 to the result of step 1 to get the UTF-8 encoded value</li>
                </ul>
                <br>
                By combining the steps above, we can formulate a equation:<br>
                <b>the UTF-8 encoded value = ((code point value / 0x40) + 0xC0) * 0x100 + (code point value mod 0x40) + 0x80</b><br><br>

                For example, find UTF-8 encoded value of the character <b>ü</b> where its code point value is U+00FC.<br>
                the UTF-8 encoded value of the character <b>ü</b> = ((code point value / 0x40) + 0xC0) * 0x100 + (code point value mod 0x40) + 0x80<br>
                the UTF-8 encoded value of the character <b>ü</b> = ((0xFC / 0x40) + 0xC0) * 0x100 + (0xFC mod 0x40) + 0x80<br>
                the UTF-8 encoded value of the character <b>ü</b> = (0x3 + 0xC0) * 0x100 + 0x3C + 0x80<br>
                the UTF-8 encoded value of the character <b>ü</b> = 0xC3 * 0x100 + 0xBC<br>
                the UTF-8 encoded value of the character <b>ü</b> = 0xC300 + 0xBC<br>
                the UTF-8 encoded value of the character <b>ü</b> = 0xC3BC
            </li>
            <li>If the code point is between U+0800 and U+FFFF, to find the UTF-8 encoded value<br>
                <ul>
                    <li><b>Step 1</b>: find the first byte value, where the leading 4 bits of the first byte must be 1110 and the trailing 4 bits of the first byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 12 bits of the code point value by dividing the code point value by 0x1000</li>
                            <li><b>Substep 2</b>: ensure the leading 4 bits of the first byte is 1110 by adding 0xE0 to the result of substep 1</li>
                            <li><b>Substep 3</b>: since the first byte is two byte away from the last byte so we multiply the result of substep 2 with 0x10000</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 2</b>: find the second byte value, where the leading 2 bits of the second byte must be 10 and the trailing 6 bits of the second byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 6 bits of the code point value by dividing the code point value by 0x40</li>
                            <li><b>Substep 2</b>: extract the trailing 6 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x40</li>
                            <li><b>Substep 3</b>: ensure the leading 2 bits of the second byte is 10 by adding 0x80 to the result of substep 2</li>
                            <li><b>Substep 4</b>: since the second byte is one byte away from the last byte so we multiply the result of substep 3 with 0x100</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 3</b>: find the third byte value, where the leading 2 bits of the third byte must be 10 and the trailing 6 bits of the third byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: extract the trailing 6 bits of the code point value by finding the remainder of the code point value divided by 0x40</li>
                            <li><b>Substep 2</b>: ensure the leading 2 bits of the third byte is 10 by adding 0x80 to the result of substep 1</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 4</b>: find the sum of the result step 1, the result of step 2 and the result of step 3 to the UTF-8 sequence</li>
                </ul>
                <br>
                By combining the steps above, we can formulate a equation:<br>
                <b>the UTF-8 encoded value = ((code point value / 0x1000) + 0xE0) * 0x10000 + (((code point value / 0x40) mod 0x40) + 0x80) * 0x100 + (code point value mod 0x40) + 0x80</b><br><br>
                
                For example, encoding the Character <b>€</b> (U+20AC):<br>

                the UTF-8 encoded value of the Character <b>€</b> = ((code point value / 0x1000) + 0xE0) * 0x10000 + (((code point value / 0x40) mod 0x40) + 0x80) * 0x100 + (code point value mod 0x40) + 0x80<br>
                the UTF-8 encoded value of the Character <b>€</b> = ((0x20AC / 0x1000) + 0xE0) * 0x10000 + (((0x20AC / 0x40) mod 0x40) + 0x80) * 0x100 + (0x20AC mod 0x40) + 0x80<br>
                the UTF-8 encoded value of the Character <b>€</b> = (0x2 + 0xE0) * 0x10000 + ((0x82 mod 0x40) + 0x80) * 0x100 + 0x2C + 0x80<br>
                the UTF-8 encoded value of the Character <b>€</b> = 0xE2 * 0x10000 + (0x2 + 0x80) * 0x100 + 0xAC<br>
                the UTF-8 encoded value of the Character <b>€</b> = 0xE20000 + 0x8200 + 0xAC<br>
                the UTF-8 encoded value of the Character <b>€</b> = 0xE282AC
            </li>
            <li>If the code point is less than U+110000 or between U+010000 and U+10FFFF, to find the UTF-8 encoded value:<br>
                <ul>
                    <li><b>Step 1</b>: find the first byte value, where the leading 5 bits of the first byte must be 11110 and the trailing 3 bits of the first byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 18 bits of the code point value by dividing the code point value by 0x40000</li>
                            <li><b>Substep 2</b>: ensure the leading 5 bits of the first byte is 11110 by adding 0xF0 to the result of substep 1</li>
                            <li><b>Substep 3</b>: since the first byte is three bytes away from the last byte so we multiply the result of substep 2 with 0x1000000</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 2</b>: find the second byte value, where the leading 2 bits of the second byte must be 10 and the trailing 6 bits of the second byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 12 bits of the code point value by dividing the code point value by 0x1000</li>
                            <li><b>Substep 2</b>: extract the trailing 6 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x40</li>
                            <li><b>Substep 3</b>: ensure the leading 2 bits of the second byte is 10 by adding 0x80 to the result of substep 2</li>
                            <li><b>Substep 4</b>: since the second byte is two bytes away from the last byte so we multiply the result of substep 3 with 0x10000</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 3</b>: find the third byte value, where the leading 2 bits of the third byte must be 10 and the trailing 6 bits of the second byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 6 bits of the code point value by dividing the code point value by 0x40</li>
                            <li><b>Substep 2</b>: extract the trailing 6 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x40</li>
                            <li><b>Substep 3</b>: ensure the leading 2 bits of the third byte is 10 by adding 0x80 to the result of substep 2</li>
                            <li><b>Substep 4</b>: since the third byte is a byte away from the last byte so we multiply the result of substep 3 with 0x100</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 4</b>: find the third byte value, where the leading 2 bits of the third byte must be 10 and the trailing 6 bits of the second byte fill with the bits of the code point value<br>
                        <ul>
                            <li><b>Substep 1</b>: extract the trailing 6 bits of the code point value by finding the remainder of the code point value divided by 0x40</li>
                            <li><b>Substep 2</b>: ensure the leading 2 bits of the third byte is 10 by adding 0x80 to the result of substep 1</li>
                        </ul>
                        
                    </li>
                    <li><b>Step 5</b>: find the sum of the result step 1, the result of step 2, the result of step 3 and the result of step 4 to the UTF-8 sequence</li>
                </ul>
                
                <br>
                By combining the steps above, we can formulate a equation:<br>
                <b>the UTF-8 encoded value = ((code point value / 0x40000) + 0xF0) * 0x1000000 + (((code point value / 0x1000) mod 0x40) + 0x80) * 0x10000 + (((code point value / 0x40) mod 0x40) + 0x80) * 0x100 + (code point value mod 0x40) + 0x80</b><br><br>

                For example, find UTF-8 encoded value of the character <b>😀</b> where its code point value is U+1F600.<br>
                the UTF-8 encoded value of the character <b>😀</b> = ((code point value / 0x40000) + 0xF0) * 0x1000000 + (((code point value / 0x1000) mod 0x40) + 0x80) * 0x10000 + (((code point value / 0x40) mod 0x40) + 0x80) * 0x100 + (code point value mod 0x40) + 0x80<br>
                the UTF-8 encoded value of the character <b>😀</b> = ((0x1F600 / 0x40000) + 0xF0) * 0x1000000 + (((0x1F600 / 0x1000) mod 0x40) + 0x80) * 0x10000 + (((0x1F600 / 0x40) mod 0x40) + 0x80) * 0x100 + (0x1F600 mod 0x40) + 0x80<br>
                the UTF-8 encoded value of the character <b>😀</b> = (0x0 + 0xF0) * 0x1000000 + ((0x1F mod 0x40) + 0x80) * 0x10000 + ((0x7D8 mod 0x40) + 0x80) * 0x100 + 0x0 + 0x80<br>
                the UTF-8 encoded value of the character <b>😀</b> = 0xF0 * 0x1000000 + (0x1F + 0x80) * 0x10000 + (0x18 + 0x80) * 0x100 + 0x0 + 0x80<br>
                the UTF-8 encoded value of the character <b>😀</b> = 0xF0000000 + 0x9F * 0x10000 + 0x98 * 0x100 + 0x80<br>
                the UTF-8 encoded value of the character <b>😀</b> = 0xF0000000 + 0x9F0000 + 0x9800 + 0x80<br>
                the UTF-8 encoded value of the character <b>😀</b> = 0xF09F9880  
            </li>
        </ol>

        <p>The calculation to convert UTF-8 sequence to a unicode code point is as follows:</p>

        <ul>
            <li>If the UTF-8 encoded value is between 0x0 and 0x7F, the the code point value is equal to UTF-8 encoded value.<br>

                For example, find the code point of the UTF-8 encoded value 0x24.<br>
                the code point of UTF-8 encoded value 0x24 = U+0024
            </li>
            <li>If the UTF-8 encoded value is between 0xC000 and 0xDF00:<br>
                <ul>
                    <li><b>Step 1</b>: extract the trailing 5 bits from the first byte of the UTF-8 encoded value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 8 bits of the UTF-8 encoded value by dividing the UTF-8 encoded value by 0x100</li>
                            <li><b>Substep 2</b>: extract the trailing 5 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x20</li>
                            <li><b>Substep 3</b>: multiply the result of substep 2 by 0x40 since these 5 bits are 6 bits away from the 1st bit of the code point value</li>
                        </ul>    
                    </li>
                    <li><b>Step 2</b>: extract the trailing 6 bits from the second byte of the UTF-8 encoded value by finding the remainder of the UTF-8 encoded value divided by 0x40</li>
                    <li><b>Step 3</b>: add the result of step 2 to the result of step 1 to get the code point value</li>
                </ul>
                <br>

                By combining the steps above, we can formulate a equation:<br>
                <b>the code point value = ((UTF-8 encoded value / 0x100) mod 0x20) * 0x40 + (UTF-8 encoded value mod 0x40)</b><br><br>

                For example, find the code point value of the UTF-8 encoded value 0xC3BC:<br>
                the code point value = ((UTF-8 encoded value / 0x100) mod 0x20) * 0x40 + (UTF-8 encoded value mod 0x40)<br>
                the code point value = ((0xC3BC / 0x100) mod 0x20) * 0x40 + (0xC3BC mod 0x40)<br>
                the code point value = (0xC3 mod 0x20) * 0x40 + 0x3C<br>
                the code point value = 0x3 * 0x40 + 0x3C<br>
                the code point value = 0xC0 + 0x3C<br>
                the code point value = 0xFC
            </li>
            <li>If the UTF-8 encoded value is between 0xE00000 and 0xEF0000: <br>
                <ul>
                    <li><b>Step 1</b>: extract the trailing 4 bits from the first byte of the UTF-8 encoded value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 16 bits of the UTF-8 encoded value by dividing the UTF-8 encoded value by 0x10000</li>
                            <li><b>Substep 2</b>: extract the trailing 4 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0xE0</li>
                            <li><b>Substep 3</b>: multiply the result of substep 2 by 0x1000 since these 4 bits are 12 bits away from the 1st bit of the code point value</li>
                        </ul>    
                    </li>
                    <li><b>Step 2</b>: extract the trailing 6 bits from the second byte of the UTF-8 encoded value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 8 bits of the UTF-8 encoded value by dividing the UTF-8 encoded value by 0x100</li>
                            <li><b>Substep 2</b>: extract the trailing 6 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x40</li>
                            <li><b>Substep 3</b>: multiply the result of substep 2 by 0x40 since these 6 bits are 6 bits away from the 1st bit of the code point value</li>
                        </ul>
                    </li>
                    <li><b>Step 3</b>: extract the trailing 6 bits from the third byte of the UTF-8 encoded value by finding the remainder of the UTF-8 encoded value divided by 0x40</li>
                    <li><b>Step 3</b>: find the sum of the result of step 1, the result of step 2 and the result of step 3 to get the code point value</li>
                </ul>
                <br>

                By combining the steps above, we can formulate a equation:<br>
                <b>the code point value = ((UTF-8 encoded value / 0x10000) mod 0xE0) * 0x1000 + ((UTF-8 encoded value / 0x100) mod 0x40) * 0x40 + (UTF-8 encoded value mod 0x40)</b><br><br>

                For example, find the code point value of the UTF-8 sequence 0xE282AC:<br>

                the code point value = ((UTF-8 encoded value / 0x10000) mod 0xE0) * 0x1000 + ((UTF-8 encoded value / 0x100) mod 0x40) * 0x40 + (UTF-8 encoded value mod 0x40)<br>
                the code point value = ((0xE282AC / 0x10000) mod 0xE0) * 0x1000 + ((0xE282AC / 0x100) mod 0x40) * 0x40 + (0xE282AC mod 0x40)<br>
                the code point value = (0xE2 mod 0xE0) * 0x1000 + (0xE282 mod 0x40) * 0x40 + 0x2C<br>
                the code point value = 0x2 * 0x1000 + 0x2 * 0x40 + 0x2C<br>
                the code point value = 0x2000 + 0x80 + 0x2C<br>
                the code point value = 0x2000 + 0xAC<br>
                the code point value = 0x20AC
            </li>
            <li>If the UTF-8 encoded value is between 0xF0000000 and 0xF7000000:<br>
                <ul>
                    <li><b>Step 1</b>: extract the trailing 3 bits from the first byte of the UTF-8 encoded value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 24 bits of the UTF-8 encoded value by dividing the UTF-8 encoded value by 0x1000000</li>
                            <li><b>Substep 2</b>: extract the trailing 3 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x8</li>
                            <li><b>Substep 3</b>: multiply the result of substep 2 by 0x40000 since these 3 bits are 18 bits away from the 1st bit of the code point value</li>
                        </ul>    
                    </li>
                    <li><b>Step 2</b>: extract the trailing 6 bits from the second byte of the UTF-8 encoded value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 16 bits of the UTF-8 encoded value by dividing the UTF-8 encoded value by 0x10000</li>
                            <li><b>Substep 2</b>: extract the trailing 6 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x40</li>
                            <li><b>Substep 3</b>: multiply the result of substep 2 by 0x1000 since these 6 bits are 12 bits away from the 1st bit of the code point value</li>
                        </ul>
                    </li>
                    <li><b>Step 3</b>: extract the trailing 6 bits from the third byte of the UTF-8 encoded value<br>
                        <ul>
                            <li><b>Substep 1</b>: remove the trailing 8 bits of the UTF-8 encoded value by dividing the UTF-8 encoded value by 0x100</li>
                            <li><b>Substep 2</b>: extract the trailing 6 bits of the result of substep 1 by finding the remainder of the result of substep 1 divided by 0x40</li>
                            <li><b>Substep 3</b>: multiply the result of substep 2 by 0x40 since these 6 bits are 6 bits away from the 1st bit of the code point value</li>
                        </ul>
                    </li>
                    <li><b>Step 4</b>: extract the trailing 6 bits from the third byte of the UTF-8 encoded value by finding the remainder of the UTF-8 encoded value divided by 0x40</li>
                    <li><b>Step 3</b>: find the sum of the result of step 1, the result of step 2, the result of step 3 and the result of step 4 to get the code point value</li>
                </ul>
                <br>

                By combining the steps above, we can formulate a equation:<br>
                <b>the code point value = ((UTF-8 encoded value / 0x1000000) mod 0x8) * 0x40000 + ((UTF-8 encoded value / 0x10000) mod 0x40) * 0x1000 + ((UTF-8 encoded value / 0x100) mod 0x40) * 0x40 + (UTF-8 encoded value mod 0x40)</b><br><br>

                For example, find the code point of the UTF-8 sequence 0xF09F9880:<br>

                the code point value = ((UTF-8 encoded value / 0x1000000) mod 0x8) * 0x40000 + ((UTF-8 encoded value / 0x10000) mod 0x40) * 0x1000 + ((UTF-8 encoded value / 0x100) mod 0x40) * 0x40 + (UTF-8 encoded value mod 0x40)<br>
                the code point value = ((0xF09F9880 / 0x1000000) mod 0x8) * 0x40000 + ((0xF09F9880 / 0x10000) mod 0x40) * 0x1000 + ((0xF09F9880 / 0x100) mod 0x40) * 0x40 + (0xF09F9880 mod 0x40)<br>
                the code point value = (0xF0 mod 0x8) * 0x40000 + (0xF09F mod 0x40) * 0x1000 + (0xF09F98 mod 0x40) * 0x40 + 0x0<br>
                the code point value = 0x0 * 0x40000 + 0x1F * 0x1000 + 0x18 * 0x40 + 0x0<br>
                the code point value = 0x0 + 0x1F000 + 0x600 + 0x0<br>
                the code point value = 0x1F600
            </li>
        </ul>  
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/computer-science" class="tag">computer science</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/math" class="tag">math</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/utf-8" class="tag">UTF-8</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/unicode" class="tag">unicode</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/encoding" class="tag">encoding</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/decoding" class="tag">decoding</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-06" /><category term="day-25" /><category term="computer science" /><category term="math" /><category term="UTF-8" /><category term="unicode" /><category term="encoding" /><category term="decoding" /><summary type="html"><![CDATA[Learn about the math behind UTF-8 encoding and decoding with detailed explanations and examples to help you understand this important concept in computer science.]]></summary></entry><entry xml:lang="en"><title type="html">UTF-16 Encoding and Decoding Algorithm</title><link href="https://hemimorphite.github.io/2024/06/24/utf-16-encoding-and-decoding-algorithm/" rel="alternate" type="text/html" title="UTF-16 Encoding and Decoding Algorithm" /><published>2024-06-24T12:51:00+00:00</published><updated>2024-06-24T12:51:00+00:00</updated><id>https://hemimorphite.github.io/2024/06/24/utf-16-encoding-and-decoding-algorithm</id><content type="html" xml:base="https://hemimorphite.github.io/2024/06/24/utf-16-encoding-and-decoding-algorithm/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">UTF-16 Encoding and Decoding Algorithm</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published June 24, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/unicode.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>In computer systems, characters are transformed and stored as numbers (sequences of bits) that can be handled by the processor. A code page is an encoding scheme that maps a specific sequence of bits to its character representation. Before Unicode, there were hundreds of different encoding schemes that assigned a number to each letter or character. Many such schemes included code pages that contained only 256 characters – each character requiring 8 bits of storage. While this was relatively compact, it was insufficient to hold ideographic character sets containing thousands of characters such as Chinese and Japanese, and also did not allow the character sets of many languages to co-exist with each other.</p>

        <p>Unicode is an attempt to include all the different schemes into one universal text-encoding standard.</p>

        <p>Unicode represents each individual character as a unique code point with a unique number. For example, the character <b>A</b> – <b>Latin Capital Letter A</b> – is represented as <b>U+0041</b> and the Hiragana <b>ふ</b> is <b>U+3075</b>.</p>

        <p>An individual Unicode code point is expressed as <b>U+n</b>, where <b>n</b> is four to six hexadecimal digits, using the digits <b>0–9</b> and uppercase letters <b>A–F</b> (for 10 through 15, respectively). Leading zeros are omitted, unless the code point would have fewer than four hexadecimal digits. For example, <b>U+0001</b>, <b>U+0012</b>, <b>U+0123</b>, <b>U+1234</b>, <b>U+12345</b>, <b>U+102345</b>.</p>

        <p>The Unicode code space is divided into seventeen planes (the basic multilingual plane, and 16 supplementary planes), each with 65,536 code points. Thus the total size of the Unicode code space is 17 × 65,536 = 1,114,112.</p>

        <p>The first plane is called the Basic Multilingual Plane or BMP. It contains the code points from <b>U+0000</b> to <b>U+FFFF</b>, which are the most frequently used characters.</p>

        <p>Unicode also defines multiple encodings of its single character set: <b>UTF-8</b>, <b>UTF-16</b>, and <b>UTF-32</b>.</p>

        <h5 class="post-subtitle">UTF-16 Encoding</h5>

        <p>UTF-16 is a character encoding that maps code points of Unicode character to a sequence of one 16-bit code unit or two 16-bit code units. UTF-16 uses a 16-bit code unit, or two 16-bit code units to represent a unicode character.</p>

        <p>Code unit is a value that encoded code point to 8/16/32 bits to store/transmit Unicode text efficiently on a computer.</p>

        <p>When representing characters in UTF-16, each code point is represented by a sequence of one or two 16-bit code units. The number of bytes used depends on the code point being represented by the character. Here's a breakdown of the usage range:</p>

        <ul>
            <li>code points in Basic Multilingual Plane (BMP) from the range <b>U+0000 - U+D7FF (0-55295)</b> and <b>U+E000 - U+FFFF (57344-65535)</b> are represented by two bytes</li>
            <li>code points in other 16 supplementary planes from the range <b>U+010000 - U+10FFFF (65536-1114111)</b> are represented by four bytes</li>
        </ul>

        <p>To encode characters outside the BMP, (e.g. U+29E3D, Japanese Kanji of Okhotsk Atka mackerel, 𩸽) UTF-16 encodes it using two 16-bit code units. This is called a surrogate pair.</p>

        <p>The Unicode standard reserves BMP in the range from <b>U+D800</b> to <b>U+DFFF</b> for surrogate pairs (this means that those code points are not assigned to any characters).</p>

        <p><b>U+D800</b> - <b>U+DBFF</b> is known as high-surrogates, and <b>U+DC00</b> - <b>U+DFFF</b> is known as low-surrogates. The first code unit of a surrogate pair is always in high-surrogates, and the second is always in low-surrogates.</p>

        <p>The algorithm to convert a unicode code point to UTF-16 sequence is as follows:</p>

        <ol>
            <li>
                If the code point is between <b>U+0000</b> and <b>U+D7FF</b> or between <b>U+E000</b> and <b>U+FFFF</b>, it is encoded in a single 16-bit code unit.<br>
                To encode a code point from <b>U+0000</b> to <b>U+D7FF</b> and <b>U+E000</b> to <b>U+FFFF</b> into UTF-16, you can simply represent the code point as UTF-16 sequence.<br>

                For example, to encode the code point <b>U+4E80</b>, just simply represent the code point as UTF-16 sequence that is <b>0x4E80</b>.
            </li>
            <li>If the code point is between U+010000 and U+10FFFF, it is encoded in two 16-bit code units.<br>
                <ul>
                    <li><b>Step 1</b>: perform subtraction operation on the code point by 0x10000</li>
                    <li><b>Step 2</b>: get the high-surrogate code unit of UTF-16 sequence<br>
                        <ul>
                            <li><b>Substep 1</b>: perform right shift operation on the result of step 1 by 10 bits</li>
                            <li><b>Substep 2</b>: perform addition operation between the result of substep 1 with 0xD800 (0b11011000 00000000)</li>
                            <li><b>Substep 3</b>: the high-surrogate code unit of UTF-16 sequence is the result of substep 2</li>
                        </ul>
                    </li>
                    <li><b>Step 3</b>: get the second low-surrogate code unit of UTF-16 sequence<br>
                        <ul>
                            <li><b>Substep 1</b>: perform masking using AND operator between the result of step 1 with 0x3FF (0b0011 11111111) to extract the trailing 10 bits of the code point</li>
                            <li><b>Substep 2</b>: perform adding operation between the result of substep 1 with 0xDC00 (0b11011100 00000000)</li>
                            <li><b>Substep 3</b>: the low-surrogate code unit of UTF-16 sequence is the result of substep 2</li>
                        </ul>
                    </li>
                    <li>
                        <b>Final step</b>: combine the result of step 1 and the result of step 2 to form a UTF-16 sequence.
                    </li>
                </ul>
                
                <br>
                For example, encode the code point <b>U+1F6A9</b> to the UTF-16 sequence:<br>

                <ul>
                    <li><b>Step 1</b>: 0x1F6A9 - 0x10000 = 0xF6A9</li>
                    <li><b>Step 2</b>: get the high-surrogate code unit of UTF-16 sequence<br>
                        <ul>
                            <li><b>Substep 1</b>: 0xF6A9 >> 10 = 0x3D</li>
                            <li><b>Substep 2</b>: 0x3D + 0xD800 = 0xD83D</li>
                            <li><b>Substep 3</b>: the high-surrogate code unit = 0xD83D</li>
                        </ul>
                    </li>
                    <li><b>Step 3</b>: get the second low-surrogate code unit of UTF-16 sequence<br>
                        <ul>
                            <li><b>Substep 1</b>: 0xF6A9 & 0x3FF = 0x02A9</li>
                            <li><b>Substep 2</b>: 0x02A9 + 0xDC00 = 0xDEA9</li>
                            <li><b>Substep 3</b>: the low-surrogate code unit = 0xDEA9</li>
                        </ul>
                    </li>
                    <li>
                        <b>Final step</b>: combine the UTF-16 sequence of the code point <b>U+1F6A9</b> is 0xD83DDEA9.
                    </li>
                </ul>
            </li>
        </ol>

        <p>The following table summarizes the conversion code points to UTF-16 sequence:</p>

        <table class="table table-bordered border-primary">
            <tbody>
                <tr>
                    <th colspan="2">Character </th>
                    <th>Binary code point </th>
                    <th>Binary UTF-16 </th>
                    <th>UTF-16 hex <br>code units </th>
                    <th>UTF-16BE <br>hex bytes </th>
                    <th>UTF-16LE <br>hex bytes </th>
                </tr>
                <tr>
                    <td>
                        $
                    </td>
                    <td>
                        U+0024
                    </td>
                    <td align="right">
                        <span style="color: #000092;">0000 0000 0010 0100</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">0000 0000 0010 0100</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">0024</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">00 24</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">24 00</span>
                    </td>
                </tr>
                <tr>
                    <td>
                        €
                    </td>
                    <td>
                        U+20AC
                    </td>
                    <td align="right">
                        <span style="color: #000092;">0010 0000 1010 1100</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">0010 0000 1010 1100</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">20AC</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">20 AC</span>
                    </td>
                    <td align="right">
                        <span style="color: #000092;">AC 20</span>
                    </td>
                </tr>
                <tr>
                    <td>
                        𐐷
                    </td>
                    <td>
                        U+10437
                    </td>
                    <td align="right">
                        <span style="color: #920000;">0001 0000 01</span><span style="color: #000092;">00 0011 0111</span>
                    </td>
                    <td align="right">
                        1101 10<span style="color: #920000;">00 0000 0001</span> 1101 11 <span style="color: #000092;">00 0011 0111</span>
                    </td>
                    <td align="right">
                        <span style="color: #920000;">D801</span>
                        <span style="color: #000092;">DC37</span>
                    </td>
                    <td align="right">
                        <span style="color: #920000;">D8 01</span>
                        <span style="color: #000092;">DC 37</span>
                    </td>
                    <td align="right">
                        <span style="color: #920000;">01 D8</span>
                        <span style="color: #000092;">37 DC</span>
                    </td>
                </tr>
                <tr>
                    <td>
                        𤭢
                    </td>
                    <td>
                        U+24B62
                    </td>
                    <td align="right">
                        <span style="color: #920000;">0010 0100 10</span><span style="color: #000092;">11 0110 0010</span>
                    </td>
                    <td align="right">
                        1101 10 <span style="color: #920000;">00 0101 0010</span> 1101 11 <span style="color: #000092;">11 0110 0010</span>
                    </td>
                    <td align="right">
                        <span style="color: #920000;">D852</span>
                        <span style="color: #000092;">DF62</span>
                    </td>
                    <td align="right">
                        <span style="color: #920000;">D8 52</span>
                        <span style="color: #000092;">DF 62</span>
                    </td>
                    <td align="right">
                        <span style="color: #920000;">52 D8</span>
                        <span style="color: #000092;">62 DF</span>
                    </td>
                </tr>
            </tbody>
        </table>

        <h5 class="post-subtitle">UTF-16 Decoding</h5>

        <p>The algorithm to convert UTF-16 sequence to a unicode code point is as follows:</p>

        <ol>
            <li>
                If the UTF-16 sequence is between <b>0x0000</b> and <b>0xD7FF</b> or between <b>0xE000</b> and <b>0xFFFF</b>:<br>

                To decode a UTF-16 sequence from <b>0x0000</b> to <b>0xD7FF</b> and <b>0xE000</b> to <b>0xFFFF</b> into a code point, you can simply represent the UTF-16 sequence as the code point.<br>

                For example, to decode the code point <b>0x4E80</b>, just simply represent the UTF-16 sequence as the code point that is <b>U+4E80</b>.
            </li>
            <li>
                If the UTF-16 sequence is between <b>U+D800</b> and <b>U+DFFF</b>, it is a surrogate pair that consists of a high surrogate and a low surrogate.<br>
                <ul>
                    <li><b>Step 1</b>: decode the high-surrogate code unit of UTF-16 sequence where the high-surrogate code unit must be between <b>U+D800</b> and <b>U+DBFF</b><br>
                        <ul>
                            <li><b>Substep 1</b>: perform subtraction operation on the high-surrogate code unit by 0xD800</li>
                            <li><b>Substep 3</b>: perform the left shift operation on the reesult of substep 1 by 10 bits</li>
                            <li><b>Substep 4</b>: the decoded high-surrogate code unit is the result of substep 3</li>
                        </ul>
                    </li>
                    <li><b>Step 2</b>: decode the second 16-bit code unit (low-surrogate code unit) of UTF-16 sequence which is between <b>U+DC00</b> and <b>U+DFFF</b><br>
                        <ul>
                            <li><b>Substep 1</b>: perform subtraction operation on the low-surrogate code unit by 0xDC00</li>
                            <li><b>Substep 2</b>: the decoded low-surrogate code unit is the result of substep 1</li>
                        </ul>
                    </li>
                    <li><b>Step 3</b>: perform addition operation among the result of step 1, the result of step 2 and 0x10000 to get the code point</li>
                    <li><b>Final step</b>: the code point is the result of step 3</li>
                </ul>
                
                <br>
                For example, decode the the UTF-16 sequence <b>0xD87DDEA9</b>:<br>

                <ul>
                    <li><b>Step 1</b>: decode the high-surrogate code unit of UTF-16 sequence where the high-surrogate code unit must be between <b>U+D800</b> and <b>U+DBFF</b><br>
                        <ul>
                            <li><b>Substep 1</b>: 0xD87D - 0xD800 = 0x007D</li>
                            <li><b>Substep 3</b>: 0x007D << 10 = 0xF400</li>
                            <li><b>Substep 4</b>: the decoded high-surrogate code unit = 0xF400</li>
                        </ul>
                    </li>
                    <li><b>Step 2</b>: decode the second 16-bit code unit (low-surrogate code unit) of UTF-16 sequence which is between <b>U+DC00</b> and <b>U+DFFF</b><br>
                        <ul>
                            <li><b>Substep 1</b>: 0xDEA9 - 0xDC00 = 0x02A9</li>
                            <li><b>Substep 2</b>: the decoded low-surrogate code unit = 0x02A9</li>
                        </ul>
                    </li>
                    <li><b>Step 3</b>: 0xF400 + 0x02A9 + 0x10000 = 0x1F6A9</li>
                    <li><b>Final step</b>: the code point = U+1F6A9</li>
                </ul>
            </li>
        </ol>
        
        <h5 class="post-subtitle">Byte Order Mark (BOM)</h5>

        <p>UTF-16 comes in two variations, big endian and little endian. In big-endian UTF-16 or UTF-16BE, the most significant byte of the character comes first. In little-endian UTF-16 or UTF-16LE, the order is reversed. Thus, in big-endian UTF-16, the code point of letter A is <b>U+0041</b> and the encoded bytes are <b>0x0041</b>. In little-endian UTF-16, the encoded bytes are swapped, and A is <b>0x4100</b>. In big-endian UTF-16, the code point of letter B is <b>U+0042</b> and the encoded bytes are <b>0x0042</b>; in little-endian UTF-16, it's <b>0x4200</b>. In big-endian UTF-16, the code point of letter Σ is <b>U+03A3</b> and the encoded bytes are <b>0x03A3</b>; in little-endian UTF-16, it's <b>0xA303</b>. In big-endian UTF-16, the code point of emoticon 😀 is <b>U+1F600</b> and the encoded bytes are <b>0xD83D</b> and <b>0xDE00</b>; in little-endian UTF-16, it's <b>0x3DD8</b> and <b>0x00DE</b>. In big-endian UTF-16, the code point of character 𠂤 is <b>U+200A4</b> and the encoded bytes are <b>0xD840</b> and <b>0xDCA4</b>; in little-endian UTF-16, it's <b>0x40D8</b> and <b>0xA4DC</b>.</p>

        <p>To distinguish between big-endian and little-endian UTF-16, a program can look at the first two bytes of a UTF-16 encoded document, a document encoded in big-endian UTF-16 begins with Unicode character <b>U+FEFF</b>, the zero-width nonbreaking space, more commonly called the byte-order mark. A document encoded in big-endian UTF-16 begins with the same Unicode character (<b>U+FEFF</b>) but the bytes is swapped (i.e. <b>U+FFFE</b>), the resulting <b>U+FFFE</b> character doesn't actually exist.</p>
        
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/utf-16" class="tag">UTF-16</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/utf-16le" class="tag">UTF-16LE</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/utf-16be" class="tag">UTF-16BE</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/unicode" class="tag">unicode</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/algorithm" class="tag">algorithm</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/encoding" class="tag">encoding</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/decoding" class="tag">decoding</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/byte-order-mark" class="tag">byte order mark</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-06" /><category term="day-24" /><category term="UTF-16" /><category term="UTF-16LE" /><category term="UTF-16BE" /><category term="unicode" /><category term="algorithm" /><category term="encoding" /><category term="decoding" /><category term="byte order mark" /><summary type="html"><![CDATA[UTF-16, UTF-16LE, UTF-16BE encoding and decoding algorithm is crucial for processing text in various programming languages. This page explains the implementation of UTF-16, UTF-16LE, UTF-16BE encoding and decoding with examples for programmers to understand and utilize effectively.]]></summary></entry><entry xml:lang="en"><title type="html">The Difference Between Little Endian and Big Endian</title><link href="https://hemimorphite.github.io/2024/06/24/the-difference-between-little-endian-and-big-endian/" rel="alternate" type="text/html" title="The Difference Between Little Endian and Big Endian" /><published>2024-06-24T12:33:00+00:00</published><updated>2024-06-24T12:33:00+00:00</updated><id>https://hemimorphite.github.io/2024/06/24/the-difference-between-little-endian-and-big-endian</id><content type="html" xml:base="https://hemimorphite.github.io/2024/06/24/the-difference-between-little-endian-and-big-endian/"><![CDATA[<div class="blog-post">
    <h2 class="post-title">The Difference Between Little Endian and Big Endian</h2>
<div class="post-author">
    <span class="avatar"></span>
    <span class="info"><span class="date">Published June 24, 2024</span><br><span class="name">By Samuel Yang</span></span>
</div>

<figure class="post-image">
    <img src="/assets/images/cpu.jpg" alt="Blog Cover">
</figure>

    <article class="post-content">
        <p>Every byte of memory has its own address, no matter how big the CPU machine word is. Eg. Intel 8086 CPU was 16-bit and it was addressing memory by bytes, so do modern 32-bit and 64-bit CPUs. That's the cause of the first limit - you can't have more addresses than memory bytes.</p>

        <p>The CPU machine word or word size of a CPU architecture refers to the number of bits that a computer's CPU can process at a time. It is typically measured in bits, with common word sizes being 16, 32, or 64 bits. In some architectures, such as Intel's PC processor architecture, a word is 16 bits or two contiguous 8-bit bytes. The word size determines the maximum amount of data that can be processed in a single operation and affects the performance and capabilities of the CPU.</p>

        <p>A machine word or word size is the amount of memory CPU uses to hold numbers (in RAM, cache or internal registers). 32-bit CPU uses 32 bits (4 bytes) to hold numbers. Memory addresses are numbers too, so on a 32-bit CPU the memory address consists of 32 bits.</p>
        
        <p>In a 32-bit system, memory addresses are typically represented as 8 hexadecimal digits, while in a 64-bit system, addresses are represented using 16 hexadecimal digits.</p>

        <p>In a 32-bit system, the memory addresses can range from 0 to 0x7FFFFFFF; that is, 2^31 (2147483648 or 0x80000000) possible numbers, while in a 64-bit system, the memory addresses can range from 0 to 0x7FFFFFFFFFFFFFFF; that is, 2^63 (9223372036854775808 or 0x8000000000000000) possible numbers.</p>

        <p>The endianness refers to the byte order used by a computer or a microcontroller or a machine to read or write a single "hello world" in memory. In other words, the endian will decide how to store multiple bytes in computer memory. It doesn't mean, the order of bits inside a byte, nor the way the computer reads an array of bytes or a file. It's all about the order of the bytes of a word (multi-byte variable) in memory.</p>

        <p>In big endian, the most significant byte of a multi-byte data type is stored at the lowest memory address, and the least significant byte is stored at the highest memory address. It is as if the data is read from left to right.</p>

        <p>In little endian, the least significant byte is stored at the lowest memory address, and the most significant byte is stored at the highest memory address. It is as if the data is read from right to left.</p>

        <p>Endian representation is crucial when data is transmitted or shared between systems with different endianness. If systems with different endianness attempt to interpret the data directly, the values may be misinterpreted, leading to errors in the program.</p>

        <p>For example, let's consider a 32-bit integer value with the hexadecimal representation 0x12345678.</p>

        <p>In big endian, it is stored in memory as:</p>

        <pre><code class="language-bash hljs">Address:    0x1000    0x1001    0x1002    0x1003
Value:      0x12      0x34      0x56      0x78</code></pre>
        
        <p>In little endian, it is stored in memory as:</p>

        <pre><code class="language-bash hljs">Address:    0x1000    0x1001    0x1002    0x1003
Value:      0x78      0x56      0x34      0x12</code></pre>
        
        <p>There are a lot of ways for determining endianness of your machine. Here is one way of determining endianness of your machine:</p>

        <pre><code class="language-bash hljs">#include &lt;stdio.h&gt;
int main(void)
{
    unsigned int value = 0x12345678;
    char *r = (char *) &value;
    int i;
    
    for(i=0; i<4; i++) {
        printf("Address of 0x%x = %p \n", r[i], &r[i]);
    }
    return 0;
}</code></pre>

        <p>Compile and run the program</p>

        <pre><code class="language-bash hljs">gcc -o endian endian.c && ./endian</code></pre>

        <p>The output on little endian architecture would look like:</p>

        <pre><code class="language-bash hljs">Address of 0x78 = 0x7fffe86cb728
Address of 0x56 = 0x7fffe86cb729
Address of 0x34 = 0x7fffe86cb72a
Address of 0x12 = 0x7fffe86cb72b</code></pre>

        <p>The output on little endian architecture would look like:</p>

        <pre><code class="language-bash hljs">Address of 0x12 = 0x7fffe86cb728
Address of 0x34 = 0x7fffe86cb729
Address of 0x56 = 0x7fffe86cb72a
Address of 0x78 = 0x7fffe86cb72b</code></pre>
    </article>

    <div class="post-tags">
	<div class="title">Tags</div>
	<ul class="tags">
		
		<li><a href="https://hemimorphite.github.io/tag/little-endian" class="tag">little endian</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/big-endian" class="tag">big endian</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/cpu-architecture" class="tag">cpu architecture</a></li>
		
		<li><a href="https://hemimorphite.github.io/tag/c" class="tag">c</a></li>
		
	</ul>
</div>


    <div class="post-share">
    <div class="title">Share this post</div>
    <ul class="rounded-social-buttons">
        <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button facebook"><i class="fab fa-facebook-f"></i></a></li>
        <li><a href="http://twitter.com/share?text=Hey+guys%2c+check+this+out!&amp;url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/&amp;hashtags=qemu,linux,fedora 38,firewalld,DHCP" class="social-button twitter"><i class="fab fa-twitter"></i></a></li>
        <li><a href="https://www.linkedin.com/sharing/share-offsite/?url=https://hemimorphite.github.io/2023/08/16/setup-fedora-server-38-as-a-dhcp-server/" class="social-button linkedin"><i class="fab fa-linkedin"></i></a></li>
    </ul>
</div>
</div>]]></content><author><name>Samuel Yang</name></author><category term="Tutorial" /><category term="year-2024" /><category term="month-06" /><category term="day-24" /><category term="little endian" /><category term="big endian" /><category term="cpu architecture" /><category term="c" /><summary type="html"><![CDATA[Learn about the key differences between little endian and big endian byte orderings, with clear explanations and illustrative examples to help you understand this fundamental concept in computer architecture.]]></summary></entry></feed>